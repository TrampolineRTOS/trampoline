/**
 * @file tpl_irq_handlers.S
 *
 * @section descr File description
 *
 * Generated from application serial
 * Automatically generated by goil on Wed Apr  6 14:44:29 2022
 * from root OIL file serial.oil
 *
 * @section infos File informations
 *
 */

#include "tpl_assembler.h"
#include "tpl_asm_definitions.h"
#include "tpl_kern_stack.h"

.extern tpl_kern
.extern tpl_kern_stack

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

/*=============================================================================
 * After en interrupt on a CPUX, the process stack is as follow
 *
 *    +----+--------------+
 *  0 | PC |      SR      | + 0
 *    +----+--------------+
 *  1 |         PC        | + 2
 *    +-------------------+
 *
 */


/*=============================================================================
 * IRQ Handler for COUNTER with source vector TIMER3_A0_VECTOR
 ******************************************************************************/

.section .irq_func, "ax"
.global tpl_primary_irq_handler_TIMER3_A0_VECTOR
.type   tpl_primary_irq_handler_TIMER3_A0_VECTOR, %function

/*-----------------------------------------------------------------------------
 */
tpl_primary_irq_handler_TIMER3_A0_VECTOR:

/*-----------------------------------------------------------------------------
 * -1- Before doing anything we have to save the volatile registers, which
 * are r11 (r11 is not volatile in the MSPGCC ABI but is volatile in GCC
 * compiler for MSP ABI. Anyway, in order to limit variabilility, r11 is 
 * saved for both ABIs) to r15, because they will not be saved when we will
 * call the underlying C function.
 */
  pushm.a   #5, r15  /* Push r11, r12, r13, r14 and r15 */
/*  
 * PROCESS STACK:
 *    +--------------------+
 *  0 |   0  | r11.19:16   | + 0
 *    +--------------------+
 *  1 |      r11.15:0      | + 2
 *    +--------------------+
 *  2 |   0  | r12.19:16   | + 4
 *    +--------------------+
 *  3 |      r12.15:0      | + 6
 *    +--------------------+
 *  4 |   0  | r13.19:16   | + 8
 *    +--------------------+
 *  5 |      r13.15:0      | + 10
 *    +--------------------+
 *  6 |   0  | r14.19:16   | + 12
 *    +--------------------+
 *  7 |      r14.15:0      | + 14
 *    +--------------------+
 *  8 |   0  | r15.19:16   | + 16
 *    +--------------------+
 *  9 |      r15.15:0      | + 18
 *    +--------------------+
 * 10 | PC.19:16 | SR.11:0 | + 20
 *    +--------------------+
 * 11 |      PC.15:0       | + 22
 *    +--------------------+
 * 12 | CallTerminateXXX   | + 24
 *    +--------------------+
 *
 *-----------------------------------------------------------------------------
 * -2- Switch to the kernel stack.
 */
  mova         r1, r11                          /* Copy the PSP in r11        */
  mova         #tpl_kern_stack + TPL_KERNEL_STACK_SIZE, r1 /* On kernel stack */
  pushx.a      r11                              /* Save PSP to kernel stack   */
/* 
 * PROCESS STACK:                 KERNEL STACK:
 *    +--------------------+            +-------------------+
 *  0 |   0  | r11.19:16   | + 0      0 |  0 |  PSP.19:16   | + 0
 *    +--------------------+            +-------------------+
 *  1 |      r11.15:0      | + 2      1 |     PSP.15:0      | + 2
 *    +--------------------+            +-------------------+
 *  2 |   0  | r12.19:16   | + 4
 *    +--------------------+
 *  3 |      r12.15:0      | + 6
 *    +--------------------+
 *  4 |   0  | r13.19:16   | + 8
 *    +--------------------+
 *  5 |      r13.15:0      | + 10
 *    +--------------------+
 *  6 |   0  | r14.19:16   | + 12
 *    +--------------------+
 *  7 |      r14.15:0      | + 14
 *    +--------------------+
 *  8 |   0  | r15.19:16   | + 16
 *    +--------------------+
 *  9 |      r15.15:0      | + 18
 *    +--------------------+
 * 10 | PC.19:16 | SR.11:0 | + 20
 *    +--------------------+
 * 11 |      PC.15:0       | + 22
 *    +--------------------+
 * 12 | CallTerminateXXX   | + 24
 *    +--------------------+
 *-----------------------------------------------------------------------------
 * -3- Init the NEED_SWITCH/SAVE in tpl_kern.
 */
  mova       #tpl_kern, r11
  movx.a     #NO_NEED_SWITCH_NOR_SCHEDULE, TPL_KERN_OFFSET_NEED_SWITCH(r11)
  movx.a     #NO_NEED_SWITCH_NOR_SCHEDULE, TPL_KERN_OFFSET_NEED_SCHEDULE(r11)
/*-----------------------------------------------------------------------------
 * -4- Call the underlying C function.
 */
  calla      #tpl_tick_TIMER3_A0_VECTOR
/* 
 * PROCESS STACK:                 KERNEL STACK:
 *    +--------------------+            +-------------------+
 *  0 |   0  | r11.19:16   | + 0      0 |  0 |   PC.19:16   | + 0
 *    +--------------------+            +-------------------+
 *  1 |      r11.15:0      | + 2      1 |      PC.15:0      | + 2
 *    +--------------------+            +-------------------+
 *  2 |   0  | r12.19:16   | + 4      2 |  0 |  PSP.19:16   | + 4 
 *    +--------------------+            +-------------------+
 *  3 |      r12.15:0      | + 6      3 |     PSP.15:0      | + 6
 *    +--------------------+            +-------------------+
 *  4 |   0  | r13.19:16   | + 8
 *    +--------------------+
 *  5 |      r13.15:0      | + 10
 *    +--------------------+
 *  6 |   0  | r14.19:16   | + 12
 *    +--------------------+
 *  7 |      r14.15:0      | + 14
 *    +--------------------+
 *  8 |   0  | r15.19:16   | + 16
 *    +--------------------+
 *  9 |      r15.15:0      | + 18
 *    +--------------------+
 * 10 | PC.19:16 | SR.11:0 | + 20
 *    +--------------------+
 * 11 |      PC.15:0       | + 22
 *    +--------------------+
 * 12 | CallTerminateXXX   | + 24
 *    +--------------------+ 
 */ 
/*-----------------------------------------------------------------------------
 * -5- Switch back to the process stack
 */
tpl_direct_irq_handler_exit_TIMER3_A0_VECTOR:
  mova       r1, r13 /* get a copy of the KSP to restore it later        */
  addx.a       #4, r13 /* and forget the pushed PC (not useful anymore).  */
  popx.a     r1   /* get the saved process stack pointer back         */
/*  
 * PROCESS STACK:                
 *    +--------------------+
 *  0 |   0  | r11.19:16   | + 0      
 *    +--------------------+           
 *  1 |      r11.15:0      | + 2      
 *    +--------------------+            
 *  2 |   0  | r12.19:16   | + 4       
 *    +--------------------+            
 *  3 |      r12.15:0      | + 6      
 *    +--------------------+            
 *  4 |   0  | r13.19:16   | + 8
 *    +--------------------+
 *  5 |      r13.15:0      | + 10
 *    +--------------------+
 *  6 |   0  | r14.19:16   | + 12
 *    +--------------------+
 *  7 |      r14.15:0      | + 14
 *    +--------------------+
 *  8 |   0  | r15.19:16   | + 16
 *    +--------------------+
 *  9 |      r15.15:0      | + 18
 *    +--------------------+
 * 10 | PC.19:16 | SR.11:0 | + 20
 *    +--------------------+
 * 11 |      PC.15:0       | + 22
 *    +--------------------+
 * 12 | CallTerminateXXX   | + 24
 *    +--------------------+ 
 */
/*-----------------------------------------------------------------------------
 * -6- Check the context switch condition in tpl_kern.
 */
  mova       #tpl_kern, r11
  tstx.a     TPL_KERN_OFFSET_NEED_SWITCH(r11)
  jz        tpl_TIMER3_A0_VECTOR_no_context_switch
/*-----------------------------------------------------------------------------
 * -7- Save the rest of the context.
 */ 
  pushm.a   #7, r10  /* Push r4 to r10 */
/*
 * PROCESS STACK:
 *    +--------------------+   
 *  0 |   0  |  r4.19:16   | + 0  
 *    +--------------------+   
 *  1 |       r4.15:0      | + 2            
 *    +--------------------+
 *  2 |   0  |  r5.19:16   | + 4  
 *    +--------------------+   
 *  3 |       r5.15:0      | + 6            
 *    +--------------------+
 *  4 |   0  |  r6.19:16   | + 8  
 *    +--------------------+   
 *  5 |       r6.15:0      | + 10            
 *    +--------------------+
 *  6 |   0  |  r7.19:16   | + 12  
 *    +--------------------+   
 *  7 |       r7.15:0      | + 14           
 *    +--------------------+
 *  8 |   0  |  r8.19:16   | + 16 
 *    +--------------------+   
 *  9 |       r8.15:0      | + 18           
 *    +--------------------+  
 * 10 |   0  |  r9.19:16   | + 20  
 *    +--------------------+   
 * 11 |       r9.15:0      | + 22            
 *    +--------------------+
 * 12 |   0  | r10.19:16   | + 24  
 *    +--------------------+   
 * 13 |      r10.15:0      | + 26            
 *    +--------------------+
 * 14 |   0  | r11.19:16   | + 28      
 *    +--------------------+           
 * 15 |      r11.15:0      | + 30      
 *    +--------------------+            
 * 16 |   0  | r12.19:16   | + 32       
 *    +--------------------+            
 * 17 |      r12.15:0      | + 34      
 *    +--------------------+            
 * 18 |   0  | r13.19:16   | + 36
 *    +--------------------+
 * 19 |      r13.15:0      | + 38
 *    +--------------------+
 * 20 |   0  | r14.19:16   | + 40
 *    +--------------------+
 * 21 |      r14.15:0      | + 42
 *    +--------------------+
 * 22 |   0  | r15.19:16   | + 44
 *    +--------------------+
 * 23 |      r15.15:0      | + 46
 *    +--------------------+
 * 24 | PC.19:16 | SR.11:0 | + 48
 *    +--------------------+
 * 25 |      PC.15:0       | + 50
 *    +--------------------+
 * 26 | CallTerminateXXX   | + 52
 *    +--------------------+ 
 */
/*-----------------------------------------------------------------------------
 * -8- Now the stack pointer is saved in the dedicated location.
 */  
  mova       &tpl_kern, r11 /* Get the s_running slot of tpl_kern in r11 */
  mova       @r11, r11      /* Get the pointer to the context (SP alone) */
  movx.a     r1, @r11       /* Save the stack pointer                    */
/*-----------------------------------------------------------------------------
 * -9- Call tpl_run_elected with argument 1 (aka save) after switching back
 * to the kernel stack.
 */
  mova       r13, r1        /* Switch back to the kernel stack           */
  movx.a     #1, REG_RETARG
  calla      #tpl_run_elected
/*
 * PROCESS STACK:                    KERNEL STACK:
 *    +--------------------+              +-------------------+
 *  0 |   0  |  r4.19:16   | + 0        0 |  0  |  PC.19:16   | + 0
 *    +--------------------+              +-------------------+
 *  1 |       r4.15:0      | + 2        1 |      PC.15:0      | + 2
 *    +--------------------+              +-------------------+
 *  2 |   0  |  r5.19:16   | + 4  
 *    +--------------------+   
 *  3 |       r5.15:0      | + 6            
 *    +--------------------+
 *  4 |   0  |  r6.19:16   | + 8  
 *    +--------------------+   
 *  5 |       r6.15:0      | + 10            
 *    +--------------------+
 *  6 |   0  |  r7.19:16   | + 12  
 *    +--------------------+   
 *  7 |       r7.15:0      | + 14           
 *    +--------------------+
 *  8 |   0  |  r8.19:16   | + 16 
 *    +--------------------+   
 *  9 |       r8.15:0      | + 18           
 *    +--------------------+  
 * 10 |   0  |  r9.19:16   | + 20  
 *    +--------------------+   
 * 11 |       r9.15:0      | + 22            
 *    +--------------------+
 * 12 |   0  | r10.19:16   | + 24  
 *    +--------------------+   
 * 13 |      r10.15:0      | + 26            
 *    +--------------------+
 * 14 |   0  | r11.19:16   | + 28      
 *    +--------------------+           
 * 15 |      r11.15:0      | + 30      
 *    +--------------------+            
 * 16 |   0  | r12.19:16   | + 32       
 *    +--------------------+            
 * 17 |      r12.15:0      | + 34      
 *    +--------------------+            
 * 18 |   0  | r13.19:16   | + 36
 *    +--------------------+
 * 19 |      r13.15:0      | + 38
 *    +--------------------+
 * 20 |   0  | r14.19:16   | + 40
 *    +--------------------+
 * 21 |      r14.15:0      | + 42
 *    +--------------------+
 * 22 |   0  | r15.19:16   | + 44
 *    +--------------------+
 * 23 |      r15.15:0      | + 46
 *    +--------------------+
 * 24 | PC.19:16 | SR.11:0 | + 48
 *    +--------------------+
 * 25 |      PC.15:0       | + 50
 *    +--------------------+
 * 26 | CallTerminateXXX   | + 52
 *    +--------------------+ 
 */
/*-----------------------------------------------------------------------------
 * -10- tpl_run_elected has copied the elected process slot of tpl_kern to the
 * running slot. We load the stack pointer of the new running process.
 */
  mova       &tpl_kern, r11 /* Get the s_running slot of tpl_kern in r11 */
  mova       @r11, r11      /* Get the pointer to the context (SP alone) */
  mova       @r11, r1       /* Get the stack pointer                     */
/*-----------------------------------------------------------------------------
 * -11- Now, the context of the new running process is loaded. All registers
 * are popped.
 */
  popm.a    #12,r15        /* Pop r4 to r15  */
  reti
/*-----------------------------------------------------------------------------
 * -12- We get here from stage 6. Restore the volatile registers and return
 * from the interrupt handler.
 */
tpl_TIMER3_A0_VECTOR_no_context_switch:
  popm.a    #5, r15
  reti
/*-----------------------------------------------------------------------------
*/


#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

/* End of file tpl_irq_handlers.S */
