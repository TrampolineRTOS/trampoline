/**
 * @file tpl_primary_irq.S
 *
 * @section descr File description
 *
 * Generated from application weird
 * Automatically generated by goil on Sun Jan 17 16:14:58 2021
 * from root OIL file switch.oil
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */

.syntax unified
.thumb

#include "tpl_assembler.h"
#include "tpl_asm_definitions.h"
#include "tpl_os_kernel_stack.h"

.equ  NO_NEED_SWITCH_NOR_SCHEDULE, 0
.equ  NO_NEED_SWITCH, 0
.equ  NEED_SWITCH, 1
.equ  NEED_SAVE, 2

#define OS_START_SEC_VAR
#include "tpl_as_memmap.h"

.extern tpl_kern

#define OS_STOP_SEC_VAR
#include "tpl_as_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

/*=============================================================================
 * The interrupt handler assumes the following:
 *
 * The process stack is populated according to the Cortex M standard
 *
 * +------------------+
 * | R0               | <- PSP
 * +------------------+
 * | R1               | <- PSP+4
 * +------------------+
 * | R2               | <- PSP+8
 * +------------------+
 * | R3               | <- PSP+12
 * +------------------+
 * | R12              | <- PSP+16
 * +------------------+
 * | LR               | <- PSP+20
 * +------------------+
 * | Return Address   | <- PSP+24
 * +------------------+
 * | xPSR (bit 9 = 1) | <- PSP+28
 * +------------------+
 *
 */



/*=============================================================================
 * IRQ Handler for IRQ SystemCounter with source vector SysTick
 ******************************************************************************/
.global tpl_primary_irq_handler_SysTick
.type   tpl_primary_irq_handler_SysTick, %function

/*---------------------------------------------------------------------------*/
tpl_primary_irq_handler_SysTick:

    /*-----------------------------------------------------------------------*
     * Once here the stack has been changed to the master stack.             *
     * So SP is MSP, not PSP                                                 *
     *-----------------------------------------------------------------------*/

    /*-------------------------------------------------------------------------
     * 1 - Save the LR on the stack
     */
    push {lr}

    /*-------------------------------------------------------------------------
     * 2 - Reset the tpl_kern variables
     */
    ldr  r0,=tpl_kern
    movs r1,#NO_NEED_SWITCH_NOR_SCHEDULE
    strb r1,[r0,#TPL_KERN_OFFSET_NEED_SWITCH]
    strb r1,[r0,#TPL_KERN_OFFSET_NEED_SCHEDULE]

    /*-------------------------------------------------------------------------
     * 3 - Interrupt function call
     */
    bl   SysTick_Handler

    /*-------------------------------------------------------------------------
     * 4 - Check the context switch condition in tpl_kern
     */
    ldr  r0,=tpl_kern
    ldrb r1,[r0,#TPL_KERN_OFFSET_NEED_SWITCH]
    cmp  r1,#NO_NEED_SWITCH
    beq  tpl_SysTick_no_context_switch

    /*-------------------------------------------------------------------------
     * 5 - Save context
     *     Load in r0 the pointer to the static descriptor of the running task
     *     r0 already points to tpl_kern (from stage 4)
     */
    ldr  r0,[r0,#TPL_KERN_OFFSET_S_RUNNING]
    bl   tpl_save_context_under_it

    /*-------------------------------------------------------------------------
     * 6 - Call tpl_run_elected.
     *     The argument is a boolean which is true if the process is
     *     preempted. Here it is true because in an interrupt handler
     *     a process is inevitably preempted
     */
    movs r0,#1
    bl   tpl_run_elected

    /*-------------------------------------------------------------------------
     * 7 - Load context
     *     Load in r0 the pointer to the context of the running task.
     *     It has been changed by tpl_run_elected
     */
    ldr  r0,=tpl_kern
    ldr  r0,[r0,#TPL_KERN_OFFSET_S_RUNNING]
    bl   tpl_load_context_under_it

tpl_SysTick_no_context_switch:

    /*-------------------------------------------------------------------------
     * 8 - pop LR that was saved at stage 1 into PC and return from the handler
     */
    pop  {pc}

/*---------------------------------------------------------------------------*/


#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

.end

/* End of file tpl_second_stage_irq.S */
