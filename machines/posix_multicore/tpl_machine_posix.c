/*
 * Trampoline OS
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * Trampoline posix machine dependent stuffs
 *
 */

#include "tpl_machine.h"
#include "tpl_app_config.h"
#include "tpl_os_internal_types.h"
#include "tpl_viper_interface.h"
#include "tpl_os_interrupt_kernel.h"
#include "tpl_os_definitions.h"
#include "tpl_machine_interface.h"
#include "tpl_os.h"
#include "tpl_os_application_def.h" /* define NO_ISR if needed. */
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#include "tpl_as_timing_protec.h"
#endif /* WITH_AUTOSAR_TIMING_PROTECTION */
#if WITH_AUTOSAR == YES
#include "tpl_as_isr_kernel.h"
#include "tpl_os_kernel.h" /* for tpl_running_obj */
#include "tpl_as_definitions.h"
#include "tpl_os_task_kernel.h"
#include "tpl_os_resource_kernel.h"
#endif /* WITH_AUTOSAR */

#if defined(__unix__) || defined(__APPLE__)
	#include <assert.h>
#endif
#include <setjmp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>

VAR(tpl_stack_word, OS_VAR) idle_stack_zone[32768/sizeof(tpl_stack_word)] = {0} ;
VAR(struct TPL_STACK, OS_VAR) idle_task_stack = { idle_stack_zone, 32768} ;
VAR(struct TPL_CONTEXT, OS_VAR) idle_task_context;

extern volatile u32 tpl_locking_depth;
extern VAR(tpl_bool, OS_VAR) tpl_user_task_lock;
extern VAR(tpl_bool, OS_VAR) tpl_cpt_os_task_lock;

#if TASK_COUNT > 0
extern FUNC(void, OS_CODE) CallTerminateTask(void);
#endif

#if ISR_COUNT > 0
extern FUNC(void, OS_CODE) CallTerminateISR2(void);
#endif

#if WITH_AUTOSAR_TIMING_PROTECTION == YES

static struct timeval startup_time;

/* Time in tenth of milliseconds since system startup */
tpl_time tpl_get_local_current_date ()
{
    struct timeval time;
    tpl_time result;
  
    gettimeofday (&time, NULL);
    result = 
      (time.tv_sec - startup_time.tv_sec) * 100
    + (time.tv_usec - startup_time.tv_usec) / 10000;
  
    return result;
}

/* Sets a watchdog to expire in tenth of millisec */
void tpl_set_watchdog (tpl_time delay)
{
    struct itimerval timer;
    tpl_time offset;
     
    offset = delay - tpl_get_local_current_date();
    
        /* configure and start the timer */
        timer.it_interval.tv_sec = 0;
        timer.it_interval.tv_usec = 0;
        timer.it_value.tv_sec = offset / 100;
        timer.it_value.tv_usec = (offset % 100)  * 10000;
        setitimer (ITIMER_REAL, &timer, NULL);
}

void tpl_cancel_watchdog(void)
{
    struct itimerval timer;
  
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_usec = 0;
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_usec = 0;
    setitimer (ITIMER_REAL, &timer, NULL);
}
#endif /* WITH_AUTOSAR_TIMING_PROTECTION */

#if WITH_AUTOSAR_STACK_MONITORING == YES
FUNC(tpl_bool, OS_CODE) tpl_check_stack_pointer(
  CONST(tpl_proc_id, AUTOMATIC) proc_id)
{
    return 1;
}

tpl_bool tpl_check_stack_footprint(
  CONST(tpl_proc_id, AUTOMATIC) proc_id)
{
    return 1;
}
#endif /* WITH_AUTOSAR_STACK_MONITORING */

/*
 * table which stores the signals used for interrupt
 * handlers.
 */
#if ISR_COUNT > 0
	extern int signal_for_isr_id[ISR_COUNT];
#endif
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
    const int signal_for_watchdog = SIGALRM;
#endif /* WITH_AUTOSAR_TIMING_PROTECTION */
#if ((WITH_AUTOSAR == YES) && (SCHEDTABLE_COUNT > 0)) || (ALARM_COUNT > 0)
	const int signal_for_counters = SIGUSR2;
#endif

/*
 * The signal set corresponding to the enabled interrupts
 */
sigset_t    signal_set;

/** fonction that calls the system function tpl_counter_tick() 
 * for each counter declared in the application.
 * tpl_call_counter_tick() is application dependant and is 
 * generated by the OIL compiler (goil).
 */
void tpl_call_counter_tick();

/*static sigset_t tpl_saved_state;*/

/**
 * Enable all interrupts
 */
void tpl_enable_interrupts(void)
{
    if ( -1 == sigprocmask(SIG_UNBLOCK, &signal_set, NULL) )
    {
        perror("tpl_enable_interrupt failed");
        exit(-1);
    }
}

/**
 * Disable all interrupts
 */
void tpl_disable_interrupts(void)
{
    if ( -1 == sigprocmask(SIG_BLOCK, &signal_set, NULL) )
    {
        perror("tpl_disable_interrupts failed");
        exit(-1);
    }
}

/*
 * The signal handler used when interrupts are enabled
 */
void tpl_signal_handler(int sig)
{
    
#if ISR_COUNT > 0
            unsigned int id;
            unsigned char found;
#endif

    tpl_locking_depth++;
    tpl_cpt_os_task_lock++;

#if ((WITH_AUTOSAR == YES) && (SCHEDTABLE_COUNT > 0)) || (ALARM_COUNT > 0)
    if (signal_for_counters == sig) 
    {
        tpl_call_counter_tick();
    }
    else
    {
#endif /*(defined WITH_AUTOSAR && !defined NO_SCHEDTABLE) || ... */
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
        if (signal_for_watchdog == sig)
        {
           tpl_watchdog_expiration();
        }
        else
        {
#endif /* WITH_AUTOSAR_TIMING_PROTECTION */
#if ISR_COUNT > 0
            id = 0;
            found = (sig == signal_for_isr_id[id]);
            while( (id < ISR_COUNT) && !found)
            {
                id++;
                if(id < ISR_COUNT) 
                {
                    found  = (sig == signal_for_isr_id[id]);
                }
            }/* while((id < ISR_COUNT) && !found) */

            if(found)
            {
                tpl_central_interrupt_handler(id + TASK_COUNT);
            } 
            else
            {
                /* Unknown interrupt request ! */
                printf("No ISR is registered for signal %d\n", sig);
                printf("Cowardly exiting!\n");
                tpl_shutdown();
            }
#endif /* ISR_COUNT > 0 */
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
        }
#endif /* WITH_AUTOSAR_TIMING_PROTECTION */
#if ((WITH_AUTOSAR == YES) && (SCHEDTABLE_COUNT > 0)) || (ALARM_COUNT > 0)
    }
#endif /* (defined WITH_AUTOSAR && !defined NO_SCHEDTABLE) || ... */
	
    tpl_locking_depth--;
    tpl_cpt_os_task_lock--;
	
}

/*
 * tpl_sleep is used by the idle task
 */
void tpl_sleep(void)
{
    while(1) pause(); 
}

extern void viper_kill(void);

void tpl_shutdown(void)
{

    /* remove ITs */
    if (sigprocmask(SIG_BLOCK,&signal_set,NULL) == -1)
    {
        perror("tpl_shutdown failed");
        exit(-1);
    }

    viper_kill();

    exit(0);
}

volatile int x = 0;
int cnt = 0;
/*
 * tpl_get_task_lock is used to lock a critical section 
 * around the task management in the os.
 */
void tpl_get_task_lock(void)
{
    /*
     * block the handling of signals
     */
    if(0 == tpl_locking_depth) {
        if (sigprocmask(SIG_BLOCK,&signal_set,NULL) == -1)
        {
            perror("tpl_get_lock failed");
            exit(-1);
        }
    }
    tpl_locking_depth++;
    tpl_cpt_os_task_lock++;
}

/*
 * tpl_release_task_lock is used to unlock a critical section
 * around the task management in the os.
 */
void tpl_release_task_lock(void)
{
#if defined(__unix__) || defined(__APPLE__)
	assert( tpl_locking_depth > 0 );
#endif
	tpl_locking_depth--;
    tpl_cpt_os_task_lock--;

    if ( (tpl_locking_depth == 0) && (FALSE == tpl_user_task_lock) )
    {
        if (sigprocmask(SIG_UNBLOCK,&signal_set,NULL) == -1) {
            perror("tpl_release_lock failed");
            exit(-1);
        }
    }
}

#define OS_START_SEC_CODE
#include "tpl_memmap.h"
FUNC(void, OS_CODE) tpl_switch_context(
    CONSTP2CONST(tpl_context, AUTOMATIC, OS_CONST) old_context,
    CONSTP2CONST(tpl_context, AUTOMATIC, OS_CONST) new_context)
{
    if( NULL == old_context)
    {
        _longjmp((*new_context)->current, 1);
    }
    else if ( 0 == _setjmp((*old_context)->current) ) 
    {
        _longjmp((*new_context)->current, 1);
    }
    return;
}


FUNC(void, OS_CODE) tpl_switch_context_from_it(
    CONSTP2CONST(tpl_context, AUTOMATIC, OS_CONST) old_context,
    CONSTP2CONST(tpl_context, AUTOMATIC, OS_CONST) new_context)
{
    if( NULL == old_context )
    {
        _longjmp((*new_context)->current, 1);
    }
    else if ( 0 == _setjmp((*old_context)->current) ) 
    {
        _longjmp((*new_context)->current, 1);
    }
    return;
}

#define OS_START_SEC_CODE
#include "tpl_memmap.h"
FUNC(void, OS_CODE) tpl_init_context(
        CONST(tpl_proc_id, OS_APPL_DATA) proc_id)
{
    /*printf("tpl_init_context(%d)\n", proc_id);*/
    memcpy( tpl_stat_proc_table[proc_id]->context->current,
            tpl_stat_proc_table[proc_id]->context->initial,
            sizeof(jmp_buf));
}

void tpl_osek_func_stub( tpl_proc_id task_id )
{
  tpl_proc_function func = tpl_stat_proc_table[task_id]->entry;
  tpl_proc_type     type = tpl_stat_proc_table[task_id]->type;
  
  /* Avoid signal blocking due to a previous call to tpl_init_context in a OS_ISR2 context. */
	tpl_release_task_lock();
    
  (*func)();
    
  /* Terminate Task/ISR*/
  if (type == IS_ROUTINE) {
#if ISR_COUNT > 0
    CallTerminateISR2();
#endif
  }
  else
  {
#if TASK_COUNT > 0
    CallTerminateTask();
    fprintf(stderr, "[OSEK/VDX Spec. 2.2.3 Sec. 4.7] Ending the task without a call to TerminateTask or ChainTask is strictly forbidden and causes undefined behaviour.\n");
    exit(1);
#endif
  }
}

/**
 * global variables used to store the "old" context
 * during the trampoline phase used to create a new context
 */
VAR(sigset_t,OS_VAR)        saved_mask;
VAR(sig_atomic_t,OS_VAR)    handler_has_been_triggered;
VAR(tpl_proc_id,OS_VAR)     new_proc_id;

#define OS_START_SEC_CODE
#include "tpl_memmap.h"
FUNC(void, OS_CODE) tpl_create_context_boot(void)
{
    tpl_proc_id context_owner_proc_id;
    
    /*
     * 10 : restore the mask modified by _longjmp so that
     * all tasks are executed with the same mask
     * Commented out since _longjmp/_setjmp replace longjmp/setjmp
     */
     sigprocmask(SIG_SETMASK, &saved_mask, NULL);

    /* 11 : store the id of the owner of this context */
    context_owner_proc_id = new_proc_id;
    /*printf("Just set context_owner_proc_id to %d\n", context_owner_proc_id); */
/*    getchar();*/

    /* 12 & 13 : context is ready, jump back to the tpl_create_context */
    if( 0 == _setjmp(tpl_stat_proc_table[context_owner_proc_id]->context->initial) ) 
    {
        _longjmp(tpl_stat_proc_table[IDLE_TASK_ID]->context->current, 1);
    }

    /*printf("About to launch proc#%d\n", context_owner_proc_id);*/
/*    getchar(); */
    /* 13 bis : save the initial context of the task */
    /*memcpy( tpl_stat_proc_table[context_owner_proc_id]->context->initial,
            tpl_stat_proc_table[context_owner_proc_id]->context->current, 
            sizeof(jmp_buf));
    */
    /* We are back for the first dispatch. Let's go */
/*    tpl_osek_func_stub(context_owner_proc_id); */
    tpl_osek_func_stub(tpl_kern.running_id);

    /* We should not be there. Let's crash*/
    abort();
    return;
}

#define OS_START_SEC_CODE
#include "tpl_memmap.h"
FUNC(void, OS_CODE) tpl_create_context_trampoline(int sigid)
{
    /* 5 : new context created. We go back to tpl_init_context */
    if( 0==_setjmp(tpl_stat_proc_table[new_proc_id]->context->initial) ) 
    {
        handler_has_been_triggered = TRUE;
        return;
    }

    /* 
     * 9 : we are back after a jump, but no more in signal handling mode
     * We are ready to boot the new context with a clean stack 
     */
    tpl_create_context_boot();
    return;
}

#define OS_START_SEC_CODE
#include "tpl_memmap.h"
FUNC(void, OS_CODE) tpl_create_context(
    CONST(tpl_proc_id, OS_APPL_DATA) proc_id)
{
    struct sigaction new_action;
    struct sigaction old_action;
    stack_t new_stack;
    stack_t old_stack;
    sigset_t new_mask;
    sigset_t old_mask;

    /* 1 : save the current mask, and mask our worker signal : SIGUSR1 */
    sigemptyset(&new_mask);
    sigaddset(&new_mask, SIGUSR1);
    sigprocmask(SIG_BLOCK, &new_mask, &old_mask); 

    /*
     * 2 : install the new action for our worker signal.
     * Triggered function : tpl_init_context_trampoline.
     * It will be executed on its own stack (that is the trick).
     * When it will be executed, all signals will be blocked.
     */
    memset((void*)&new_action, 0, sizeof(new_action));
    new_action.sa_handler = tpl_create_context_trampoline;
    new_action.sa_flags = SA_ONSTACK;
    sigemptyset(&new_action.sa_mask);
    sigaction(SIGUSR1, &new_action, &old_action);

    /* 3 : prepare the new stack */
    new_stack.ss_sp = (tpl_stat_proc_table[proc_id]->stack)->stack_zone;
    new_stack.ss_size = (tpl_stat_proc_table[proc_id]->stack)->stack_size;
    new_stack.ss_flags = 0;
    sigaltstack(&new_stack, &old_stack);

    /* 4-a : store data for new context in globals */
/*    new_env = &((tpl_stat_proc_table[proc_id]->context)->current);*/
    new_proc_id = proc_id;
    saved_mask = old_mask; 
    handler_has_been_triggered = FALSE;
    /* 4-b : send the worker signal */
    kill(getpid(), SIGUSR1);
    /* 4-c : prepare to unblock the worker signal */
    sigfillset(&new_mask);
    sigdelset(&new_mask, SIGUSR1);
    /* 
     * 4-d : unblock the worker signal and wait for it.
     * Once it is arrived, the previous mask is restored.
     */
    while(FALSE == handler_has_been_triggered)
        sigsuspend(&new_mask);

    /*
     * 6 : we are back from tpl_init_context_trampoline.
     * We can restore the previous signal handling configuration
     */
    sigaltstack(NULL, &new_stack);
    new_stack.ss_flags = SS_DISABLE;
    sigaltstack(&new_stack, NULL);
    if( ! (old_stack.ss_flags & SS_DISABLE) ) 
        sigaltstack(&old_stack, NULL);
    sigaction(SIGUSR1, &old_action, NULL);
    sigprocmask(SIG_SETMASK, &old_mask, NULL);

    /*
     * 7 & 8 : we jump back to the created context.
     * This time, we are no more in signal handling mode
     */
    if ( 0 == _setjmp(tpl_stat_proc_table[IDLE_TASK_ID]->context->current) )
        _longjmp(tpl_stat_proc_table[new_proc_id]->context->initial,1);

    /* 
     * 14 : we go back to the caller 
     */
    return;
}

void quit(int n)
{
    ShutdownOS(E_OK);  
}

/*
 * tpl_init_machine init the virtual processor hosted in
 * a Unix process
 */
void tpl_init_machine(void)
{
    tpl_proc_id proc_id;
#if ISR_COUNT > 0
    int id;
#endif
    struct sigaction sa;


    /* create the context of each tpl_proc */
    for(    proc_id = 0; 
            proc_id < TASK_COUNT+ISR_COUNT+1; 
            proc_id++)
    {
        tpl_create_context(proc_id);
    }
    
    signal(SIGINT, quit);
    signal(SIGHUP, quit);

    sigemptyset(&signal_set);
    
    /*
     * init a signal mask to block all signals (aka interrupts)
     */
#if ISR_COUNT > 0
    for (id = 0; id < ISR_COUNT; id++) {
        sigaddset(&signal_set,signal_for_isr_id[id]);
    }
#endif
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
    sigaddset(&signal_set,signal_for_watchdog);
#endif /* WITH_AUTOSAR_TIMING_PROTECTION */
#if ((WITH_AUTOSAR == YES) && (SCHEDTABLE_COUNT > 0)) || (ALARM_COUNT > 0)
    sigaddset(&signal_set,signal_for_counters);
#endif /*(defined WITH_AUTOSAR && !defined NO_SCHEDTABLE) || ... */


    /*
     * init the sa structure to install the handler
     */
    sa.sa_handler = tpl_signal_handler;
    sa.sa_mask = signal_set;
    sa.sa_flags = SA_RESTART;
    /*
     * Install the signal handler used to emulate interruptions
     */
#if ISR_COUNT > 0
    for (id = 0; id < ISR_COUNT; id++) {
        sigaction(signal_for_isr_id[id],&sa,NULL);
    }
#endif
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
    sigaction(signal_for_watchdog,&sa,NULL);
#endif /* WITH_AUTOSAR_TIMING_PROTECTION */
#if ((WITH_AUTOSAR == YES) && (SCHEDTABLE_COUNT > 0)) || (ALARM_COUNT > 0)
    sigaction(signal_for_counters,&sa,NULL);
#endif /*(defined WITH_AUTOSAR && !defined NO_SCHEDTABLE) || ... */

    tpl_viper_init();

#if ((WITH_AUTOSAR == YES) && (SCHEDTABLE_COUNT > 0)) || (ALARM_COUNT > 0)
    tpl_viper_start_auto_timer(signal_for_counters,10000);  /* 10 ms */
#endif

    /*
     * unblock the handling of signals
     */
    /*if (sigprocmask(SIG_UNBLOCK,&signal_set,NULL) == -1) {
        perror("tpl_init_machine failed");
        exit(-1);
    }
	*/
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
    gettimeofday (&startup_time, NULL);  
#endif /* WITH_AUTOSAR_TIMING_PROTECTION */
}


#if NUMBER_OF_CORES > 1
/**
 * Table used to store the correspondance between the core identifier
 * and the pthread.
 */
static pthread_t tpl_threads[NUMBER_OF_CORES];

/**
 * tpl_start_core
 *
 * Starts a core. This function create a pthread with main as the
 * entry point. 
 */
FUNC(void, OS_CODE) tpl_start_core(
  CONST(CoreIdType, AUTOMATIC) core_id)
{
  int result = pthread_create(&tpl_threads[core_id], NULL, main, NULL);
}

/**
 * tpl_actual_main
 *
 * Actual entry point of an application. Posix being an emulated hardware
 * platform, tpl_actual_main create the first core in the machine (ie
 * the core having the OS_CORE_ID_MASTER (that is OS_CORE_ID_0) core id)
 */
FUNC(void, OS_CODE) tpl_actual_main(void)
{
  tpl_start_core(OS_CORE_ID_MASTER);
  
  while(1) pause();
}

#endif

/* End of file tpl_machine_posix.c */
