%!TEX root = ./main.tex

\chapter{Tracing the execution}

\section*{Introduction}

The code of Trampoline RTOS embeds a tracing subsystem that can be activated at
system configuration time.
This toolkit sends a stream of events describing the execution of the
application to a target specific backend.
The resulting data can then be exploited to compute statistics on some
performance figures of the system (such as execution times, jitters, etc.)
and/or to feed a visualization tool.
Please notice that, in the current implementation, the tracing toolkit has a small, albeit non null, overhead so
the system from which traces are computed is not exactly the same than the
system without traces.

\section{Traced events}

Events that can be traced during an execution are given below.
Each event is described by its name and a set of attributes.
These attributes are made available by the kernel to the platform specific
backend (see section~\ref{sec:trace:targetbackend} below).

\begin{description}
  \item[PROC\_CHANGE\_STATE]: state of a process (task or ISR) is changed.
    \begin{itemize}
      \item \texttt{proc\_id}: identifier of the process.
      \item \texttt{target\_state}: new state of the proc. %TODO: list states
    \end{itemize}

  \item[RES\_CHANGE\_STATE]: state of a resource is changed.
    \begin{itemize}
      \item \texttt{res\_id}: identifier of the resource.
      \item \texttt{target\_state}: new state of the resource. %TODO: list states
    \end{itemize}

  \item[EVENT\_SET]: a process sets one or more event to another process.
    \begin{itemize}
      \item \texttt{proc\_id}: owner of the events.
      \item \texttt{ev\_id}: list of events that have been set.
    \end{itemize}

  \item[EVENT\_RESET]: a process resets a subset of its events
    \begin{itemize}
      \item \texttt{ev\_id}: list of events that have been reset.
    \end{itemize}

  \item[TIMEOBJ\_CHANGE\_STATE]: state of a timeobj (alarm, schedule table
    expiry point) is changed.
    \begin{itemize}
      \item \texttt{timeobj\_id}: identifier of the timeobj.
      \item \texttt{target\_state}: new state of the timeobj.
    \end{itemize}

  \item[TIMEOBJ\_EXPIRE]: a timeobj expires.
    \begin{itemize}
      \item \texttt{alarm\_id}: identifier of the timeobj.
    \end{itemize}

\end{description}

Notice that each event contains the minimal information that is needed
to rebuild the whole state of the system.
Hence, the running task is never used as an attribute because it can be deduced
by analysing the sequence of \emph{PROC\_CHANGE\_STATE} events.

\section{OIL declaration}
\subsection{Generic part}

Activation of tracing is done at system configuration time through the OIL file.
A boolean attribute \oilattr{TRACE} is defined in the \oilobj{OS} object. It has
several subattributes has shown in the code below:

\begin{lstlisting}[language=OIL]
TRACE = TRUE {
    FORMAT = SERIAL;
    PROC = TRUE;
    RESOURCE = TRUE;
    ALARM = TRUE;
    EVENT = TRUE;
};
\end{lstlisting}

\begin{description}
	\item[FORMAT] specifies the output format of the trace. This is a target dependant attribute. For instance, the posix target allows the \texttt{json} output, while the msp430 allows the \texttt{serial} and \texttt{fram} targets (with sub-attributes). See section \ref{sec:traceTargetFormat}.

  \item[PROC] controls the tracing of event \texttt{PROC\_CHANGE\_STATE};

  \item[RESOURCE] controls the tracing of event \texttt{RES\_CHANGE\_STATE};

  \item[ALARM] controls the tracing of events \texttt{TIMEOBJ\_CHANGE\_STATE}
    and \texttt{TIMEOBJ\_EXPIRE};

  \item[EVENT]  controls the tracing of events \texttt{EVENT\_SET}
    and \texttt{EVENT\_RESET};
\end{description}

\subsection{Target specific part}
\label{sec:traceTargetFormat}
\subsubsection{Posix target}
The posix target is the simplest one, as there is no problem to get back the trace. The trace can be saved in \texttt{json} mode only. The generated file is always called \file{trace.json}.

\subsubsection{MSP430 target}
For the MSP430 format, different methods can be implemented to retrieve the trace:
\begin{description}
	\item[\texttt{SERIAL}] the serial communication, using the \emph{serial over USB} link on launchpad dev board;
	\item[\texttt{FRAM}] the FRAM storage. In that case, the trace is stored directly on the FRAM and can be read using a gdb dump. Sub-attributs are:
\begin{description}
	\item[\texttt{SIZE}] the size of the dump in bytes;
	\item[\texttt{ADDRESS}] the base address.
\end{description} It should not be used if the throughput is too high!
(not implemented yet).

	\item[\texttt{SD}] the embedded SD card (not implemented yet).
\end{description}

In all cases, a trace event should take as low room as possible, and is stored in binary format (see section \ref{sec:traceBinFormat}).



\section{Using the tracing subsystem}

The trace are generated by trampoline on the target. A difficulty resides in the ability to retrieve the information on the host system. 

The trace system is split in 3 steps, as defined in Figure \ref{fig:trace}:
\begin{description}
	\item[TraceReader] reads \textsl{raw events} from the target. A \textsl{raw event} deals only with numerical ids from Trampoline. The reader can read events from the serial or from a file at this date. It can store them to a file for later evaluation.
	\item[TraceEvaluate] associates a name with each ids, thanks to the \file{tpl_static_info.json} file generated by goil. It can make some extra evaluation on the application: there is never an event received to a suspended task, there is never critical section overlap due to bad resource usage, â€¦
	\item[TraceExport] prints the trace (text based or graphical).
\end{description}

\begin{figure}[htbp]
    \centering
	\begin{adjustbox}{width=.7\linewidth,keepaspectratio}
		\input{./trace.tikz}
	\end{adjustbox}
	\caption{Getting trace list from the target. The \file{readTrace.py} script calls the 3 steps of the trace : \pyfunction{TraceReader}, \pyfunction{TraceEvaluate} and \pyfunction{TraceExport}, for each event.}
	\label{fig:trace}
\end{figure}

For the serial line reader, the events are queued in a dedicated thread, so that there is no event loss, even if evaluation/export are too slow.

\note{On the posix target, trampoline generates directly the \texttt{trace.json} file.}

Tools are provided in the \file{extra/trace-tools/} directory of Trampoline, and called directly by the generated script \file{readTrace.py}. Run to have information how to use the script:

\begin{lstlisting}
./readTrace.py --help
\end{lstlisting}

For now, the script can read from a json file (posix or saved trace) or a serial line. It can save a received trace to a file for later use. The export is text based only.

\note{When receiving an endless trace (serial line for instance), you can terminate the reception with \texttt{Ctrl+C}}.


\section{Implementation}
The implementation is split in 2 parts:
\begin{pitemize}
	\item the \emph{generic} part is a set of macro in the \file{os/} kernel files to captures trace events. The file \file{os/tpl_trace.h} list all the specific functions that should be implemented.
	\item the \emph{target specific} part in \file{machine/.../tpl_trace.c} implements the trace back-end. 
\end{pitemize}

\subsection{Implementing target specific backends}
\label{sec:trace:targetbackend}

The backend consists in a set of 7 functions that should be implemented in the target to store events, and communicate them to an host computer for analysis. Prototypes are in the \texttt{os/tpl_trace.h} are each function is related to a trace event. For instance, the following function will be called by the kernel internal files (\emph{in kernel mode!}) each time a proc (task/isr) state is updated.

\begin{lstlisting}[language=C]
/**
 * trace the execution of a task or ISR
 * This function should be implemented
 * in the machine dependant trace backend.
 */
FUNC(void, OS_CODE) tpl_trace_proc_change_state(
    CONST(tpl_proc_id,AUTOMATIC) proc_id,
    CONST(tpl_proc_state,AUTOMATIC) target_state);
\end{lstlisting}

A new file is now generated by goil \file{tpl_static_info.oil} that lists the objects defined in the oil file. This file can be combined with the trace to deal with the name of an object instead of its internal id.


\subsection{Binary format}
\label{sec:traceBinFormat}

The binary format is defined in Figure \ref{fig:traceBin}. It is composed of:
\begin{description}
	\item[Type] There are 6 events types: PROC\_CHANGE\_STATE, RES\_CHANGE\_STATE, EVENT\_SET, EVENT\_RESET, TIMEOBJ\_CHANGE\_STATE and TIMEOBJ\_EXPIRE. One extra type \emph{OVERFLOW} is defined if the communication medium cannot assure a sufficent bandwidth. 3 bits are required.
	\item[TimeStamp] The time stamp. The overflow should be taken into account by the receiver (events are in chronological order). Most significant byte first.
	\item[xxx] This is the event dependent data (5+8 bits).
	\item[Chksum] The checksum (8 bits) is the sum of the 4 previous bytes. Its goal is both to detect errors and frame limits.
\end{description}

\begin{figure}[htbp]
    \centering
	\begin{adjustbox}{width=.8\linewidth,keepaspectratio}
		\input{./traceBin.tikz}
	\end{adjustbox}
	\caption{binary format of a trace event (5 bytes)}
	\label{fig:traceBin}
\end{figure}

For each type, we define the specific bits:

\begin{table}[htbp]
	\rowcolors{1}{white}{light-gray}
	\begin{longtable}[c]{c|c|l}
		\bf Type & \bf format (5+8 bits) & \bf fields \\ \hline
		PROC\_CHANGE\_STATE    & \texttt{00SSS PPPPPPPP}& \texttt{S} (3 bits): proc state \\
		                       &                        & \texttt{P} (8 bits): proc id    \\ \hline
		RES\_CHANGE\_STATE     & \texttt{00SSS RRRRRRRR}& \texttt{S} (3 bits): res state  \\
		                       &                        & \texttt{R} (8 bits): res id     \\ \hline
		EVENT\_SET             & \texttt{EEEEE TTTTTTTT}& \texttt{E} (5 bits): event id   \\
		                       &                        & \texttt{T} (8 bits): task id     \\ \hline
		EVENT\_RESET           & \texttt{EEEEE 00000000}& \texttt{E} (5 bits): event id   \\ \hline
		TIMEOBJ\_EXPIRE        & \texttt{00000 TTTTTTTT}& \texttt{R} (8 bits): time obj id    \\ \hline
		TIMEOBJ\_CHANGE\_STATE & \texttt{00SSS TTTTTTTT}& \texttt{S} (3 bits): time obj. state \\
		                       &                        & \texttt{T} (8 bits): time obj id    \\ \hline
	\end{longtable}
	\caption{Specific bits for each event type}
	\label{tab:traceBin}
\end{table}

Due to frame size limits, the number of events is limited to 31, the number of procs (task/isr) to 255, as well as time objects (alarms, schedule tables) and resources.

\subsection{JSON format}
\label{sec:traceJSONFormat}

The JSON format embedds a list of events (\texttt{trace.json} in Fig.\ref{fig:trace}). This trace is generated and handled by the \texttt{TraceReader} script (in \texttt{extra/trace-tools/TraceReader.py}). 

This file is generated from the binary format (see section \ref{sec:traceBinFormat}), it contains raw information (using ids instead of names):

\begin{description}
	\item[\texttt{ts}] a timestamp (integer value). The overflow that may appear in binary format is not possible in the JSON format;
	\item[\texttt{type}] The event type. Depending on the event, the sub-attributes (always integers) are given:
		\begin{description}
			\item[\texttt{proc}:] attributes \texttt{target_state} and \texttt{proc_id}
			\item[\texttt{set_event}:] attributes \texttt{event} and \texttt{target_task_id}.
			\item[\texttt{reset_event}:] attribute \texttt{event}
			\item[\texttt{timeobj}:] attributes \texttt{target_state} and \texttt{timeobj_id}
			\item[\texttt{timeobj_expire}:] attributes \texttt{timeobj_id}
\end{description}
\end{description}
All the attributes are the one manipulated internally by the kernel, and are used to get corresponding application names using the file \texttt{tpl_static_info.json} generated by goil.

Here is a (short) example of a JSON trace file:
\begin{verbatim}
[
  {
    "ts": 28600,
    "type": "timeobj_expire",
    "timeobj_id": 0
  },
  {
    "ts": 28600,
    "type": "proc",
    "target_state": 5,
    "proc_id": 0
  },
  {
    "ts": 28600,
    "type": "proc",
    "target_state": 1,
    "proc_id": 1
  },
  ...
]
\end{verbatim}

The generation of a JSON file from binary events is implemented in function \texttt{decodeBinaryEvent} in script \texttt{extra/trace-tools/TraceReader.py}.

\subsection{How to port \texttt{trace} to another target}

The \texttt{tpl\_trace.c} is target specific. It should be defined in the \lstinline{machine} hierarchy. A good starting point is the msp430's version, with a SERIAL implementation. In the \texttt{avr/arduino} version, a C++ example is provided.

Then, the goil templates should be updated. This is done in 2 steps:

\begin{itemize}
	\item Add the new file \texttt{tpl\_trace.c} (or \texttt{.cpp}) to be compiled in the project: in \texttt{config/\textit{target}/config.oil} \\

\lstset{language=OIL}
\begin{lstlisting}
  PLATFORM_FILES targetTrace {
    PATH    = "target";        //path, starting from machine/
    CFILE   = "tpl_trace.c";   // file name (cpp allowed)
  };
\end{lstlisting}

	\item Add the definition of the trace type to be defined in the oil file: in section IMPLEMENTATION/OS in \texttt{config/\textit{target}/config.oil}:
\begin{lstlisting}
    /* trace */
    BOOLEAN [
      TRUE {
        ENUM [
          serial
        ] FORMAT = serial;
      },
      FALSE
    ] TRACE = FALSE;
\end{lstlisting}
\end{itemize}

In this example, only the serial type is allowed. You can have a look to the msp430 version, where other modes are available, and one have sub-attributes (for fram target).

That's all!
%\subsubsection{MSP430}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
