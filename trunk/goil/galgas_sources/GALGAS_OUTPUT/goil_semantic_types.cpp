//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'goil_semantic_types.cpp'                       *
//                       Generated by version 1.9.12                         *
//                       may 17th, 2010, at 15h23'48"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != 742
  #error "This file has been compiled with a version of GALGAS that uses libpm version 742, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_semantic_types.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_semantic_types.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_implementation_spec'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_implementation_spec::e_implementation_spec (void) :
type () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@implementation_spec'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_implementation_spec ("implementation_spec", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_implementation_spec::
elementOf_GGS_implementation_spec (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_implementation_spec & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementation_spec::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.type.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_implementation_spec::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_implementation_spec * ptr = dynamic_cast <const elementOf_GGS_implementation_spec *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.type.operator_isEqual (ptr->mInfo.type)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementation_spec::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_implementation_spec *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementation_spec * info = (e_implementation_spec *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_implementation_spec *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_implementation_spec * info = (e_implementation_spec *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation_spec result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_implementation_spec info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation_spec::
operator_isEqual (const GGS_implementation_spec & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation_spec::
operator_isNotEqual (const GGS_implementation_spec & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_imp_type & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.type ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_imp_type & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_implementation_spec info  ;
    info.type = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_imp_type   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation_spec::kSearchMessage_get [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_imp_type   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation_spec::kRemoveMessage_del [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_imp_type & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation_spec::kInsertMessage_put [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation_spec::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_imp_type & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_implementation_spec & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation_spec result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementation_spec result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementation_spec::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @implementation_spec " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_imp_type  & GGS_implementation_spec::cEnumerator::_type (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.type ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_implementation_spec::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_implementation_spec * p = NULL ;
    macroMyNew (p, GGS_implementation_spec (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation_spec GGS_implementation_spec::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_implementation_spec result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_implementation_spec * p = dynamic_cast <const GGS_implementation_spec *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_implementation_spec, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_implementation_spec::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_implementation_spec ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_implementation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_implementation::e_implementation (void) :
spec () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@implementation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_implementation ("implementation", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_implementation::
elementOf_GGS_implementation (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_implementation & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_implementation::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.spec.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_implementation::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_implementation * ptr = dynamic_cast <const elementOf_GGS_implementation *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.spec.operator_isEqual (ptr->mInfo.spec)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_implementation::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_implementation *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_implementation * info = (e_implementation *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_implementation *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_implementation * info = (e_implementation *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_implementation info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation::
operator_isEqual (const GGS_implementation & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_implementation::
operator_isNotEqual (const GGS_implementation & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_implementation_spec & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.spec ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_implementation::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_implementation_spec & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_implementation info  ;
    info.spec = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_implementation::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_implementation_spec   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.spec ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation::kSearchMessage_get [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_implementation_spec   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation::kRemoveMessage_del [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_implementation_spec & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_implementation::kInsertMessage_put [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_implementation::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_implementation_spec & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_implementation & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_implementation result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_implementation result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_implementation::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @implementation " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_implementation_spec  & GGS_implementation::cEnumerator::_spec (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.spec ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_implementation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_implementation * p = NULL ;
    macroMyNew (p, GGS_implementation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_implementation GGS_implementation::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_implementation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_implementation * p = dynamic_cast <const GGS_implementation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_implementation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_implementation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_implementation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                             class 'e_os_imp'                              *
//                                                                           *
//---------------------------------------------------------------------------*

e_os_imp::e_os_imp (void) :
type () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@os_imp'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_os_imp ("os_imp", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_os_imp::
elementOf_GGS_os_imp (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_os_imp & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_os_imp::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.type.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_os_imp::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_os_imp * ptr = dynamic_cast <const elementOf_GGS_os_imp *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.type.operator_isEqual (ptr->mInfo.type)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_os_imp::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_os_imp *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_os_imp * info = (e_os_imp *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_os_imp *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_os_imp * info = (e_os_imp *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_os_imp info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_os_imp::
operator_isEqual (const GGS_os_imp & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_os_imp::
operator_isNotEqual (const GGS_os_imp & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_os_imp info  ;
    info.type = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_imp::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.type ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_os_imp & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_os_imp result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_os_imp result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_os_imp::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @os_imp " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_os_imp::cEnumerator::_type (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.type ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_os_imp::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_os_imp * p = NULL ;
    macroMyNew (p, GGS_os_imp (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_imp GGS_os_imp::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_os_imp result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_os_imp * p = dynamic_cast <const GGS_os_imp *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_os_imp, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_os_imp::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_os_imp ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_event_mask_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_obj::
cPtr_event_mask_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_obj * GGS_event_mask_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_event_mask_obj) ;
    return (cPtr_event_mask_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_event_mask_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_mask_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_obj (& typeid (cPtr_event_mask_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_event_mask_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_event_mask_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_event_mask_obj ("event_mask_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_event_mask_obj::
GGS_event_mask_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_obj::
GGS_event_mask_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_mask_obj GGS_event_mask_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_mask_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_event_mask_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_mask_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_obj::actualTypeName (void) const {
  return "event_mask_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_event_mask_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__event_mask_obj ("event_mask_obj", & kTypeDescriptor_GGS_event_mask_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_mask_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_mask_obj * p = NULL ;
    macroMyNew (p, GGS_event_mask_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_obj GGS_event_mask_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_mask_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_mask_obj * p = dynamic_cast <const GGS_event_mask_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_mask_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_event_mask_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_mask_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_void_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_void_obj::
cPtr_event_mask_void_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_void_obj * GGS_event_mask_void_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_event_mask_void_obj) ;
    return (cPtr_event_mask_void_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_void_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_void_obj * ptr = dynamic_cast <const cPtr_event_mask_void_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_void_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_mask_void_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_void_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_void_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_void_obj (& typeid (cPtr_event_mask_void_obj), & typeid (cPtr_event_mask_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_event_mask_void_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_void_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_event_mask_void_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_event_mask_void_obj (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_void_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_event_mask_void_obj ("event_mask_void_obj", true, & kTypeDescriptor_GGS_event_mask_obj) ;

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj::
GGS_event_mask_void_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj::
GGS_event_mask_void_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_mask_void_obj GGS_event_mask_void_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_void_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_void_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_void_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_mask_void_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_void_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj GGS_event_mask_void_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_void_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_void_obj (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_void_obj::actualTypeName (void) const {
  return "event_mask_void_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__event_mask_void_obj ("event_mask_void_obj", gClassInfoFor__event_mask_obj, & kTypeDescriptor_GGS_event_mask_void_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_mask_void_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_mask_void_obj * p = NULL ;
    macroMyNew (p, GGS_event_mask_void_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_void_obj GGS_event_mask_void_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_mask_void_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_mask_void_obj * p = dynamic_cast <const GGS_event_mask_void_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_mask_void_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_event_mask_void_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_mask_void_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_user_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_user_obj::
cPtr_event_mask_user_obj (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE),
mask (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_user_obj * GGS_event_mask_user_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_event_mask_user_obj) ;
    return (cPtr_event_mask_user_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_user_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_user_obj * ptr = dynamic_cast <const cPtr_event_mask_user_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && mask.operator_isEqual (ptr->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_user_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_mask_user_obj:"
           << location.reader_description (inIndentation + 1)
           << mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_user_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_user_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_user_obj (& typeid (cPtr_event_mask_user_obj), & typeid (cPtr_event_mask_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_event_mask_user_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_user_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_event_mask_user_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_event_mask_user_obj (location, mask COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_user_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_event_mask_user_obj ("event_mask_user_obj", true, & kTypeDescriptor_GGS_event_mask_obj) ;

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj::
GGS_event_mask_user_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj::
GGS_event_mask_user_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_mask_user_obj GGS_event_mask_user_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_user_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_user_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_user_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_mask_user_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_user_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj GGS_event_mask_user_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_user_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_user_obj (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_event_mask_user_obj::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_mask_user_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_mask_user_obj *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_user_obj::actualTypeName (void) const {
  return "event_mask_user_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__event_mask_user_obj ("event_mask_user_obj", gClassInfoFor__event_mask_obj, & kTypeDescriptor_GGS_event_mask_user_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_mask_user_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_mask_user_obj * p = NULL ;
    macroMyNew (p, GGS_event_mask_user_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_user_obj GGS_event_mask_user_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_mask_user_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_mask_user_obj * p = dynamic_cast <const GGS_event_mask_user_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_mask_user_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_event_mask_user_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_mask_user_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_event_mask_auto_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_mask_auto_obj::
cPtr_event_mask_auto_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_event_mask_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_mask_auto_obj * GGS_event_mask_auto_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_event_mask_auto_obj) ;
    return (cPtr_event_mask_auto_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_mask_auto_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_mask_auto_obj * ptr = dynamic_cast <const cPtr_event_mask_auto_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_mask_auto_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_mask_auto_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_mask_auto_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_mask_auto_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_mask_auto_obj (& typeid (cPtr_event_mask_auto_obj), & typeid (cPtr_event_mask_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_event_mask_auto_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_mask_auto_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_event_mask_auto_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_event_mask_auto_obj (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_event_mask_auto_obj'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_event_mask_auto_obj ("event_mask_auto_obj", true, & kTypeDescriptor_GGS_event_mask_obj) ;

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj::
GGS_event_mask_auto_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj::
GGS_event_mask_auto_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_mask_auto_obj GGS_event_mask_auto_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_mask_auto_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_mask_auto_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_mask_auto_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_mask_auto_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_mask_auto_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj GGS_event_mask_auto_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_event_mask_auto_obj result ;
  macroMyNew (result.mPointer, cPtr_event_mask_auto_obj (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_mask_auto_obj::actualTypeName (void) const {
  return "event_mask_auto_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__event_mask_auto_obj ("event_mask_auto_obj", gClassInfoFor__event_mask_obj, & kTypeDescriptor_GGS_event_mask_auto_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_mask_auto_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_mask_auto_obj * p = NULL ;
    macroMyNew (p, GGS_event_mask_auto_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_auto_obj GGS_event_mask_auto_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_mask_auto_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_mask_auto_obj * p = dynamic_cast <const GGS_event_mask_auto_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_mask_auto_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_event_mask_auto_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_mask_auto_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_event_obj'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_event_obj::
cPtr_event_obj (const GGS_lstring & argument_0,
                                const GGS_event_mask_obj & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
mask (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_event_obj * GGS_event_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_event_obj) ;
    return (cPtr_event_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_event_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_event_obj * ptr = dynamic_cast <const cPtr_event_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = desc.operator_isEqual (ptr->desc).boolValue ()
         && mask.operator_isEqual (ptr->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_event_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@event_obj:"
           << desc.reader_description (inIndentation + 1)
           << mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_event_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_event_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_event_obj (& typeid (cPtr_event_obj), & typeid (cPtr_oil_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_event_obj::galgasRTTI (void) const {
  return & gClassInfoFor__event_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_event_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_event_obj (desc, mask COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_event_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_event_obj ("event_obj", true, & kTypeDescriptor_GGS_oil_obj) ;

//---------------------------------------------------------------------------*

GGS_event_obj::
GGS_event_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_event_obj::
GGS_event_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_event_obj GGS_event_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_event_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_event_obj *> (inPointer) != NULL)
      : (typeid (cPtr_event_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_event_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_event_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_obj GGS_event_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_event_mask_obj & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_event_obj result ;
  macroMyNew (result.mPointer, cPtr_event_obj (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_mask_obj  GGS_event_obj::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_mask_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_event_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_event_obj *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_event_obj::actualTypeName (void) const {
  return "event_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__event_obj ("event_obj", gClassInfoFor__oil_obj, & kTypeDescriptor_GGS_event_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_event_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_obj * p = NULL ;
    macroMyNew (p, GGS_event_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_obj GGS_event_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_obj * p = dynamic_cast <const GGS_event_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_event_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_event_map'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_event_map::e_event_map (void) :
event () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@event_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_event_map ("event_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_event_map::
elementOf_GGS_event_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_event_map & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_event_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.event.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_event_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_event_map * ptr = dynamic_cast <const elementOf_GGS_event_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.event.operator_isEqual (ptr->mInfo.event)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_event_map::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_event_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_event_map * info = (e_event_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_event_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_event_map * info = (e_event_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_event_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_map::
operator_isEqual (const GGS_event_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_map::
operator_isNotEqual (const GGS_event_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_event_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.event ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_event_map::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_event_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_event_map info  ;
    info.event = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_event_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_event_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.event ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_map::kSearchMessage_get [] = {
  TO_UNICODE ('G'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('_'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (':'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_event_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_map::kRemoveMessage_del [] = {
  TO_UNICODE ('D'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('_'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (':'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_map::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_event_obj & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_map::kInsertMessage_put [] = {
  TO_UNICODE ('P'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('_'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (':'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_event_obj & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_event_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_event_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @event_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_event_obj  & GGS_event_map::cEnumerator::_event (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.event ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_event_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_map * p = NULL ;
    macroMyNew (p, GGS_event_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_map GGS_event_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_map * p = dynamic_cast <const GGS_event_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_event_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_eventMaskMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_eventMaskMap::e_eventMaskMap (void) :
mask () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@eventMaskMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_eventMaskMap ("eventMaskMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_eventMaskMap::
elementOf_GGS_eventMaskMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_eventMaskMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_eventMaskMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_eventMaskMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_eventMaskMap * ptr = dynamic_cast <const elementOf_GGS_eventMaskMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mask.operator_isEqual (ptr->mInfo.mask)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_eventMaskMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_eventMaskMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_eventMaskMap * info = (e_eventMaskMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_eventMaskMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_eventMaskMap * info = (e_eventMaskMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_eventMaskMap GGS_eventMaskMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_eventMaskMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_eventMaskMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_eventMaskMap::
operator_isEqual (const GGS_eventMaskMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_eventMaskMap::
operator_isNotEqual (const GGS_eventMaskMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_uint64 & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.mask ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint64 & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_eventMaskMap info  ;
    info.mask = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint64   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mask ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_eventMaskMap::kSearchMessage_get [] = {
  TO_UNICODE ('G'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('@'),
  TO_UNICODE ('e'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('M'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE ('M'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (':'),
  TO_UNICODE (' '),
  TO_UNICODE ('E'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint64   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_eventMaskMap::kRemoveMessage_del [] = {
  TO_UNICODE ('D'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('@'),
  TO_UNICODE ('e'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('M'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE ('M'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (':'),
  TO_UNICODE (' '),
  TO_UNICODE ('E'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint64 & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_eventMaskMap::kInsertMessage_put [] = {
  TO_UNICODE ('E'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_eventMaskMap::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint64 & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_eventMaskMap GGS_eventMaskMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_eventMaskMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_eventMaskMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_eventMaskMap GGS_eventMaskMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_eventMaskMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_eventMaskMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @eventMaskMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint64  & GGS_eventMaskMap::cEnumerator::_mask (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mask ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_eventMaskMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_eventMaskMap * p = NULL ;
    macroMyNew (p, GGS_eventMaskMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_eventMaskMap GGS_eventMaskMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_eventMaskMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_eventMaskMap * p = dynamic_cast <const GGS_eventMaskMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_eventMaskMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_eventMaskMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_eventMaskMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_event_usage_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_event_usage_map::e_event_usage_map (void) :
count () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@event_usage_map'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_event_usage_map ("event_usage_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_event_usage_map::
elementOf_GGS_event_usage_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_event_usage_map & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_event_usage_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.count.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_event_usage_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_event_usage_map * ptr = dynamic_cast <const elementOf_GGS_event_usage_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.count.operator_isEqual (ptr->mInfo.count)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_event_usage_map::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_event_usage_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_event_usage_map * info = (e_event_usage_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_event_usage_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_event_usage_map * info = (e_event_usage_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_usage_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_event_usage_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_usage_map::
operator_isEqual (const GGS_event_usage_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_event_usage_map::
operator_isNotEqual (const GGS_event_usage_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_uint & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.count ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_event_usage_map info  ;
    info.count = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.count ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_usage_map::kSearchMessage_get_count [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
method_get_count (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get_count,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_usage_map::kRemoveMessage_delete [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
modifier_delete (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_delete,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_event_usage_map::kInsertMessage_insert_count [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_event_usage_map::
modifier_insert_count (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insert_count,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_event_usage_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_event_usage_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_event_usage_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_event_usage_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @event_usage_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_event_usage_map::cEnumerator::_count (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.count ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_event_usage_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_event_usage_map * p = NULL ;
    macroMyNew (p, GGS_event_usage_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_event_usage_map GGS_event_usage_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_event_usage_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_event_usage_map * p = dynamic_cast <const GGS_event_usage_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_event_usage_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_event_usage_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_event_usage_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@sorted_events'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sorted_events::
elementOf_GGS_sorted_events (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1):
event_name (argument_0),
count (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sorted_events::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sorted_events * ptr = dynamic_cast <const elementOf_GGS_sorted_events *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = event_name.operator_isEqual (ptr->event_name).boolValue ()
         && count.operator_isEqual (ptr->count).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_sorted_events::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_sorted_events * operand = (const elementOf_GGS_sorted_events *) inOperand ;
  PMSInt32 result = - count.genericObjectCompare (operand->count) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sorted_events::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << event_name.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << count.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Sorted list '@sorted_events'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sorted_events ("sorted_events", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_sorted_events::GGS_sorted_events (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_sorted_events::
GGS_sorted_events (const GGS_sorted_events & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sorted_events::
operator_isEqual (const GGS_sorted_events & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sorted_events::
operator_isNotEqual (const GGS_sorted_events & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sorted_events GGS_sorted_events::
operator_concat (const GGS_sorted_events & inOperand) const {
  GGS_sorted_events result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
dotAssign_operation (const GGS_sorted_events inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sorted_events * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->event_name ;
          GGS_uint  p_1 = p->count ;
          internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->event_name,
                                ptr->count) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sorted_events  GGS_sorted_events::
constructor_emptySortedList (void) {
  GGS_sorted_events result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sorted_events  GGS_sorted_events::
constructor_sortedListWithValue (const GGS_lstring & argument_0,
                           const GGS_uint & argument_1) {
  GGS_sorted_events result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sorted_events::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sorted_events", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
method_smallest (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->event_name ;
    _out_1 = ptr->count ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
method_greatest (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->event_name ;
    _out_1 = ptr->count ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->event_name ;
    _out_1 = ptr->count ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sorted_events::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->event_name ;
    _out_1 = ptr->count ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_sorted_events::cEnumerator::_event_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->event_name ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_sorted_events::cEnumerator::_count (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->count ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sorted_events::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sorted_events * p = NULL ;
    macroMyNew (p, GGS_sorted_events (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sorted_events GGS_sorted_events::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sorted_events result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sorted_events * p = dynamic_cast <const GGS_sorted_events *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sorted_events, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sorted_events::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sorted_events ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_alarm_autostart_true'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_alarm_autostart_true::
cPtr_alarm_autostart_true (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1,
                                const GGS_luint64 & argument_2,
                                const GGS_stringset & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_autostart_obj (argument_0 COMMA_THERE),
alarm_time (argument_1),
cycle_time (argument_2),
app_modes (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_alarm_autostart_true * GGS_alarm_autostart_true::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_alarm_autostart_true) ;
    return (cPtr_alarm_autostart_true *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_alarm_autostart_true::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_alarm_autostart_true * ptr = dynamic_cast <const cPtr_alarm_autostart_true *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && alarm_time.operator_isEqual (ptr->alarm_time).boolValue ()
         && cycle_time.operator_isEqual (ptr->cycle_time).boolValue ()
         && app_modes.operator_isEqual (ptr->app_modes).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_alarm_autostart_true::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@alarm_autostart_true:"
           << location.reader_description (inIndentation + 1)
           << alarm_time.reader_description (inIndentation + 1)
           << cycle_time.reader_description (inIndentation + 1)
           << app_modes.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_alarm_autostart_true::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_alarm_autostart_true::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_alarm_autostart_true (& typeid (cPtr_alarm_autostart_true), & typeid (cPtr_autostart_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_alarm_autostart_true::galgasRTTI (void) const {
  return & gClassInfoFor__alarm_autostart_true ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_alarm_autostart_true::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_alarm_autostart_true (location, alarm_time, cycle_time, app_modes COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_alarm_autostart_true'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_alarm_autostart_true ("alarm_autostart_true", true, & kTypeDescriptor_GGS_autostart_obj) ;

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true::
GGS_alarm_autostart_true (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true::
GGS_alarm_autostart_true (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_alarm_autostart_true GGS_alarm_autostart_true::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_alarm_autostart_true result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_alarm_autostart_true *> (inPointer) != NULL)
      : (typeid (cPtr_alarm_autostart_true) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_alarm_autostart_true (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_alarm_autostart_true),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true GGS_alarm_autostart_true::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1,
                 const GGS_luint64 & argument_2,
                 const GGS_stringset & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_alarm_autostart_true result ;
  macroMyNew (result.mPointer, cPtr_alarm_autostart_true (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_alarm_autostart_true::
reader_alarm_time (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->alarm_time ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_alarm_autostart_true::
reader_cycle_time (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->cycle_time ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_alarm_autostart_true::
reader_app_modes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_autostart_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_autostart_true *) mPointer)->app_modes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_alarm_autostart_true::actualTypeName (void) const {
  return "alarm_autostart_true" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__alarm_autostart_true ("alarm_autostart_true", gClassInfoFor__autostart_obj, & kTypeDescriptor_GGS_alarm_autostart_true) ;

//---------------------------------------------------------------------------*

GGS_object GGS_alarm_autostart_true::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_alarm_autostart_true * p = NULL ;
    macroMyNew (p, GGS_alarm_autostart_true (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_autostart_true GGS_alarm_autostart_true::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_alarm_autostart_true result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_alarm_autostart_true * p = dynamic_cast <const GGS_alarm_autostart_true *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_alarm_autostart_true, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_alarm_autostart_true::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_alarm_autostart_true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_alarm_obj'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_alarm_obj::
cPtr_alarm_obj (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_autostart_obj & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
counter_name (argument_1),
action_params (argument_2),
autostart_params (argument_3),
acc_apps (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_alarm_obj * GGS_alarm_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_alarm_obj) ;
    return (cPtr_alarm_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_alarm_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_alarm_obj * ptr = dynamic_cast <const cPtr_alarm_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = desc.operator_isEqual (ptr->desc).boolValue ()
         && counter_name.operator_isEqual (ptr->counter_name).boolValue ()
         && action_params.operator_isEqual (ptr->action_params).boolValue ()
         && autostart_params.operator_isEqual (ptr->autostart_params).boolValue ()
         && acc_apps.operator_isEqual (ptr->acc_apps).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_alarm_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@alarm_obj:"
           << desc.reader_description (inIndentation + 1)
           << counter_name.reader_description (inIndentation + 1)
           << action_params.reader_description (inIndentation + 1)
           << autostart_params.reader_description (inIndentation + 1)
           << acc_apps.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_alarm_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_alarm_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_alarm_obj (& typeid (cPtr_alarm_obj), & typeid (cPtr_oil_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_alarm_obj::galgasRTTI (void) const {
  return & gClassInfoFor__alarm_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_alarm_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_alarm_obj (desc, counter_name, action_params, autostart_params, acc_apps COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_alarm_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_alarm_obj ("alarm_obj", true, & kTypeDescriptor_GGS_oil_obj) ;

//---------------------------------------------------------------------------*

GGS_alarm_obj::
GGS_alarm_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_obj::
GGS_alarm_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_alarm_obj GGS_alarm_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_alarm_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_alarm_obj *> (inPointer) != NULL)
      : (typeid (cPtr_alarm_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_alarm_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_alarm_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_obj GGS_alarm_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_action_obj & argument_2,
                 const GGS_autostart_obj & argument_3,
                 const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_alarm_obj result ;
  macroMyNew (result.mPointer, cPtr_alarm_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_alarm_obj::
reader_counter_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->counter_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_alarm_obj::
reader_action_params (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->action_params ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_obj  GGS_alarm_obj::
reader_autostart_params (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_autostart_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->autostart_params ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_alarm_obj::
reader_acc_apps (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_alarm_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_alarm_obj *) mPointer)->acc_apps ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_alarm_obj::actualTypeName (void) const {
  return "alarm_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__alarm_obj ("alarm_obj", gClassInfoFor__oil_obj, & kTypeDescriptor_GGS_alarm_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_alarm_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_alarm_obj * p = NULL ;
    macroMyNew (p, GGS_alarm_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_obj GGS_alarm_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_alarm_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_alarm_obj * p = dynamic_cast <const GGS_alarm_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_alarm_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_alarm_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_alarm_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_alarm_map'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_alarm_map::e_alarm_map (void) :
alarm () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@alarm_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_alarm_map ("alarm_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_alarm_map::
elementOf_GGS_alarm_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_alarm_map & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_alarm_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.alarm.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_alarm_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_alarm_map * ptr = dynamic_cast <const elementOf_GGS_alarm_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.alarm.operator_isEqual (ptr->mInfo.alarm)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_alarm_map::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_alarm_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_alarm_map * info = (e_alarm_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_alarm_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_alarm_map * info = (e_alarm_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_alarm_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_alarm_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_alarm_map::
operator_isEqual (const GGS_alarm_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_alarm_map::
operator_isNotEqual (const GGS_alarm_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_alarm_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.alarm ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_alarm_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_alarm_map info  ;
    info.alarm = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_alarm_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_alarm_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.alarm ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_alarm_map::kSearchMessage_get [] = {
  TO_UNICODE ('A'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_alarm_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_alarm_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_alarm_map::kRemoveMessage_del [] = {
  TO_UNICODE ('A'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_alarm_map::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_alarm_obj & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_alarm_map::kInsertMessage_put [] = {
  TO_UNICODE ('A'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_alarm_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_alarm_obj & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_alarm_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_alarm_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_alarm_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_alarm_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @alarm_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_alarm_obj  & GGS_alarm_map::cEnumerator::_alarm (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.alarm ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_alarm_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_alarm_map * p = NULL ;
    macroMyNew (p, GGS_alarm_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_alarm_map GGS_alarm_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_alarm_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_alarm_map * p = dynamic_cast <const GGS_alarm_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_alarm_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_alarm_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_alarm_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_base_mess'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_base_mess::
cPtr_base_mess (const GGS_lstring & argument_0,
                                const GGS_action_obj & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_ident_map & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
notification (argument_1),
notificationerror (argument_2),
acc_apps (argument_3),
other_fields (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_base_mess * GGS_base_mess::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_base_mess) ;
    return (cPtr_base_mess *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_base_mess::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@base_mess:"
           << desc.reader_description (inIndentation + 1)
           << notification.reader_description (inIndentation + 1)
           << notificationerror.reader_description (inIndentation + 1)
           << acc_apps.reader_description (inIndentation + 1)
           << other_fields.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_base_mess::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_base_mess::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_base_mess (& typeid (cPtr_base_mess), & typeid (cPtr_oil_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_base_mess::galgasRTTI (void) const {
  return & gClassInfoFor__base_mess ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_base_mess'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_base_mess ("base_mess", true, & kTypeDescriptor_GGS_oil_obj) ;

//---------------------------------------------------------------------------*

GGS_base_mess::
GGS_base_mess (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_base_mess::
GGS_base_mess (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_base_mess GGS_base_mess::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_base_mess result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_base_mess *> (inPointer) != NULL)
      : (typeid (cPtr_base_mess) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_base_mess (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_base_mess),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_base_mess::
reader_notification (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->notification ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_action_obj  GGS_base_mess::
reader_notificationerror (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_action_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->notificationerror ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_base_mess::
reader_acc_apps (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->acc_apps ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map  GGS_base_mess::
reader_other_fields (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_base_mess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_base_mess *) mPointer)->other_fields ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_base_mess::actualTypeName (void) const {
  return "base_mess" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__base_mess ("base_mess", gClassInfoFor__oil_obj, & kTypeDescriptor_GGS_base_mess) ;

//---------------------------------------------------------------------------*

GGS_object GGS_base_mess::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_base_mess * p = NULL ;
    macroMyNew (p, GGS_base_mess (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_base_mess GGS_base_mess::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_base_mess result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_base_mess * p = dynamic_cast <const GGS_base_mess *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_base_mess, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_base_mess::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_base_mess ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_mess_prop_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mess_prop_obj::
cPtr_mess_prop_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mess_prop_obj * GGS_mess_prop_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mess_prop_obj) ;
    return (cPtr_mess_prop_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_mess_prop_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mess_prop_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mess_prop_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mess_prop_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mess_prop_obj (& typeid (cPtr_mess_prop_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mess_prop_obj::galgasRTTI (void) const {
  return & gClassInfoFor__mess_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_mess_prop_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mess_prop_obj ("mess_prop_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_mess_prop_obj::
GGS_mess_prop_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mess_prop_obj::
GGS_mess_prop_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mess_prop_obj GGS_mess_prop_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mess_prop_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mess_prop_obj *> (inPointer) != NULL)
      : (typeid (cPtr_mess_prop_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mess_prop_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mess_prop_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_mess_prop_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mess_prop_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mess_prop_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mess_prop_obj::actualTypeName (void) const {
  return "mess_prop_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_mess_prop_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__mess_prop_obj ("mess_prop_obj", & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mess_prop_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mess_prop_obj * p = NULL ;
    macroMyNew (p, GGS_mess_prop_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mess_prop_obj GGS_mess_prop_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mess_prop_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mess_prop_obj * p = dynamic_cast <const GGS_mess_prop_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mess_prop_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mess_prop_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mess_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_message_obj'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_message_obj::
cPtr_message_obj (const GGS_lstring & argument_0,
                                const GGS_action_obj & argument_1,
                                const GGS_action_obj & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_ident_map & argument_4,
                                const GGS_mess_prop_obj & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_base_mess (argument_0, argument_1, argument_2, argument_3, argument_4 COMMA_THERE),
messageproperty (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_message_obj * GGS_message_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_message_obj) ;
    return (cPtr_message_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_message_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_message_obj * ptr = dynamic_cast <const cPtr_message_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = desc.operator_isEqual (ptr->desc).boolValue ()
         && notification.operator_isEqual (ptr->notification).boolValue ()
         && notificationerror.operator_isEqual (ptr->notificationerror).boolValue ()
         && acc_apps.operator_isEqual (ptr->acc_apps).boolValue ()
         && other_fields.operator_isEqual (ptr->other_fields).boolValue ()
         && messageproperty.operator_isEqual (ptr->messageproperty).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_message_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@message_obj:"
           << desc.reader_description (inIndentation + 1)
           << notification.reader_description (inIndentation + 1)
           << notificationerror.reader_description (inIndentation + 1)
           << acc_apps.reader_description (inIndentation + 1)
           << other_fields.reader_description (inIndentation + 1)
           << messageproperty.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_message_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_message_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_message_obj (& typeid (cPtr_message_obj), & typeid (cPtr_base_mess), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_message_obj::galgasRTTI (void) const {
  return & gClassInfoFor__message_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_message_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_message_obj (desc, notification, notificationerror, acc_apps, other_fields, messageproperty COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_message_obj'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_message_obj ("message_obj", true, & kTypeDescriptor_GGS_base_mess) ;

//---------------------------------------------------------------------------*

GGS_message_obj::
GGS_message_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_message_obj::
GGS_message_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_message_obj GGS_message_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_message_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_message_obj *> (inPointer) != NULL)
      : (typeid (cPtr_message_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_message_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_message_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_obj GGS_message_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_action_obj & argument_1,
                 const GGS_action_obj & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_ident_map & argument_4,
                 const GGS_mess_prop_obj & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_message_obj result ;
  macroMyNew (result.mPointer, cPtr_message_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mess_prop_obj  GGS_message_obj::
reader_messageproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mess_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_message_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_message_obj *) mPointer)->messageproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_message_obj::actualTypeName (void) const {
  return "message_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__message_obj ("message_obj", gClassInfoFor__base_mess, & kTypeDescriptor_GGS_message_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_message_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_message_obj * p = NULL ;
    macroMyNew (p, GGS_message_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_obj GGS_message_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_message_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_message_obj * p = dynamic_cast <const GGS_message_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_message_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_message_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_message_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_message_map'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_message_map::e_message_map (void) :
mess () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@message_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_message_map ("message_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_message_map::
elementOf_GGS_message_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_message_map & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_message_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mess.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_message_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_message_map * ptr = dynamic_cast <const elementOf_GGS_message_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mess.operator_isEqual (ptr->mInfo.mess)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_message_map::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_message_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_message_map * info = (e_message_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_message_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_message_map * info = (e_message_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_message_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_message_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_message_map::
operator_isEqual (const GGS_message_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_message_map::
operator_isNotEqual (const GGS_message_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_message_obj & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.mess ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_message_map::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_message_obj & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_message_map info  ;
    info.mess = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_message_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_message_obj   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mess ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_message_map::kSearchMessage_get [] = {
  TO_UNICODE ('M'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_message_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_message_obj   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_get,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_message_map::kRemoveMessage_del [] = {
  TO_UNICODE ('M'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_message_map::
modifier_del (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_message_obj & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_del,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_message_map::kInsertMessage_put [] = {
  TO_UNICODE ('M'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_message_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_message_obj & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_message_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_message_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_message_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_message_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @message_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_message_obj  & GGS_message_map::cEnumerator::_mess (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mess ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_message_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_message_map * p = NULL ;
    macroMyNew (p, GGS_message_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_message_map GGS_message_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_message_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_message_map * p = dynamic_cast <const GGS_message_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_message_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_message_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_message_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_filter_prop_obj'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filter_prop_obj::
cPtr_filter_prop_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filter_prop_obj * GGS_filter_prop_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filter_prop_obj) ;
    return (cPtr_filter_prop_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_filter_prop_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filter_prop_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filter_prop_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filter_prop_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filter_prop_obj (& typeid (cPtr_filter_prop_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filter_prop_obj::galgasRTTI (void) const {
  return & gClassInfoFor__filter_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_filter_prop_obj'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filter_prop_obj ("filter_prop_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_filter_prop_obj::
GGS_filter_prop_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj::
GGS_filter_prop_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filter_prop_obj GGS_filter_prop_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filter_prop_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filter_prop_obj *> (inPointer) != NULL)
      : (typeid (cPtr_filter_prop_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filter_prop_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filter_prop_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_filter_prop_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filter_prop_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filter_prop_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filter_prop_obj::actualTypeName (void) const {
  return "filter_prop_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_filter_prop_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__filter_prop_obj ("filter_prop_obj", & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filter_prop_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filter_prop_obj * p = NULL ;
    macroMyNew (p, GGS_filter_prop_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj GGS_filter_prop_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filter_prop_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filter_prop_obj * p = dynamic_cast <const GGS_filter_prop_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filter_prop_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filter_prop_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filter_prop_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_void_filter'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_filter::
cPtr_void_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_filter * GGS_void_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_filter) ;
    return (cPtr_void_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_filter * ptr = dynamic_cast <const cPtr_void_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_filter (& typeid (cPtr_void_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_filter::galgasRTTI (void) const {
  return & gClassInfoFor__void_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_void_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_filter ("void_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_void_filter::
GGS_void_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_filter::
GGS_void_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_filter GGS_void_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_filter *> (inPointer) != NULL)
      : (typeid (cPtr_void_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_filter GGS_void_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void_filter result ;
  macroMyNew (result.mPointer, cPtr_void_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_filter::actualTypeName (void) const {
  return "void_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_filter ("void_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_void_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_filter * p = NULL ;
    macroMyNew (p, GGS_void_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_filter GGS_void_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_filter * p = dynamic_cast <const GGS_void_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_always_filter'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_always_filter::
cPtr_always_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_always_filter * GGS_always_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_always_filter) ;
    return (cPtr_always_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_always_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_always_filter * ptr = dynamic_cast <const cPtr_always_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_always_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@always_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_always_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_always_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_always_filter (& typeid (cPtr_always_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_always_filter::galgasRTTI (void) const {
  return & gClassInfoFor__always_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_always_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_always_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_always_filter'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_always_filter ("always_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_always_filter::
GGS_always_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_always_filter::
GGS_always_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_always_filter GGS_always_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_always_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_always_filter *> (inPointer) != NULL)
      : (typeid (cPtr_always_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_always_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_always_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_always_filter GGS_always_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_always_filter result ;
  macroMyNew (result.mPointer, cPtr_always_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_always_filter::actualTypeName (void) const {
  return "always_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__always_filter ("always_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_always_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_always_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_always_filter * p = NULL ;
    macroMyNew (p, GGS_always_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_always_filter GGS_always_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_always_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_always_filter * p = dynamic_cast <const GGS_always_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_always_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_always_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_always_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_never_filter'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_never_filter::
cPtr_never_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_never_filter * GGS_never_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_never_filter) ;
    return (cPtr_never_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_never_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_never_filter * ptr = dynamic_cast <const cPtr_never_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_never_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@never_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_never_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_never_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_never_filter (& typeid (cPtr_never_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_never_filter::galgasRTTI (void) const {
  return & gClassInfoFor__never_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_never_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_never_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_never_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_never_filter ("never_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_never_filter::
GGS_never_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_never_filter::
GGS_never_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_never_filter GGS_never_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_never_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_never_filter *> (inPointer) != NULL)
      : (typeid (cPtr_never_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_never_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_never_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_never_filter GGS_never_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_never_filter result ;
  macroMyNew (result.mPointer, cPtr_never_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_never_filter::actualTypeName (void) const {
  return "never_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__never_filter ("never_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_never_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_never_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_never_filter * p = NULL ;
    macroMyNew (p, GGS_never_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_never_filter GGS_never_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_never_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_never_filter * p = dynamic_cast <const GGS_never_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_never_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_never_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_never_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_maskednewequalsx_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewequalsx_filter::
cPtr_maskednewequalsx_filter (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1,
                                const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE),
mask (argument_1),
x (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewequalsx_filter * GGS_maskednewequalsx_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_maskednewequalsx_filter) ;
    return (cPtr_maskednewequalsx_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewequalsx_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewequalsx_filter * ptr = dynamic_cast <const cPtr_maskednewequalsx_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && mask.operator_isEqual (ptr->mask).boolValue ()
         && x.operator_isEqual (ptr->x).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsx_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@maskednewequalsx_filter:"
           << location.reader_description (inIndentation + 1)
           << mask.reader_description (inIndentation + 1)
           << x.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsx_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsx_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewequalsx_filter (& typeid (cPtr_maskednewequalsx_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_maskednewequalsx_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewequalsx_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_maskednewequalsx_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_maskednewequalsx_filter (location, mask, x COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_maskednewequalsx_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_maskednewequalsx_filter ("maskednewequalsx_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter::
GGS_maskednewequalsx_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter::
GGS_maskednewequalsx_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_maskednewequalsx_filter GGS_maskednewequalsx_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsx_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewequalsx_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewequalsx_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_maskednewequalsx_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewequalsx_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter GGS_maskednewequalsx_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1,
                 const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsx_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewequalsx_filter (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsx_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsx_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsx_filter::
reader_x (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsx_filter *) mPointer)->x ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewequalsx_filter::actualTypeName (void) const {
  return "maskednewequalsx_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__maskednewequalsx_filter ("maskednewequalsx_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_maskednewequalsx_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_maskednewequalsx_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_maskednewequalsx_filter * p = NULL ;
    macroMyNew (p, GGS_maskednewequalsx_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsx_filter GGS_maskednewequalsx_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsx_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_maskednewequalsx_filter * p = dynamic_cast <const GGS_maskednewequalsx_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_maskednewequalsx_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_maskednewequalsx_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_maskednewequalsx_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_maskednewdiffersx_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewdiffersx_filter::
cPtr_maskednewdiffersx_filter (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1,
                                const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE),
mask (argument_1),
x (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewdiffersx_filter * GGS_maskednewdiffersx_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_maskednewdiffersx_filter) ;
    return (cPtr_maskednewdiffersx_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewdiffersx_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewdiffersx_filter * ptr = dynamic_cast <const cPtr_maskednewdiffersx_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && mask.operator_isEqual (ptr->mask).boolValue ()
         && x.operator_isEqual (ptr->x).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersx_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@maskednewdiffersx_filter:"
           << location.reader_description (inIndentation + 1)
           << mask.reader_description (inIndentation + 1)
           << x.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersx_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersx_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewdiffersx_filter (& typeid (cPtr_maskednewdiffersx_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_maskednewdiffersx_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewdiffersx_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_maskednewdiffersx_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_maskednewdiffersx_filter (location, mask, x COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_maskednewdiffersx_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_maskednewdiffersx_filter ("maskednewdiffersx_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter::
GGS_maskednewdiffersx_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter::
GGS_maskednewdiffersx_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_maskednewdiffersx_filter GGS_maskednewdiffersx_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersx_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewdiffersx_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewdiffersx_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_maskednewdiffersx_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewdiffersx_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter GGS_maskednewdiffersx_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1,
                 const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersx_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewdiffersx_filter (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersx_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersx_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersx_filter::
reader_x (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersx_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersx_filter *) mPointer)->x ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewdiffersx_filter::actualTypeName (void) const {
  return "maskednewdiffersx_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__maskednewdiffersx_filter ("maskednewdiffersx_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_maskednewdiffersx_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_maskednewdiffersx_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_maskednewdiffersx_filter * p = NULL ;
    macroMyNew (p, GGS_maskednewdiffersx_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersx_filter GGS_maskednewdiffersx_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersx_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_maskednewdiffersx_filter * p = dynamic_cast <const GGS_maskednewdiffersx_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_maskednewdiffersx_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_maskednewdiffersx_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_maskednewdiffersx_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_newisequal_filter'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisequal_filter::
cPtr_newisequal_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisequal_filter * GGS_newisequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_newisequal_filter) ;
    return (cPtr_newisequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newisequal_filter * ptr = dynamic_cast <const cPtr_newisequal_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newisequal_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newisequal_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisequal_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisequal_filter (& typeid (cPtr_newisequal_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_newisequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisequal_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newisequal_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newisequal_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_newisequal_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_newisequal_filter ("newisequal_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisequal_filter::
GGS_newisequal_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisequal_filter::
GGS_newisequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisequal_filter GGS_newisequal_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisequal_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisequal_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisequal_filter GGS_newisequal_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_newisequal_filter result ;
  macroMyNew (result.mPointer, cPtr_newisequal_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisequal_filter::actualTypeName (void) const {
  return "newisequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__newisequal_filter ("newisequal_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisequal_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisequal_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisequal_filter * p = NULL ;
    macroMyNew (p, GGS_newisequal_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisequal_filter GGS_newisequal_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisequal_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisequal_filter * p = dynamic_cast <const GGS_newisequal_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisequal_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_newisequal_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_newisdifferent_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisdifferent_filter::
cPtr_newisdifferent_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisdifferent_filter * GGS_newisdifferent_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_newisdifferent_filter) ;
    return (cPtr_newisdifferent_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisdifferent_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newisdifferent_filter * ptr = dynamic_cast <const cPtr_newisdifferent_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newisdifferent_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newisdifferent_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisdifferent_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisdifferent_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisdifferent_filter (& typeid (cPtr_newisdifferent_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_newisdifferent_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisdifferent_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newisdifferent_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newisdifferent_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_newisdifferent_filter'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_newisdifferent_filter ("newisdifferent_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter::
GGS_newisdifferent_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter::
GGS_newisdifferent_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisdifferent_filter GGS_newisdifferent_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisdifferent_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisdifferent_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisdifferent_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisdifferent_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisdifferent_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter GGS_newisdifferent_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_newisdifferent_filter result ;
  macroMyNew (result.mPointer, cPtr_newisdifferent_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisdifferent_filter::actualTypeName (void) const {
  return "newisdifferent_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__newisdifferent_filter ("newisdifferent_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisdifferent_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisdifferent_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisdifferent_filter * p = NULL ;
    macroMyNew (p, GGS_newisdifferent_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisdifferent_filter GGS_newisdifferent_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisdifferent_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisdifferent_filter * p = dynamic_cast <const GGS_newisdifferent_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisdifferent_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_newisdifferent_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisdifferent_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_maskednewequalsmaskedold_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewequalsmaskedold_filter::
cPtr_maskednewequalsmaskedold_filter (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE),
mask (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewequalsmaskedold_filter * GGS_maskednewequalsmaskedold_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_maskednewequalsmaskedold_filter) ;
    return (cPtr_maskednewequalsmaskedold_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewequalsmaskedold_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewequalsmaskedold_filter * ptr = dynamic_cast <const cPtr_maskednewequalsmaskedold_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && mask.operator_isEqual (ptr->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewequalsmaskedold_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@maskednewequalsmaskedold_filter:"
           << location.reader_description (inIndentation + 1)
           << mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsmaskedold_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewequalsmaskedold_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewequalsmaskedold_filter (& typeid (cPtr_maskednewequalsmaskedold_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_maskednewequalsmaskedold_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewequalsmaskedold_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_maskednewequalsmaskedold_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_maskednewequalsmaskedold_filter (location, mask COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_maskednewequalsmaskedold_filter'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_maskednewequalsmaskedold_filter ("maskednewequalsmaskedold_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter::
GGS_maskednewequalsmaskedold_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter::
GGS_maskednewequalsmaskedold_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_maskednewequalsmaskedold_filter GGS_maskednewequalsmaskedold_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsmaskedold_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewequalsmaskedold_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewequalsmaskedold_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_maskednewequalsmaskedold_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewequalsmaskedold_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter GGS_maskednewequalsmaskedold_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsmaskedold_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewequalsmaskedold_filter (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewequalsmaskedold_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewequalsmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewequalsmaskedold_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewequalsmaskedold_filter::actualTypeName (void) const {
  return "maskednewequalsmaskedold_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__maskednewequalsmaskedold_filter ("maskednewequalsmaskedold_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_maskednewequalsmaskedold_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_maskednewequalsmaskedold_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_maskednewequalsmaskedold_filter * p = NULL ;
    macroMyNew (p, GGS_maskednewequalsmaskedold_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewequalsmaskedold_filter GGS_maskednewequalsmaskedold_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_maskednewequalsmaskedold_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_maskednewequalsmaskedold_filter * p = dynamic_cast <const GGS_maskednewequalsmaskedold_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_maskednewequalsmaskedold_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_maskednewequalsmaskedold_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_maskednewequalsmaskedold_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_maskednewdiffersmaskedold_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_maskednewdiffersmaskedold_filter::
cPtr_maskednewdiffersmaskedold_filter (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE),
mask (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_maskednewdiffersmaskedold_filter * GGS_maskednewdiffersmaskedold_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_maskednewdiffersmaskedold_filter) ;
    return (cPtr_maskednewdiffersmaskedold_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_maskednewdiffersmaskedold_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_maskednewdiffersmaskedold_filter * ptr = dynamic_cast <const cPtr_maskednewdiffersmaskedold_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && mask.operator_isEqual (ptr->mask).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_maskednewdiffersmaskedold_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@maskednewdiffersmaskedold_filter:"
           << location.reader_description (inIndentation + 1)
           << mask.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersmaskedold_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_maskednewdiffersmaskedold_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_maskednewdiffersmaskedold_filter (& typeid (cPtr_maskednewdiffersmaskedold_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_maskednewdiffersmaskedold_filter::galgasRTTI (void) const {
  return & gClassInfoFor__maskednewdiffersmaskedold_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_maskednewdiffersmaskedold_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_maskednewdiffersmaskedold_filter (location, mask COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_maskednewdiffersmaskedold_filter'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_maskednewdiffersmaskedold_filter ("maskednewdiffersmaskedold_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter::
GGS_maskednewdiffersmaskedold_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter::
GGS_maskednewdiffersmaskedold_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_maskednewdiffersmaskedold_filter GGS_maskednewdiffersmaskedold_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersmaskedold_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_maskednewdiffersmaskedold_filter *> (inPointer) != NULL)
      : (typeid (cPtr_maskednewdiffersmaskedold_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_maskednewdiffersmaskedold_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_maskednewdiffersmaskedold_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter GGS_maskednewdiffersmaskedold_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersmaskedold_filter result ;
  macroMyNew (result.mPointer, cPtr_maskednewdiffersmaskedold_filter (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_maskednewdiffersmaskedold_filter::
reader_mask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_maskednewdiffersmaskedold_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_maskednewdiffersmaskedold_filter *) mPointer)->mask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_maskednewdiffersmaskedold_filter::actualTypeName (void) const {
  return "maskednewdiffersmaskedold_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__maskednewdiffersmaskedold_filter ("maskednewdiffersmaskedold_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_maskednewdiffersmaskedold_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_maskednewdiffersmaskedold_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_maskednewdiffersmaskedold_filter * p = NULL ;
    macroMyNew (p, GGS_maskednewdiffersmaskedold_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_maskednewdiffersmaskedold_filter GGS_maskednewdiffersmaskedold_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_maskednewdiffersmaskedold_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_maskednewdiffersmaskedold_filter * p = dynamic_cast <const GGS_maskednewdiffersmaskedold_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_maskednewdiffersmaskedold_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_maskednewdiffersmaskedold_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_maskednewdiffersmaskedold_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_newiswithin'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newiswithin::
cPtr_newiswithin (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1,
                                const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newiswithin * GGS_newiswithin::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_newiswithin) ;
    return (cPtr_newiswithin *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newiswithin::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newiswithin * ptr = dynamic_cast <const cPtr_newiswithin *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newiswithin::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newiswithin:"
           << location.reader_description (inIndentation + 1)
           << min.reader_description (inIndentation + 1)
           << max.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newiswithin::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newiswithin::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newiswithin (& typeid (cPtr_newiswithin), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_newiswithin::galgasRTTI (void) const {
  return & gClassInfoFor__newiswithin ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newiswithin::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newiswithin (location, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_newiswithin'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_newiswithin ("newiswithin", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newiswithin::
GGS_newiswithin (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newiswithin::
GGS_newiswithin (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newiswithin GGS_newiswithin::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newiswithin result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newiswithin *> (inPointer) != NULL)
      : (typeid (cPtr_newiswithin) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newiswithin (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newiswithin),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newiswithin GGS_newiswithin::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1,
                 const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_newiswithin result ;
  macroMyNew (result.mPointer, cPtr_newiswithin (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newiswithin::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newiswithin *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newiswithin *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newiswithin::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newiswithin *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newiswithin *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newiswithin::actualTypeName (void) const {
  return "newiswithin" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__newiswithin ("newiswithin", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newiswithin) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newiswithin::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newiswithin * p = NULL ;
    macroMyNew (p, GGS_newiswithin (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newiswithin GGS_newiswithin::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newiswithin result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newiswithin * p = dynamic_cast <const GGS_newiswithin *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newiswithin, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_newiswithin::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newiswithin ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_newisoutside'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisoutside::
cPtr_newisoutside (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1,
                                const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisoutside * GGS_newisoutside::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_newisoutside) ;
    return (cPtr_newisoutside *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisoutside::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newisoutside * ptr = dynamic_cast <const cPtr_newisoutside *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newisoutside::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newisoutside:"
           << location.reader_description (inIndentation + 1)
           << min.reader_description (inIndentation + 1)
           << max.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisoutside::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisoutside::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisoutside (& typeid (cPtr_newisoutside), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_newisoutside::galgasRTTI (void) const {
  return & gClassInfoFor__newisoutside ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newisoutside::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newisoutside (location, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_newisoutside'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_newisoutside ("newisoutside", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisoutside::
GGS_newisoutside (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisoutside::
GGS_newisoutside (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisoutside GGS_newisoutside::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisoutside result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisoutside *> (inPointer) != NULL)
      : (typeid (cPtr_newisoutside) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisoutside (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisoutside),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisoutside GGS_newisoutside::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1,
                 const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_newisoutside result ;
  macroMyNew (result.mPointer, cPtr_newisoutside (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newisoutside::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisoutside *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newisoutside *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_newisoutside::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_newisoutside *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_newisoutside *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisoutside::actualTypeName (void) const {
  return "newisoutside" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__newisoutside ("newisoutside", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisoutside) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisoutside::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisoutside * p = NULL ;
    macroMyNew (p, GGS_newisoutside (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisoutside GGS_newisoutside::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisoutside result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisoutside * p = dynamic_cast <const GGS_newisoutside *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisoutside, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_newisoutside::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisoutside ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_newisgreater_filter'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisgreater_filter::
cPtr_newisgreater_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisgreater_filter * GGS_newisgreater_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_newisgreater_filter) ;
    return (cPtr_newisgreater_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisgreater_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newisgreater_filter * ptr = dynamic_cast <const cPtr_newisgreater_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreater_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newisgreater_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisgreater_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisgreater_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisgreater_filter (& typeid (cPtr_newisgreater_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_newisgreater_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisgreater_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newisgreater_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newisgreater_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_newisgreater_filter'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_newisgreater_filter ("newisgreater_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisgreater_filter::
GGS_newisgreater_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreater_filter::
GGS_newisgreater_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisgreater_filter GGS_newisgreater_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisgreater_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisgreater_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisgreater_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisgreater_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisgreater_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisgreater_filter GGS_newisgreater_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_newisgreater_filter result ;
  macroMyNew (result.mPointer, cPtr_newisgreater_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisgreater_filter::actualTypeName (void) const {
  return "newisgreater_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__newisgreater_filter ("newisgreater_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisgreater_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisgreater_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisgreater_filter * p = NULL ;
    macroMyNew (p, GGS_newisgreater_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisgreater_filter GGS_newisgreater_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisgreater_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisgreater_filter * p = dynamic_cast <const GGS_newisgreater_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisgreater_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_newisgreater_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisgreater_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_newislessorequal_filter'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newislessorequal_filter::
cPtr_newislessorequal_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newislessorequal_filter * GGS_newislessorequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_newislessorequal_filter) ;
    return (cPtr_newislessorequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newislessorequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newislessorequal_filter * ptr = dynamic_cast <const cPtr_newislessorequal_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newislessorequal_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newislessorequal_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newislessorequal_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newislessorequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newislessorequal_filter (& typeid (cPtr_newislessorequal_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_newislessorequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newislessorequal_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newislessorequal_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newislessorequal_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_newislessorequal_filter'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_newislessorequal_filter ("newislessorequal_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter::
GGS_newislessorequal_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter::
GGS_newislessorequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newislessorequal_filter GGS_newislessorequal_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newislessorequal_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newislessorequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newislessorequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newislessorequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newislessorequal_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter GGS_newislessorequal_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_newislessorequal_filter result ;
  macroMyNew (result.mPointer, cPtr_newislessorequal_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newislessorequal_filter::actualTypeName (void) const {
  return "newislessorequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__newislessorequal_filter ("newislessorequal_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newislessorequal_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newislessorequal_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newislessorequal_filter * p = NULL ;
    macroMyNew (p, GGS_newislessorequal_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newislessorequal_filter GGS_newislessorequal_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newislessorequal_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newislessorequal_filter * p = dynamic_cast <const GGS_newislessorequal_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newislessorequal_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_newislessorequal_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newislessorequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_newisless_filter'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisless_filter::
cPtr_newisless_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisless_filter * GGS_newisless_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_newisless_filter) ;
    return (cPtr_newisless_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisless_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newisless_filter * ptr = dynamic_cast <const cPtr_newisless_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newisless_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newisless_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisless_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisless_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisless_filter (& typeid (cPtr_newisless_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_newisless_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisless_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newisless_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newisless_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_newisless_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_newisless_filter ("newisless_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisless_filter::
GGS_newisless_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisless_filter::
GGS_newisless_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisless_filter GGS_newisless_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisless_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisless_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisless_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisless_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisless_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisless_filter GGS_newisless_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_newisless_filter result ;
  macroMyNew (result.mPointer, cPtr_newisless_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisless_filter::actualTypeName (void) const {
  return "newisless_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__newisless_filter ("newisless_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisless_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisless_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisless_filter * p = NULL ;
    macroMyNew (p, GGS_newisless_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisless_filter GGS_newisless_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisless_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisless_filter * p = dynamic_cast <const GGS_newisless_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisless_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_newisless_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisless_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_newisgreaterorequal_filter'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_newisgreaterorequal_filter::
cPtr_newisgreaterorequal_filter (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_newisgreaterorequal_filter * GGS_newisgreaterorequal_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_newisgreaterorequal_filter) ;
    return (cPtr_newisgreaterorequal_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_newisgreaterorequal_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_newisgreaterorequal_filter * ptr = dynamic_cast <const cPtr_newisgreaterorequal_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_newisgreaterorequal_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@newisgreaterorequal_filter:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_newisgreaterorequal_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_newisgreaterorequal_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_newisgreaterorequal_filter (& typeid (cPtr_newisgreaterorequal_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_newisgreaterorequal_filter::galgasRTTI (void) const {
  return & gClassInfoFor__newisgreaterorequal_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_newisgreaterorequal_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_newisgreaterorequal_filter (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_newisgreaterorequal_filter'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_newisgreaterorequal_filter ("newisgreaterorequal_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter::
GGS_newisgreaterorequal_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter::
GGS_newisgreaterorequal_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_newisgreaterorequal_filter GGS_newisgreaterorequal_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_newisgreaterorequal_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_newisgreaterorequal_filter *> (inPointer) != NULL)
      : (typeid (cPtr_newisgreaterorequal_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_newisgreaterorequal_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_newisgreaterorequal_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter GGS_newisgreaterorequal_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_newisgreaterorequal_filter result ;
  macroMyNew (result.mPointer, cPtr_newisgreaterorequal_filter (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_newisgreaterorequal_filter::actualTypeName (void) const {
  return "newisgreaterorequal_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__newisgreaterorequal_filter ("newisgreaterorequal_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_newisgreaterorequal_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_newisgreaterorequal_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_newisgreaterorequal_filter * p = NULL ;
    macroMyNew (p, GGS_newisgreaterorequal_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_newisgreaterorequal_filter GGS_newisgreaterorequal_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_newisgreaterorequal_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_newisgreaterorequal_filter * p = dynamic_cast <const GGS_newisgreaterorequal_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_newisgreaterorequal_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_newisgreaterorequal_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_newisgreaterorequal_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_oneeveryn_filter'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_oneeveryn_filter::
cPtr_oneeveryn_filter (const GGS_location & argument_0,
                                const GGS_luint64 & argument_1,
                                const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_filter_prop_obj (argument_0 COMMA_THERE),
period (argument_1),
offset (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_oneeveryn_filter * GGS_oneeveryn_filter::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_oneeveryn_filter) ;
    return (cPtr_oneeveryn_filter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_oneeveryn_filter::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_oneeveryn_filter * ptr = dynamic_cast <const cPtr_oneeveryn_filter *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && period.operator_isEqual (ptr->period).boolValue ()
         && offset.operator_isEqual (ptr->offset).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_oneeveryn_filter::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@oneeveryn_filter:"
           << location.reader_description (inIndentation + 1)
           << period.reader_description (inIndentation + 1)
           << offset.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_oneeveryn_filter::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_oneeveryn_filter::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_oneeveryn_filter (& typeid (cPtr_oneeveryn_filter), & typeid (cPtr_filter_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_oneeveryn_filter::galgasRTTI (void) const {
  return & gClassInfoFor__oneeveryn_filter ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_oneeveryn_filter::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_oneeveryn_filter (location, period, offset COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_oneeveryn_filter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_oneeveryn_filter ("oneeveryn_filter", true, & kTypeDescriptor_GGS_filter_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter::
GGS_oneeveryn_filter (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter::
GGS_oneeveryn_filter (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_oneeveryn_filter GGS_oneeveryn_filter::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_oneeveryn_filter result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_oneeveryn_filter *> (inPointer) != NULL)
      : (typeid (cPtr_oneeveryn_filter) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_oneeveryn_filter (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_oneeveryn_filter),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter GGS_oneeveryn_filter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_luint64 & argument_1,
                 const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_oneeveryn_filter result ;
  macroMyNew (result.mPointer, cPtr_oneeveryn_filter (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_oneeveryn_filter::
reader_period (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oneeveryn_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_oneeveryn_filter *) mPointer)->period ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_oneeveryn_filter::
reader_offset (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oneeveryn_filter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_oneeveryn_filter *) mPointer)->offset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_oneeveryn_filter::actualTypeName (void) const {
  return "oneeveryn_filter" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__oneeveryn_filter ("oneeveryn_filter", gClassInfoFor__filter_prop_obj, & kTypeDescriptor_GGS_oneeveryn_filter) ;

//---------------------------------------------------------------------------*

GGS_object GGS_oneeveryn_filter::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_oneeveryn_filter * p = NULL ;
    macroMyNew (p, GGS_oneeveryn_filter (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_oneeveryn_filter GGS_oneeveryn_filter::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_oneeveryn_filter result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_oneeveryn_filter * p = dynamic_cast <const GGS_oneeveryn_filter *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_oneeveryn_filter, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_oneeveryn_filter::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_oneeveryn_filter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_link_obj'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_link_obj::
cPtr_link_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_link_obj * GGS_link_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_link_obj) ;
    return (cPtr_link_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_link_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@link_obj:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_link_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_link_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_link_obj (& typeid (cPtr_link_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_link_obj::galgasRTTI (void) const {
  return & gClassInfoFor__link_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_link_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_link_obj ("link_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_link_obj::
GGS_link_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_link_obj::
GGS_link_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_link_obj GGS_link_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_link_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_link_obj *> (inPointer) != NULL)
      : (typeid (cPtr_link_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_link_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_link_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_link_obj::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_link_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_link_obj *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_link_obj::actualTypeName (void) const {
  return "link_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_link_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__link_obj ("link_obj", & kTypeDescriptor_GGS_link_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_link_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_link_obj * p = NULL ;
    macroMyNew (p, GGS_link_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj GGS_link_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_link_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_link_obj * p = dynamic_cast <const GGS_link_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_link_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_link_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_link_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_void_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_mess_prop::
cPtr_void_mess_prop (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_mess_prop * GGS_void_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_mess_prop) ;
    return (cPtr_void_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_mess_prop * ptr = dynamic_cast <const cPtr_void_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_mess_prop:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_mess_prop (& typeid (cPtr_void_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__void_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_mess_prop (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_void_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_mess_prop ("void_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_void_mess_prop::
GGS_void_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_mess_prop::
GGS_void_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_mess_prop GGS_void_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_void_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_mess_prop GGS_void_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_void_mess_prop (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_mess_prop::actualTypeName (void) const {
  return "void_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_mess_prop ("void_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_void_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_mess_prop * p = NULL ;
    macroMyNew (p, GGS_void_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_mess_prop GGS_void_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_mess_prop * p = dynamic_cast <const GGS_void_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_ssi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ssi_mess_prop::
cPtr_ssi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ssi_mess_prop * GGS_ssi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ssi_mess_prop) ;
    return (cPtr_ssi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ssi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ssi_mess_prop * ptr = dynamic_cast <const cPtr_ssi_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ssi_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ssi_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ssi_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ssi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ssi_mess_prop (& typeid (cPtr_ssi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ssi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__ssi_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ssi_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ssi_mess_prop (location, cdatatype COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_ssi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ssi_mess_prop ("ssi_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop::
GGS_ssi_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop::
GGS_ssi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ssi_mess_prop GGS_ssi_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ssi_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ssi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_ssi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ssi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ssi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop GGS_ssi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_ssi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_ssi_mess_prop (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ssi_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ssi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ssi_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ssi_mess_prop::actualTypeName (void) const {
  return "ssi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ssi_mess_prop ("ssi_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_ssi_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ssi_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ssi_mess_prop * p = NULL ;
    macroMyNew (p, GGS_ssi_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ssi_mess_prop GGS_ssi_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ssi_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ssi_mess_prop * p = dynamic_cast <const GGS_ssi_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ssi_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ssi_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ssi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sse_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sse_mess_prop::
cPtr_sse_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_filter_prop_obj & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_lstring & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
tranferproperty (argument_2),
filter (argument_3),
networkordercallout (argument_4),
cpuordercallout (argument_5),
initialvalue (argument_6),
networkmessage (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sse_mess_prop * GGS_sse_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sse_mess_prop) ;
    return (cPtr_sse_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sse_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sse_mess_prop * ptr = dynamic_cast <const cPtr_sse_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue ()
         && tranferproperty.operator_isEqual (ptr->tranferproperty).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && networkordercallout.operator_isEqual (ptr->networkordercallout).boolValue ()
         && cpuordercallout.operator_isEqual (ptr->cpuordercallout).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sse_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sse_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1)
           << tranferproperty.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << networkordercallout.reader_description (inIndentation + 1)
           << cpuordercallout.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sse_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sse_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sse_mess_prop (& typeid (cPtr_sse_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sse_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sse_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sse_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sse_mess_prop (location, cdatatype, tranferproperty, filter, networkordercallout, cpuordercallout, initialvalue, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sse_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sse_mess_prop ("sse_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_sse_mess_prop::
GGS_sse_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sse_mess_prop::
GGS_sse_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sse_mess_prop GGS_sse_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sse_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sse_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sse_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sse_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sse_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sse_mess_prop GGS_sse_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_filter_prop_obj & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_lstring & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_sse_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sse_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_tranferproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->tranferproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_sse_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_sse_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sse_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sse_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sse_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sse_mess_prop::actualTypeName (void) const {
  return "sse_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sse_mess_prop ("sse_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_sse_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sse_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sse_mess_prop * p = NULL ;
    macroMyNew (p, GGS_sse_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sse_mess_prop GGS_sse_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sse_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sse_mess_prop * p = dynamic_cast <const GGS_sse_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sse_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sse_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sse_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sde_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sde_mess_prop::
cPtr_sde_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
tranferproperty (argument_1),
networkordercallout (argument_2),
cpuordercallout (argument_3),
initialvalue (argument_4),
networkmessage (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sde_mess_prop * GGS_sde_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sde_mess_prop) ;
    return (cPtr_sde_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sde_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sde_mess_prop * ptr = dynamic_cast <const cPtr_sde_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && tranferproperty.operator_isEqual (ptr->tranferproperty).boolValue ()
         && networkordercallout.operator_isEqual (ptr->networkordercallout).boolValue ()
         && cpuordercallout.operator_isEqual (ptr->cpuordercallout).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sde_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sde_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << tranferproperty.reader_description (inIndentation + 1)
           << networkordercallout.reader_description (inIndentation + 1)
           << cpuordercallout.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sde_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sde_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sde_mess_prop (& typeid (cPtr_sde_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sde_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sde_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sde_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sde_mess_prop (location, tranferproperty, networkordercallout, cpuordercallout, initialvalue, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sde_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sde_mess_prop ("sde_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_sde_mess_prop::
GGS_sde_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sde_mess_prop::
GGS_sde_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sde_mess_prop GGS_sde_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sde_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sde_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sde_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sde_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sde_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sde_mess_prop GGS_sde_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_sde_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sde_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_tranferproperty (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->tranferproperty ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_sde_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sde_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sde_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sde_mess_prop::actualTypeName (void) const {
  return "sde_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sde_mess_prop ("sde_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_sde_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sde_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sde_mess_prop * p = NULL ;
    macroMyNew (p, GGS_sde_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sde_mess_prop GGS_sde_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sde_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sde_mess_prop * p = dynamic_cast <const GGS_sde_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sde_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sde_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sde_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_szi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_szi_mess_prop::
cPtr_szi_mess_prop (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_szi_mess_prop * GGS_szi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_szi_mess_prop) ;
    return (cPtr_szi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_szi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_szi_mess_prop * ptr = dynamic_cast <const cPtr_szi_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_szi_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@szi_mess_prop:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_szi_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_szi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_szi_mess_prop (& typeid (cPtr_szi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_szi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__szi_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_szi_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_szi_mess_prop (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_szi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_szi_mess_prop ("szi_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_szi_mess_prop::
GGS_szi_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_szi_mess_prop::
GGS_szi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_szi_mess_prop GGS_szi_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_szi_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_szi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_szi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_szi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_szi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_szi_mess_prop GGS_szi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_szi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_szi_mess_prop (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_szi_mess_prop::actualTypeName (void) const {
  return "szi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__szi_mess_prop ("szi_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_szi_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_szi_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_szi_mess_prop * p = NULL ;
    macroMyNew (p, GGS_szi_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_szi_mess_prop GGS_szi_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_szi_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_szi_mess_prop * p = dynamic_cast <const GGS_szi_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_szi_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_szi_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_szi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sze_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sze_mess_prop::
cPtr_sze_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
networkordercallout (argument_1),
cpuordercallout (argument_2),
networkmessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sze_mess_prop * GGS_sze_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sze_mess_prop) ;
    return (cPtr_sze_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sze_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sze_mess_prop * ptr = dynamic_cast <const cPtr_sze_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && networkordercallout.operator_isEqual (ptr->networkordercallout).boolValue ()
         && cpuordercallout.operator_isEqual (ptr->cpuordercallout).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sze_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sze_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << networkordercallout.reader_description (inIndentation + 1)
           << cpuordercallout.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sze_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sze_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sze_mess_prop (& typeid (cPtr_sze_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sze_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__sze_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sze_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sze_mess_prop (location, networkordercallout, cpuordercallout, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sze_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sze_mess_prop ("sze_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_sze_mess_prop::
GGS_sze_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sze_mess_prop::
GGS_sze_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sze_mess_prop GGS_sze_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sze_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sze_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_sze_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sze_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sze_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sze_mess_prop GGS_sze_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_sze_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_sze_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sze_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sze_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sze_mess_prop::actualTypeName (void) const {
  return "sze_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sze_mess_prop ("sze_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_sze_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sze_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sze_mess_prop * p = NULL ;
    macroMyNew (p, GGS_sze_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sze_mess_prop GGS_sze_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sze_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sze_mess_prop * p = dynamic_cast <const GGS_sze_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sze_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sze_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sze_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rzi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rzi_mess_prop::
cPtr_rzi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rzi_mess_prop * GGS_rzi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rzi_mess_prop) ;
    return (cPtr_rzi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rzi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rzi_mess_prop * ptr = dynamic_cast <const cPtr_rzi_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && sendingmessage.operator_isEqual (ptr->sendingmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rzi_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rzi_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << sendingmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rzi_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rzi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rzi_mess_prop (& typeid (cPtr_rzi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rzi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rzi_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rzi_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rzi_mess_prop (location, sendingmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rzi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rzi_mess_prop ("rzi_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop::
GGS_rzi_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop::
GGS_rzi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rzi_mess_prop GGS_rzi_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rzi_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rzi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rzi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rzi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rzi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop GGS_rzi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_rzi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rzi_mess_prop (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rzi_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzi_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rzi_mess_prop::actualTypeName (void) const {
  return "rzi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rzi_mess_prop ("rzi_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rzi_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rzi_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rzi_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rzi_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rzi_mess_prop GGS_rzi_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rzi_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rzi_mess_prop * p = dynamic_cast <const GGS_rzi_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rzi_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rzi_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rzi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rze_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rze_mess_prop::
cPtr_rze_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
networkordercallout (argument_1),
cpuordercallout (argument_2),
networkmessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rze_mess_prop * GGS_rze_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rze_mess_prop) ;
    return (cPtr_rze_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rze_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rze_mess_prop * ptr = dynamic_cast <const cPtr_rze_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && networkordercallout.operator_isEqual (ptr->networkordercallout).boolValue ()
         && cpuordercallout.operator_isEqual (ptr->cpuordercallout).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rze_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rze_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << networkordercallout.reader_description (inIndentation + 1)
           << cpuordercallout.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rze_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rze_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rze_mess_prop (& typeid (cPtr_rze_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rze_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rze_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rze_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rze_mess_prop (location, networkordercallout, cpuordercallout, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rze_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rze_mess_prop ("rze_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rze_mess_prop::
GGS_rze_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rze_mess_prop::
GGS_rze_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rze_mess_prop GGS_rze_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rze_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rze_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rze_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rze_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rze_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rze_mess_prop GGS_rze_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rze_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rze_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_networkordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->networkordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_cpuordercallout (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->cpuordercallout ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rze_mess_prop::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rze_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rze_mess_prop *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rze_mess_prop::actualTypeName (void) const {
  return "rze_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rze_mess_prop ("rze_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rze_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rze_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rze_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rze_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rze_mess_prop GGS_rze_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rze_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rze_mess_prop * p = dynamic_cast <const GGS_rze_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rze_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rze_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rze_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rui_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rui_mess_prop::
cPtr_rui_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_basic_type & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1),
filter (argument_2),
initialvalue (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rui_mess_prop * GGS_rui_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rui_mess_prop) ;
    return (cPtr_rui_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rui_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rui_mess_prop * ptr = dynamic_cast <const cPtr_rui_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && sendingmessage.operator_isEqual (ptr->sendingmessage).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rui_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rui_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << sendingmessage.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rui_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rui_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rui_mess_prop (& typeid (cPtr_rui_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rui_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rui_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rui_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rui_mess_prop (location, sendingmessage, filter, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rui_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rui_mess_prop ("rui_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rui_mess_prop::
GGS_rui_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rui_mess_prop::
GGS_rui_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rui_mess_prop GGS_rui_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rui_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rui_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rui_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rui_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rui_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rui_mess_prop GGS_rui_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_basic_type & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rui_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rui_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rui_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rui_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rui_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rui_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rui_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rui_mess_prop::actualTypeName (void) const {
  return "rui_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rui_mess_prop ("rui_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rui_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rui_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rui_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rui_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rui_mess_prop GGS_rui_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rui_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rui_mess_prop * p = dynamic_cast <const GGS_rui_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rui_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rui_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rui_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rqi_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rqi_mess_prop::
cPtr_rqi_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_luint64 & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
sendingmessage (argument_1),
filter (argument_2),
queuesize (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rqi_mess_prop * GGS_rqi_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rqi_mess_prop) ;
    return (cPtr_rqi_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rqi_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rqi_mess_prop * ptr = dynamic_cast <const cPtr_rqi_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && sendingmessage.operator_isEqual (ptr->sendingmessage).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && queuesize.operator_isEqual (ptr->queuesize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rqi_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rqi_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << sendingmessage.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << queuesize.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rqi_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rqi_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rqi_mess_prop (& typeid (cPtr_rqi_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rqi_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rqi_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rqi_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rqi_mess_prop (location, sendingmessage, filter, queuesize COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rqi_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rqi_mess_prop ("rqi_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop::
GGS_rqi_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop::
GGS_rqi_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rqi_mess_prop GGS_rqi_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rqi_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rqi_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rqi_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rqi_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rqi_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop GGS_rqi_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_luint64 & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rqi_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rqi_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rqi_mess_prop::
reader_sendingmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->sendingmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rqi_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_rqi_mess_prop::
reader_queuesize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqi_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqi_mess_prop *) mPointer)->queuesize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rqi_mess_prop::actualTypeName (void) const {
  return "rqi_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rqi_mess_prop ("rqi_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rqi_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rqi_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rqi_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rqi_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rqi_mess_prop GGS_rqi_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rqi_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rqi_mess_prop * p = dynamic_cast <const GGS_rqi_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rqi_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rqi_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rqi_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rue_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rue_mess_prop::
cPtr_rue_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_filter_prop_obj & argument_2,
                                const GGS_link_obj & argument_3,
                                const GGS_basic_type & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
filter (argument_2),
link (argument_3),
initialvalue (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rue_mess_prop * GGS_rue_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rue_mess_prop) ;
    return (cPtr_rue_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rue_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rue_mess_prop * ptr = dynamic_cast <const cPtr_rue_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && link.operator_isEqual (ptr->link).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rue_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rue_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << link.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rue_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rue_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rue_mess_prop (& typeid (cPtr_rue_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rue_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rue_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rue_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rue_mess_prop (location, cdatatype, filter, link, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rue_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rue_mess_prop ("rue_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rue_mess_prop::
GGS_rue_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rue_mess_prop::
GGS_rue_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rue_mess_prop GGS_rue_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rue_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rue_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rue_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rue_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rue_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rue_mess_prop GGS_rue_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_filter_prop_obj & argument_2,
                 const GGS_link_obj & argument_3,
                 const GGS_basic_type & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_rue_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rue_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rue_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rue_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rue_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rue_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rue_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rue_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rue_mess_prop::actualTypeName (void) const {
  return "rue_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rue_mess_prop ("rue_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rue_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rue_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rue_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rue_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rue_mess_prop GGS_rue_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rue_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rue_mess_prop * p = dynamic_cast <const GGS_rue_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rue_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rue_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rue_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rqe_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rqe_mess_prop::
cPtr_rqe_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint64 & argument_2,
                                const GGS_filter_prop_obj & argument_3,
                                const GGS_link_obj & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
queuesize (argument_2),
filter (argument_3),
link (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rqe_mess_prop * GGS_rqe_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rqe_mess_prop) ;
    return (cPtr_rqe_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rqe_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rqe_mess_prop * ptr = dynamic_cast <const cPtr_rqe_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue ()
         && queuesize.operator_isEqual (ptr->queuesize).boolValue ()
         && filter.operator_isEqual (ptr->filter).boolValue ()
         && link.operator_isEqual (ptr->link).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rqe_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rqe_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1)
           << queuesize.reader_description (inIndentation + 1)
           << filter.reader_description (inIndentation + 1)
           << link.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rqe_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rqe_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rqe_mess_prop (& typeid (cPtr_rqe_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rqe_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rqe_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rqe_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rqe_mess_prop (location, cdatatype, queuesize, filter, link COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rqe_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rqe_mess_prop ("rqe_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop::
GGS_rqe_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop::
GGS_rqe_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rqe_mess_prop GGS_rqe_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rqe_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rqe_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rqe_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rqe_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rqe_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop GGS_rqe_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_luint64 & argument_2,
                 const GGS_filter_prop_obj & argument_3,
                 const GGS_link_obj & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_rqe_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rqe_mess_prop (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rqe_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_rqe_mess_prop::
reader_queuesize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->queuesize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filter_prop_obj  GGS_rqe_mess_prop::
reader_filter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filter_prop_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->filter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rqe_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rqe_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rqe_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rqe_mess_prop::actualTypeName (void) const {
  return "rqe_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rqe_mess_prop ("rqe_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rqe_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rqe_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rqe_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rqe_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rqe_mess_prop GGS_rqe_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rqe_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rqe_mess_prop * p = dynamic_cast <const GGS_rqe_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rqe_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rqe_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rqe_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rde_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rde_mess_prop::
cPtr_rde_mess_prop (const GGS_location & argument_0,
                                const GGS_link_obj & argument_1,
                                const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
link (argument_1),
initialvalue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rde_mess_prop * GGS_rde_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rde_mess_prop) ;
    return (cPtr_rde_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rde_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rde_mess_prop * ptr = dynamic_cast <const cPtr_rde_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && link.operator_isEqual (ptr->link).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rde_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rde_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << link.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rde_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rde_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rde_mess_prop (& typeid (cPtr_rde_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rde_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rde_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rde_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rde_mess_prop (location, link, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rde_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rde_mess_prop ("rde_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rde_mess_prop::
GGS_rde_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rde_mess_prop::
GGS_rde_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rde_mess_prop GGS_rde_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rde_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rde_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rde_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rde_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rde_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rde_mess_prop GGS_rde_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_link_obj & argument_1,
                 const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rde_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rde_mess_prop (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_link_obj  GGS_rde_mess_prop::
reader_link (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_link_obj   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rde_mess_prop *) mPointer)->link ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rde_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rde_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rde_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rde_mess_prop::actualTypeName (void) const {
  return "rde_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rde_mess_prop ("rde_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rde_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rde_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rde_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rde_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rde_mess_prop GGS_rde_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rde_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rde_mess_prop * p = dynamic_cast <const GGS_rde_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rde_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rde_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rde_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_rzs_mess_prop'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rzs_mess_prop::
cPtr_rzs_mess_prop (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_mess_prop_obj (argument_0 COMMA_THERE),
cdatatype (argument_1),
initialvalue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rzs_mess_prop * GGS_rzs_mess_prop::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rzs_mess_prop) ;
    return (cPtr_rzs_mess_prop *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rzs_mess_prop::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rzs_mess_prop * ptr = dynamic_cast <const cPtr_rzs_mess_prop *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && cdatatype.operator_isEqual (ptr->cdatatype).boolValue ()
         && initialvalue.operator_isEqual (ptr->initialvalue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rzs_mess_prop::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rzs_mess_prop:"
           << location.reader_description (inIndentation + 1)
           << cdatatype.reader_description (inIndentation + 1)
           << initialvalue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rzs_mess_prop::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rzs_mess_prop::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rzs_mess_prop (& typeid (cPtr_rzs_mess_prop), & typeid (cPtr_mess_prop_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rzs_mess_prop::galgasRTTI (void) const {
  return & gClassInfoFor__rzs_mess_prop ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rzs_mess_prop::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rzs_mess_prop (location, cdatatype, initialvalue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_rzs_mess_prop'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rzs_mess_prop ("rzs_mess_prop", true, & kTypeDescriptor_GGS_mess_prop_obj) ;

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop::
GGS_rzs_mess_prop (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop::
GGS_rzs_mess_prop (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rzs_mess_prop GGS_rzs_mess_prop::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rzs_mess_prop result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rzs_mess_prop *> (inPointer) != NULL)
      : (typeid (cPtr_rzs_mess_prop) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rzs_mess_prop (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rzs_mess_prop),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop GGS_rzs_mess_prop::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_basic_type & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rzs_mess_prop result ;
  macroMyNew (result.mPointer, cPtr_rzs_mess_prop (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_rzs_mess_prop::
reader_cdatatype (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzs_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzs_mess_prop *) mPointer)->cdatatype ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_rzs_mess_prop::
reader_initialvalue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rzs_mess_prop *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rzs_mess_prop *) mPointer)->initialvalue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rzs_mess_prop::actualTypeName (void) const {
  return "rzs_mess_prop" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rzs_mess_prop ("rzs_mess_prop", gClassInfoFor__mess_prop_obj, & kTypeDescriptor_GGS_rzs_mess_prop) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rzs_mess_prop::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rzs_mess_prop * p = NULL ;
    macroMyNew (p, GGS_rzs_mess_prop (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rzs_mess_prop GGS_rzs_mess_prop::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rzs_mess_prop result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rzs_mess_prop * p = dynamic_cast <const GGS_rzs_mess_prop *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rzs_mess_prop, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rzs_mess_prop::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rzs_mess_prop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_void_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_link::
cPtr_void_link (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_link * GGS_void_link::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_link) ;
    return (cPtr_void_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_link * ptr = dynamic_cast <const cPtr_void_link *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_link::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_link:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_link::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_link (& typeid (cPtr_void_link), & typeid (cPtr_link_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_link::galgasRTTI (void) const {
  return & gClassInfoFor__void_link ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_link::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_link (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_void_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_link ("void_link", true, & kTypeDescriptor_GGS_link_obj) ;

//---------------------------------------------------------------------------*

GGS_void_link::
GGS_void_link (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_link::
GGS_void_link (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_link GGS_void_link::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_link result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_link *> (inPointer) != NULL)
      : (typeid (cPtr_void_link) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_link),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_link GGS_void_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void_link result ;
  macroMyNew (result.mPointer, cPtr_void_link (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_link::actualTypeName (void) const {
  return "void_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_link ("void_link", gClassInfoFor__link_obj, & kTypeDescriptor_GGS_void_link) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_link::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_link * p = NULL ;
    macroMyNew (p, GGS_void_link (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_link GGS_void_link::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_link result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_link * p = dynamic_cast <const GGS_void_link *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_link, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_link::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_true_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_true_link::
cPtr_true_link (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE),
receivemessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_true_link * GGS_true_link::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_true_link) ;
    return (cPtr_true_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_true_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_true_link * ptr = dynamic_cast <const cPtr_true_link *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && receivemessage.operator_isEqual (ptr->receivemessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_true_link::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@true_link:"
           << loc.reader_description (inIndentation + 1)
           << receivemessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_true_link::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_true_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_true_link (& typeid (cPtr_true_link), & typeid (cPtr_link_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_true_link::galgasRTTI (void) const {
  return & gClassInfoFor__true_link ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_true_link::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_true_link (loc, receivemessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_true_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_true_link ("true_link", true, & kTypeDescriptor_GGS_link_obj) ;

//---------------------------------------------------------------------------*

GGS_true_link::
GGS_true_link (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_true_link::
GGS_true_link (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_true_link GGS_true_link::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_true_link result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_true_link *> (inPointer) != NULL)
      : (typeid (cPtr_true_link) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_true_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_true_link),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_true_link GGS_true_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_true_link result ;
  macroMyNew (result.mPointer, cPtr_true_link (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_true_link::
reader_receivemessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_true_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_true_link *) mPointer)->receivemessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_true_link::actualTypeName (void) const {
  return "true_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__true_link ("true_link", gClassInfoFor__link_obj, & kTypeDescriptor_GGS_true_link) ;

//---------------------------------------------------------------------------*

GGS_object GGS_true_link::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_true_link * p = NULL ;
    macroMyNew (p, GGS_true_link (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_true_link GGS_true_link::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_true_link result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_true_link * p = dynamic_cast <const GGS_true_link *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_true_link, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_true_link::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_true_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_false_link'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_false_link::
cPtr_false_link (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_link_obj (argument_0 COMMA_THERE),
networkmessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_false_link * GGS_false_link::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_false_link) ;
    return (cPtr_false_link *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_false_link::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_false_link * ptr = dynamic_cast <const cPtr_false_link *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && networkmessage.operator_isEqual (ptr->networkmessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_false_link::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@false_link:"
           << loc.reader_description (inIndentation + 1)
           << networkmessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_false_link::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_false_link::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_false_link (& typeid (cPtr_false_link), & typeid (cPtr_link_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_false_link::galgasRTTI (void) const {
  return & gClassInfoFor__false_link ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_false_link::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_false_link (loc, networkmessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_false_link'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_false_link ("false_link", true, & kTypeDescriptor_GGS_link_obj) ;

//---------------------------------------------------------------------------*

GGS_false_link::
GGS_false_link (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_false_link::
GGS_false_link (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_false_link GGS_false_link::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_false_link result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_false_link *> (inPointer) != NULL)
      : (typeid (cPtr_false_link) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_false_link (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_false_link),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_false_link GGS_false_link::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_false_link result ;
  macroMyNew (result.mPointer, cPtr_false_link (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_false_link::
reader_networkmessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_false_link *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_false_link *) mPointer)->networkmessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_false_link::actualTypeName (void) const {
  return "false_link" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__false_link ("false_link", gClassInfoFor__link_obj, & kTypeDescriptor_GGS_false_link) ;

//---------------------------------------------------------------------------*

GGS_object GGS_false_link::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_false_link * p = NULL ;
    macroMyNew (p, GGS_false_link (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_false_link GGS_false_link::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_false_link result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_false_link * p = dynamic_cast <const GGS_false_link *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_false_link, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_false_link::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_false_link ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_nmcallback_action'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nmcallback_action::
cPtr_nmcallback_action (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_action_obj (argument_0 COMMA_THERE),
function_name (argument_1),
ipdu (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nmcallback_action * GGS_nmcallback_action::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_nmcallback_action) ;
    return (cPtr_nmcallback_action *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_nmcallback_action::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_nmcallback_action * ptr = dynamic_cast <const cPtr_nmcallback_action *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && function_name.operator_isEqual (ptr->function_name).boolValue ()
         && ipdu.operator_isEqual (ptr->ipdu).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nmcallback_action::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@nmcallback_action:"
           << location.reader_description (inIndentation + 1)
           << function_name.reader_description (inIndentation + 1)
           << ipdu.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_nmcallback_action::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nmcallback_action::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_nmcallback_action (& typeid (cPtr_nmcallback_action), & typeid (cPtr_action_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_nmcallback_action::galgasRTTI (void) const {
  return & gClassInfoFor__nmcallback_action ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_nmcallback_action::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_nmcallback_action (location, function_name, ipdu COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_nmcallback_action'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nmcallback_action ("nmcallback_action", true, & kTypeDescriptor_GGS_action_obj) ;

//---------------------------------------------------------------------------*

GGS_nmcallback_action::
GGS_nmcallback_action (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_nmcallback_action::
GGS_nmcallback_action (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_nmcallback_action GGS_nmcallback_action::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_nmcallback_action result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_nmcallback_action *> (inPointer) != NULL)
      : (typeid (cPtr_nmcallback_action) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_nmcallback_action (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_nmcallback_action),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nmcallback_action GGS_nmcallback_action::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_luint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_nmcallback_action result ;
  macroMyNew (result.mPointer, cPtr_nmcallback_action (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nmcallback_action::
reader_function_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nmcallback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nmcallback_action *) mPointer)->function_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_nmcallback_action::
reader_ipdu (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nmcallback_action *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nmcallback_action *) mPointer)->ipdu ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nmcallback_action::actualTypeName (void) const {
  return "nmcallback_action" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__nmcallback_action ("nmcallback_action", gClassInfoFor__action_obj, & kTypeDescriptor_GGS_nmcallback_action) ;

//---------------------------------------------------------------------------*

GGS_object GGS_nmcallback_action::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nmcallback_action * p = NULL ;
    macroMyNew (p, GGS_nmcallback_action (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nmcallback_action GGS_nmcallback_action::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nmcallback_action result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nmcallback_action * p = dynamic_cast <const GGS_nmcallback_action *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nmcallback_action, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nmcallback_action::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nmcallback_action ;
}

//---------------------------------------------------------------------------*

