//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'xml_parsing_lexique.cpp'                       *
//                        Generated by version 1.8.3                         *
//                       may 29th, 2009, at 11h47'27"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 491
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "xml_parsing_lexique.h"

#include "strings/unicode_character.h"
#include "galgas/scanner_actions.h"
#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (HERE), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           Template Delimiters                             *
//                                                                           *
//---------------------------------------------------------------------------*

static const utf32 kTemplateDefinitionArray_0_startString [] = {
  TO_UNICODE ('<'),
  TO_UNICODE (0)
} ;

static const templateDelimiterStruct kTemplateDefinitionArray [1] = {
  {kTemplateDefinitionArray_0_startString, 1, NULL, 0, NULL, false},
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Template Replacements                            *
//                                                                           *
//---------------------------------------------------------------------------*

static const utf32 kTemplateReplacementArray_0_startString [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_0_endString [] = {
  TO_UNICODE ('&'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_1_startString [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('l'),
  TO_UNICODE ('t'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_1_endString [] = {
  TO_UNICODE ('<'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_2_startString [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('g'),
  TO_UNICODE ('t'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_2_endString [] = {
  TO_UNICODE ('>'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_3_startString [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('q'),
  TO_UNICODE ('u'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_3_endString [] = {
  TO_UNICODE ('\"'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_4_startString [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('s'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_4_endString [] = {
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_5_startString [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('#'),
  TO_UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_5_endString [] = {
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ;

static const templateDelimiterStruct kTemplateReplacementArray [6] = {
  {kTemplateReplacementArray_0_startString, 5, kTemplateReplacementArray_0_endString, 1, NULL, true},
  {kTemplateReplacementArray_1_startString, 4, kTemplateReplacementArray_1_endString, 1, NULL, true},
  {kTemplateReplacementArray_2_startString, 4, kTemplateReplacementArray_2_endString, 1, NULL, true},
  {kTemplateReplacementArray_3_startString, 6, kTemplateReplacementArray_3_endString, 1, NULL, true},
  {kTemplateReplacementArray_4_startString, 6, kTemplateReplacementArray_4_endString, 1, NULL, true},
  {kTemplateReplacementArray_5_startString, 2, kTemplateReplacementArray_5_endString, 1, scanner_action_codePointToUnicode, true},
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Terminal Symbols as end of script in template mark             *
//                                                                           *
//---------------------------------------------------------------------------*

static const bool kEndOfScriptInTemplateArray [10] = {
  true, // $comment$
  false, // $<$
  false, // $<?$
  true, // $>$
  true, // $?>$
  true, // $/>$
  false, // $</$
  false, // $=$
  false, // $name$
  false, // $value$
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_xml_parsing_lexique::cTokenFor_xml_parsing_lexique (void) :
tokenString () {
}

//---------------------------------------------------------------------------*

xml_parsing_lexique::
xml_parsing_lexique (C_Compiler * inCallerCompiler,
                const C_String & inDependencyFileExtension,
                const C_String & inDependencyFilePath,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE),
mMatchedTemplateDelimiterIndex (-1) {
}

//---------------------------------------------------------------------------*

xml_parsing_lexique::
xml_parsing_lexique (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE),
mMatchedTemplateDelimiterIndex (-1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Message 0
static const utf32 gErrorMessage_0 [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('X'),
  TO_UNICODE ('M'),
  TO_UNICODE ('L'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
} ;
//--- Message 1
static const utf32 gErrorMessage_1 [] = {
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('u'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('o'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('w'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('('),
  TO_UNICODE ('\''),
  TO_UNICODE (')'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('q'),
  TO_UNICODE ('u'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('k'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('('),
  TO_UNICODE ('\"'),
  TO_UNICODE (')'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Syntax error messages                            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Syntax error message for terminal '$comment$' :
static const utf32 gSyntaxErrorMessage_comment [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$<$' :
static const utf32 gSyntaxErrorMessage__3C [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('<'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$<?$' :
static const utf32 gSyntaxErrorMessage__3C_3F [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('<'),
  TO_UNICODE ('\?'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$>$' :
static const utf32 gSyntaxErrorMessage__3E [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('>'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$?>$' :
static const utf32 gSyntaxErrorMessage__3F_3E [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('\?'),
  TO_UNICODE ('>'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$/>$' :
static const utf32 gSyntaxErrorMessage__2F_3E [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('/'),
  TO_UNICODE ('>'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$</$' :
static const utf32 gSyntaxErrorMessage__3C_2F [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('<'),
  TO_UNICODE ('/'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$=$' :
static const utf32 gSyntaxErrorMessage__3D [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('='),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$name$' :
static const utf32 gSyntaxErrorMessage_name [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for terminal '$value$' :
static const utf32 gSyntaxErrorMessage_value [] = {
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('u'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//--- Syntax error message for 'end of source' :
static const utf32 kEndOfSourceLexicalErrorMessage [] = {
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('f'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void xml_parsing_lexique::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const utf32 * syntaxErrorMessageArray [11] = {kEndOfSourceLexicalErrorMessage,
       gSyntaxErrorMessage_comment,
       gSyntaxErrorMessage__3C,
       gSyntaxErrorMessage__3C_3F,
       gSyntaxErrorMessage__3E,
       gSyntaxErrorMessage__3F_3E,
       gSyntaxErrorMessage__2F_3E,
       gSyntaxErrorMessage__3C_2F,
       gSyntaxErrorMessage__3D,
       gSyntaxErrorMessage_name,
       gSyntaxErrorMessage_value} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Key words table 'xmlDelimitorsList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

static const sint32 ktable_size_xmlDelimitorsList = 7 ;

static const utf32 kEntry_0_forTable_xmlDelimitorsList [] = {
  TO_UNICODE ('<'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_1_forTable_xmlDelimitorsList [] = {
  TO_UNICODE ('='),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_2_forTable_xmlDelimitorsList [] = {
  TO_UNICODE ('>'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_3_forTable_xmlDelimitorsList [] = {
  TO_UNICODE ('/'),
  TO_UNICODE ('>'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_4_forTable_xmlDelimitorsList [] = {
  TO_UNICODE ('<'),
  TO_UNICODE ('/'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_5_forTable_xmlDelimitorsList [] = {
  TO_UNICODE ('<'),
  TO_UNICODE ('\?'),
  TO_UNICODE (0)
}; 

static const utf32 kEntry_6_forTable_xmlDelimitorsList [] = {
  TO_UNICODE ('\?'),
  TO_UNICODE ('>'),
  TO_UNICODE (0)
}; 

static const C_unicode_lexique_table_entry ktable_for_xmlDelimitorsList [ktable_size_xmlDelimitorsList] = {
  {kEntry_0_forTable_xmlDelimitorsList, 1, xml_parsing_lexique::xml_parsing_lexique_1__3C},
  {kEntry_1_forTable_xmlDelimitorsList, 1, xml_parsing_lexique::xml_parsing_lexique_1__3D},
  {kEntry_2_forTable_xmlDelimitorsList, 1, xml_parsing_lexique::xml_parsing_lexique_1__3E},
  {kEntry_3_forTable_xmlDelimitorsList, 2, xml_parsing_lexique::xml_parsing_lexique_1__2F_3E},
  {kEntry_4_forTable_xmlDelimitorsList, 2, xml_parsing_lexique::xml_parsing_lexique_1__3C_2F},
  {kEntry_5_forTable_xmlDelimitorsList, 2, xml_parsing_lexique::xml_parsing_lexique_1__3C_3F},
  {kEntry_6_forTable_xmlDelimitorsList, 2, xml_parsing_lexique::xml_parsing_lexique_1__3F_3E}
} ;

sint16 xml_parsing_lexique::search_into_xmlDelimitorsList (const C_String & inSearchedString) {
  return searchInList (inSearchedString, ktable_for_xmlDelimitorsList, ktable_size_xmlDelimitorsList) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String xml_parsing_lexique::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) inTokenPtr ;
  C_String s ;
  if (_p == NULL) {
    s << "$$" ;
  }else{
    switch (_p->mTokenCode) {
    case  xml_parsing_lexique_1_:
      s << "$$" ;
      break ;
    case  xml_parsing_lexique_1_comment:
      s << "$"
        << "comment"
        << "$" ;
    s << " " ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    case  xml_parsing_lexique_1__3C:
      s << "$"
        << "<"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3C_3F:
      s << "$"
        << "<\?"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3E:
      s << "$"
        << ">"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3F_3E:
      s << "$"
        << "\?>"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__2F_3E:
      s << "$"
        << "/>"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3C_2F:
      s << "$"
        << "</"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3D:
      s << "$"
        << "="
        << "$" ;
      break;
    case  xml_parsing_lexique_1_name:
      s << "$"
        << "name"
        << "$" ;
    s << " " ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    case  xml_parsing_lexique_1_value:
      s << "$"
        << "value"
        << "$" ;
    s << " " ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      U N I C O D E    S T R I N G S                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Unicode string for '"'
static const utf32 kUnicodeString__22_ [] = {
  TO_UNICODE ('\"'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '&amp;'
static const utf32 kUnicodeString__3B_pma_26_ [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '&apos;'
static const utf32 kUnicodeString__3B_sopa_26_ [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('s'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '&gt;'
static const utf32 kUnicodeString__3B_tg_26_ [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('g'),
  TO_UNICODE ('t'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '&lt;'
static const utf32 kUnicodeString__3B_tl_26_ [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('l'),
  TO_UNICODE ('t'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '&quot;'
static const utf32 kUnicodeString__3B_touq_26_ [] = {
  TO_UNICODE ('&'),
  TO_UNICODE ('q'),
  TO_UNICODE ('u'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (';'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '''
static const utf32 kUnicodeString__27_ [] = {
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '-->'
static const utf32 kUnicodeString__3E__2D__2D_ [] = {
  TO_UNICODE ('-'),
  TO_UNICODE ('-'),
  TO_UNICODE ('>'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '/>'
static const utf32 kUnicodeString__3E__2F_ [] = {
  TO_UNICODE ('/'),
  TO_UNICODE ('>'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '<'
static const utf32 kUnicodeString__3C_ [] = {
  TO_UNICODE ('<'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '<!--'
static const utf32 kUnicodeString__2D__2D__21__3C_ [] = {
  TO_UNICODE ('<'),
  TO_UNICODE ('!'),
  TO_UNICODE ('-'),
  TO_UNICODE ('-'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '</'
static const utf32 kUnicodeString__2F__3C_ [] = {
  TO_UNICODE ('<'),
  TO_UNICODE ('/'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '<?'
static const utf32 kUnicodeString__3F__3C_ [] = {
  TO_UNICODE ('<'),
  TO_UNICODE ('\?'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '='
static const utf32 kUnicodeString__3D_ [] = {
  TO_UNICODE ('='),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '>'
static const utf32 kUnicodeString__3E_ [] = {
  TO_UNICODE ('>'),
  TO_UNICODE (0)
} ; 

//--- Unicode string for '?>'
static const utf32 kUnicodeString__3E__3F_ [] = {
  TO_UNICODE ('\?'),
  TO_UNICODE ('>'),
  TO_UNICODE (0)
} ; 

//---------------------------------------------------------------------------*
//                                                                           *
//                            parseLexicalToken                              *
//                                                                           *
//---------------------------------------------------------------------------*

bool xml_parsing_lexique::
parseLexicalToken (void) {
  cTokenFor_xml_parsing_lexique token ;
  bool loop = true ;
  token.mTokenCode = -1 ;
  while ((token.mTokenCode < 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
    if ((mMatchedTemplateDelimiterIndex >= 0)
     && (kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndStringLength > 0)
     && (UNICODE_VALUE (mCurrentChar) != '\0')) {
      const bool foundEndDelimitor = testForInputUTF32String (kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndString,
                                                              kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndStringLength,
                                                              true) ;
      if (foundEndDelimitor) {
        mMatchedTemplateDelimiterIndex = -1 ;
      }
    }
    while ((mMatchedTemplateDelimiterIndex < 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
      sint32 replacementIndex = 0 ;
      while (replacementIndex >= 0) {
        replacementIndex = findTemplateDelimiterIndex (kTemplateReplacementArray, 6) ;
        if (replacementIndex >= 0) {
          if (kTemplateReplacementArray [replacementIndex].mReplacementFunction == NULL) {
            token.mTemplateStringBeforeToken << kTemplateReplacementArray [replacementIndex].mEndString ;
          }else{
            C_String s ;
            while (notTestForInputUTF32String (kTemplateReplacementArray [replacementIndex].mEndString,
                                               kTemplateReplacementArray [replacementIndex].mEndStringLength,
                                               kEndOfSourceLexicalErrorMessage
                                               COMMA_HERE)) {
              s.appendUnicodeCharacter (previousChar () COMMA_HERE) ;
            }
            kTemplateReplacementArray [replacementIndex].mReplacementFunction (*this, s, token.mTemplateStringBeforeToken) ;
          }
        }
      }
      mMatchedTemplateDelimiterIndex = findTemplateDelimiterIndex (kTemplateDefinitionArray, 1) ;
      if (mMatchedTemplateDelimiterIndex < 0) {
        token.mTemplateStringBeforeToken.appendUnicodeCharacter (mCurrentChar COMMA_HERE) ;
        advance () ;
      }
    }
    if ((mMatchedTemplateDelimiterIndex >= 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
      token.tokenString.setLengthToZero () ;
      mTokenFirstLocation = mCurrentLocation ;
      try{
        if (testForInputUTF32String (kUnicodeString__2D__2D__21__3C_, 4, true)) {
          do {
            if (testForInputUTF32String (kUnicodeString__3B_pma_26_, 5, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('&')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_tl_26_, 4, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('<')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_tg_26_, 4, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('>')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_touq_26_, 6, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\"')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_sopa_26_, 6, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\'')) ;
            }else if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE (',')) ||
                testForInputUTF32CharRange (TO_UNICODE ('.'), TO_UNICODE (1114111))) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;
            }else if (notTestForInputUTF32String (kUnicodeString__3E__2D__2D_, 3, gErrorMessage_0 COMMA_LINE_AND_SOURCE_FILE)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('-')) ;
            }else{
              loop = false ;
            }
          }while (loop) ;
          loop = true ;
          token.mTokenCode = xml_parsing_lexique_1_comment ;
          enterToken (token) ;
        }else if (testForInputUTF32String (kUnicodeString__3F__3C_, 2, true)) {
          token.mTokenCode = xml_parsing_lexique_1__3C_3F ;
          enterToken (token) ;
        }else if (testForInputUTF32String (kUnicodeString__3E__3F_, 2, true)) {
          token.mTokenCode = xml_parsing_lexique_1__3F_3E ;
          enterToken (token) ;
        }else if (testForInputUTF32String (kUnicodeString__3E__2F_, 2, true)) {
          token.mTokenCode = xml_parsing_lexique_1__2F_3E ;
          enterToken (token) ;
        }else if (testForInputUTF32String (kUnicodeString__2F__3C_, 2, true)) {
          token.mTokenCode = xml_parsing_lexique_1__3C_2F ;
          enterToken (token) ;
        }else if (testForInputUTF32String (kUnicodeString__3C_, 1, true)) {
          token.mTokenCode = xml_parsing_lexique_1__3C ;
          enterToken (token) ;
        }else if (testForInputUTF32String (kUnicodeString__3E_, 1, true)) {
          token.mTokenCode = xml_parsing_lexique_1__3E ;
          enterToken (token) ;
        }else if (testForInputUTF32String (kUnicodeString__3D_, 1, true)) {
          token.mTokenCode = xml_parsing_lexique_1__3D ;
          enterToken (token) ;
        }else if (testForCharWithFunction (isUnicodeLetter)) {
          do {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;
            if (testForCharWithFunction (isUnicodeLetter) ||
                testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9')) ||
                testForInputUTF32Char (TO_UNICODE ('-'))) {
            }else{
              loop = false ;
            }
          }while (loop) ;
          loop = true ;
          token.mTokenCode = xml_parsing_lexique_1_name ;
          enterToken (token) ;
        }else if (testForInputUTF32Char (TO_UNICODE ('\"'))) {
          do {
            if (testForInputUTF32String (kUnicodeString__3B_pma_26_, 5, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('&')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_tl_26_, 4, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('<')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_tg_26_, 4, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('>')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_touq_26_, 6, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\"')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_sopa_26_, 6, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\'')) ;
            }else if (notTestForInputUTF32String (kUnicodeString__22_, 1, gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;
            }else{
              loop = false ;
            }
          }while (loop) ;
          loop = true ;
          token.mTokenCode = xml_parsing_lexique_1_value ;
          enterToken (token) ;
        }else if (testForInputUTF32Char (TO_UNICODE ('\''))) {
          do {
            if (testForInputUTF32String (kUnicodeString__3B_pma_26_, 5, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('&')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_tl_26_, 4, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('<')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_tg_26_, 4, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('>')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_touq_26_, 6, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\"')) ;
            }else if (testForInputUTF32String (kUnicodeString__3B_sopa_26_, 6, true)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\'')) ;
            }else if (notTestForInputUTF32String (kUnicodeString__27_, 1, gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE)) {
              ::scanner_action_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;
            }else{
              loop = false ;
            }
          }while (loop) ;
          loop = true ;
          token.mTokenCode = xml_parsing_lexique_1_value ;
          enterToken (token) ;
        }else if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE (' '))) {
        }else if (testForInputUTF32Char (TO_UNICODE ('\0'))) { // End of source text ? 
          token.mTokenCode = xml_parsing_lexique_1_ ; // Empty string code
        }else{ // Unknown input character
          unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
        }
      }catch (const C_lexicalErrorException &) {
        token.mTokenCode = -1 ; // No token
        advance () ; // ... go throught unknown character
      }
    }
    if ((token.mTokenCode > 0) && kEndOfScriptInTemplateArray [token.mTokenCode - 1]) {
      mMatchedTemplateDelimiterIndex = -1 ;
    }
  }
  if ((UNICODE_VALUE (mCurrentChar) == '\0') && (token.mTemplateStringBeforeToken.length () > 0)) {
    token.mTokenCode = 0 ;
    enterToken (token) ;
  }
  return token.mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   parseLexicalTokenForLexicalColoring                     *
//                                                                           *
//---------------------------------------------------------------------------*

sint16 xml_parsing_lexique::
parseLexicalTokenForLexicalColoring (void) {
  cTokenFor_xml_parsing_lexique token ;
  bool loop = true ;
  token.mTokenCode = -1 ;
  while (token.mTokenCode < 0) {
    token.tokenString.setLengthToZero () ;
    mTokenFirstLocation = mCurrentLocation ;
    try{
      if (testForInputUTF32String (kUnicodeString__2D__2D__21__3C_, 4, true)) {
        do {
          if (testForInputUTF32String (kUnicodeString__3B_pma_26_, 5, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('&')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_tl_26_, 4, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('<')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_tg_26_, 4, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('>')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_touq_26_, 6, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\"')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_sopa_26_, 6, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\'')) ;
          }else if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE (',')) ||
              testForInputUTF32CharRange (TO_UNICODE ('.'), TO_UNICODE (1114111))) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;
          }else if (notTestForInputUTF32String (kUnicodeString__3E__2D__2D_, 3, gErrorMessage_0 COMMA_LINE_AND_SOURCE_FILE)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('-')) ;
          }else{
            loop = false ;
          }
        }while (loop) ;
        loop = true ;
        token.mTokenCode = xml_parsing_lexique_1_comment ;
      }else if (testForInputUTF32String (kUnicodeString__3F__3C_, 2, true)) {
        token.mTokenCode = xml_parsing_lexique_1__3C_3F ;
      }else if (testForInputUTF32String (kUnicodeString__3E__3F_, 2, true)) {
        token.mTokenCode = xml_parsing_lexique_1__3F_3E ;
      }else if (testForInputUTF32String (kUnicodeString__3E__2F_, 2, true)) {
        token.mTokenCode = xml_parsing_lexique_1__2F_3E ;
      }else if (testForInputUTF32String (kUnicodeString__2F__3C_, 2, true)) {
        token.mTokenCode = xml_parsing_lexique_1__3C_2F ;
      }else if (testForInputUTF32String (kUnicodeString__3C_, 1, true)) {
        token.mTokenCode = xml_parsing_lexique_1__3C ;
      }else if (testForInputUTF32String (kUnicodeString__3E_, 1, true)) {
        token.mTokenCode = xml_parsing_lexique_1__3E ;
      }else if (testForInputUTF32String (kUnicodeString__3D_, 1, true)) {
        token.mTokenCode = xml_parsing_lexique_1__3D ;
      }else if (testForCharWithFunction (isUnicodeLetter)) {
        do {
          ::scanner_action_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;
          if (testForCharWithFunction (isUnicodeLetter) ||
              testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9')) ||
              testForInputUTF32Char (TO_UNICODE ('-'))) {
          }else{
            loop = false ;
          }
        }while (loop) ;
        loop = true ;
        token.mTokenCode = xml_parsing_lexique_1_name ;
      }else if (testForInputUTF32Char (TO_UNICODE ('\"'))) {
        do {
          if (testForInputUTF32String (kUnicodeString__3B_pma_26_, 5, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('&')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_tl_26_, 4, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('<')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_tg_26_, 4, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('>')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_touq_26_, 6, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\"')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_sopa_26_, 6, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\'')) ;
          }else if (notTestForInputUTF32String (kUnicodeString__22_, 1, gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;
          }else{
            loop = false ;
          }
        }while (loop) ;
        loop = true ;
        token.mTokenCode = xml_parsing_lexique_1_value ;
      }else if (testForInputUTF32Char (TO_UNICODE ('\''))) {
        do {
          if (testForInputUTF32String (kUnicodeString__3B_pma_26_, 5, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('&')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_tl_26_, 4, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('<')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_tg_26_, 4, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('>')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_touq_26_, 6, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\"')) ;
          }else if (testForInputUTF32String (kUnicodeString__3B_sopa_26_, 6, true)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, TO_UNICODE ('\'')) ;
          }else if (notTestForInputUTF32String (kUnicodeString__27_, 1, gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE)) {
            ::scanner_action_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;
          }else{
            loop = false ;
          }
        }while (loop) ;
        loop = true ;
        token.mTokenCode = xml_parsing_lexique_1_value ;
      }else if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE (' '))) {
      }else if (testForInputUTF32Char (TO_UNICODE ('\0'))) { // End of source text ? 
        token.mTokenCode = xml_parsing_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      token.mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      throw ;
    }
  }
  return token.mTokenCode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 xml_parsing_lexique::getStylesCount (void) {
  return 6 ;
}

//---------------------------------------------------------------------------*

const char * xml_parsing_lexique::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [7] = {"Default style", "Delimiter:", "Name:", "Attribute value:", "Comment:", "Text:", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

const char * xml_parsing_lexique::getStyleIdentifier (const sint32 inIndex) {
  const char * kStylesArray [7] = {"", "delimitersStyle", "nameStyle", "attributeValue", "commentStyle", "textStyle", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 xml_parsing_lexique::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [11] = {0,
    4 /* xml_parsing_lexique_1_comment */,
    1 /* xml_parsing_lexique_1__3C */,
    1 /* xml_parsing_lexique_1__3C_3F */,
    1 /* xml_parsing_lexique_1__3E */,
    1 /* xml_parsing_lexique_1__3F_3E */,
    1 /* xml_parsing_lexique_1__2F_3E */,
    1 /* xml_parsing_lexique_1__3C_2F */,
    1 /* xml_parsing_lexique_1__3D */,
    2 /* xml_parsing_lexique_1_name */,
    3 /* xml_parsing_lexique_1_value */
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*

void xml_parsing_lexique::enterToken (const cTokenFor_xml_parsing_lexique & inToken) {
  cTokenFor_xml_parsing_lexique * _p = NULL ;
  macroMyNew (_p, cTokenFor_xml_parsing_lexique ()) ;
  _p->mTokenCode = inToken.mTokenCode ;
  _p->mFirstLocation = mTokenFirstLocation ;
  _p->mLastLocation  = mTokenLastLocation ;
  _p->mTemplateStringBeforeToken  = inToken.mTemplateStringBeforeToken ;
  _p->tokenString = inToken.tokenString ;
  enterTokenFromPointer (_p) ;
}

//---------------------------------------------------------------------------*

void xml_parsing_lexique::
_assignFromAttribute_tokenString (GGS_lstring & outValue) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->tokenString) ;
}

//---------------------------------------------------------------------------*

C_String xml_parsing_lexique::
_attributeValue_tokenString (void) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) mCurrentTokenPtr ;
  return _p->tokenString ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

