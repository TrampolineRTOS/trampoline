//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'goil_target_h8300h.cpp'                        *
//                        Generated by version 1.9.5                         *
//                     november 23th, 2009, at 12h7'26"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 614
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_target_h8300h.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_target_h8300h.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "generate_target_h8300h"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_generate_target_h8300h (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_name,
                                const GGS_ident_map   var_cas_others,
                                const GGS_oil_obj   var_cas_exe,
                                GGS_string & var_cas_result COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_generate_target_h8300h at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  ::routine_doReplace (inLexique,  var_cas_result,  GGS_string ("$STACK_ZONE$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (51))).operator_concat (GGS_string ("_stack")) COMMA_SOURCE_FILE_AT_LINE (51)) ;
  ::routine_doReplace (inLexique,  var_cas_result,  GGS_string ("$EXEC_INTEGER_CONTEXT$"),  (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (52))).operator_concat (GGS_string ("_integer_context")) COMMA_SOURCE_FILE_AT_LINE (52)) ;
  GGS_uint  var_cas_stack_size ;
  ::routine_additional_int_key_required (inLexique,  GGS_string ("STACKSIZE"),  var_cas_others,  var_cas_name,  var_cas_stack_size COMMA_SOURCE_FILE_AT_LINE (55)) ;
  var_cas_result = var_cas_result.reader_stringByReplacingStringByString (inLexique, GGS_string ("$STACK_SIZE$"), var_cas_stack_size.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (56)) COMMA_SOURCE_FILE_AT_LINE (56)) ;
  { const GGS_oil_obj _var_1903 = var_cas_exe ; // CAST instruction
    if (_var_1903.getPtr () != NULL) {
      macroValidPointer (_var_1903.getPtr ()) ;
      if (typeid (cPtr_isr_obj) == typeid (* (_var_1903.getPtr ()))) {
        GGS_uint  var_cas_trap ;
        ::routine_additional_int_key_required (inLexique,  GGS_string ("EXCEPTION_HANDLER"),  var_cas_others,  var_cas_name,  var_cas_trap COMMA_SOURCE_FILE_AT_LINE (62)) ;
        ::routine_doReplace (inLexique,  var_cas_result,  GGS_string ("$EXCEPTION_HANDLER$"),  var_cas_trap.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (63)) COMMA_SOURCE_FILE_AT_LINE (63)) ;
      }else{
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_generate_target_h8300h\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "generate_isr_h8300h"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_generate_isr_h8300h (C_Compiler & inLexique,
                                const GGS_isr_map   var_cas_isrs,
                                GGS_string & var_cas_code COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_generate_isr_h8300h at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_result = GGS_string ("") ;
  {
    GGS_isr_map::cEnumerator enumerator_2031 (var_cas_isrs, true) ;
    const GGS_isr_map::cElement * operand_2031 = NULL ;
    while (((operand_2031 = enumerator_2031.nextObject ()))) {
      macroValidPointer (operand_2031) ;
      GGS_ident_map  var_cas_others = operand_2031->mInfo.isr.reader_other_fields (inLexique COMMA_SOURCE_FILE_AT_LINE (74)) ;
      GGS_uint  var_cas_trap ;
      ::routine_additional_int_key_required (inLexique,  GGS_string ("EXCEPTION_HANDLER"),  var_cas_others,  operand_2031->mKey,  var_cas_trap COMMA_SOURCE_FILE_AT_LINE (76)) ;
      GGS_string var_cas_tmp = function_template_string (inLexique, GGS_string ("code"), GGS_string ("isr_list_specific") COMMA_SOURCE_FILE_AT_LINE (79)) ;
      ::routine_doReplace (inLexique,  var_cas_tmp,  GGS_string ("$EXCEPTION_HANDLER$"),  var_cas_trap.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (81)) COMMA_SOURCE_FILE_AT_LINE (81)) ;
      ::routine_doReplace (inLexique,  var_cas_tmp,  GGS_string ("$EXEC_NAME$"),  operand_2031->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (83)) COMMA_SOURCE_FILE_AT_LINE (83)) ;
      var_cas_result.dotAssign_operation (var_cas_tmp) ;
    }
  }
  ::routine_doReplace (inLexique,  var_cas_code,  GGS_string ("$ISR_LIST$"),  var_cas_result COMMA_SOURCE_FILE_AT_LINE (86)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_generate_isr_h8300h\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "generate_counter_h8300h"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_generate_counter_h8300h (C_Compiler & inLexique,
                                const GGS_counter_map   var_cas_counters,
                                GGS_string & var_cas_code COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_generate_counter_h8300h at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_result = GGS_string ("") ;
  {
    GGS_counter_map::cEnumerator enumerator_2722 (var_cas_counters, true) ;
    const GGS_counter_map::cElement * operand_2722 = NULL ;
    while (((operand_2722 = enumerator_2722.nextObject ()))) {
      macroValidPointer (operand_2722) ;
      { const GGS_counter_type _var_3021 = operand_2722->mInfo.counter.reader_type (inLexique COMMA_SOURCE_FILE_AT_LINE (95)) ; // CAST instruction
        if (_var_3021.getPtr () != NULL) {
          macroValidPointer (_var_3021.getPtr ()) ;
          if (typeid (cPtr_software_counter) == typeid (* (_var_3021.getPtr ()))) {
          }else{
            GGS_string var_cas_tmp = function_template_string (inLexique, GGS_string ("code"), GGS_string ("counter_list_specific") COMMA_SOURCE_FILE_AT_LINE (98)) ;
            ::routine_doReplace (inLexique,  var_cas_tmp,  GGS_string ("$COUNTER$"),  (operand_2722->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (99))).operator_concat (GGS_string ("_counter_desc")) COMMA_SOURCE_FILE_AT_LINE (99)) ;
            var_cas_result.dotAssign_operation (var_cas_tmp) ;
          }
        }
      }
    }
  }
  ::routine_doReplace (inLexique,  var_cas_code,  GGS_string ("$COUNTER_LIST$"),  var_cas_result COMMA_SOURCE_FILE_AT_LINE (104)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_generate_counter_h8300h\n") ;
  #endif
}

//---------------------------------------------------------------------------*

