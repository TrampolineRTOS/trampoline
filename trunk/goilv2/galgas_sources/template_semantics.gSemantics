#---------------------------------------------------------------------------*
#                                                                           *
#  Types for GOIL templates                                                 *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics template_semantics :

#------------------------------------------------------------------------------*

enum @Ttype {
  boolType,
  unsignedType,
  stringType,
  listType,
  mapType,
  structType,
  enumType,
  unconstructedType
}{
}

reader @Ttype messageGoilTemplateType -> @string outResult :
  switch selfcopy
    when boolType : outResult := "bool";
    when unsignedType : outResult := "unsigned";
    when stringType : outResult := "string";
    when listType : outResult := "list";
    when mapType : outResult := "map";
    when structType : outResult := "struct";
    when enumType : outResult := "enum";
    when unconstructedType : outResult := "unconstructed";
  end switch;
end reader;

#------------------------------------------------------------------------------*

list @TtypeList {
  @Ttype mType;
}

#------------------------------------------------------------------------------*

map @TfieldMap {
  @Ttype  mType;
  @Tvalue mValue; 
  insert insertKey error message "a template field named '%K' is already declared in %L";
  search searchKey error message "there is no template field named '%K'";
  remove removeKey error message "there is no template field named '%K' to delete";
}

#------------------------------------------------------------------------------*

list @TfieldMapList {
  @TfieldMap mMap;
}

#------------------------------------------------------------------------------*

struct @Tvalue {
  @uint64 mUnsigned64Value;
  @string mStringValue;
  @TfieldMapList mMapListValue;
  @TfieldMap mStructValue;
}

#------------------------------------------------------------------------------*

list @TexpressionList {
  @Tvalue mValue;
  @Ttype mType;
}

#------------------------------------------------------------------------------*

list @TenumationList {
  @Tvalue mEnumeratedValue;
  @string mPrefix;
}

#------------------------------------------------------------------------------*

function valueWithBool
  ??@bool inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    ![inValue uint64]
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithUnsigned
  ??@uint64 inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !inValue
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithString
  ??@string inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0L
    !inValue
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithStruct
  ??@TfieldMap inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0L
    !""
    ![@TfieldMapList emptyList]
    !inValue
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithMap
  ??@TfieldMap inValue
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0L
    !""
    ![@TfieldMapList emptyList]
    !inValue
  ];
end function;

#------------------------------------------------------------------------------*

function valueWithVoid
  ->@Tvalue outValue
:
  outValue := [@Tvalue new
    !0L
    !""
    ![@TfieldMapList emptyList]
    ![@TfieldMap emptyMap]
  ];
end function;

#------------------------------------------------------------------------------*

routine addBoolValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@bool inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype boolType]
    !valueWithBool[!inValue]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addUnsignedValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@uint64 inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype unsignedType]
    !valueWithUnsigned[!inValue]
    #[@goilTemplateValue new !inValue !"" ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addLUnsignedValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@string inVariableName
  ??@luint64 inValue
:
  addUnsignedValue !?ioTemplateVariableMap ![@lstring new !inVariableName ![inValue location]] ![inValue uint64];
end routine;

#------------------------------------------------------------------------------*

routine addStringValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@string inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype stringType]
    !valueWithString[!inValue]
    #[@goilTemplateValue new !0L !inValue ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addLStringValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@string inVariableName
  ??@lstring inValue
:
  addStringValue !?ioTemplateVariableMap ![@lstring new !inVariableName ![inValue location]] ![inValue string];
end routine;

#------------------------------------------------------------------------------*

routine addListValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@TfieldMapList inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype listType]
    ![@Tvalue new !0L !"" !inValue ![@TfieldMap emptyMap]]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addStructValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@TfieldMap inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype structType]
    ![@Tvalue new !0L !"" ![@TfieldMapList emptyList] !inValue]
  ];
end routine;

#------------------------------------------------------------------------------*

routine addEnumValue
  ?!@TfieldMap ioTemplateVariableMap
  ??@lstring inVariableName
  ??@string inValue
:
  [!?ioTemplateVariableMap insertKey
    !inVariableName
    ![@Ttype enumType]
    !valueWithString[!inValue]
    #[@goilTemplateValue new !0L !inValue ![@goilTemplateFieldMapList emptyList]]
  ];
end routine;

#------------------------------------------------------------------------------*

list @TvarPath {
  @lstring item;
  @lstring key;
  @lsint idx;
}

#------------------------------------------------------------------------------*

routine printPath
  ??@TvarPath path
:
  foreach path do
    message [item string];
    if [key string] != "" then
      message "[\"".key."\"]";
    end if;
    if [idx sint] != -1s then
      message "[".[idx string]."]";
    end if;
  between message "::";
  end foreach;
end routine;

#------------------------------------------------------------------------------*

routine searchField
  ?@TvarPath variable
  ??@TfieldMap inTemplateFieldMap
  !@Ttype variableType
  !@Tvalue variableValue
  !@location variableLocation
:
  @lstring field;
  @lstring key;
  @lsint idx;
  variableLocation := here;
  [!?variable popFirst ?field ?key ?idx];
  [inTemplateFieldMap searchKey !field ?variableType ?variableValue];
  if [inTemplateFieldMap hasKey ![field string]] then
    variableLocation := [inTemplateFieldMap locationForKey ![field string]];
  end if;
  if [key string] != "" & variableType == [@Ttype mapType] then
    @TfieldMap mapMap := [variableValue mStructValue];
    [mapMap searchKey !key ?variableType ?variableValue];
    if [mapMap hasKey ![key string]] then
      variableLocation := [mapMap locationForKey ![key string]];
    end if;
  elsif [idx sint] != -1s & variableType == [@Ttype listType] then
    @TfieldMapList mapList := [variableValue mMapListValue];
    variableValue->mStructValue := [mapList mMapAtIndex ![idx uint]];
    variableType := [@Ttype structType];
  end if;
  if [variable length] > 0 then
    if variableType == [@Ttype structType] then
      searchField !variable ![variableValue mStructValue] ?variableType ?variableValue ?variableLocation;
    else
      variableLocation := here;
      error field: "struct variable expected": variableValue;
    end if;
  end if;
end routine;

#------------------------------------------------------------------------------*

routine searchFieldIfExists
  ?@TvarPath variable
  ??@TfieldMap inTemplateFieldMap
  !@Ttype variableType
  !@Tvalue variableValue
  !@bool found
:
  @lstring field;
  @lstring key;
  @lsint idx;
  [!?variable popFirst ?field ?key ?idx];
  
  if [inTemplateFieldMap hasKey ![field string]] then
    [inTemplateFieldMap searchKey !field ?variableType ?variableValue];
    if [key string] != "" & variableType == [@Ttype mapType] then
      if [[variableValue mStructValue] hasKey ![key string]] then
        [[variableValue mStructValue] searchKey !key ?variableType ?variableValue];
        found := true;
      else
        found := false;
      end if;
    elsif [idx sint] != -1s & variableType == [@Ttype listType] then
      if [idx uint] < [[variableValue mMapListValue] length] then
        @TfieldMapList mapList := [variableValue mMapListValue];
        variableValue->mStructValue := [mapList mMapAtIndex ![idx uint]];
        variableType := [@Ttype structType];
        found := true;
      else
        found := false;
      end if;
    else
      found := true;
    end if;
  else
    variableType := [@Ttype unconstructedType];
    variableValue := valueWithVoid[];
    found := false;
  end if;
  if [variable length] > 0 & found then
    if variableType == [@Ttype structType] then
      searchFieldIfExists !variable ![variableValue mStructValue] ?variableType ?variableValue ?found;
    else
      found := false;
    end if;
  end if;
end routine;

end semantics;
