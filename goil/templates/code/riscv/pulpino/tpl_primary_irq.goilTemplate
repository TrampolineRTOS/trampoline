.global tpl_interruption_handler

%#------------------------------------------------------------------------------*
# Target specific initializations
# build the maps for IRQ
#
let objForIRQ := @[ ]

# Map ISR into objForIRQ
foreach isr in ISR do
  let key := isr::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := @( )
  end if
  let isr::KIND := "ISR"
  let objForIRQ[key] += isr
end foreach

# Map COUNTER into objForIRQ
foreach cnt in COUNTER do
  let key := cnt::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := @( )
  end if
  let cnt::KIND := "COUNTER"
  let objForIRQ[key] += cnt
end foreach

#------------------------------------------------------------------------------*
# ISR1 cannot use the same IRQ as ISR2 or COUNTER.
#
foreach irq in objForIRQ do
  let objISR1 := @()
  let objOther := @()
  # look if the list contains an ISR1
  foreach obj in irq do
    if exists obj::CATEGORY then
      if obj::CATEGORY == 1 then
        let objISR1 += obj
      else
        let objOther += obj
      end if
    end if
  end foreach
  if [objISR1 length] > 0 & [objOther length] > 0 then
    foreach isr1 in objISR1 do
      error isr1::SOURCE : "Cannot use same IRQ for an ISR1 and an ISR2 or COUNTER"
      foreach obj in objOther do
        error obj::SOURCE : "Was used here"
      end foreach
    end foreach
  end if
end foreach

let INTERRUPTMAP := mapof INTERRUPT by NAME

# Build the list of IRQ handlers to call
let irqStageList := @( )

# Build a list of virtual objects (sources of interrupts) each of them holding values :
# handlerSource, handlerName, handlerAck, generatePrimaryIrq
foreach objList in objForIRQ do
  let anIrq::handlerSource := KEY
  let anIrq::handlerName := objList[0]::NAME
  let anIrq::handlerAck := false
  let anIrq::generatePrimaryIrq := false
  foreach obj in objList do
    let anIrq::handlerAck := INTERRUPTMAP[anIrq::handlerSource]::ACK
    if obj::KIND == "ISR" then
      if obj::CATEGORY == 1 then
        let generatePrimaryIrq := true
      end if
    end if
  end foreach
  let irqStageList += anIrq 
end foreach

#------------------------------------------------------------------------------*
%/**
 * @file tpl_primary_irq.% !EXTENSIONSECONDSTAGE %
 *
 * @section descr File description
 *
 * Generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */

#include <pulpino.h>
#include <tpl_asm_definitions.h>

#define NO_NEED_SWITCH_NOR_SCHEDULE 0
#define NO_NEED_SWITCH 0
#define NEED_SWITCH 1
#define NEED_SAVE 2
#define EXCEPTION_STACK_SIZE 96

.extern tpl_kern
.extern tpl_it_vectors

tpl_interruption_handler:
  addi sp, sp, -EXCEPTION_STACK_SIZE
  sw ra, 0x5C(x2)
  jal store_regs
  la ra, end_except

  la a0, tpl_it_vectors
  csrr a1, mcause
  slli a1, a1, 2
  add a0, a0, a1
  lw a0, -4(a0)
  jr a0
  ret

%

foreach irq in irqStageList
  before
%

%
  do
    let handlerSource := irq::handlerSource
    let handlerName := irq::handlerName
    let handlerIRQ := handlerSource."_Handler"
    if not irq::generatePrimaryIrq then
%
/*=============================================================================
 * IRQ Handler for IRQ % !handlerName % with source vector % !handlerSource %
 ******************************************************************************/
%
      template if exists handler_body
    end if
  after
%
%
end foreach

%

/* End of file tpl_second_stage_irq.% !EXTENSIONSECONDSTAGE % */

