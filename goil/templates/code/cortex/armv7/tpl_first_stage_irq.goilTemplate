/**
 * @file tpl_first_stage_irq.% !EXTENSIONFIRSTSTAGE %
 *
 * @section descr File description
 *
 * 
 *
 * @warning this file is generated by gen_invoque.sh based on the 
 * tpl_os_service_ids.h header file.
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005+
 * Copyright ESEO for function and data structures documentation and ARM port
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */

#include "tpl_assembler.h"
#include "tpl_asm_definitions.h"
#include "tpl_os_application_def.h"
#include "tpl_service_ids.h"

  .syntax unified
  .thumb

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

.section .osCode CODE_ACCESS_RIGHT

%
let IT_SOURCES := mapof INTERRUPT by NAME
foreach counter in HARDWARECOUNTERS do 
  if not exists IT_SOURCES[counter::SOURCE] then
    error counter::SOURCE : "Interrupt source ".counter::SOURCE." does not exist"
  end if
end foreach
foreach isr in ISRS2 do
  if not exists IT_SOURCES[isr::SOURCE] then
    error isr::SOURCE : "Interrupt source ".isr::SOURCE." does not exist"
  end if
end foreach

loop ENTRY from 0 to INTERRUPT_COUNT::IT_TABLE_SIZE - 1
  before
%

%
  do
    let entryFound := false
    foreach interrupt in INTERRUPT do
      if ENTRY == interrupt::VECT then
        # check first for counters
        foreach counter in HARDWARECOUNTERS do
          if counter::SOURCE == interrupt::NAME & not entryFound & interrupt::VECTOR_TYPE == "HANDLER" & interrupt::VECTOR_TYPE_S::NAME != "NONE" then
%
	.extern tpl_primary_irq_handler_% !interrupt::VECT %
	.global tpl_primary_irq_handler_% !interrupt::NAME %
	.type tpl_primary_irq_handler_% !interrupt::NAME %, \%function
tpl_primary_irq_handler_% !interrupt::NAME %:%
            if interrupt::ACK then
%
	push {lr}
	mov r0,#% !interrupt::VECT %
	bl % !interrupt::NAME %_ClearFlag
	pop {lr}
%
            end if
%
	mov r0,#% !interrupt::VECT %
	b tpl_primary_irq_handler_% !interrupt::VECT %
tpl_primary_irq_handler_% !interrupt::VECTOR_TYPE_S::NAME %_exit:
	bx lr%
            let entryFound := true
          end if
          between %
%
        end foreach
        if not entryFound then
          foreach isr in ISRS2 do
            if isr::SOURCE == interrupt::NAME & not entryFound & interrupt::VECTOR_TYPE == "HANDLER" & interrupt::VECTOR_TYPE_S::NAME != "NONE" then
%
	.extern tpl_primary_irq_handler_% !interrupt::VECT %
	.global tpl_primary_irq_handler_% !interrupt::NAME %
	.type tpl_primary_irq_handler_% !interrupt::NAME %, \%function
tpl_primary_irq_handler_% !interrupt::NAME %:%
              if interrupt::ACK then
%
	push {lr}
	mov r0,#% !interrupt::VECT %
	bl % !interrupt::NAME %_ClearFlag
	pop {lr}
%
              end if
%
	mov r0,#% !interrupt::VECT %
	b tpl_primary_irq_handler_% !interrupt::VECT %
tpl_primary_irq_handler_% !interrupt::VECTOR_TYPE_S::NAME %_exit:
	bx lr%
              let entryFound := true
            end if
            between %
%
          end foreach
        end if
      end if
    end foreach
#    if not entryFound then
#      %  { (tpl_it_handler)tpl_null_it, (void *)NULL }%
#    end if
#  between %,
#%
    after
%
%
end loop

%

#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

#define OS_START_LTORG
#include "tpl_as_memmap.h"
#define OS_STOP_LTORG
#include "tpl_as_memmap.h"

/* End of file tpl_first_stage_irq.% !EXTENSIONFIRSTSTAGE % */
