%#------------------------------------------------------------------------------*
# Target specific initializations
# build the maps for IRQ
#
let objForIRQ := @[ ]

# Map ISR into objForIRQ
foreach isr in ISR do
  let key := isr::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := @( )
  end if
  let isr::KIND := "ISR"
  let objForIRQ[key] += isr
end foreach

# Map COUNTER into objForIRQ
foreach cnt in COUNTER do
  let key := cnt::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := @( )
  end if
  let cnt::KIND := "COUNTER"
  let objForIRQ[key] += cnt
end foreach

let INTERRUPTMAP := mapof INTERRUPT by NAME

# Build the list of IRQ handlers to call
let irqStageList := @( )

# Build a list of virtual objects (sources of interrupts) each of them holding values :
# handlerSource, handlerName, handlerAck, generatePrimaryIrq
foreach objList in objForIRQ do
  let anIrq::handlerSource := KEY
  let anIrq::handlerName := objList[0]::NAME
  let anIrq::handlerAck := false
  let anIrq::generatePrimaryIrq := false
  foreach obj in objList do
    let anIrq::handlerAck := INTERRUPTMAP[anIrq::handlerSource]::ACK
    if obj::KIND == "ISR" then
      if obj::CATEGORY == 1 then
        let generatePrimaryIrq := true
      end if
    end if
  end foreach
  let irqStageList += anIrq 
end foreach

#------------------------------------------------------------------------------*
%/**
 * @file tpl_primary_irq.% !EXTENSIONSECONDSTAGE %
 *
 * @section descr File description
 *
 * 
 *
 * @warning this file is generated by gen_invoque.sh based on the 
 * tpl_os_service_ids.h header file.
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005+
 * Copyright ESEO for function and data structures documentation and ARM port
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */

#include "tpl_assembler.h"
#include "tpl_asm_definitions.h"
#include "tpl_os_kernel_stack.h"

.syntax unified
.thumb

.section .osVar CAR_ACCESS_RIGHT

.equ  NO_NEED_SWITCH_NOR_SCHEDULE , 0
.equ  NO_NEED_SWITCH , 0
.equ  NEED_SWITCH , 1
.equ  NEED_SAVE , 2

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

.extern nested_kernel_entrance_counter
.extern tpl_kern
.extern tpl_dispatch_table

/*
 * Second stage category 2 interrupt handler (which means only IRQ on
 * this architecture, FIQ are category 1 interrupts)
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * We take care to not alter callee saved registers
 * which are all except r0-r3 (EABI convention).
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * We do not use r3 because it is used to give the service number
 * in a system call. After dispatching, r3 can be altered.
 *
 * This exception to EABI conventions is specific to system call
 * mechanism.
 */

/*
 ---------------
 | WITHOUT FPU |
        ---------------
 STACK BEFORE SYSTEM CALL, BEFORE PUSHING CONTEXT

*          |---------------------------|
*          |                           |
* SP    -> |---------------------------|

  STACK AFTER PUSHING CONTEXT

*          |---------------------------|
*          |                           | |
*          |---------------------------| |<- Pre-IRQ Top of Stack
*          | {aligner}                 | |
* SP+32 -> |---------------------------|
*          | xPSR                      |
* SP+28 -> |---------------------------|
*          | PC                        |
* SP+24 -> |---------------------------|
*          | LR return address         |
* SP+20 -> |---------------------------|
*          | R12                       |
* SP+16 -> |---------------------------|
*          | R3 service number         |
* SP+12 -> |---------------------------|
*          | R2                        |
* SP+8  -> |---------------------------|
*          | R1                        |
* SP+4  -> |---------------------------|
*          | R0                        |
* SP    -> |---------------------------| <- IRQ Top of stack

        ---------------
 | WITH FPU    |
        ---------------
 STACK BEFORE SYSTEM CALL, BEFORE PUSHING CONTEXT

*          |---------------------------|
*          |                           |
* SP    -> |---------------------------|

  STACK AFTER PUSHING CONTEXT

* SP+32 -> |---------------------------|
*          | xPSR                      |
* SP+28 -> |---------------------------|
*          | PC                        |
* SP+24 -> |---------------------------|
*          | LR return address         |
* SP+20 -> |---------------------------|
*          | R12                       |
* SP+16 -> |---------------------------|
*          | R3 service number         |
* SP+12 -> |---------------------------|
*          | R2                        |
* SP+8  -> |---------------------------|
*          | R1                        |
* SP+4  -> |---------------------------|
*          | R0                        |
* SP    -> |---------------------------| <- IRQ Top of stack

*/

.section .osCode CODE_ACCESS_RIGHT

/*******************************************************************************
 *
 *******************************************************************************/
tpl_enter_kernel:
 #if WITH_MEMORY_PROTECTION == YES
 /*
  * Switch to kernel memory protection scheme
  */
  bl tpl_kernel_mp
 #endif
 /* 
  * Manage reentrance of kernel
  * Increment nested_kernel_entrance_counter
  */
  ldr r12, =nested_kernel_entrance_counter
  ldr r4, [r12]
  add r4, r4, #1
  str r4, [r12]
 /* 
  * NA: Switch to the kernel stack
  * Automatic (configuration) for the Cortex-M4
  */

 /*
  * NA: Make space on the stack to call C functions
  * Automatic for the Cortex-M4
  */
tpl_enter_kernel_exit: 
  bx lr

/*******************************************************************************
 *
 *******************************************************************************/
tpl_leave_kernel:
 /*
  * NA: Restore saved registers in the system stack
  * Automatic for the Cortex-M4
  */
 
 /* 
  * Manage reentrance of kernel
  * Decrement nested_kernel_entrance_counter
  *
  * We update kernel reentrance counter while registers are freely
  * usable and as we know we won t enter in kernel again (IRQ locked and
  * no SWI can occur)
  *
  * NA: If it reaches 0, the process stack is restored
  * Automatic for the Cortex-M4
  */
  ldr r12, =nested_kernel_entrance_counter
  ldr r4, [r12]
  sub r4, r4, #1
  str r4, [r12]
 
 #if WITH_MEMORY_PROTECTION == YES
 /*
  * Switch to user memory protection scheme
  */
  bl tpl_user_mp
 #endif
tpl_leave_kernel_exit:
 bx lr

%

foreach irq in irqStageList
  before
%

%
  do
    let handlerSource := irq::handlerSource
    let handlerName := irq::handlerName
    let handlerIRQ := INTERRUPTMAP[irq::handlerSource]::VECTOR_TYPE_S::NAME
    if not irq::generatePrimaryIrq then
%
 /******************************************************************************
 * IRQ Handler for ISR % !handlerName % with source vector % !handlerSource %
 *******************************************************************************/
%
      template if exists handler_body
    end if
  after
%
%
end foreach

%
#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

#define OS_START_LTORG
#include "tpl_as_memmap.h"
#define OS_STOP_LTORG
#include "tpl_as_memmap.h"

.end

/* End of file tpl_second_stage_irq.% !EXTENSIONSECONDSTAGE % */
