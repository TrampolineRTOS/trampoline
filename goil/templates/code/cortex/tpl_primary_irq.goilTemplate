%#------------------------------------------------------------------------------*
# Target specific initializations
# build the maps for IRQ
#
let objForIRQ := @[ ]

# Map ISR into objForIRQ
foreach isr in ISR do
  let key := isr::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := @( )
  end if
  let isr::KIND := "ISR"
  let objForIRQ[key] += isr
end foreach

# Map COUNTER into objForIRQ
foreach cnt in COUNTER do
  let key := cnt::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := @( )
  end if
  let cnt::KIND := "COUNTER"
  let objForIRQ[key] += cnt
end foreach

#------------------------------------------------------------------------------*
# ISR1 cannot use the same IRQ as ISR2 or COUNTER.
#
foreach irq in objForIRQ do
  let objISR1 := @()
  let objOther := @()
  # look if the list contains an ISR1
  foreach obj in irq do
    if exists obj::CATEGORY then
      if obj::CATEGORY == 1 then
        let objISR1 += obj
      else
        let objOther += obj
      end if
    end if
  end foreach
  if [objISR1 length] > 0 & [objOther length] > 0 then
    foreach isr1 in objISR1 do
      error isr1::SOURCE : "Cannot use same IRQ for an ISR1 and an ISR2 or COUNTER"
      foreach obj in objOther do
        error obj::SOURCE : "Was used here"
      end foreach
    end foreach
  end if
end foreach

let INTERRUPTMAP := mapof INTERRUPT by NAME

# Build the list of IRQ handlers to call
let irqStageList := @( )

# Build a list of virtual objects (sources of interrupts) each of them holding values :
# handlerSource, handlerName, handlerAck, generatePrimaryIrq
foreach objList in objForIRQ do
  let anIrq::handlerSource := KEY
  let anIrq::handlerName := objList[0]::NAME
  let anIrq::handlerAck := false
  let anIrq::generatePrimaryIrq := false
  foreach obj in objList do
    let anIrq::handlerAck := INTERRUPTMAP[anIrq::handlerSource]::ACK
    if obj::KIND == "ISR" then
      if obj::CATEGORY == 1 then
        let generatePrimaryIrq := true
      end if
    end if
  end foreach
  let irqStageList += anIrq 
end foreach

#------------------------------------------------------------------------------*
%/**
 * @file tpl_primary_irq.% !EXTENSIONSECONDSTAGE %
 *
 * @section descr File description
 *
 * Generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */

.syntax unified
.thumb

#include "tpl_assembler.h"
#include "tpl_asm_definitions.h"
#include "tpl_os_kernel_stack.h"

.equ  NO_NEED_SWITCH_NOR_SCHEDULE, 0
.equ  NO_NEED_SWITCH, 0
.equ  NEED_SWITCH, 1
.equ  NEED_SAVE, 2

#define OS_START_SEC_VAR
#include "tpl_as_memmap.h"

.extern tpl_kern

#define OS_STOP_SEC_VAR
#include "tpl_as_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

/*=============================================================================
 * The interrupt handler assumes the following:
 *
 * The process stack is populated according to the Cortex M standard
 *
 * +------------------+
 * | R0               | <- PSP
 * +------------------+
 * | R1               | <- PSP+4
 * +------------------+
 * | R2               | <- PSP+8
 * +------------------+
 * | R3               | <- PSP+12
 * +------------------+
 * | R12              | <- PSP+16
 * +------------------+
 * | LR               | <- PSP+20
 * +------------------+
 * | Return Address   | <- PSP+24
 * +------------------+
 * | xPSR (bit 9 = 1) | <- PSP+28
 * +------------------+
 *
 */
%

foreach irq in irqStageList
  before
%

%
  do
    let handlerSource := irq::handlerSource
    let handlerName := irq::handlerName
    let handlerIRQ := handlerSource."_Handler"
    if not irq::generatePrimaryIrq then
%
/*=============================================================================
 * IRQ Handler for IRQ % !handlerName % with source vector % !handlerSource %
 ******************************************************************************/
%
      template if exists handler_body
    end if
  after
%
%
end foreach

if OS::TIMINGPROTECTION then
%
/*=============================================================================
 * IRQ Handler for IRQ tpl_primary_irq_handler_timing_protection with source
 * vector TIM2_IRQ
 ******************************************************************************/
%
  let handlerSource := "timing_protection"
  let handlerIRQ := "tpl_timing_protection_isr"
%
.global tpl_primary_irq_handler_% !handlerSource %
.type   tpl_primary_irq_handler_% !handlerSource %, \%function

/*---------------------------------------------------------------------------*/
tpl_primary_irq_handler_% !handlerSource %:

    /*-----------------------------------------------------------------------*
     * Once here the stack has been changed to the master stack.             *
     * So SP is MSP, not PSP                                                 *
     *-----------------------------------------------------------------------*/

    /*-------------------------------------------------------------------------
     * 1 - Save the LR on the stack
     */
    push {lr}

    /*-------------------------------------------------------------------------
     * 2 - Reset the tpl_kern variables
     */
    ldr  r0,=tpl_kern
    movs r1,#NO_NEED_SWITCH_NOR_SCHEDULE
    strb r1,[r0,#TPL_KERN_OFFSET_NEED_SWITCH]
    strb r1,[r0,#TPL_KERN_OFFSET_NEED_SCHEDULE]

    /*-------------------------------------------------------------------------
     * 3 - Interrupt function call
     */
    bl   % !handlerIRQ %

    /*-------------------------------------------------------------------------
     * 4 - Check the context switch condition in tpl_kern
     */
    ldr  r1,=tpl_kern
    ldrb r2,[r1,#TPL_KERN_OFFSET_NEED_SWITCH]
    cmp  r2,#NO_NEED_SWITCH
    beq  tpl_% !handlerSource %_no_context_switch

    /*-------------------------------------------------------------------------
     * 4b - Prepare the call to tpl_run_elected by setting r0 to 0, aka no save
     */
    movs r0,0
    
    /*-------------------------------------------------------------------------
     * 4c - Check the save condition
     */
    movs r3,#NEED_SAVE
    tst  r2,r3
    beq  timing_protection_no_save_running_context
    
    /*-------------------------------------------------------------------------
     * 5 - Save context
     *     Load in r0 the pointer to the static descriptor of the running task
     *     r1 already points to tpl_kern (from stage 4)
     */
    ldr  r0,[r1,#TPL_KERN_OFFSET_S_RUNNING]
    bl   tpl_save_context_under_it

    /*-------------------------------------------------------------------------
     * 5b - Prepare the call to tpl_run_elected by setting r0 to 1, aka save
     */
    movs r0,#1

timing_protection_no_save_running_context:

    /*-------------------------------------------------------------------------
     * 6 - Call tpl_run_elected.
     *     The argument is a boolean which is true if the process is
     *     preempted. Here it is true because in an interrupt handler
     *     a process is inevitably preempted
     */
    bl   tpl_run_elected

    /*-------------------------------------------------------------------------
     * 7 - Load context
     *     Load in r0 the pointer to the context of the running task.
     *     It has been changed by tpl_run_elected
     */
    ldr  r0,=tpl_kern
    ldr  r0,[r0,#TPL_KERN_OFFSET_S_RUNNING]
    bl   tpl_load_context_under_it

tpl_% !handlerSource %_no_context_switch:

    /*-------------------------------------------------------------------------
     * 8 - pop LR that was saved at stage 1 into PC and return from the handler
     */
    pop  {pc}

/*---------------------------------------------------------------------------*/
%
end if

%
#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

.end

/* End of file tpl_second_stage_irq.% !EXTENSIONSECONDSTAGE % */
