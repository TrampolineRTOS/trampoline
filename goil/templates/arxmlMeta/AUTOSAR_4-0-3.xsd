<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://autosar.org/schema/r4.0" xmlns:AR="http://autosar.org/schema/r4.0">
   <xsd:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="xml.xsd"/>
   <!-- 
Document Owner: AUTOSAR
Document Responsibility: AUTOSAR
Document Identification No: 230
Document Classification: Standard
Document Version: 4.2.1
Document Status: Final
Part of Release: 4.0 (Thu Jan 19 00:00:00 CET 2012)
Revision: 3 
-->
   <!--
Disclaimer

This specification and the material contained in it, as released by AUTOSAR, 
is for the purpose of information only. AUTOSAR and the companies that have 
contributed to it shall not be liable for any use of the specification.

The material contained in this specification is protected by copyright and 
other types of Intellectual Property Rights. The commercial exploitation of 
the material contained in this specification requires a license to such 
Intellectual Property Rights.

This specification may be utilized or reproduced without any modification, in 
any form or by any means, for informational purposes only.
For any other purpose, no part of the specification may be utilized or 
reproduced, in any form or by any means, without permission in writing from 
the publisher.

The AUTOSAR specifications have been developed for automotive applications 
only. They have neither been developed, nor tested for non-automotive 
applications.

The word AUTOSAR and the AUTOSAR logo are registered trademarks.



Advice for users

AUTOSAR specifications may contain exemplary items (exemplary reference models,
"use cases", and/or references to exemplary technical solutions, devices, 
processes or software).

Any such exemplary items are contained in the specifications for illustration 
purposes only, and they themselves are not part of the AUTOSAR Standard. 
Neither their presence in such specifications, nor any later documentation of 
AUTOSAR conformance of products actually implementing such exemplary items, 
imply that intellectual property rights covering such exemplary items are 
licensed under the same rules as applicable to the AUTOSAR Standard.

-->
   <!-- element group for class ARPackage::ARElement -->
   <xsd:group name="AR-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>An element that can be defined stand-alone, i.e. without being part of another element (except for packages of course).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ArObject::ARObject -->
   <xsd:group name="AR-OBJECT">
      <xsd:annotation>
         <xsd:documentation>Implicit base class of all classes in meta-model.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARObject"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class ArObject::ARObject -->
   <xsd:attributeGroup name="AR-OBJECT">
      <xsd:annotation>
         <xsd:documentation>Implicit base class of all classes in meta-model.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARObject"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="S" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Checksum calculated from the 
         * attributes
         * aggregations and aggregated non-identifiables
         * references</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="ARObject.checksum";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true";xml.name="S"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="T" type="AR:DATE--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The timestamp of the creation or modification of an instance, its attributes, references or aggregated non-identifiables.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="ARObject.timestamp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true";xml.name="T"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- element group for class ARPackage::ARPackage -->
   <xsd:group name="AR-PACKAGE">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR package, allowing to create top level packages to structure the contained ARElements.

      ARPackages are open sets. This means that in a file based description system multiple files can be used to partially describe the contents of a package.

      This is an extended version of MSR's SW-SYSTEM.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARPackage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFERENCE-BASES">
            <xsd:annotation>
               <xsd:documentation>This denotes the reference bases for the package. This is the basis for all relative references within the package. The base needs to be selected according to the base attribute within the references.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ARPackage.referenceBase";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="REFERENCE-BASE" type="AR:REFERENCE-BASE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>Elements that are part of this package
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="element.ARPackage";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ALIAS-NAME-SET" type="AR:ALIAS-NAME-SET"/>
                  <xsd:element name="APPLICATION-ARRAY-DATA-TYPE" type="AR:APPLICATION-ARRAY-DATA-TYPE"/>
                  <xsd:element name="APPLICATION-PRIMITIVE-DATA-TYPE" type="AR:APPLICATION-PRIMITIVE-DATA-TYPE"/>
                  <xsd:element name="APPLICATION-RECORD-DATA-TYPE" type="AR:APPLICATION-RECORD-DATA-TYPE"/>
                  <xsd:element name="APPLICATION-SW-COMPONENT-TYPE" type="AR:APPLICATION-SW-COMPONENT-TYPE"/>
                  <xsd:element name="BLUEPRINT-MAPPING-SET" type="AR:BLUEPRINT-MAPPING-SET"/>
                  <xsd:element name="BSW-IMPLEMENTATION" type="AR:BSW-IMPLEMENTATION"/>
                  <xsd:element name="BSW-MODULE-DESCRIPTION" type="AR:BSW-MODULE-DESCRIPTION"/>
                  <xsd:element name="BSW-MODULE-ENTRY" type="AR:BSW-MODULE-ENTRY"/>
                  <xsd:element name="BSW-MODULE-TIMING" type="AR:BSW-MODULE-TIMING"/>
                  <xsd:element name="CALIBRATION-PARAMETER-VALUE-SET" type="AR:CALIBRATION-PARAMETER-VALUE-SET"/>
                  <xsd:element name="CAN-CLUSTER" type="AR:CAN-CLUSTER"/>
                  <xsd:element name="CAN-FRAME" type="AR:CAN-FRAME"/>
                  <xsd:element name="CAN-TP-CONFIG" type="AR:CAN-TP-CONFIG"/>
                  <xsd:element name="CLIENT-SERVER-INTERFACE" type="AR:CLIENT-SERVER-INTERFACE"/>
                  <xsd:element name="COLLECTION" type="AR:COLLECTION"/>
                  <xsd:element name="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE" type="AR:COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
                  <xsd:element name="COMPOSITION-SW-COMPONENT-TYPE" type="AR:COMPOSITION-SW-COMPONENT-TYPE"/>
                  <xsd:element name="COMPU-METHOD" type="AR:COMPU-METHOD"/>
                  <xsd:element name="CONSTANT-SPECIFICATION" type="AR:CONSTANT-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-SPECIFICATION-MAPPING-SET" type="AR:CONSTANT-SPECIFICATION-MAPPING-SET"/>
                  <xsd:element name="DATA-CONSTR" type="AR:DATA-CONSTR"/>
                  <xsd:element name="DATA-TYPE-MAPPING-SET" type="AR:DATA-TYPE-MAPPING-SET"/>
                  <xsd:element name="DCM-I-PDU" type="AR:DCM-I-PDU"/>
                  <xsd:element name="DOCUMENTATION" type="AR:DOCUMENTATION"/>
                  <xsd:element name="ECU-ABSTRACTION-SW-COMPONENT-TYPE" type="AR:ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
                  <xsd:element name="ECU-INSTANCE" type="AR:ECU-INSTANCE"/>
                  <xsd:element name="ECU-TIMING" type="AR:ECU-TIMING"/>
                  <xsd:element name="ECUC-DEFINITION-COLLECTION" type="AR:ECUC-DEFINITION-COLLECTION"/>
                  <xsd:element name="ECUC-MODULE-CONFIGURATION-VALUES" type="AR:ECUC-MODULE-CONFIGURATION-VALUES"/>
                  <xsd:element name="ECUC-MODULE-DEF" type="AR:ECUC-MODULE-DEF"/>
                  <xsd:element name="ECUC-VALUE-COLLECTION" type="AR:ECUC-VALUE-COLLECTION"/>
                  <xsd:element name="END-TO-END-PROTECTION-SET" type="AR:END-TO-END-PROTECTION-SET"/>
                  <xsd:element name="ETHERNET-CLUSTER" type="AR:ETHERNET-CLUSTER"/>
                  <xsd:element name="ETHERNET-FRAME" type="AR:ETHERNET-FRAME"/>
                  <xsd:element name="EVALUATED-VARIANT-SET" type="AR:EVALUATED-VARIANT-SET"/>
                  <xsd:element name="FLAT-MAP" type="AR:FLAT-MAP"/>
                  <xsd:element name="FLEXRAY-AR-TP-CONFIG" type="AR:FLEXRAY-AR-TP-CONFIG"/>
                  <xsd:element name="FLEXRAY-CLUSTER" type="AR:FLEXRAY-CLUSTER"/>
                  <xsd:element name="FLEXRAY-FRAME" type="AR:FLEXRAY-FRAME"/>
                  <xsd:element name="FLEXRAY-TP-CONFIG" type="AR:FLEXRAY-TP-CONFIG"/>
                  <xsd:element name="GATEWAY" type="AR:GATEWAY"/>
                  <xsd:element name="HW-CATEGORY" type="AR:HW-CATEGORY"/>
                  <xsd:element name="HW-ELEMENT" type="AR:HW-ELEMENT"/>
                  <xsd:element name="HW-TYPE" type="AR:HW-TYPE"/>
                  <xsd:element name="I-SIGNAL" type="AR:I-SIGNAL"/>
                  <xsd:element name="I-SIGNAL-GROUP" type="AR:I-SIGNAL-GROUP"/>
                  <xsd:element name="I-SIGNAL-I-PDU" type="AR:I-SIGNAL-I-PDU"/>
                  <xsd:element name="I-SIGNAL-I-PDU-GROUP" type="AR:I-SIGNAL-I-PDU-GROUP"/>
                  <xsd:element name="IMPLEMENTATION-DATA-TYPE" type="AR:IMPLEMENTATION-DATA-TYPE"/>
                  <xsd:element name="INTERPOLATION-ROUTINE-MAPPING-SET" type="AR:INTERPOLATION-ROUTINE-MAPPING-SET"/>
                  <xsd:element name="J-1939-TP-CONFIG" type="AR:J-1939-TP-CONFIG"/>
                  <xsd:element name="KEYWORD-SET" type="AR:KEYWORD-SET"/>
                  <xsd:element name="LIN-CLUSTER" type="AR:LIN-CLUSTER"/>
                  <xsd:element name="LIN-EVENT-TRIGGERED-FRAME" type="AR:LIN-EVENT-TRIGGERED-FRAME"/>
                  <xsd:element name="LIN-SPORADIC-FRAME" type="AR:LIN-SPORADIC-FRAME"/>
                  <xsd:element name="LIN-TP-CONFIG" type="AR:LIN-TP-CONFIG"/>
                  <xsd:element name="LIN-UNCONDITIONAL-FRAME" type="AR:LIN-UNCONDITIONAL-FRAME"/>
                  <xsd:element name="MODE-DECLARATION-GROUP" type="AR:MODE-DECLARATION-GROUP"/>
                  <xsd:element name="MODE-SWITCH-INTERFACE" type="AR:MODE-SWITCH-INTERFACE"/>
                  <xsd:element name="MULTIPLEXED-I-PDU" type="AR:MULTIPLEXED-I-PDU"/>
                  <xsd:element name="N-PDU" type="AR:N-PDU"/>
                  <xsd:element name="NM-CONFIG" type="AR:NM-CONFIG"/>
                  <xsd:element name="NM-PDU" type="AR:NM-PDU"/>
                  <xsd:element name="NV-BLOCK-SW-COMPONENT-TYPE" type="AR:NV-BLOCK-SW-COMPONENT-TYPE"/>
                  <xsd:element name="NV-DATA-INTERFACE" type="AR:NV-DATA-INTERFACE"/>
                  <xsd:element name="PARAMETER-INTERFACE" type="AR:PARAMETER-INTERFACE"/>
                  <xsd:element name="PARAMETER-SW-COMPONENT-TYPE" type="AR:PARAMETER-SW-COMPONENT-TYPE"/>
                  <xsd:element name="PDUR-I-PDU-GROUP" type="AR:PDUR-I-PDU-GROUP"/>
                  <xsd:element name="PHYSICAL-DIMENSION" type="AR:PHYSICAL-DIMENSION"/>
                  <xsd:element name="PORT-INTERFACE-MAPPING-SET" type="AR:PORT-INTERFACE-MAPPING-SET"/>
                  <xsd:element name="PORT-PROTOTYPE-BLUEPRINT" type="AR:PORT-PROTOTYPE-BLUEPRINT"/>
                  <xsd:element name="POST-BUILD-VARIANT-CRITERION" type="AR:POST-BUILD-VARIANT-CRITERION"/>
                  <xsd:element name="POST-BUILD-VARIANT-CRITERION-VALUE-SET" type="AR:POST-BUILD-VARIANT-CRITERION-VALUE-SET"/>
                  <xsd:element name="PREDEFINED-VARIANT" type="AR:PREDEFINED-VARIANT"/>
                  <xsd:element name="SENDER-RECEIVER-INTERFACE" type="AR:SENDER-RECEIVER-INTERFACE"/>
                  <xsd:element name="SENSOR-ACTUATOR-SW-COMPONENT-TYPE" type="AR:SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
                  <xsd:element name="SERVICE-PROXY-SW-COMPONENT-TYPE" type="AR:SERVICE-PROXY-SW-COMPONENT-TYPE"/>
                  <xsd:element name="SERVICE-SW-COMPONENT-TYPE" type="AR:SERVICE-SW-COMPONENT-TYPE"/>
                  <xsd:element name="SW-ADDR-METHOD" type="AR:SW-ADDR-METHOD"/>
                  <xsd:element name="SW-AXIS-TYPE" type="AR:SW-AXIS-TYPE"/>
                  <xsd:element name="SW-BASE-TYPE" type="AR:SW-BASE-TYPE"/>
                  <xsd:element name="SW-RECORD-LAYOUT" type="AR:SW-RECORD-LAYOUT"/>
                  <xsd:element name="SW-SYSTEMCONST" type="AR:SW-SYSTEMCONST"/>
                  <xsd:element name="SW-SYSTEMCONSTANT-VALUE-SET" type="AR:SW-SYSTEMCONSTANT-VALUE-SET"/>
                  <xsd:element name="SWC-BSW-MAPPING" type="AR:SWC-BSW-MAPPING"/>
                  <xsd:element name="SWC-IMPLEMENTATION" type="AR:SWC-IMPLEMENTATION"/>
                  <xsd:element name="SWC-TIMING" type="AR:SWC-TIMING"/>
                  <xsd:element name="SYSTEM" type="AR:SYSTEM"/>
                  <xsd:element name="SYSTEM-SIGNAL" type="AR:SYSTEM-SIGNAL"/>
                  <xsd:element name="SYSTEM-SIGNAL-GROUP" type="AR:SYSTEM-SIGNAL-GROUP"/>
                  <xsd:element name="SYSTEM-TIMING" type="AR:SYSTEM-TIMING"/>
                  <xsd:element name="TRIGGER-INTERFACE" type="AR:TRIGGER-INTERFACE"/>
                  <xsd:element name="TTCAN-CLUSTER" type="AR:TTCAN-CLUSTER"/>
                  <xsd:element name="UNIT" type="AR:UNIT"/>
                  <xsd:element name="UNIT-GROUP" type="AR:UNIT-GROUP"/>
                  <xsd:element name="USER-DEFINED-I-PDU" type="AR:USER-DEFINED-I-PDU"/>
                  <xsd:element name="USER-DEFINED-PDU" type="AR:USER-DEFINED-PDU"/>
                  <xsd:element name="VFB-TIMING" type="AR:VFB-TIMING"/>
                  <xsd:element name="XCP-PDU" type="AR:XCP-PDU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-PACKAGES">
            <xsd:annotation>
               <xsd:documentation>This represents a sub package within an ARPackage, thus allowing an unlimited package hierarchy.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="BlueprintDerivationTime";atp.Splitkey="shortName";mmt.qualifiedName="ARPackage.arPackage";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AR-PACKAGE" type="AR:AR-PACKAGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ARPackage::ARPackage -->
   <xsd:complexType abstract="false" mixed="false" name="AR-PACKAGE">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR package, allowing to create top level packages to structure the contained ARElements.

      ARPackages are open sets. This means that in a file based description system multiple files can be used to partially describe the contents of a package.

      This is an extended version of MSR's SW-SYSTEM.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARPackage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:AR-PACKAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="AR-PACKAGE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AR-PACKAGE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class AutosarTopLevelStructure::AUTOSAR -->
   <xsd:group name="AUTOSAR">
      <xsd:annotation>
         <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR";xml.globalElement="true"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADMIN-DATA" type="AR:ADMIN-DATA">
            <xsd:annotation>
               <xsd:documentation>This represents the administrative data of an Autosar file.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR.adminData";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents an introduction on the Autosar file. It is intended for example to rpresent disclaimers and legal notes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-PACKAGES">
            <xsd:annotation>
               <xsd:documentation>This is the top level package in an AUTOSAR model.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="BlueprintDerivationTime";atp.Splitkey="shortName";mmt.qualifiedName="AUTOSAR.arPackage";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AR-PACKAGE" type="AR:AR-PACKAGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AutosarTopLevelStructure::AUTOSAR -->
   <xsd:complexType abstract="false" mixed="false" name="AUTOSAR">
      <xsd:annotation>
         <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR";xml.globalElement="true"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:AUTOSAR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- global element for class AutosarTopLevelStructure::AUTOSAR -->
   <xsd:element name="AUTOSAR" type="AR:AUTOSAR">
      <xsd:annotation>
         <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR";xml.globalElement="true"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
   </xsd:element>
   <!-- element group for class Timing::AbsoluteTolerance -->
   <xsd:group name="ABSOLUTE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbsoluteTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ABSOLUTE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Maximum allowable deviation in duration (in seconds)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AbsoluteTolerance.absolute";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::AbsoluteTolerance -->
   <xsd:complexType abstract="false" mixed="false" name="ABSOLUTE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbsoluteTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TIME-RANGE-TYPE-TOLERANCE"/>
         <xsd:group ref="AR:ABSOLUTE-TOLERANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::AbstractCanCluster -->
   <xsd:group name="ABSTRACT-CAN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>Abstract class that is used to collect the common TtCAN and CAN Cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbstractCanCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class CanTopology::AbstractCanClusterContent -->
   <xsd:group name="ABSTRACT-CAN-CLUSTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class CanTopology::AbstractCanCommunicationConnector -->
   <xsd:group name="ABSTRACT-CAN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>Abstract class that is used to collect the common TtCAN and CAN CommunicationConnector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbstractCanCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class CanTopology::AbstractCanCommunicationController -->
   <xsd:group name="ABSTRACT-CAN-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>Abstract class that is used to collect the common TtCAN and CAN Controller attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbstractCanCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class CanTopology::AbstractCanCommunicationControllerAttributes -->
   <xsd:group name="ABSTRACT-CAN-COMMUNICATION-CONTROLLER-ATTRIBUTES">
      <xsd:annotation>
         <xsd:documentation>For the configuration of the CanController parameters two different approaches can be used:
      1. Providing exact values which are taken by the ECU developer (CanControllerConfiguration).
      2. Providing ranges of values which are taken as requirements and have to be respected by the ECU developer (CanControllerConfigurationRequirements).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbstractCanCommunicationControllerAttributes"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class CanTopology::AbstractCanCommunicationControllerContent -->
   <xsd:group name="ABSTRACT-CAN-COMMUNICATION-CONTROLLER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-CONTROLLER-ATTRIBUTES">
            <xsd:annotation>
               <xsd:documentation>CAN Bit Timing configuration</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="canControllerAttributes.AbstractCanCommunicationController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CAN-CONTROLLER-CONFIGURATION" type="AR:CAN-CONTROLLER-CONFIGURATION"/>
                  <xsd:element name="CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS" type="AR:CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class CanTopology::AbstractCanPhysicalChannel -->
   <xsd:group name="ABSTRACT-CAN-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>Abstract class that is used to collect the common TtCAN and CAN PhysicalChannel attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbstractCanPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class VariantHandling::AbstractNumericalVariationPoint -->
   <xsd:group name="ABSTRACT-NUMERICAL-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This is an abstract NumericalValueVariationPoint. It is introduced to support the case that additional attributes are required for particular purposes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbstractNumericalVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class AdminData::AdminData -->
   <xsd:group name="ADMIN-DATA">
      <xsd:annotation>
         <xsd:documentation>AdminData represents the ability to express administrative information for an element. This administration information is to be treated as metadata such as revision id or state of the file. There are basically four kinds of metadata

      * The language and/or used languages.

      * Revision information covering e.g. revision number, state, release date, changes. Note that this information can be given in general as well as related to a particular company.

      * Document metadata specific for a company</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AdminData"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LANGUAGE" type="AR:L-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute  specifies the master language of the document or the document fragment. The master language is the one in which the document is maintained and from which the other languages are derived from. In particular in case of inconsistencies, the information in the master language is priority.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AdminData.language";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-LANGUAGES" type="AR:MULTI-LANGUAGE-PLAIN-TEXT">
            <xsd:annotation>
               <xsd:documentation>This property specifies the langauges which are provided in the document. Therefore it should only be specified in the top level admin data. For each language provided in the document there is one entry in MultilanguagePlainText. The content of each entry can be used for illustration of the language. The used langauge itself depends on the language attribute in the entry.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AdminData.usedLanguages";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DOC-REVISIONS">
            <xsd:annotation>
               <xsd:documentation>This allows to denote information about the current revision of the object. 
            Note that information about previous revisions can also be logged here. The entries shall be sorted descendent by date in order to reflect the history. Therefore the most recent entry representing the current version is denoted first.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AdminData.docRevision";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="50";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DOC-REVISION" type="AR:DOC-REVISION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SDGS">
            <xsd:annotation>
               <xsd:documentation>This property allows to keep special data which is not represented by the standard model. It can be utilited to keep e.g. tool specific data.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AdminData.sdg";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="60";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SDG" type="AR:SDG"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AdminData::AdminData -->
   <xsd:complexType abstract="false" mixed="false" name="ADMIN-DATA">
      <xsd:annotation>
         <xsd:documentation>AdminData represents the ability to express administrative information for an element. This administration information is to be treated as metadata such as revision id or state of the file. There are basically four kinds of metadata

      * The language and/or used languages.

      * Revision information covering e.g. revision number, state, release date, changes. Note that this information can be given in general as well as related to a particular company.

      * Document metadata specific for a company</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AdminData"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ADMIN-DATA"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class AgeConstraint::AgeConstraint -->
   <xsd:group name="AGE-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>The AgeConstraint is used to impose a constraint on the age of a VariableDataPrototype referenced by the scope.

      A minimum and a maximum age can be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AgeConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum age.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="maximum.AgeConstraint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The minimum age.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="minimum.AgeConstraint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCOPE-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of an AgeConstraint is a TDEventVariableDataPrototype. The constraint is applied to the VariableDataPrototype referenced by this event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AgeConstraint.scope";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TD-EVENT-VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AgeConstraint::AgeConstraint -->
   <xsd:complexType abstract="false" mixed="false" name="AGE-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>The AgeConstraint is used to impose a constraint on the age of a VariableDataPrototype referenced by the scope.

      A minimum and a maximum age can be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AgeConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:AGE-CONSTRAINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class FlatMap::AliasNameAssignment -->
   <xsd:group name="ALIAS-NAME-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to associate an alternative name to a flat representations or an Identifiable.

      The usage of this name is defined outside of AUTOSAR. For example this name can be used by MCD tools or as a name for component instances in the ECU extract.

      Note that flatInstance and identifiable are mutually exclusive.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AliasNameAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute represents the alias name. It is modeled as string because the alias name is used outside of AUTOSAR and therefore no naming conventions can be applied within AUTOSAR.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AliasNameAssignment.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LABEL" type="AR:MULTILANGUAGE-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This represents an "Alias LongName".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AliasNameAssignment.label";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IDENTIFIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>Assignment of a unique name to an Identifiable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AliasNameAssignment.identifiable";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IDENTIFIABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLAT-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Assignment of a unique name to a flat representation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AliasNameAssignment.flatInstance";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLAT-INSTANCE-DESCRIPTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlatMap::AliasNameAssignment -->
   <xsd:complexType abstract="false" mixed="false" name="ALIAS-NAME-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to associate an alternative name to a flat representations or an Identifiable.

      The usage of this name is defined outside of AUTOSAR. For example this name can be used by MCD tools or as a name for component instances in the ECU extract.

      Note that flatInstance and identifiable are mutually exclusive.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AliasNameAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ALIAS-NAME-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlatMap::AliasNameSet -->
   <xsd:group name="ALIAS-NAME-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a set of AliasNames. The AliasNameSet can for example be an input to the A2L-Generator. It shall not be used by the RTE generator to generate the MC-Support.

      In a given instance of AliasNameSet in the bound system there must be at most one aliasName per FlatInstanceDescriptor.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="AliasNameSets";mmt.qualifiedName="AliasNameSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALIAS-NAMES">
            <xsd:annotation>
               <xsd:documentation>AliasNames contained in the AliasNameSet.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortLabel";mmt.qualifiedName="AliasNameSet.aliasName";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ALIAS-NAME-ASSIGNMENT" type="AR:ALIAS-NAME-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlatMap::AliasNameSet -->
   <xsd:complexType abstract="false" mixed="false" name="ALIAS-NAME-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a set of AliasNames. The AliasNameSet can for example be an input to the A2L-Generator. It shall not be used by the RTE generator to generate the MC-Support.

      In a given instance of AliasNameSet in the bound system there must be at most one aliasName per FlatInstanceDescriptor.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="AliasNameSets";mmt.qualifiedName="AliasNameSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ALIAS-NAME-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::AnalyzedExecutionTime -->
   <xsd:group name="ANALYZED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>AnalyzedExecutionTime provides an analytic method for specifying the best and worst case execution time.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AnalyzedExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BEST-CASE-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The best case execution time (BCET) defines the minimum amount of time the related executable entity requires for its execution.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalyzedExecutionTime.bestCaseExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WORST-CASE-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The worst case execution time (WCET) defines the maximum amount of time the related executable entity requires for its execution.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalyzedExecutionTime.worstCaseExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::AnalyzedExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="ANALYZED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>AnalyzedExecutionTime provides an analytic method for specifying the best and worst case execution time.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AnalyzedExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
         <xsd:group ref="AR:ANALYZED-EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Annotation::Annotation -->
   <xsd:group name="ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>This is a plain annotation which does not have further formal data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Annotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class Annotation::Annotation -->
   <xsd:complexType abstract="false" mixed="false" name="ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>This is a plain annotation which does not have further formal data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Annotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class AnyInstanceRef::AnyInstanceRef -->
   <xsd:group name="ANY-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>Describes a reference to any instance in an AUTOSAR model. This is the most generic form of an instance ref. Refer to the superclass notes for more details.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AnyInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>This is one step in the navigation path specified by the instance ref.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnyInstanceRef.contextElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ATP-FEATURE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REF">
            <xsd:annotation>
               <xsd:documentation>This is the target of the instance ref.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnyInstanceRef.target";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ATP-FEATURE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AnyInstanceRef::AnyInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="ANY-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>Describes a reference to any instance in an AUTOSAR model. This is the most generic form of an instance ref. Refer to the superclass notes for more details.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AnyInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:ANY-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::ApplicationArrayDataType -->
   <xsd:group name="APPLICATION-ARRAY-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>An application data type which is an array, each element is of the same application data type.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ApplicationDataTypes";mmt.qualifiedName="ApplicationArrayDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENT" type="AR:APPLICATION-ARRAY-ELEMENT">
            <xsd:annotation>
               <xsd:documentation>This association implements the concept of an array element. That is, in some cases it is necessary to be able to identify single array elements, e.g. as input values for an interpolation routine.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationArrayDataType.element";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::ApplicationArrayDataType -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-ARRAY-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>An application data type which is an array, each element is of the same application data type.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ApplicationDataTypes";mmt.qualifiedName="ApplicationArrayDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:AUTOSAR-DATA-TYPE"/>
         <xsd:group ref="AR:APPLICATION-DATA-TYPE"/>
         <xsd:group ref="AR:APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:group ref="AR:APPLICATION-ARRAY-DATA-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataPrototypes::ApplicationArrayElement -->
   <xsd:group name="APPLICATION-ARRAY-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Describes the properties of the elements of an application array data type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationArrayElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-SIZE-SEMANTICS" type="AR:ARRAY-SIZE-SEMANTICS-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls how the information about the array size shall be interpreted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationArrayElement.arraySizeSemantics";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-ELEMENTS" type="AR:POSITIVE-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>The maximum number of elements that the array can contain.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ApplicationArrayElement.maxNumberOfElements";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataPrototypes::ApplicationArrayElement -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-ARRAY-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Describes the properties of the elements of an application array data type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationArrayElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE"/>
         <xsd:group ref="AR:APPLICATION-ARRAY-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="APPLICATION-ARRAY-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-ELEMENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Datatypes::ApplicationCompositeDataType -->
   <xsd:group name="APPLICATION-COMPOSITE-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>Abstract base class for all application data types composed of other data types.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class PortInterface::ApplicationCompositeDataTypeSubElementRef -->
   <xsd:group name="APPLICATION-COMPOSITE-DATA-TYPE-SUB-ELEMENT-REF">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the specialization of SubElementMapping with respect to ApplicationCompositeDataTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeDataTypeSubElementRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPLICATION-COMPOSITE-ELEMENT-IREF" type="AR:APPLICATION-COMPOSITE-ELEMENT-IN-PORT-INTERFACE-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the referenced ApplicationCompositeDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeDataTypeSubElementRef.applicationCompositeElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ApplicationCompositeDataTypeSubElementRef -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-COMPOSITE-DATA-TYPE-SUB-ELEMENT-REF">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the specialization of SubElementMapping with respect to ApplicationCompositeDataTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeDataTypeSubElementRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SUB-ELEMENT-REF"/>
         <xsd:group ref="AR:APPLICATION-COMPOSITE-DATA-TYPE-SUB-ELEMENT-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataPrototypes::ApplicationCompositeElementDataPrototype -->
   <xsd:group name="APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>This class represents a data prototype which is aggregated within a composite application data type (record or array). It is introduced to provide a better distinction between target and context in instanceRefs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeElementDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-TREF">
            <xsd:annotation>
               <xsd:documentation>This represents the corresponding data type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeElementDataPrototype.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-ELEMENT"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-ELEMENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InstanceRefs::ApplicationCompositeElementInPortInterfaceInstanceRef -->
   <xsd:group name="APPLICATION-COMPOSITE-ELEMENT-IN-PORT-INTERFACE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeElementInPortInterfaceInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROOT-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This refers to the dataPrototype which is typed by theApplicationDatatype in which which the target can be found.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeElementInPortInterfaceInstanceRef.rootDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:AUTOSAR-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents a context ApplicationCompositeDataPrototype</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeElementInPortInterfaceInstanceRef.contextDataPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the referenced ApplicationCompositeDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeElementInPortInterfaceInstanceRef.targetDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::ApplicationCompositeElementInPortInterfaceInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-COMPOSITE-ELEMENT-IN-PORT-INTERFACE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationCompositeElementInPortInterfaceInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:APPLICATION-COMPOSITE-ELEMENT-IN-PORT-INTERFACE-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::ApplicationDataType -->
   <xsd:group name="APPLICATION-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>ApplicationDataType defines a data type from the application point of view. Especially it should be used whenever something "physical" is at stake. An ApplicationDataType represents a set of values as seen in the application model, such as measurement units. It does not consider implementation details such as bit-size, endianess, etc.

      It should be possible to model the application level aspects of a VFB system by using ApplicationDataTypes only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="APPLICATION-DATA-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinCommunication::ApplicationEntry -->
   <xsd:group name="APPLICATION-ENTRY">
      <xsd:annotation>
         <xsd:documentation>There are three types of frames defined in LIN, i.e. unconditional frame, event triggered frame and sporadic frame. The ApplicationEntry refers to a frame that will be transfered in the frame slot.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:documentation>Specifies the LinFrame that will be transmitted in this frame slot.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationEntry.frameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::ApplicationEntry -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-ENTRY">
      <xsd:annotation>
         <xsd:documentation>There are three types of frames defined in LIN, i.e. unconditional frame, event triggered frame and sporadic frame. The ApplicationEntry refers to a frame that will be transfered in the frame slot.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:APPLICATION-ENTRY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ApplicationError -->
   <xsd:group name="APPLICATION-ERROR">
      <xsd:annotation>
         <xsd:documentation>This is a user-defined error that is associated with an element of an AUTOSAR interface. It is specific for the particular functionality or service provided by the AUTOSAR software component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationError"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ERROR-CODE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The RTE generator is forced to assign this value to the corresponding error symbol. Note that for error codes certain ranges are predefined (see RTE specification).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationError.errorCode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ApplicationError -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-ERROR">
      <xsd:annotation>
         <xsd:documentation>This is a user-defined error that is associated with an element of an AUTOSAR interface. It is specific for the particular functionality or service provided by the AUTOSAR software component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationError"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:APPLICATION-ERROR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="APPLICATION-ERROR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ERROR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataMapping::ApplicationErrorMapping -->
   <xsd:group name="APPLICATION-ERROR-MAPPING">
      <xsd:annotation>
         <xsd:documentation>In client server communication, the server may return any value within the application error range.

      The ApplicationError is mapped to the responseGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationErrorMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the SystemSignal with the ApplicationError.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationErrorMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ApplicationErrorMapping -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-ERROR-MAPPING">
      <xsd:annotation>
         <xsd:documentation>In client server communication, the server may return any value within the application error range.

      The ApplicationError is mapped to the responseGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationErrorMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:APPLICATION-ERROR-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::ApplicationPrimitiveDataType -->
   <xsd:group name="APPLICATION-PRIMITIVE-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>A primitive datatype defines a set of allowed values.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ApplicationDataTypes";mmt.qualifiedName="ApplicationPrimitiveDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class Datatypes::ApplicationPrimitiveDataType -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-PRIMITIVE-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>A primitive datatype defines a set of allowed values.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ApplicationDataTypes";mmt.qualifiedName="ApplicationPrimitiveDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:AUTOSAR-DATA-TYPE"/>
         <xsd:group ref="AR:APPLICATION-DATA-TYPE"/>
         <xsd:group ref="AR:APPLICATION-PRIMITIVE-DATA-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="APPLICATION-PRIMITIVE-DATA-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Datatypes::ApplicationRecordDataType -->
   <xsd:group name="APPLICATION-RECORD-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>An application data type which can be decomposed into prototypes of other application data types.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ApplicationDataTypes";mmt.qualifiedName="ApplicationRecordDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>Specifies an element of a record.

            The aggregation of ApplicationRecordElement is subject to variability with the purpose to support the conditional existence of elements inside a ApplicationrecordDataType.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="element.ApplicationRecordDataType";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-RECORD-ELEMENT" type="AR:APPLICATION-RECORD-ELEMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::ApplicationRecordDataType -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-RECORD-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>An application data type which can be decomposed into prototypes of other application data types.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ApplicationDataTypes";mmt.qualifiedName="ApplicationRecordDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:AUTOSAR-DATA-TYPE"/>
         <xsd:group ref="AR:APPLICATION-DATA-TYPE"/>
         <xsd:group ref="AR:APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:group ref="AR:APPLICATION-RECORD-DATA-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataPrototypes::ApplicationRecordElement -->
   <xsd:group name="APPLICATION-RECORD-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Describes the properties of one particular element of an application record data type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationRecordElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataPrototypes::ApplicationRecordElement -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-RECORD-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Describes the properties of one particular element of an application record data type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationRecordElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE"/>
         <xsd:group ref="AR:APPLICATION-RECORD-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="APPLICATION-RECORD-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-RECORD-ELEMENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Components::ApplicationSwComponentType -->
   <xsd:group name="APPLICATION-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ApplicationSwComponentType is used to represent the application software.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ApplicationSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class Components::ApplicationSwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ApplicationSwComponentType is used to represent the application software.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ApplicationSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:APPLICATION-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Constants::ApplicationValueSpecification -->
   <xsd:group name="APPLICATION-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents values for DataPrototypes typed by ApplicationDataTypes (this includes in particular compound primitives). 

      For further details refer to ASAM CDF 2.0. This meta-class corresponds to some extent with SW-INSTANCE in ASAM CDF 2.0.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Specifies to which category of ApplicationDataType this ApplicationValueSpecification can be applied (e.g. as an initial value), thus imposing constraints on the structure and semantics of the contained values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationValueSpecification.category";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-CONTS">
            <xsd:annotation>
               <xsd:documentation>This represents the axis values of a compound primitive (curve or map)
            The first swAxisCont describes the x-axis, the second the y-axis, the third the z-axis. In addition to this, the axis can be denoted in swAxisIndex.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationValueSpecification.swAxisCont";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-AXIS-CONT" type="AR:SW-AXIS-CONT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VALUE-CONT" type="AR:SW-VALUE-CONT">
            <xsd:annotation>
               <xsd:documentation>This represents the values of a compoundPrimitive.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationValueSpecification.SwValueCont";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ApplicationValueSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents values for DataPrototypes typed by ApplicationDataTypes (this includes in particular compound primitives). 

      For further details refer to ASAM CDF 2.0. This meta-class corresponds to some extent with SW-INSTANCE in ASAM CDF 2.0.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-SPECIFICATION"/>
         <xsd:group ref="AR:APPLICATION-VALUE-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataElements::ArVariableInImplementationDataInstanceRef -->
   <xsd:group name="AR-VARIABLE-IN-IMPLEMENTATION-DATA-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to navigate into a data element inside of an VariableDataPrototype which is typed  by an ImplementationDatatype.

      Note that it shall not be used if the target is the VariableDataPrototype itself (e.g. if its a primitive).

      Note that this class follows the pattern of an InstanceRef but is not implemented based on the abstract classes because the ImplementationDataType isn't either, especially because ImplementationDataTypeElement isn't derived from AtpPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArVariableInImplementationDataInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the port providing/receiving the root of the variable</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArVariableInImplementationDataInstanceRef.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROOT-VARIABLE-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This refers to the variableDataPrototype which is typed by the implementationDatatype in which which the target can be found.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArVariableInImplementationDataInstanceRef.rootVariableDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-DATA-PROTOTYPE-REFS">
            <xsd:annotation>
               <xsd:documentation>This is a context in case there are subelements with explicit types. The reference has to be ordered to properly reflect the nested structure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArVariableInImplementationDataInstanceRef.contextDataPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONTEXT-DATA-PROTOTYPE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is a context in case there are subelements with explicit types.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArVariableInImplementationDataInstanceRef.targetDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::ArVariableInImplementationDataInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="AR-VARIABLE-IN-IMPLEMENTATION-DATA-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to navigate into a data element inside of an VariableDataPrototype which is typed  by an ImplementationDatatype.

      Note that it shall not be used if the target is the VariableDataPrototype itself (e.g. if its a primitive).

      Note that this class follows the pattern of an InstanceRef but is not implemented based on the abstract classes because the ImplementationDataType isn't either, especially because ImplementationDataTypeElement isn't derived from AtpPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArVariableInImplementationDataInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:AR-VARIABLE-IN-IMPLEMENTATION-DATA-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EventTriggeringConstraint::ArbitraryEventTriggering -->
   <xsd:group name="ARBITRARY-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The ArbitraryEventTriggering describes that an event occurs occasionally, singly, irregularly or randomly.

      The primary purpose of this event triggering is to abstract event occurrences captured by data acquisition tools (background debugger, trace analyzer, etc.) during system runtime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArbitraryEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-DISTANCES">
            <xsd:annotation>
               <xsd:documentation>The nth array element describes the minimum distance that can be observed for a sample of n+1 event occurrences.

            This is an array with an identical number of elements as for the maximumDistance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArbitraryEventTriggering.minimumDistance";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.name="TIME-VALUE";xml.roleElement="true";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TIME-VALUE" type="AR:MULTIDIMENSIONAL-TIME"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-DISTANCES">
            <xsd:annotation>
               <xsd:documentation>The nth array element describes the maximum distance that can be observed for a sample of n+1 event occurrences.

            This is an array with an identical number of elements as for the minimumDistance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArbitraryEventTriggering.maximumDistance";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.name="TIME-VALUE";xml.roleElement="true";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TIME-VALUE" type="AR:MULTIDIMENSIONAL-TIME"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIDENCE-INTERVALS">
            <xsd:annotation>
               <xsd:documentation>List of confidence intervals.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArbitraryEventTriggering.confidenceInterval";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONFIDENCE-INTERVAL" type="AR:CONFIDENCE-INTERVAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EventTriggeringConstraint::ArbitraryEventTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="ARBITRARY-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The ArbitraryEventTriggering describes that an event occurs occasionally, singly, irregularly or randomly.

      The primary purpose of this event triggering is to abstract event occurrences captured by data acquisition tools (background debugger, trace analyzer, etc.) during system runtime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArbitraryEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:EVENT-TRIGGERING-CONSTRAINT"/>
         <xsd:group ref="AR:ARBITRARY-EVENT-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Figure::Area -->
   <xsd:group name="AREA">
      <xsd:annotation>
         <xsd:documentation>This element specifies a region in an image map. Image maps enable authors to specify regions in an object (e.g. a graphic) and to assign a specific activity to each region (e.g. load a document, launch a program etc.).

      For more details refer to the specification of HTML.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Area"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class Figure::Area -->
   <xsd:attributeGroup name="AREA">
      <xsd:annotation>
         <xsd:documentation>This element specifies a region in an image map. Image maps enable authors to specify regions in an object (e.g. a graphic) and to assign a specific activity to each region (e.g. load a document, launch a program etc.).

      For more details refer to the specification of HTML.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Area"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ACCESSKEY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute assigns an access key to an element.
         An access key is an individual character (e.g. "B") within the document character
         range. If an access key with an element assigned to it is pressed, the element comes
         into focus. The activity performed when an element comes into focus, is dependent on
         the element itself</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.accesskey";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ALT" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute specifies the text to be inserted as an alternative to illustrations, shapes or applets, where these
         cannot be displayed by user agents.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.alt";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="CLASS" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Blank separated list of classes</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.class";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COORDS" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute specifies the position and shape on the screen.
         The number of values and their order depend on the geometrical figure defined.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.coords";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HREF" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute specifies the memory location of a web resource. It is therefore able to specify a link between the current element and the target element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.href";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="NOHREF" type="AR:AREA-ENUM-NOHREF--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>If this attribute is set, the Area has no associated link.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.nohref";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONBLUR" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONBLUR-Event occurs, when focus is switched away from an element. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onblur";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONCLICK" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONCLICK-Event occurs, if the current element is clicked-on. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onclick";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONDBLCLICK" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONCLICK-Event occurs, if the current element is "double" clicked-on. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.ondblclick";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONFOCUS" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONFOCUS-Event occurs, if an element comes into focus (e.g., through navigation using the tab button). 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onfocus";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONKEYDOWN" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONKEYDOWN-Event occurs, if a button on the current element is pressed down. 

         A script can be stored in this attribute to be performed in the event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onkeydown";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONKEYPRESS" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONKEYPRESS-Event occurs, if a button on the current element is pressed down and released. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onkeypress";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONKEYUP" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONKEYUP-Event occurs, if a button on the current element is released. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onkeyup";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEDOWN" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEDOWN-Event occurs, if the mouse button used for clicking is held down on the current element. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onmousedown";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEMOVE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEMOVE-Event occurs, if the mouse pointer is moved on the current 
         element (i.e. it is located on the current element). 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onmousemove";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEOUT" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEOUT-Event occurs, if the mouse pointer is moved from the current element.

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onmouseout";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEOVER" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEOVER-Event occurs, if the mouse pointer is moved to the current element
         from another location outside it. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onmouseover";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEUP" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEUP-Event occurs if the mouse button used for clicking is released on the
         current element. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.onmouseup";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHAPE" type="AR:AREA-ENUM-SHAPE--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The shape of the area. Note that in HTML this is defaulted to RECT.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.shape";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="STYLE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Information on the associated style</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.style";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="TABINDEX" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute specifies the position of the current element in tabbing-order for the corresponding document.

         The value must lie between 0 and 32767. The Tabbing Order defines the sequence in which elements are focused on, when the user navigates using the keyboard.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.tabindex";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="TITLE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Title information of the Area element</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Area.title";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Figure::Area -->
   <xsd:complexType abstract="false" mixed="false" name="AREA">
      <xsd:annotation>
         <xsd:documentation>This element specifies a region in an image map. Image maps enable authors to specify regions in an object (e.g. a graphic) and to assign a specific activity to each region (e.g. load a document, launch a program etc.).

      For more details refer to the specification of HTML.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Area"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:AREA"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:AREA"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ArgumentDataPrototype -->
   <xsd:group name="ARGUMENT-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>An argument of an operation, much like a data element, but also carries direction information and is associated with a particular operation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECTION" type="AR:ARGUMENT-DIRECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the direction of the argument prototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentDataPrototype.direction";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVER-ARGUMENT-IMPL-POLICY" type="AR:SERVER-ARGUMENT-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This defines how the argument type of the servers RunnableEntity is implemented.  

            If the attribute is not defined this has the same semantic as if the attribute is set to useArgumentType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentDataPrototype.serverArgumentImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ArgumentDataPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="ARGUMENT-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>An argument of an operation, much like a data element, but also carries direction information and is associated with a particular operation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:group ref="AR:ARGUMENT-DATA-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ARGUMENT-DATA-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ARGUMENT-DATA-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Constants::ArrayValueSpecification -->
   <xsd:group name="ARRAY-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specifies the values for an array.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArrayValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>The value for a single array element. All ValueSpecifications aggregated by ArrayValueSpecification must have the same structure.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ArrayValueSpecification.element";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ArrayValueSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="ARRAY-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specifies the values for an array.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArrayValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-SPECIFICATION"/>
         <xsd:group ref="AR:ARRAY-VALUE-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Composition::AssemblySwConnector -->
   <xsd:group name="ASSEMBLY-SW-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>AssemblySwConnectors are exclusively used to connect SwComponentPrototypes in the context of a CompositionSwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblySwConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDER-IREF" type="AR:P-PORT-IN-COMPOSITION-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Instance of providing port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssemblySwConnector.provider";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUESTER-IREF" type="AR:R-PORT-IN-COMPOSITION-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Instance of requiring port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssemblySwConnector.requester";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::AssemblySwConnector -->
   <xsd:complexType abstract="false" mixed="false" name="ASSEMBLY-SW-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>AssemblySwConnectors are exclusively used to connect SwComponentPrototypes in the context of a CompositionSwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblySwConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:SW-CONNECTOR"/>
         <xsd:group ref="AR:ASSEMBLY-SW-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::AssignFrameId -->
   <xsd:group name="ASSIGN-FRAME-ID">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an  Assign Frame Id master request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameId"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-FRAME-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:documentation>The frame whose identifier is set by this assignment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameId.assignedFrameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::AssignFrameId -->
   <xsd:complexType abstract="false" mixed="false" name="ASSIGN-FRAME-ID">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an  Assign Frame Id master request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameId"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:LIN-CONFIGURATION-ENTRY"/>
         <xsd:group ref="AR:ASSIGN-FRAME-ID"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::AssignFrameIdRange -->
   <xsd:group name="ASSIGN-FRAME-ID-RANGE">
      <xsd:annotation>
         <xsd:documentation>AssignFrameIdRange generates an assign frame PID range request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameIdRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-PIDS">
            <xsd:annotation>
               <xsd:documentation>Optional assignment of frame_PID values that are included in the request. The frame_PIDs are ordered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="framePid.AssignFrameIdRange";pureMM.maxOccurs="4";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="4" minOccurs="0">
                  <xsd:element name="FRAME-PID" type="AR:FRAME-PID"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="START-INDEX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The startIndex sets the index to the first frame to assign a PID.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameIdRange.startIndex";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::AssignFrameIdRange -->
   <xsd:complexType abstract="false" mixed="false" name="ASSIGN-FRAME-ID-RANGE">
      <xsd:annotation>
         <xsd:documentation>AssignFrameIdRange generates an assign frame PID range request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameIdRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:LIN-CONFIGURATION-ENTRY"/>
         <xsd:group ref="AR:ASSIGN-FRAME-ID-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::AssignNad -->
   <xsd:group name="ASSIGN-NAD">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an Assign NAD master request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignNad"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NEW-NAD" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The newly assigned NAD value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssignNad.newNad";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::AssignNad -->
   <xsd:complexType abstract="false" mixed="false" name="ASSIGN-NAD">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an Assign NAD master request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignNad"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:LIN-CONFIGURATION-ENTRY"/>
         <xsd:group ref="AR:ASSIGN-NAD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServerCall::AsynchronousServerCallPoint -->
   <xsd:group name="ASYNCHRONOUS-SERVER-CALL-POINT">
      <xsd:annotation>
         <xsd:documentation>An AsynchronousServerCallPoint is used for asynchronous invocation of a ClientServerOperation.
      IMPORTANT: a ServerCallPoint cannot be used concurrently. Once the client RunnableEntity has made the invocation, the ServerCallPoint cannot be used until the call returns (or an error occurs!) at which point the ServerCallPoint becomes available again.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServerCall::AsynchronousServerCallPoint -->
   <xsd:complexType abstract="false" mixed="false" name="ASYNCHRONOUS-SERVER-CALL-POINT">
      <xsd:annotation>
         <xsd:documentation>An AsynchronousServerCallPoint is used for asynchronous invocation of a ClientServerOperation.
      IMPORTANT: a ServerCallPoint cannot be used concurrently. Once the client RunnableEntity has made the invocation, the ServerCallPoint cannot be used until the call returns (or an error occurs!) at which point the ServerCallPoint becomes available again.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVER-CALL-POINT"/>
         <xsd:group ref="AR:ASYNCHRONOUS-SERVER-CALL-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ASYNCHRONOUS-SERVER-CALL-POINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-POINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ServerCall::AsynchronousServerCallResultPoint -->
   <xsd:group name="ASYNCHRONOUS-SERVER-CALL-RESULT-POINT">
      <xsd:annotation>
         <xsd:documentation>If a RunnableEntity owns a AsynchronousServerCallResultPoint it is entitled to get the result of the referenced AsynchronousServerCallPoint.
      If it is associated with AsynchronousServerCallReturnsEvent, this RTEEvent notifies the completion of the required ClientServerOperation or a timeout. The occurrence of this event can either unblock a WaitPoint or can lead to the invocation of a RunnableEntity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallResultPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASYNCHRONOUS-SERVER-CALL-POINT-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced Asynchronous Server Call Point defines the asynchronous server call from which the results are returned.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallResultPoint.asynchronousServerCallPoint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ASYNCHRONOUS-SERVER-CALL-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServerCall::AsynchronousServerCallResultPoint -->
   <xsd:complexType abstract="false" mixed="false" name="ASYNCHRONOUS-SERVER-CALL-RESULT-POINT">
      <xsd:annotation>
         <xsd:documentation>If a RunnableEntity owns a AsynchronousServerCallResultPoint it is entitled to get the result of the referenced AsynchronousServerCallPoint.
      If it is associated with AsynchronousServerCallReturnsEvent, this RTEEvent notifies the completion of the required ClientServerOperation or a timeout. The occurrence of this event can either unblock a WaitPoint or can lead to the invocation of a RunnableEntity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallResultPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ASYNCHRONOUS-SERVER-CALL-RESULT-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ASYNCHRONOUS-SERVER-CALL-RESULT-POINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RESULT-POINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RTEEvents::AsynchronousServerCallReturnsEvent -->
   <xsd:group name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised when an asynchronous server call is finished.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallReturnsEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced AsynchronousServerCallResultPoint which is raises the RTEEvent in case of returning asynchronous server call.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="event.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ASYNCHRONOUS-SERVER-CALL-RESULT-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::AsynchronousServerCallReturnsEvent -->
   <xsd:complexType abstract="false" mixed="false" name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised when an asynchronous server call is finished.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallReturnsEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Components::AtomicSwComponentType -->
   <xsd:group name="ATOMIC-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>An atomic software component is atomic in the sense that it cannot be further decomposed and distributed across multiple ECUs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtomicSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERNAL-BEHAVIORS">
            <xsd:annotation>
               <xsd:documentation>The SwcInternalBehaviors owned by an AtomicSwComponentType can be located in a different physical file. Therefore the aggregation is &lt;&lt;atpSplitable&gt;&gt;.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="internalBehavior, variationPoint.shortLabel";mmt.qualifiedName="AtomicSwComponentType.internalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-INTERNAL-BEHAVIOR" type="AR:SWC-INTERNAL-BEHAVIOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL-PROPS" type="AR:SYMBOL-PROPS">
            <xsd:annotation>
               <xsd:documentation>This represents the SymbolProps for the AtomicSwComponentType.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Splitkey="shortName";mmt.qualifiedName="AtomicSwComponentType.symbolProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="ATOMIC-SW-COMPONENT-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class AbstractBlueprintStructure::AtpBlueprint -->
   <xsd:group name="ATP-BLUEPRINT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to act as a Blueprint. As this class is an abstract one, particular blueprint meta-classes inherit from this one.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpBlueprint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-NAME-PATTERN" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute represents the pattern which shall be used to build the shortName of the derived elements. As of now it is modeled as a String.  In general it should follow the pattern:

              pattern = (placeholder | namePart)*
              placeholder = "{" namePart "}"
              namePart = identifier | "_"

            This is subject to be refined in subsequent versions.

            Note that this is marked as obsolete. Use the xml attribute namePattern instead as it applies to Identifer and CIdentifer (shortName, symbol etc.)</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="AtpBlueprint.shortNamePattern";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="ATP-BLUEPRINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AR-PACKAGE"/>
         <xsd:enumeration value="ALIAS-NAME-SET"/>
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATP-BLUEPRINT"/>
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
         <xsd:enumeration value="BSW-MODULE-ENTRY"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPU-METHOD"/>
         <xsd:enumeration value="DATA-CONSTR"/>
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="DATA-TYPE-MAPPING-SET"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECUC-DEFINITION-COLLECTION"/>
         <xsd:enumeration value="ECUC-MODULE-DEF"/>
         <xsd:enumeration value="FLAT-MAP"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
         <xsd:enumeration value="MODE-SWITCH-INTERFACE"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="PORT-INTERFACE"/>
         <xsd:enumeration value="PORT-PROTOTYPE-BLUEPRINT"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-BASE-TYPE"/>
         <xsd:enumeration value="SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="TRIGGER-INTERFACE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class AbstractBlueprintStructure::AtpBlueprintMapping -->
   <xsd:group name="ATP-BLUEPRINT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a particular mapping between a blueprint and an element derived from this blueprint.

      Particular mappings are defined by specializations of this meta-class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpBlueprintMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>atpBlueprint skipped -->
         <!-- Association <<atpDerived>>atpBlueprintedElement skipped -->
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class AbstractBlueprintStructure::AtpBlueprintable -->
   <xsd:group name="ATP-BLUEPRINTABLE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to be derived from a Blueprint. As this class is an abstract one, particular blueprintable meta-classes inherit from this one.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpBlueprintable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="ATP-BLUEPRINTABLE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AR-PACKAGE"/>
         <xsd:enumeration value="ALIAS-NAME-SET"/>
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATP-BLUEPRINTABLE"/>
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
         <xsd:enumeration value="BSW-MODULE-ENTRY"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPU-METHOD"/>
         <xsd:enumeration value="DATA-CONSTR"/>
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="DATA-TYPE-MAPPING-SET"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECUC-DEFINITION-COLLECTION"/>
         <xsd:enumeration value="ECUC-MODULE-DEF"/>
         <xsd:enumeration value="FLAT-MAP"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
         <xsd:enumeration value="MODE-SWITCH-INTERFACE"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="PORT-INTERFACE"/>
         <xsd:enumeration value="PORT-PROTOTYPE"/>
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-BASE-TYPE"/>
         <xsd:enumeration value="SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="TRIGGER-INTERFACE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class AbstractStructure::AtpClassifier -->
   <xsd:group name="ATP-CLASSIFIER">
      <xsd:annotation>
         <xsd:documentation>A classifier classifies M0 instances according to their features. Or: a classifier is something that has instances - an M1 classifier has M0 instances.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpClassifier"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>atpFeature skipped -->
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="ATP-CLASSIFIER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ASSEMBLY-SW-CONNECTOR"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATP-CLASSIFIER"/>
         <xsd:enumeration value="ATP-STRUCTURE-ELEMENT"/>
         <xsd:enumeration value="ATP-TYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-TYPE"/>
         <xsd:enumeration value="BACKGROUND-EVENT"/>
         <xsd:enumeration value="BSW-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="CLIENT-SERVER-OPERATION"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="DATA-RECEIVE-ERROR-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVED-EVENT"/>
         <xsd:enumeration value="DATA-SEND-COMPLETED-EVENT"/>
         <xsd:enumeration value="DATA-WRITE-COMPLETED-EVENT"/>
         <xsd:enumeration value="DELEGATION-SW-CONNECTOR"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
         <xsd:enumeration value="INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="INTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="MODE-DECLARATION"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
         <xsd:enumeration value="MODE-SWITCH-INTERFACE"/>
         <xsd:enumeration value="MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="OPERATION-INVOKED-EVENT"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="PER-INSTANCE-MEMORY"/>
         <xsd:enumeration value="PORT-GROUP"/>
         <xsd:enumeration value="PORT-INTERFACE"/>
         <xsd:enumeration value="PORT-PROTOTYPE-BLUEPRINT"/>
         <xsd:enumeration value="RTE-EVENT"/>
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-CONNECTOR"/>
         <xsd:enumeration value="SWC-BSW-MAPPING"/>
         <xsd:enumeration value="SWC-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="SWC-MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="SWC-SERVICE-DEPENDENCY"/>
         <xsd:enumeration value="SYSTEM"/>
         <xsd:enumeration value="TIMING-EVENT"/>
         <xsd:enumeration value="TRIGGER"/>
         <xsd:enumeration value="TRIGGER-INTERFACE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class AbstractStructure::AtpFeature -->
   <xsd:group name="ATP-FEATURE">
      <xsd:annotation>
         <xsd:documentation>Features are properties via which a classifier classifies instances. Or: a classifier has features and every M0 instance of it will have those features.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpFeature"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="ATP-FEATURE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-ELEMENT"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-ELEMENT"/>
         <xsd:enumeration value="ARGUMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="ASSEMBLY-SW-CONNECTOR"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
         <xsd:enumeration value="ATP-FEATURE"/>
         <xsd:enumeration value="ATP-PROTOTYPE"/>
         <xsd:enumeration value="ATP-STRUCTURE-ELEMENT"/>
         <xsd:enumeration value="AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:enumeration value="BACKGROUND-EVENT"/>
         <xsd:enumeration value="BSW-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
         <xsd:enumeration value="CLIENT-SERVER-OPERATION"/>
         <xsd:enumeration value="DATA-PROTOTYPE"/>
         <xsd:enumeration value="DATA-RECEIVE-ERROR-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVED-EVENT"/>
         <xsd:enumeration value="DATA-SEND-COMPLETED-EVENT"/>
         <xsd:enumeration value="DATA-WRITE-COMPLETED-EVENT"/>
         <xsd:enumeration value="DELEGATION-SW-CONNECTOR"/>
         <xsd:enumeration value="EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="INTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="MODE-DECLARATION"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP-PROTOTYPE"/>
         <xsd:enumeration value="MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="OPERATION-INVOKED-EVENT"/>
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
         <xsd:enumeration value="PARAMETER-DATA-PROTOTYPE"/>
         <xsd:enumeration value="PER-INSTANCE-MEMORY"/>
         <xsd:enumeration value="PORT-GROUP"/>
         <xsd:enumeration value="PORT-PROTOTYPE"/>
         <xsd:enumeration value="PORT-PROTOTYPE-BLUEPRINT"/>
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
         <xsd:enumeration value="RTE-EVENT"/>
         <xsd:enumeration value="ROOT-SW-COMPOSITION-PROTOTYPE"/>
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
         <xsd:enumeration value="SW-COMPONENT-PROTOTYPE"/>
         <xsd:enumeration value="SW-CONNECTOR"/>
         <xsd:enumeration value="SWC-BSW-MAPPING"/>
         <xsd:enumeration value="SWC-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="SWC-MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="SWC-SERVICE-DEPENDENCY"/>
         <xsd:enumeration value="SYSTEM"/>
         <xsd:enumeration value="TIMING-EVENT"/>
         <xsd:enumeration value="TRIGGER"/>
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class AbstractStructure::AtpInstanceRef -->
   <xsd:group name="ATP-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>An M0 instance of a classifier may be represented as a tree rooted at that instance, where under each node come the sub-trees representing the instances which act as features under that node. 

      An instance ref specifies a navigation path from any M0 tree-instance of the base (which is a classifier) to a leaf (which is an instance of the target).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>atpBase skipped -->
         <!-- Association <<atpDerived>>atpContextElement skipped -->
         <!-- Association <<atpDerived>>atpTarget skipped -->
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class AbstractStructure::AtpPrototype -->
   <xsd:group name="ATP-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A prototype is a typed feature. A prototype in a classifier indicates that instances of that classifier will have a feature, and the structure of that feature is given by the its type. An instance of that type will play the role indicated by the feature in the owning classifier.

      A feature is not an instance but an indication of an instance-to-be.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>atpType skipped -->
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="ATP-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-ELEMENT"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-ELEMENT"/>
         <xsd:enumeration value="ARGUMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="ATP-PROTOTYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:enumeration value="DATA-PROTOTYPE"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP-PROTOTYPE"/>
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
         <xsd:enumeration value="PARAMETER-DATA-PROTOTYPE"/>
         <xsd:enumeration value="PORT-PROTOTYPE"/>
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
         <xsd:enumeration value="ROOT-SW-COMPOSITION-PROTOTYPE"/>
         <xsd:enumeration value="SW-COMPONENT-PROTOTYPE"/>
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class AbstractStructure::AtpStructureElement -->
   <xsd:group name="ATP-STRUCTURE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>A structure element is both a classifier and a feature. As a feature, its structure is given by the feature it owns as a classifier.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpStructureElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class AbstractStructure::AtpType -->
   <xsd:group name="ATP-TYPE">
      <xsd:annotation>
         <xsd:documentation>A type is a classifier that may serve to type prototypes. It is a reusable classifier.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AtpType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="ATP-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATP-TYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-TYPE"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
         <xsd:enumeration value="MODE-SWITCH-INTERFACE"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="PORT-INTERFACE"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="TRIGGER-INTERFACE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class VariantHandling::AttributeValueVariationPoint -->
   <xsd:group name="ATTRIBUTE-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to derive the value of the Attribute from a system constant (by SwSystemconstDependentFormula). It also provides a bindingTime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AttributeValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class VariantHandling::AttributeValueVariationPoint -->
   <xsd:attributeGroup name="ATTRIBUTE-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to derive the value of the Attribute from a system constant (by SwSystemconstDependentFormula). It also provides a bindingTime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AttributeValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="BINDING-TIME" type="AR:BINDING-TIME-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This is the binding time in which the attribute value needs to be bound.

         If this attribute is missing, the attribute is not a variation point. In particular this means that It needs to be a single value according to the type specified in the pure model. It is an error if it is still a formula.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="AttributeValueVariationPoint.bindingTime";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="BLUEPRINT-VALUE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This represents a description that documents how the value shall be defined when deriving objects from the blueprint.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="AttributeValueVariationPoint.blueprintValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SD" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This special data is provided to allow synchronisation of Attribute value variation points with variant management systems. The usage is subject of agreement between the involved parties.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="AttributeValueVariationPoint.sd";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHORT-LABEL" type="AR:IDENTIFIER--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This allows to identify the variation point. It is also intended to allow RTE support for CompileTime Variation points.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="AttributeValueVariationPoint.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- element group for class DataPrototypes::AutosarDataPrototype -->
   <xsd:group name="AUTOSAR-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Base class for prototypical roles of an AutosarDataType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-TREF">
            <xsd:annotation>
               <xsd:documentation>This represents the corresponding data type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AutosarDataPrototype.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:AUTOSAR-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="AUTOSAR-DATA-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ARGUMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:enumeration value="PARAMETER-DATA-PROTOTYPE"/>
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Datatypes::AutosarDataType -->
   <xsd:group name="AUTOSAR-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>Abstract base class for user defined AUTOSAR data types for ECU software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>The properties of this AutosarDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AutosarDataType.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="AUTOSAR-DATA-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-TYPE"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class EngineeringObject::AutosarEngineeringObject -->
   <xsd:group name="AUTOSAR-ENGINEERING-OBJECT">
      <xsd:annotation>
         <xsd:documentation>This denotes an engineering object being part of the process. It is a specialization of the abstract class EngineeringObject for usage within AUTOSAR.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarEngineeringObject"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class EngineeringObject::AutosarEngineeringObject -->
   <xsd:complexType abstract="false" mixed="false" name="AUTOSAR-ENGINEERING-OBJECT">
      <xsd:annotation>
         <xsd:documentation>This denotes an engineering object being part of the process. It is a specialization of the abstract class EngineeringObject for usage within AUTOSAR.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarEngineeringObject"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ENGINEERING-OBJECT"/>
         <xsd:group ref="AR:AUTOSAR-ENGINEERING-OBJECT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefsUsage::AutosarOperationArgumentInstance -->
   <xsd:group name="AUTOSAR-OPERATION-ARGUMENT-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>This class represents a reference to an argument instance. This way it is possible to reference an argument instance in the occurrence expression formula. The argument instance can target to one of the following arguments:

      * a whole argument used in an operation of a PortPrototype with ClientServerInterface

      * an element inside of a composite argument used in an operation of a PortPrototype with ClientServerInterface</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarOperationArgumentInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-ARGUMENT-INSTANCE-IREF" type="AR:OPERATION-ARGUMENT-IN-COMPONENT-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the referenceto the instanceRef definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operationArgumentInstance.AutosarOperationArgumentInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefsUsage::AutosarOperationArgumentInstance -->
   <xsd:complexType abstract="false" mixed="false" name="AUTOSAR-OPERATION-ARGUMENT-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>This class represents a reference to an argument instance. This way it is possible to reference an argument instance in the occurrence expression formula. The argument instance can target to one of the following arguments:

      * a whole argument used in an operation of a PortPrototype with ClientServerInterface

      * an element inside of a composite argument used in an operation of a PortPrototype with ClientServerInterface</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarOperationArgumentInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:AUTOSAR-OPERATION-ARGUMENT-INSTANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="AUTOSAR-OPERATION-ARGUMENT-INSTANCE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AUTOSAR-OPERATION-ARGUMENT-INSTANCE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataElements::AutosarParameterRef -->
   <xsd:group name="AUTOSAR-PARAMETER-REF">
      <xsd:annotation>
         <xsd:documentation>This class represents a reference to a parameter within AUTOSAR which can be one of the following use cases:

      localParameter:

      * localParameter which is used as whole (e.g.  sharedAxis for curve)

      autosarVariable:

      * a parameter provided via PortPrototype which is used as whole (e.g. parameterAccess)

      * an element inside of a composite local parameter typed by ApplicationDatatype (e.g. sharedAxis for a curve)

      * an element inside of a composite parameter provided via Port and typed by ApplicationDatatype (e.g. sharedAxis for a curve)

      autosarParameterInImplDatatype:

      * an element inside of a composite local parameter typed by ImplementationDatatype

      * an element inside of a composite parameter provided via PortPrototype and typed by ImplementationDatatype</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarParameterRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AUTOSAR-PARAMETER-IREF" type="AR:PARAMETER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This instance reference is used if the callibration parameter is either imported via a port or is part of a composite data structure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AutosarParameterRef.autosarParameter";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOCAL-PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>In the majority of cases this reference goes to ParameterDataPrototyoes rather than VariableDataPrototypes. Pointing the reference to a VariableDataPrototype is limited to special use cases, e.g. if the AutosarParameterRef is used in the context of an SwAxisGrouped.

            This reference is used if the arParameter is local to the current component. 

            Of course, it would technically also be feasible to use an InstanceRef for this case. However, the InstanceRef would not have a contextElement (because the cureent instance is the context).

            Hence, the local instance is a special case which may provide further optimization. Therefore an expclicit reference is provided for this case.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AutosarParameterRef.localParameter";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::AutosarParameterRef -->
   <xsd:complexType abstract="false" mixed="false" name="AUTOSAR-PARAMETER-REF">
      <xsd:annotation>
         <xsd:documentation>This class represents a reference to a parameter within AUTOSAR which can be one of the following use cases:

      localParameter:

      * localParameter which is used as whole (e.g.  sharedAxis for curve)

      autosarVariable:

      * a parameter provided via PortPrototype which is used as whole (e.g. parameterAccess)

      * an element inside of a composite local parameter typed by ApplicationDatatype (e.g. sharedAxis for a curve)

      * an element inside of a composite parameter provided via Port and typed by ApplicationDatatype (e.g. sharedAxis for a curve)

      autosarParameterInImplDatatype:

      * an element inside of a composite local parameter typed by ImplementationDatatype

      * an element inside of a composite parameter provided via PortPrototype and typed by ImplementationDatatype</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarParameterRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:AUTOSAR-PARAMETER-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefsUsage::AutosarVariableInstance -->
   <xsd:group name="AUTOSAR-VARIABLE-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>This class represents a reference to a variable instance within AUTOSAR. This way it is possible to reference a variable instance in the occurrence expression formula. The variable instance can target to one of the following variables:

      * a variable provided via a PortPrototype as whole

      * an element inside of a composite variable provided via a PortPrototype</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarVariableInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIABLE-INSTANCE-IREF" type="AR:VARIABLE-IN-COMPONENT-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the referenceto the instanceRef definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="variableInstance.AutosarVariableInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefsUsage::AutosarVariableInstance -->
   <xsd:complexType abstract="false" mixed="false" name="AUTOSAR-VARIABLE-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>This class represents a reference to a variable instance within AUTOSAR. This way it is possible to reference a variable instance in the occurrence expression formula. The variable instance can target to one of the following variables:

      * a variable provided via a PortPrototype as whole

      * an element inside of a composite variable provided via a PortPrototype</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarVariableInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:AUTOSAR-VARIABLE-INSTANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="AUTOSAR-VARIABLE-INSTANCE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AUTOSAR-VARIABLE-INSTANCE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataElements::AutosarVariableRef -->
   <xsd:group name="AUTOSAR-VARIABLE-REF">
      <xsd:annotation>
         <xsd:documentation>This class represents a reference to a variable within AUTOSAR which can be one of the following use cases:

      localVariable:

      * localVariable which is used as whole (e.g. InterRunnableVariable, inputValue for curve)

      autosarVariable:

      * a variable provided via Port which is used as whole (e.g. dataAccesspoints)

      * an element inside of a composite local variable typed by ApplicationDatatype (e.g. inputValue for a curve)

      * an element inside of a composite variable provided via Port and typed by ApplicationDatatype (e.g. inputValue for a curve)

      autosarVariableInImplDatatype:

      * an element inside of a composite local variable typed by ImplementationDatatype  (e.g. nvramData mapping)

      * an element inside of a composite variable provided via Port and typed by ImplementationDatatype (e.g. inputValue for a curve)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarVariableRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AUTOSAR-VARIABLE-IN-IMPL-DATATYPE" type="AR:AR-VARIABLE-IN-IMPLEMENTATION-DATA-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This is used if the target variable is inside of variableDataPrototype typed by an ImplementationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AutosarVariableRef.autosarVariableInImplDatatype";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="AUTOSAR-VARIABLE-IREF" type="AR:VARIABLE-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This references a variable which is provided by a port and/or which is part of a CompositeDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AutosarVariableRef.autosarVariable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOCAL-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>This reference is used if the variable is local to the current component. It would also be possible to use the instance refence here.
            Such an instance ref would not have a contextElement, since the current instance is the context.
            But the local instance is a special case which may provide further optimization. Therefore an expclicit reference is provided for this case.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AutosarVariableRef.localVariable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::AutosarVariableRef -->
   <xsd:complexType abstract="false" mixed="false" name="AUTOSAR-VARIABLE-REF">
      <xsd:annotation>
         <xsd:documentation>This class represents a reference to a variable within AUTOSAR which can be one of the following use cases:

      localVariable:

      * localVariable which is used as whole (e.g. InterRunnableVariable, inputValue for curve)

      autosarVariable:

      * a variable provided via Port which is used as whole (e.g. dataAccesspoints)

      * an element inside of a composite local variable typed by ApplicationDatatype (e.g. inputValue for a curve)

      * an element inside of a composite variable provided via Port and typed by ApplicationDatatype (e.g. inputValue for a curve)

      autosarVariableInImplDatatype:

      * an element inside of a composite local variable typed by ImplementationDatatype  (e.g. nvramData mapping)

      * an element inside of a composite variable provided via Port and typed by ImplementationDatatype (e.g. inputValue for a curve)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AutosarVariableRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:AUTOSAR-VARIABLE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::BackgroundEvent -->
   <xsd:group name="BACKGROUND-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is used to trigger RunnableEntities that are supposed to be executed in the background.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BackgroundEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class RTEEvents::BackgroundEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BACKGROUND-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is used to trigger RunnableEntities that are supposed to be executed in the background.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BackgroundEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:BACKGROUND-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BaseTypes::BaseType -->
   <xsd:group name="BASE-TYPE">
      <xsd:annotation>
         <xsd:documentation>This abstract meta-class represents the ability to specify a platform dependant base type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:BASE-TYPE-DIRECT-DEFINITION"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class BaseTypes::BaseTypeAbsSize -->
   <xsd:group name="BASE-TYPE-ABS-SIZE">
      <xsd:annotation>
         <xsd:documentation>This is the absolute size of the basetype. In this case the BaseType is of fixed length.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeAbsSize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-SIZE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Describes the length of the data type specified in the container in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeAbsSize.baseTypeSize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BaseTypes::BaseTypeAbsSize -->
   <xsd:complexType abstract="false" mixed="false" name="BASE-TYPE-ABS-SIZE">
      <xsd:annotation>
         <xsd:documentation>This is the absolute size of the basetype. In this case the BaseType is of fixed length.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeAbsSize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BASE-TYPE-SIZE-DEFINITION"/>
         <xsd:group ref="AR:BASE-TYPE-ABS-SIZE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BaseTypes::BaseTypeDefinition -->
   <xsd:group name="BASE-TYPE-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to define a basetype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class BaseTypes::BaseTypeDirectDefinition -->
   <xsd:group name="BASE-TYPE-DIRECT-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This BaseType is defined directly (as opposite to a derived BaseType)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:BASE-TYPE-ABS-SIZE"/>
            <xsd:group ref="AR:BASE-TYPE-MAX-SIZE"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-ENCODING" type="AR:BASE-TYPE-ENCODING-STRING">
            <xsd:annotation>
               <xsd:documentation>This specifies, how an object of the current BaseType is encoded e.g.. in an ECU in a message sequence.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition.baseTypeEncoding";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEM-ALIGNMENT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute describes the alignment of the memory object in bits. E.g. "1" specifies, that the object in question is aligned to a byte while "32" specifies that it is aligned four byte.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition.memAlignment";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the byte order of the base type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition.byteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="110"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NATIVE-DECLARATION" type="AR:NATIVE-DECLARATION-STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute describes the declaration of such a base type in the native programming language, primarily in the Programming language C. This can then be used by a code generator to include the necessary declarations into a header file. For example

            BaseType with
               shortName: "MyUnsignedInt"
               nativeDeclaration: "unsigned short"

            Results in

              typedef unsigned short MyUnsignedInt;

            If the attribute is not defined the referring ImplementationDataTypes will not be generated as a typedef by RTE.

            If a nativeDeclaration type is given it shall fulfill the characteristic given by basetypeEncoding and baseTypeSize. This is required to ensure the consistent handling and interpretation by software components, RTE, COM and MCM systems.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition.nativeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="120"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BaseTypes::BaseTypeDirectDefinition -->
   <xsd:complexType abstract="false" mixed="false" name="BASE-TYPE-DIRECT-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This BaseType is defined directly (as opposite to a derived BaseType)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BASE-TYPE-DEFINITION"/>
         <xsd:group ref="AR:BASE-TYPE-DIRECT-DEFINITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BaseTypes::BaseTypeMaxSize -->
   <xsd:group name="BASE-TYPE-MAX-SIZE">
      <xsd:annotation>
         <xsd:documentation>This is the maximum size of a BaseType in case of a dynamic BaseType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeMaxSize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BASE-TYPE-SIZE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Describes the maximum length of the BaseType  in bits</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeMaxSize.maxBaseTypeSize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BaseTypes::BaseTypeMaxSize -->
   <xsd:complexType abstract="false" mixed="false" name="BASE-TYPE-MAX-SIZE">
      <xsd:annotation>
         <xsd:documentation>This is the maximum size of a BaseType in case of a dynamic BaseType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeMaxSize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BASE-TYPE-SIZE-DEFINITION"/>
         <xsd:group ref="AR:BASE-TYPE-MAX-SIZE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BaseTypes::BaseTypeSizeDefinition -->
   <xsd:group name="BASE-TYPE-SIZE-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This abstract class represents the possible methods of defining the size of a BaseType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeSizeDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class GenericBlueprint::BlueprintMapping -->
   <xsd:group name="BLUEPRINT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to map two an object and its blueprint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BlueprintMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BLUEPRINT-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the mapped blueprint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BlueprintMapping.blueprint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ATP-BLUEPRINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DERIVED-OBJECT-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the object which was derived from the blueprint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BlueprintMapping.derivedObject";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ATP-BLUEPRINTABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GenericBlueprint::BlueprintMapping -->
   <xsd:complexType abstract="false" mixed="false" name="BLUEPRINT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to map two an object and its blueprint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BlueprintMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT-MAPPING"/>
         <xsd:group ref="AR:BLUEPRINT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BlueprintMapping::BlueprintMappingSet -->
   <xsd:group name="BLUEPRINT-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>This represents a container of mappings between "actual" model elements and the "blueprint" that has been taken for their creation.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BlueprintMappingSets";mmt.qualifiedName="BlueprintMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BLUEPRINT-MAPS">
            <xsd:annotation>
               <xsd:documentation>This represents a partiuclar blueprint map in the set.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BlueprintMappingSet.blueprintMap";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BLUEPRINT-MAPPING" type="AR:BLUEPRINT-MAPPING"/>
                  <xsd:element name="PORT-INTERFACE-BLUEPRINT-MAPPING" type="AR:PORT-INTERFACE-BLUEPRINT-MAPPING"/>
                  <xsd:element name="PORT-PROTOTYPE-BLUEPRINT-MAPPING" type="AR:PORT-PROTOTYPE-BLUEPRINT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BlueprintMapping::BlueprintMappingSet -->
   <xsd:complexType abstract="false" mixed="false" name="BLUEPRINT-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>This represents a container of mappings between "actual" model elements and the "blueprint" that has been taken for their creation.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BlueprintMappingSets";mmt.qualifiedName="BlueprintMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:BLUEPRINT-MAPPING-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::BooleanValueVariationPoint -->
   <xsd:group name="BOOLEAN-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for Boolean attributes.

      Note that this class might be used in the extended meta-model on</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class VariantHandling::BooleanValueVariationPoint -->
   <xsd:complexType abstract="false" mixed="true" name="BOOLEAN-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for Boolean attributes.

      Note that this class might be used in the extended meta-model on</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-DEPENDENT-FORMULA"/>
         <xsd:group ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
         <xsd:group ref="AR:BOOLEAN-VALUE-VARIATION-POINT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::Br -->
   <xsd:group name="BR">
      <xsd:annotation>
         <xsd:documentation>This element is the same as function here as in a HTML document i.e. it forces a line break.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Br"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class InlineTextElements::Br -->
   <xsd:complexType abstract="false" mixed="false" name="BR">
      <xsd:annotation>
         <xsd:documentation>This element is the same as function here as in a HTML document i.e. it forces a line break.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Br"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswBackgroundEvent -->
   <xsd:group name="BSW-BACKGROUND-EVENT">
      <xsd:annotation>
         <xsd:documentation>A recurring BswEvent which is used to perform background activities. It is similar to a BswTimingEvent but has no fixed time period and is activated only with low priority.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswBackgroundEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswBackgroundEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-BACKGROUND-EVENT">
      <xsd:annotation>
         <xsd:documentation>A recurring BswEvent which is used to perform background activities. It is similar to a BswTimingEvent but has no fixed time period and is activated only with low priority.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswBackgroundEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-EVENT"/>
         <xsd:group ref="AR:BSW-BACKGROUND-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswCalledEntity -->
   <xsd:group name="BSW-CALLED-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed to be called from another BSW module or cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswCalledEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswCalledEntity -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-CALLED-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed to be called from another BSW module or cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswCalledEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTABLE-ENTITY"/>
         <xsd:group ref="AR:BSW-MODULE-ENTITY"/>
         <xsd:group ref="AR:BSW-CALLED-ENTITY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswImplementation::BswDebugInfo -->
   <xsd:group name="BSW-DEBUG-INFO">
      <xsd:annotation>
         <xsd:documentation>Collects the information on the data provided to the AUTOSAR debug module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswDebugInfo"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOCAL-DEBUG-DATAS">
            <xsd:annotation>
               <xsd:documentation>A data element declared locally to this module, cluster or library. It shall be used (within AUTOSAR) only for debugging purposes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswDebugInfo.localDebugData";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="IMPLEMENTATION-DATA-TYPE-ELEMENT" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-ACCESSED-FOR-DEBUG-REFS">
            <xsd:annotation>
               <xsd:documentation>Indicates a parameter as to be debugged.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswDebugInfo.parameterAccessedForDebug";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAMETER-ACCESSED-FOR-DEBUG-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PARAMETER-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIABLE-ACCESSED-FOR-DEBUG-REFS">
            <xsd:annotation>
               <xsd:documentation>Indicates a variable as to be debugged.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswDebugInfo.variableAccessedForDebug";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-ACCESSED-FOR-DEBUG-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswImplementation::BswDebugInfo -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-DEBUG-INFO">
      <xsd:annotation>
         <xsd:documentation>Collects the information on the data provided to the AUTOSAR debug module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswDebugInfo"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-DEBUG-INFO"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswEvent -->
   <xsd:group name="BSW-EVENT">
      <xsd:annotation>
         <xsd:documentation>Defines an event which is used to trigger a schedulable entity of this BSW module or cluster. The event is local to the BSW module or cluster. The short name of the class instance is intended as an input to configure the required API of the BSW Scheduler.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISABLED-IN-MODE-IREFS">
            <xsd:annotation>
               <xsd:documentation>The modes, in which this event is disabled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswEvent.disabledInMode";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DISABLED-IN-MODE-IREF" type="AR:MODE-IN-BSW-MODULE-DESCRIPTION-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STARTS-ON-EVENT-REF">
            <xsd:annotation>
               <xsd:documentation>This entity which is started by the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswEvent.startsOnEvent";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-SCHEDULABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class BswBehavior::BswExternalTriggerOccurredEvent -->
   <xsd:group name="BSW-EXTERNAL-TRIGGER-OCCURRED-EVENT">
      <xsd:annotation>
         <xsd:documentation>A BswEvent resulting from a trigger released by another module or cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswExternalTriggerOccurredEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-REF">
            <xsd:annotation>
               <xsd:documentation>The trigger associated with this event. The trigger is external to this module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswExternalTriggerOccurredEvent.trigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswExternalTriggerOccurredEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-EXTERNAL-TRIGGER-OCCURRED-EVENT">
      <xsd:annotation>
         <xsd:documentation>A BswEvent resulting from a trigger released by another module or cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswExternalTriggerOccurredEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-EVENT"/>
         <xsd:group ref="AR:BSW-EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswImplementation::BswImplementation -->
   <xsd:group name="BSW-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Contains the implementation specific information in addition to the generic specification (BswModuleDescription and BswBehavior).
      It is possible to have several different BswImplementations referring to the same BswBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BswImplementations";mmt.qualifiedName="BswImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-RELEASE-VERSION" type="AR:REVISION-LABEL-STRING">
            <xsd:annotation>
               <xsd:documentation>Version of the AUTOSAR Release on which this implementation is based. The numbering contains three levels (major, minor, revision) which are defined by AUTOSAR.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.arReleaseVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BEHAVIOR-REF">
            <xsd:annotation>
               <xsd:documentation>The behavior of this implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.behavior";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-INTERNAL-BEHAVIOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEBUG-INFOS">
            <xsd:annotation>
               <xsd:documentation>Collects the debug info for this implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswImplementation.debugInfo";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-DEBUG-INFO" type="AR:BSW-DEBUG-INFO"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PRECONFIGURED-CONFIGURATION-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the set of preconfigured (i.e. fixed) configuration values for this BswImplementation.

            If the BswImplementation represents a cluster of several modules, more than one EcucModuleConfigurationValues element can be referred (at most one per module), otherwise at most one such element can be referred.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.preconfiguredConfiguration";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleWrapperElement="true"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PRECONFIGURED-CONFIGURATION-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:ECUC-MODULE-CONFIGURATION-VALUES--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECOMMENDED-CONFIGURATION-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to one or more sets of recommended configuration values for this module or module cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.recommendedConfiguration";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECOMMENDED-CONFIGURATION-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:ECUC-MODULE-CONFIGURATION-VALUES--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR-API-INFIX" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>In driver modules which can be instantiated several times on a single ECU, BSW00347 requires that the names of files, APIs, published parameters and memory allocation keywords are extended by the vendorId and a vendor specific name. 
            This parameter is used to specify the vendor specific name. In total, the implementation specific API name is generated as follows:
            &amp;lt;ModuleName&amp;gt;_&amp;lt;vendorId&amp;gt;_ &amp;lt;vendorApiInfix&amp;gt;_&amp;lt;API name from SWS&amp;gt;.

            E.g.  assuming that the vendorId of the implementer is 123 and the implementer chose a vendorApiInfix of "v11r456" an API name Can_Write defined in the SWS will translate to Can_123_v11r456_Write. 

            This attribute is mandatory for all modules with upper multiplicity &amp;gt; 1. It shall not be used for modules with upper multiplicity =1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.vendorApiInfix";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR-SPECIFIC-MODULE-DEF-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to 

            * the vendor specific EcucModuleDef used in this BswImplementation if it represents a single module

            * several EcucModuleDefs used in this BswImplementation if it  represents a cluster of modules

            * one or no EcucModuleDefs used in this BswImplementation if it represents a library</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.vendorSpecificModuleDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleWrapperElement="true"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VENDOR-SPECIFIC-MODULE-DEF-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:ECUC-MODULE-DEF--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswImplementation::BswImplementation -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Contains the implementation specific information in addition to the generic specification (BswModuleDescription and BswBehavior).
      It is possible to have several different BswImplementations referring to the same BswBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BswImplementations";mmt.qualifiedName="BswImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:IMPLEMENTATION"/>
         <xsd:group ref="AR:BSW-IMPLEMENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-IMPLEMENTATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-IMPLEMENTATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswInternalBehavior -->
   <xsd:group name="BSW-INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>Specifies the behavior of a BSW module or a BSW cluster w.r.t. the code entities visible by the BSW Scheduler.
      It is possible to have several different BswInternalBehaviors referring to the same BswModuleDescription.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERNAL-TRIGGERING-POINTS">
            <xsd:annotation>
               <xsd:documentation>An internal triggering point.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswInternalBehavior.internalTriggeringPoint";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-INTERNAL-TRIGGERING-POINT" type="AR:BSW-INTERNAL-TRIGGERING-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENTITYS">
            <xsd:annotation>
               <xsd:documentation>A code entity for which the behavior is described
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswInternalBehavior.entity";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="5"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-CALLED-ENTITY" type="AR:BSW-CALLED-ENTITY"/>
                  <xsd:element name="BSW-INTERRUPT-ENTITY" type="AR:BSW-INTERRUPT-ENTITY"/>
                  <xsd:element name="BSW-SCHEDULABLE-ENTITY" type="AR:BSW-SCHEDULABLE-ENTITY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENTS">
            <xsd:annotation>
               <xsd:documentation>An event required by this module behavior.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswInternalBehavior.event";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-BACKGROUND-EVENT" type="AR:BSW-BACKGROUND-EVENT"/>
                  <xsd:element name="BSW-EXTERNAL-TRIGGER-OCCURRED-EVENT" type="AR:BSW-EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
                  <xsd:element name="BSW-INTERNAL-TRIGGER-OCCURRED-EVENT" type="AR:BSW-INTERNAL-TRIGGER-OCCURRED-EVENT"/>
                  <xsd:element name="BSW-MODE-SWITCH-EVENT" type="AR:BSW-MODE-SWITCH-EVENT"/>
                  <xsd:element name="BSW-MODE-SWITCHED-ACK-EVENT" type="AR:BSW-MODE-SWITCHED-ACK-EVENT"/>
                  <xsd:element name="BSW-TIMING-EVENT" type="AR:BSW-TIMING-EVENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-DIRECT-IMPLEMENTATIONS">
            <xsd:annotation>
               <xsd:documentation>Specifies a trigger to be directly implemented via OS calls.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswInternalBehavior.triggerDirectImplementation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="15"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-TRIGGER-DIRECT-IMPLEMENTATION" type="AR:BSW-TRIGGER-DIRECT-IMPLEMENTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-SENDER-POLICYS">
            <xsd:annotation>
               <xsd:documentation>Implementation policy for providing a mode group.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswInternalBehavior.modeSenderPolicy";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODE-SENDER-POLICY" type="AR:BSW-MODE-SENDER-POLICY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-RECEIVER-POLICYS">
            <xsd:annotation>
               <xsd:documentation>Implementation policy for the reception of mode switches.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswInternalBehavior.modeReceiverPolicy";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="25"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODE-RECEIVER-POLICY" type="AR:BSW-MODE-RECEIVER-POLICY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-DEPENDENCYS">
            <xsd:annotation>
               <xsd:documentation>Defines the requirements on AUTOSAR Services for a particular item.

            The aggregation is subject to variability with the purpose to support the conditional existence of ServiceNeeds.

            The aggregation is splitable in order to support that ServiceNeeds might be provided in later development steps.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="BswInternalBehavior.serviceDependency";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-SERVICE-DEPENDENCY" type="AR:BSW-SERVICE-DEPENDENCY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-PARAMETERS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswInternalBehavior.perInstanceParameter";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="45"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAMETER-DATA-PROTOTYPE" type="AR:PARAMETER-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCHEDULER-NAME-PREFIXS">
            <xsd:annotation>
               <xsd:documentation>Optional definition of one or more prefixes to be used for the BswScheduler.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswInternalBehavior.schedulerNamePrefix";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-SCHEDULER-NAME-PREFIX" type="AR:BSW-SCHEDULER-NAME-PREFIX"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswInternalBehavior -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>Specifies the behavior of a BSW module or a BSW cluster w.r.t. the code entities visible by the BSW Scheduler.
      It is possible to have several different BswInternalBehaviors referring to the same BswModuleDescription.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:INTERNAL-BEHAVIOR"/>
         <xsd:group ref="AR:BSW-INTERNAL-BEHAVIOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-INTERNAL-BEHAVIOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-INTERNAL-BEHAVIOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswInternalTriggerOccurredEvent -->
   <xsd:group name="BSW-INTERNAL-TRIGGER-OCCURRED-EVENT">
      <xsd:annotation>
         <xsd:documentation>A BswEvent, which can happen sporadically. The event is activated by explicit calls from the module to the BSW Scheduler. The main purpose for such an event is to cause a context switch, e.g. from an ISR context into a task context. Activation and switching are handled within the same module or cluster only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInternalTriggerOccurredEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The activation point is the source of this event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswInternalTriggerOccurredEvent.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-INTERNAL-TRIGGERING-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswInternalTriggerOccurredEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-INTERNAL-TRIGGER-OCCURRED-EVENT">
      <xsd:annotation>
         <xsd:documentation>A BswEvent, which can happen sporadically. The event is activated by explicit calls from the module to the BSW Scheduler. The main purpose for such an event is to cause a context switch, e.g. from an ISR context into a task context. Activation and switching are handled within the same module or cluster only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInternalTriggerOccurredEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-EVENT"/>
         <xsd:group ref="AR:BSW-INTERNAL-TRIGGER-OCCURRED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswInternalTriggeringPoint -->
   <xsd:group name="BSW-INTERNAL-TRIGGERING-POINT">
      <xsd:annotation>
         <xsd:documentation>Represents the activation point for one or more BswInternalTriggerOccurredEvents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInternalTriggeringPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IMPL-POLICY" type="AR:SW-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute, when set to value queued, specifies a queued processing of the internal trigger event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswInternalTriggeringPoint.swImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswInternalTriggeringPoint -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-INTERNAL-TRIGGERING-POINT">
      <xsd:annotation>
         <xsd:documentation>Represents the activation point for one or more BswInternalTriggerOccurredEvents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInternalTriggeringPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-INTERNAL-TRIGGERING-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-INTERNAL-TRIGGERING-POINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-INTERNAL-TRIGGERING-POINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswInternalTriggeringPointRefConditional -->
   <xsd:group name="BSW-INTERNAL-TRIGGERING-POINT-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-INTERNAL-TRIGGERING-POINT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-INTERNAL-TRIGGERING-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswInternalTriggeringPointRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-INTERNAL-TRIGGERING-POINT-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BSW-INTERNAL-TRIGGERING-POINT-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswInterruptEntity -->
   <xsd:group name="BSW-INTERRUPT-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed to be triggered by an interrupt.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERRUPT-CATEGORY" type="AR:BSW-INTERRUPT-CATEGORY">
            <xsd:annotation>
               <xsd:documentation>Category of the interrupt</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptEntity.interruptCategory";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERRUPT-SOURCE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Allows a textual documentation of the intended interrupt source.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptEntity.interruptSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswInterruptEntity -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-INTERRUPT-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed to be triggered by an interrupt.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTABLE-ENTITY"/>
         <xsd:group ref="AR:BSW-MODULE-ENTITY"/>
         <xsd:group ref="AR:BSW-INTERRUPT-ENTITY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::BswMgrNeeds -->
   <xsd:group name="BSW-MGR-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Basic Software Manager for one "user".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswMgrNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::BswMgrNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MGR-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Basic Software Manager for one "user".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswMgrNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:BSW-MGR-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswModeReceiverPolicy -->
   <xsd:group name="BSW-MODE-RECEIVER-POLICY">
      <xsd:annotation>
         <xsd:documentation>Specifies the details for the reception of a mode switch for the referred mode group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeReceiverPolicy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENHANCED-MODE-API" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This controls the creation of the enhanced mode API that returns information about the previous mode and the next mode. If set to TRUE the enhanced mode API is supposed to be generated. For more details please refer to the SWS_RTE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeReceiverPolicy.enhancedModeApi";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>The required mode group for which the policy is specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeReceiverPolicy.requiredModeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTS-ASYNCHRONOUS-MODE-SWITCH" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Specifies whether the module can handle the reception of an asynchronous mode switch (true) or not (false).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeReceiverPolicy.supportsAsynchronousModeSwitch";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswModeReceiverPolicy -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODE-RECEIVER-POLICY">
      <xsd:annotation>
         <xsd:documentation>Specifies the details for the reception of a mode switch for the referred mode group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeReceiverPolicy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BSW-MODE-RECEIVER-POLICY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswModeSenderPolicy -->
   <xsd:group name="BSW-MODE-SENDER-POLICY">
      <xsd:annotation>
         <xsd:documentation>Specifies the details for the sending of a mode switch for the referred mode group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSenderPolicy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACK-REQUEST" type="AR:BSW-MODE-SWITCH-ACK-REQUEST">
            <xsd:annotation>
               <xsd:documentation>Request for acknowledgement</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSenderPolicy.ackRequest";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENHANCED-MODE-API" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSenderPolicy.enhancedModeApi";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>The provided mode group for which the policy is specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSenderPolicy.providedModeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="QUEUE-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Length of call queue on the sender side. The queue is implemented by the RTE resp.BswScheduler. The value must be greater or equal to 0. Setting the value of queueLength to 0 implies non-queued communication.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSenderPolicy.queueLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswModeSenderPolicy -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODE-SENDER-POLICY">
      <xsd:annotation>
         <xsd:documentation>Specifies the details for the sending of a mode switch for the referred mode group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSenderPolicy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BSW-MODE-SENDER-POLICY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswModeSwitchAckRequest -->
   <xsd:group name="BSW-MODE-SWITCH-ACK-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests acknowledgements that a mode switch has been processed  successfully</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchAckRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Number of seconds before an error is reported.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchAckRequest.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswModeSwitchAckRequest -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODE-SWITCH-ACK-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests acknowledgements that a mode switch has been processed  successfully</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchAckRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BSW-MODE-SWITCH-ACK-REQUEST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswModeSwitchEvent -->
   <xsd:group name="BSW-MODE-SWITCH-EVENT">
      <xsd:annotation>
         <xsd:documentation>A BswEvent resulting from a mode switch.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVATION" type="AR:MODE-ACTIVATION-KIND">
            <xsd:annotation>
               <xsd:documentation>Kind of activation w.r.t. to the referred mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchEvent.activation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to one or two Modes that initiate the Mode Switch Event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchEvent.mode";pureMM.maxOccurs="2";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="MODE-IREF" type="AR:MODE-IN-BSW-MODULE-DESCRIPTION-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswModeSwitchEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODE-SWITCH-EVENT">
      <xsd:annotation>
         <xsd:documentation>A BswEvent resulting from a mode switch.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-EVENT"/>
         <xsd:group ref="AR:BSW-MODE-SWITCH-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswModeSwitchedAckEvent -->
   <xsd:group name="BSW-MODE-SWITCHED-ACK-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised after a switch of the referenced mode group has been acknowledged or an error occurs. The referenced mode group must be provided by this module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchedAckEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>A mode group provided by this module. The acknowlede of a switch of this group raises this event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchedAckEvent.modeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswModeSwitchedAckEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODE-SWITCHED-ACK-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised after a switch of the referenced mode group has been acknowledged or an error occurs. The referenced mode group must be provided by this module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModeSwitchedAckEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-EVENT"/>
         <xsd:group ref="AR:BSW-MODE-SWITCHED-ACK-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswInterfaces::BswModuleDependency -->
   <xsd:group name="BSW-MODULE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>This class collects the dependencies of a BSW module or cluster on a certain other BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-MODULE-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>AUTOSAR identifier of the target module of which the dependencies are defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency.targetModuleId";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-ENTRYS">
            <xsd:annotation>
               <xsd:documentation>Indicates an entry into another modules which is required by this module.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleDependency.requiredEntry";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-ENTRY-REF-CONDITIONAL" type="AR:BSW-MODULE-ENTRY-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXPECTED-CALLBACKS">
            <xsd:annotation>
               <xsd:documentation>Indicates a callback expected to be called from another module and implemented by this module.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleDependency.expectedCallback";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="15"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-ENTRY-REF-CONDITIONAL" type="AR:BSW-MODULE-ENTRY-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-ITEMS">
            <xsd:annotation>
               <xsd:documentation>A single item (example: Nv block) for which the quality of a service is defined.

            The aggregation is marked as &lt;&lt;atpSplitable&gt;&gt; to allow for extension during the ECU configuration process.

            This association is deprecated since R4.0.3, since ServiceNeeds shall be associated with the new element BswServiceDependency within the BswInternalBehavior.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Splitkey="shortName";atp.Status="obsolete";mmt.qualifiedName="BswModuleDependency.serviceItem";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MGR-NEEDS" type="AR:BSW-MGR-NEEDS"/>
                  <xsd:element name="COM-MGR-USER-NEEDS" type="AR:COM-MGR-USER-NEEDS"/>
                  <xsd:element name="CRYPTO-SERVICE-NEEDS" type="AR:CRYPTO-SERVICE-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS" type="AR:DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-EVENT-MANAGER-NEEDS" type="AR:DIAGNOSTIC-EVENT-MANAGER-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-EVENT-NEEDS" type="AR:DIAGNOSTIC-EVENT-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-IO-CONTROL-NEEDS" type="AR:DIAGNOSTIC-IO-CONTROL-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-ROUTINE-NEEDS" type="AR:DIAGNOSTIC-ROUTINE-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-VALUE-NEEDS" type="AR:DIAGNOSTIC-VALUE-NEEDS"/>
                  <xsd:element name="DLT-USER-NEEDS" type="AR:DLT-USER-NEEDS"/>
                  <xsd:element name="ECU-STATE-MGR-USER-NEEDS" type="AR:ECU-STATE-MGR-USER-NEEDS"/>
                  <xsd:element name="FUNCTION-INHIBITION-NEEDS" type="AR:FUNCTION-INHIBITION-NEEDS"/>
                  <xsd:element name="NV-BLOCK-NEEDS" type="AR:NV-BLOCK-NEEDS"/>
                  <xsd:element name="OBD-CONTROL-SERVICE-NEEDS" type="AR:OBD-CONTROL-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-INFO-SERVICE-NEEDS" type="AR:OBD-INFO-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-MONITOR-SERVICE-NEEDS" type="AR:OBD-MONITOR-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-PID-SERVICE-NEEDS" type="AR:OBD-PID-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-RATIO-SERVICE-NEEDS" type="AR:OBD-RATIO-SERVICE-NEEDS"/>
                  <xsd:element name="SUPERVISED-ENTITY-NEEDS" type="AR:SUPERVISED-ENTITY-NEEDS"/>
                  <xsd:element name="SYNC-TIME-BASE-MGR-USER-NEEDS" type="AR:SYNC-TIME-BASE-MGR-USER-NEEDS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswInterfaces::BswModuleDependency -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>This class collects the dependencies of a BSW module or cluster on a certain other BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-MODULE-DEPENDENCY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswOverview::BswModuleDescription -->
   <xsd:group name="BSW-MODULE-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>Root element for the description of a single BSW module or BSW cluster.
      In case it describes a BSW module, the short name of this element equals the name of the BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BswModuleDescriptions";mmt.qualifiedName="BswModuleDescription"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODULE-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Refers to the BSW Module Identifier defined by the AUTOSAR standard. For non-standardized modules, a proprietary identifier can be chosen.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDescription.moduleId";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-DOCUMENTATIONS">
            <xsd:annotation>
               <xsd:documentation>This adds a documentation to the BSW module.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="bswModuleDocumentation, variationPoint.shortLabel";mmt.qualifiedName="BswModuleDescription.bswModuleDocumentation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="6"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-COMPONENT-DOCUMENTATION" type="AR:SW-COMPONENT-DOCUMENTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-ENTRYS">
            <xsd:annotation>
               <xsd:documentation>Specifies an entry provided by this module which can be called by other modules. This includes "main" functions and interrupt routines, but not callbacks (because the signature of a callback is defined by the caller).
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleDescription.providedEntry";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-ENTRY-REF-CONDITIONAL" type="AR:BSW-MODULE-ENTRY-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OUTGOING-CALLBACKS">
            <xsd:annotation>
               <xsd:documentation>Specifies a callback, which will be called from this module if required by 
            another module.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleDescription.outgoingCallback";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="15"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-ENTRY-REF-CONDITIONAL" type="AR:BSW-MODULE-ENTRY-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-DEPENDENCYS">
            <xsd:annotation>
               <xsd:documentation>Describes the dependency to another BSW module.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="BswModuleDescription.bswModuleDependency";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-DEPENDENCY" type="AR:BSW-MODULE-DEPENDENCY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-MODE-GROUPS">
            <xsd:annotation>
               <xsd:documentation>A set of modes which is owned and provided by this module or cluster. It can be connected to the requiredModeGroups of other modules or clusters via the configuration of the BswScheduler. It can also be synchronized with modes provided via ports by an associated ServiceSwComponentType, EcuAbstractionSwComponentType or ComplexDeviceDriverSwComponentType.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleDescription.providedModeGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="25"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION-GROUP-PROTOTYPE" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-MODE-GROUPS">
            <xsd:annotation>
               <xsd:documentation>Specifies that this module or cluster depends on a certain mode group. The requiredModeGroup is local to  this context and will be connected to the providedModeGroup of another module or cluster via the configuration of the BswScheduler.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleDescription.requiredModeGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION-GROUP-PROTOTYPE" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RELEASED-TRIGGERS">
            <xsd:annotation>
               <xsd:documentation>A Trigger released by this module or cluster. It can be connected to the requiredTriggers of other modules or clusters via the configuration of the BswScheduler. It can also be synchronized with Triggers provided via ports by an associated ServiceSwComponentType, EcuAbstractionSwComponentType or ComplexDeviceDriverSwComponentType.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleDescription.releasedTrigger";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="35"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRIGGER" type="AR:TRIGGER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-TRIGGERS">
            <xsd:annotation>
               <xsd:documentation>Specifies that this module or cluster reacts upon an external trigger.This requiredTrigger is declared locally to this context and will be connected to the providedTrigger of another module or cluster via the configuration of the BswScheduler.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleDescription.requiredTrigger";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRIGGER" type="AR:TRIGGER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERNAL-BEHAVIORS">
            <xsd:annotation>
               <xsd:documentation>The various BswInternalBehaviors associated with a BswModuleDescription can be distributed over several physical files. Therefore the aggregation is &lt;&lt;atpSplitable&gt;&gt;.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Splitkey="shortName";mmt.qualifiedName="BswModuleDescription.internalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="45"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-INTERNAL-BEHAVIOR" type="AR:BSW-INTERNAL-BEHAVIOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswOverview::BswModuleDescription -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>Root element for the description of a single BSW module or BSW cluster.
      In case it describes a BSW module, the short name of this element equals the name of the BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BswModuleDescriptions";mmt.qualifiedName="BswModuleDescription"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:BSW-MODULE-DESCRIPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-MODULE-DESCRIPTION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswModuleEntity -->
   <xsd:group name="BSW-MODULE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>Specifies the smallest code fragment which can be described for a BSW module or cluster within AUTOSAR.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCESSED-MODE-GROUPS">
            <xsd:annotation>
               <xsd:documentation>A mode group which is accessed via API call by this entity. It must be a ModeDeclarationGroupPrototype required by this module or cluster.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleEntity.accessedModeGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION-GROUP-PROTOTYPE-REF-CONDITIONAL" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVATION-POINTS">
            <xsd:annotation>
               <xsd:documentation>Activation point used by the module entity to activate one or more internal triggers.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleEntity.activationPoint";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-INTERNAL-TRIGGERING-POINT-REF-CONDITIONAL" type="AR:BSW-INTERNAL-TRIGGERING-POINT-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLED-ENTRYS">
            <xsd:annotation>
               <xsd:documentation>The entry of another (or the same) BSW module which is called by this entry (usually via C function call). This information allows to set up a model of call chains.

            The variablity of this association is especially targeted at debug scenarios: It is possible to have one variant calling into the AUTOSAR debug module and another one which doesn't.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleEntity.calledEntry";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-ENTRY-REF-CONDITIONAL" type="AR:BSW-MODULE-ENTRY-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTED-ENTRY-REF">
            <xsd:annotation>
               <xsd:documentation>The entry which is implemented by this module entity.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity.implementedEntry";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ISSUED-TRIGGERS">
            <xsd:annotation>
               <xsd:documentation>A trigger issued by this entity via BSW Scheduler API call. It must be a BswTrigger released (i.e. owned) by this module or cluster.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleEntity.issuedTrigger";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRIGGER-REF-CONDITIONAL" type="AR:TRIGGER-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MANAGED-MODE-GROUPS">
            <xsd:annotation>
               <xsd:documentation>A mode group which is managed by this entity. It must be a ModeDeclarationGroupPrototype provided by this module or cluster.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="BswModuleEntity.managedModeGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION-GROUP-PROTOTYPE-REF-CONDITIONAL" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCHEDULER-NAME-PREFIX-REF">
            <xsd:annotation>
               <xsd:documentation>A prefix to be used in generated names for the BswModuleScheduler in the context of this BswModuleEntity, for example entry point prototypes, macros for dealing with exclusive areas, header file names.

            Details are defined in the SWS RTE.

            The prefix supersedes default rules for the prefix of those names.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity.schedulerNamePrefix";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-SCHEDULER-NAME-PREFIX--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="BSW-MODULE-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-CALLED-ENTITY"/>
         <xsd:enumeration value="BSW-INTERRUPT-ENTITY"/>
         <xsd:enumeration value="BSW-MODULE-ENTITY"/>
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswInterfaces::BswModuleEntry -->
   <xsd:group name="BSW-MODULE-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This class represents a single API entry (C-function prototype) into the BSW module or cluster.

      The name of the C-function is equal to the short name of this element with one exception: In case of multiple instances of a module on the same CPU, special rules for "infixes" apply, see description of class BswImplementation.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BswModuleEntrys";mmt.qualifiedName="BswModuleEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Refers to the service identifier of the Standardized Interfaces of AUTOSAR basic software. For non-standardized interfaces, it can optionally be used for proprietary identification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.serviceId";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROLE" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Specifies the role of the entry in the given context. It shall be equal to the standardized name of the service call, especially in cases where no ServiceIdentifier is specified, e.g. for callbacks. Note that the ShortName is not always sufficient because it maybe vendor specific (e.g. for callbacks which can have more than one instance).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.role";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-REENTRANT" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>True: Enables the service to be invoked again, before the service has finished. 
            false: It is prohibited to invoke the service again before is has finished.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.isReentrant";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="15"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-SYNCHRONOUS" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>True: This calls a synchronous service, i.e. the service is completed when the call returns.
            false: The service (on semantical level) may not be complete when the call returns.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.isSynchronous";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALL-TYPE" type="AR:BSW-CALL-TYPE">
            <xsd:annotation>
               <xsd:documentation>The type of call associated with this service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.callType";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="25"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTION-CONTEXT" type="AR:BSW-EXECUTION-CONTEXT">
            <xsd:annotation>
               <xsd:documentation>Specifies the execution context which is required (in case of entries into this module) or guaranteed (in case of entries called from this module) for this service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.executionContext";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SERVICE-IMPL-POLICY" type="AR:SW-SERVICE-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Denotes the implementation policy as a standard function call, inline function or macro. This has to be specified on interface level because it determines the signature of the call.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.swServiceImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="35"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RETURN-TYPE" type="AR:SW-SERVICE-ARG">
            <xsd:annotation>
               <xsd:documentation>The return type belonging to this bswModuleEntry.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.returnType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENTS">
            <xsd:annotation>
               <xsd:documentation>An argument belonging to this BswModuleEntry.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.argument";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="45"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-SERVICE-ARG" type="AR:SW-SERVICE-ARG"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswInterfaces::BswModuleEntry -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This class represents a single API entry (C-function prototype) into the BSW module or cluster.

      The name of the C-function is equal to the short name of this element with one exception: In case of multiple instances of a module on the same CPU, special rules for "infixes" apply, see description of class BswImplementation.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BswModuleEntrys";mmt.qualifiedName="BswModuleEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:BSW-MODULE-ENTRY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-MODULE-ENTRY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-MODULE-ENTRY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswInterfaces::BswModuleEntryRefConditional -->
   <xsd:group name="BSW-MODULE-ENTRY-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-ENTRY-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswInterfaces::BswModuleEntryRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-ENTRY-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BSW-MODULE-ENTRY-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::BswModuleTiming -->
   <xsd:group name="BSW-MODULE-TIMING">
      <xsd:annotation>
         <xsd:documentation>A model element used to define timing descriptions and constraints for the BswInternalBehavior of one BSW Module. Thereby, for each BswInternalBehavior a separate timing can be specified.

      A constraint defined at this level holds true for all Implementations of that BswInternalBehavior.

      TimingDescriptions aggregated by BswModuleTiming are restricted to event chains referring to events which are derived from the class TDEventBswInternalBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="BswModuleTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BEHAVIOR-REF">
            <xsd:annotation>
               <xsd:documentation>This defines the scope of a BswModuleTiming. All corresponding timing descriptions and constraints must be defined within this scope.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleTiming.behavior";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-INTERNAL-BEHAVIOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::BswModuleTiming -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-TIMING">
      <xsd:annotation>
         <xsd:documentation>A model element used to define timing descriptions and constraints for the BswInternalBehavior of one BSW Module. Thereby, for each BswInternalBehavior a separate timing can be specified.

      A constraint defined at this level holds true for all Implementations of that BswInternalBehavior.

      TimingDescriptions aggregated by BswModuleTiming are restricted to event chains referring to events which are derived from the class TDEventBswInternalBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="BswModuleTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:TIMING-EXTENSION"/>
         <xsd:group ref="AR:BSW-MODULE-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswSchedulableEntity -->
   <xsd:group name="BSW-SCHEDULABLE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed for control by the BSW Scheduler. It implements a so-called "main" function.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswSchedulableEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswSchedulableEntity -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-SCHEDULABLE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed for control by the BSW Scheduler. It implements a so-called "main" function.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswSchedulableEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTABLE-ENTITY"/>
         <xsd:group ref="AR:BSW-MODULE-ENTITY"/>
         <xsd:group ref="AR:BSW-SCHEDULABLE-ENTITY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-SCHEDULABLE-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswSchedulerNamePrefix -->
   <xsd:group name="BSW-SCHEDULER-NAME-PREFIX">
      <xsd:annotation>
         <xsd:documentation>A prefix to be used in names of generated code artifacts which make up the interface of a BSW module to the BswScheduler.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswSchedulerNamePrefix"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswSchedulerNamePrefix -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-SCHEDULER-NAME-PREFIX">
      <xsd:annotation>
         <xsd:documentation>A prefix to be used in names of generated code artifacts which make up the interface of a BSW module to the BswScheduler.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswSchedulerNamePrefix"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:IMPLEMENTATION-PROPS"/>
         <xsd:group ref="AR:BSW-SCHEDULER-NAME-PREFIX"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-SCHEDULER-NAME-PREFIX--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-SCHEDULER-NAME-PREFIX"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswServiceDependency -->
   <xsd:group name="BSW-SERVICE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>Specialization of ServiceDependency in the context of an BswInternalBehavior. It allows to associate BswModuleEntries and data defined for a BSW module or cluster to a given ServiceNeeds element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswServiceDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-DATAS">
            <xsd:annotation>
               <xsd:documentation>Defines the role of an associated data object (owned by this module or cluster) in the context of the ServiceNeeds element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswServiceDependency.assignedData";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-DATA-ASSIGNMENT" type="AR:ROLE-BASED-DATA-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-ENTRY-ROLES">
            <xsd:annotation>
               <xsd:documentation>Defines the role of an associated BswModuleEntry in the context of the ServiceNeeds element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswServiceDependency.assignedEntryRole";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-BSW-MODULE-ENTRY-ASSIGNMENT" type="AR:ROLE-BASED-BSW-MODULE-ENTRY-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-NEEDS">
            <xsd:annotation>
               <xsd:documentation>The associated ServiceNeeds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswServiceDependency.serviceNeeds";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="BSW-MGR-NEEDS" type="AR:BSW-MGR-NEEDS"/>
                  <xsd:element name="COM-MGR-USER-NEEDS" type="AR:COM-MGR-USER-NEEDS"/>
                  <xsd:element name="CRYPTO-SERVICE-NEEDS" type="AR:CRYPTO-SERVICE-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS" type="AR:DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-EVENT-MANAGER-NEEDS" type="AR:DIAGNOSTIC-EVENT-MANAGER-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-EVENT-NEEDS" type="AR:DIAGNOSTIC-EVENT-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-IO-CONTROL-NEEDS" type="AR:DIAGNOSTIC-IO-CONTROL-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-ROUTINE-NEEDS" type="AR:DIAGNOSTIC-ROUTINE-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-VALUE-NEEDS" type="AR:DIAGNOSTIC-VALUE-NEEDS"/>
                  <xsd:element name="DLT-USER-NEEDS" type="AR:DLT-USER-NEEDS"/>
                  <xsd:element name="ECU-STATE-MGR-USER-NEEDS" type="AR:ECU-STATE-MGR-USER-NEEDS"/>
                  <xsd:element name="FUNCTION-INHIBITION-NEEDS" type="AR:FUNCTION-INHIBITION-NEEDS"/>
                  <xsd:element name="NV-BLOCK-NEEDS" type="AR:NV-BLOCK-NEEDS"/>
                  <xsd:element name="OBD-CONTROL-SERVICE-NEEDS" type="AR:OBD-CONTROL-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-INFO-SERVICE-NEEDS" type="AR:OBD-INFO-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-MONITOR-SERVICE-NEEDS" type="AR:OBD-MONITOR-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-PID-SERVICE-NEEDS" type="AR:OBD-PID-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-RATIO-SERVICE-NEEDS" type="AR:OBD-RATIO-SERVICE-NEEDS"/>
                  <xsd:element name="SUPERVISED-ENTITY-NEEDS" type="AR:SUPERVISED-ENTITY-NEEDS"/>
                  <xsd:element name="SYNC-TIME-BASE-MGR-USER-NEEDS" type="AR:SYNC-TIME-BASE-MGR-USER-NEEDS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswServiceDependency -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-SERVICE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>Specialization of ServiceDependency in the context of an BswInternalBehavior. It allows to associate BswModuleEntries and data defined for a BSW module or cluster to a given ServiceNeeds element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswServiceDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SERVICE-DEPENDENCY"/>
         <xsd:group ref="AR:BSW-SERVICE-DEPENDENCY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswTimingEvent -->
   <xsd:group name="BSW-TIMING-EVENT">
      <xsd:annotation>
         <xsd:documentation>A recurring BswEvent driven by a time period.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswTimingEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PERIOD" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Requirement for the time period (in seconds) by which this event is triggered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswTimingEvent.period";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswTimingEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-TIMING-EVENT">
      <xsd:annotation>
         <xsd:documentation>A recurring BswEvent driven by a time period.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswTimingEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-EVENT"/>
         <xsd:group ref="AR:BSW-TIMING-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswTriggerDirectImplementation -->
   <xsd:group name="BSW-TRIGGER-DIRECT-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Specifies a released trigger to be directly implemented via OS calls, for example in a complex driver module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswTriggerDirectImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASTERED-TRIGGER-REF">
            <xsd:annotation>
               <xsd:documentation>The trigger which is directly mastered by this module.

            There may be several different BswTriggerDirectImplementations mastering the same Trigger. This may be required e.g. due to memory partitioning.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswTriggerDirectImplementation.masteredTrigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TASK" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>The name of the OS task, which is controlled by the referred trigger. This means, that the module uses the trigger condition to directly activate an OS task instead of calling an API of the BswScheduler. The task name is required by the RTE generator resp. BswScheduler to raise the appropriate events in components or modules receiving the trigger.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswTriggerDirectImplementation.task";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswTriggerDirectImplementation -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-TRIGGER-DIRECT-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Specifies a released trigger to be directly implemented via OS calls, for example in a complex driver module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswTriggerDirectImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BSW-TRIGGER-DIRECT-IMPLEMENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EventTriggeringConstraint::BurstPatternEventTriggering -->
   <xsd:group name="BURST-PATTERN-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>A BurstPatternEventTriggering describes the maximum number of occurrences of the same event in a given time interval.
      This is typically used to model a worst case activation scenario.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BurstPatternEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-OCCURRENCES" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The maximum number of event occurrences within the given time interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BurstPatternEventTriggering.maxNumberOfOccurrences";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-INTER-ARRIVAL-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The parameter Minimum Inter-Arrival Time specifies the minimum distance between subsequent occurrences of the event within the given time interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BurstPatternEventTriggering.minimumInterArrivalTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PATTERN-JITTER" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The optional parameter Pattern Jitter specifies the deviation of the time intervals starting point from the beginning of the given period. This parameter is only applicable in conjunction with the parameter Pattern Period.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="patternJitter.BurstPatternEventTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PATTERN-LENGTH" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The parameter Pattern Length specifies the duration of the time interval within which the event repeatedly occurs. The event occurs at arbitrary points in time within the given time interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BurstPatternEventTriggering.patternLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PATTERN-PERIOD" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The optional parameter Pattern Period specifies the time distance between the beginnings of subsequent repetitions of the given burst pattern.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="patternPeriod.BurstPatternEventTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-NUMBER-OF-OCCURRENCES" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The minimum number of event occurrences within the given time interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BurstPatternEventTriggering.minNumberOfOccurrences";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EventTriggeringConstraint::BurstPatternEventTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="BURST-PATTERN-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>A BurstPatternEventTriggering describes the maximum number of occurrences of the same event in a given time interval.
      This is typically used to model a worst case activation scenario.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BurstPatternEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:EVENT-TRIGGERING-CONSTRAINT"/>
         <xsd:group ref="AR:BURST-PATTERN-EVENT-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::BusspecificNmEcu -->
   <xsd:group name="BUSSPECIFIC-NM-ECU">
      <xsd:annotation>
         <xsd:documentation>Busspecific NmEcu attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BusspecificNmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:complexType name="C-IDENTIFIER">
      <xsd:annotation>
         <xsd:documentation>This datatype represents a string, that follows the rules of C-identifiers.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CIdentifier";xml.xsd.customType="C-IDENTIFIER";xml.xsd.pattern="[a-zA-Z_][a-zA-Z0-9_]*";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:C-IDENTIFIER--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:C-IDENTIFIER"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- attribute group for class C-IDENTIFIER -->
   <xsd:attributeGroup name="C-IDENTIFIER">
      <xsd:annotation/>
      <xsd:attribute name="NAME-PATTERN" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute represents a pattern which shall be used to define the value of the identifier if the CIdentifier in question is part of a blueprint. 

         For more details refer to TPS_StandardizationTemplate.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="CIdentifier.namePattern";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <xsd:simpleType name="C-IDENTIFIER--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[a-zA-Z_][a-zA-Z0-9_]*"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CalibrationParameterValues::CalibrationParameterValue -->
   <xsd:group name="CALIBRATION-PARAMETER-VALUE">
      <xsd:annotation>
         <xsd:documentation>Specifies instance specific calibration parameter values used to initialize the memory objects implementing calibration parameters in the generated RTE code.

      RTE generator will use the implInitValue to override the initial values specified for the DataPrototypes of a component type. 

      The applInitValue is used to exchange init values with the component vendor not publishing the transformation algorithm between ApplicationDataTypes and ImplementationDataTypes or defining a instance specific initialization of components which are only defined with ApplicationDataTypes.

      Note: If both representations of init values are available these need to represent the same content.

      Note further that in this case an explicit mapping of ValueSpecification is not implemented because calibration parameters are delivered back after the calibration phase.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationParameterValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPL-INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>This is the initial value specification structured according to the ApplicationDataType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationParameterValue.applInitValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPL-INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>This is the initial value specification structured according to the ImplementationDataType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationParameterValue.implInitValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INITIALIZED-PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the parameter that is initilaized by the CalibrationParameterValue.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationParameterValue.initializedParameter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLAT-INSTANCE-DESCRIPTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationParameterValues::CalibrationParameterValue -->
   <xsd:complexType abstract="false" mixed="false" name="CALIBRATION-PARAMETER-VALUE">
      <xsd:annotation>
         <xsd:documentation>Specifies instance specific calibration parameter values used to initialize the memory objects implementing calibration parameters in the generated RTE code.

      RTE generator will use the implInitValue to override the initial values specified for the DataPrototypes of a component type. 

      The applInitValue is used to exchange init values with the component vendor not publishing the transformation algorithm between ApplicationDataTypes and ImplementationDataTypes or defining a instance specific initialization of components which are only defined with ApplicationDataTypes.

      Note: If both representations of init values are available these need to represent the same content.

      Note further that in this case an explicit mapping of ValueSpecification is not implemented because calibration parameters are delivered back after the calibration phase.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationParameterValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CALIBRATION-PARAMETER-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameterValues::CalibrationParameterValueSet -->
   <xsd:group name="CALIBRATION-PARAMETER-VALUE-SET">
      <xsd:annotation>
         <xsd:documentation>Specification of a constant that can be part of a package, i.e. it can be defined stand-alone.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CalibrationParameterValueSets";mmt.qualifiedName="CalibrationParameterValueSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALIBRATION-PARAMETER-VALUES">
            <xsd:annotation>
               <xsd:documentation>This represents single CalibrationParameterValues in the CalibrationParameterValueSet.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationParameterValueSet.calibrationParameterValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CALIBRATION-PARAMETER-VALUE" type="AR:CALIBRATION-PARAMETER-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationParameterValues::CalibrationParameterValueSet -->
   <xsd:complexType abstract="false" mixed="false" name="CALIBRATION-PARAMETER-VALUE-SET">
      <xsd:annotation>
         <xsd:documentation>Specification of a constant that can be part of a package, i.e. it can be defined stand-alone.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CalibrationParameterValueSets";mmt.qualifiedName="CalibrationParameterValueSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:CALIBRATION-PARAMETER-VALUE-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CALIBRATION-PARAMETER-VALUE-SET--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CALIBRATION-PARAMETER-VALUE-SET"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CanTopology::CanCluster -->
   <xsd:group name="CAN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="CanCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-CLUSTER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-CLUSTER-CONDITIONAL" type="AR:CAN-CLUSTER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanCluster -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="CanCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
         <xsd:group ref="AR:ABSTRACT-CAN-CLUSTER"/>
         <xsd:group ref="AR:CAN-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanClusterConditional -->
   <xsd:group name="CAN-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanClusterConditional -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:ABSTRACT-CAN-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:CAN-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:CAN-CLUSTER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanClusterContent -->
   <xsd:group name="CAN-CLUSTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class CanTopology::CanCommunicationConnector -->
   <xsd:group name="CAN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific communication connector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-CAN-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>CAN Identifier used to configure the CAN Transceiver for partial network wakeup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupCanId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-CAN-ID-EXTENDED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines whether pncWakeupCanId and pncWakeupCanIdMask shall be interpreted as extended or standard CAN ID.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupCanIdExtended";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-CAN-ID-MASK" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Bit mask for CAN Identifier used to configure the CAN Transceiver for partial network wakeup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupCanIdMask";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-DATA-MASK" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Bit mask for CAN Payload used to configure the CAN Transceiver for partial network wakeup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupDataMask";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-DLC" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Data Length of the remote data frame used to configure the CAN Transceiver for partial network wakeup in Bytes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupDlc";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanCommunicationConnector -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific communication connector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:ABSTRACT-CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:CAN-COMMUNICATION-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanCommunicationController -->
   <xsd:group name="CAN-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-COMMUNICATION-CONTROLLER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-COMMUNICATION-CONTROLLER-CONDITIONAL" type="AR:CAN-COMMUNICATION-CONTROLLER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanCommunicationController -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:ABSTRACT-CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:CAN-COMMUNICATION-CONTROLLER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanCommunicationControllerConditional -->
   <xsd:group name="CAN-COMMUNICATION-CONTROLLER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanCommunicationControllerConditional -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-COMMUNICATION-CONTROLLER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:ABSTRACT-CAN-COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:CAN-COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:CAN-COMMUNICATION-CONTROLLER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanCommunicationControllerContent -->
   <xsd:group name="CAN-COMMUNICATION-CONTROLLER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class CanTopology::CanControllerConfiguration -->
   <xsd:group name="CAN-CONTROLLER-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>This element is used for the specification of the exact CAN Bit Timing configuration parameter values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYNC-JUMP-WIDTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The number of quanta in the Synchronization Jump Width, SJW. The (Re-)Synchronization Jump Width (SJW) defines how far a resynchronization may move the Sample Point inside the limits defined by the Phase Buffer Segments to compensate for edge phase errors.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration.syncJumpWidth";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-SEG-1" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The number of quanta before the sampling point.

            The propagation time segment is factored into the timeSeg1 configuration parameter:
            timeSeg1 = tPROP_SEG + tPHASE_SEG1</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration.timeSeg1";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-SEG-2" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The number of quanta after the sampling point:
            timeSeg2 = Phase_Seg2</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration.timeSeg2";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanControllerConfiguration -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-CONTROLLER-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>This element is used for the specification of the exact CAN Bit Timing configuration parameter values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ABSTRACT-CAN-COMMUNICATION-CONTROLLER-ATTRIBUTES"/>
         <xsd:group ref="AR:CAN-CONTROLLER-CONFIGURATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanControllerConfigurationRequirements -->
   <xsd:group name="CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS">
      <xsd:annotation>
         <xsd:documentation>This element allows the specification of ranges for the CAN Bit Timing configuration parameters. These ranges are taken as requirements and have to be respected by the ECU developer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-TIME-QUANTA-PER-BIT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Maximum number of time quanta in the bit time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.maxNumberOfTimeQuantaPerBit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-SAMPLE-POINT" type="AR:FLOAT">
            <xsd:annotation>
               <xsd:documentation>The max. value of the sample point as a percentage of the total bit time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.maxSamplePoint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-SYNC-JUMP-WIDTH" type="AR:FLOAT">
            <xsd:annotation>
               <xsd:documentation>The max. Synchronization Jump Width value as a percentage of the total bit time. The (Re-)Synchronization Jump Width (SJW) defines how far a resynchronization may move the Sample Point inside the limits defined by the Phase Buffer Segments to compensate for edge phase errors.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.maxSyncJumpWidth";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-NUMBER-OF-TIME-QUANTA-PER-BIT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Minimum number of time quanta in the bit time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.minNumberOfTimeQuantaPerBit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-SAMPLE-POINT" type="AR:FLOAT">
            <xsd:annotation>
               <xsd:documentation>The min. value of the sample point as a percentage of the total bit time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.minSamplePoint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-SYNC-JUMP-WIDTH" type="AR:FLOAT">
            <xsd:annotation>
               <xsd:documentation>The min. Synchronization Jump Width value as a percentage of the total bit time. The (Re-)Synchronization Jump Width (SJW) defines how far a resynchronization may move the Sample Point inside the limits defined by the Phase Buffer Segments to compensate for edge phase errors.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.minSyncJumpWidth";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanControllerConfigurationRequirements -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS">
      <xsd:annotation>
         <xsd:documentation>This element allows the specification of ranges for the CAN Bit Timing configuration parameters. These ranges are taken as requirements and have to be respected by the ECU developer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ABSTRACT-CAN-COMMUNICATION-CONTROLLER-ATTRIBUTES"/>
         <xsd:group ref="AR:CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanCommunication::CanFrame -->
   <xsd:group name="CAN-FRAME">
      <xsd:annotation>
         <xsd:documentation>CAN specific Frame element. This element shall also be used for TTCan.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="CanFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class CanCommunication::CanFrame -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-FRAME">
      <xsd:annotation>
         <xsd:documentation>CAN specific Frame element. This element shall also be used for TTCan.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="CanFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:FRAME"/>
         <xsd:group ref="AR:CAN-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CanCommunication::CanFrameTriggering -->
   <xsd:group name="CAN-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>CAN specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ABSOLUTELY-SCHEDULED-TIMINGS">
            <xsd:annotation>
               <xsd:documentation>Each frame in TTCAN is identified by its slot id and communication cycle. A description is provided by the usage of AbsolutelyScheduledTiming.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="absolutelyScheduledTiming.CanFrameTriggering";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TTCAN-ABSOLUTELY-SCHEDULED-TIMING" type="AR:TTCAN-ABSOLUTELY-SCHEDULED-TIMING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-ADDRESSING-MODE" type="AR:CAN-ADDRESSING-MODE-TYPE">
            <xsd:annotation>
               <xsd:documentation>The CAN protocol supports two types of frame formats. The standard frame format uses 11-bit identifiers and is defined in the CAN specification 2.0 A. Additionally the extended frame format allows 29-bit identifiers and is defined in the CAN specification 2.0 B.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanFrameTriggering.canAddressingMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IDENTIFIER" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>To describe a frames identifier on the communication system, usually with a fixed identifierValue. In a complete system description this attribute is mandatory. In an Ecu Extract for the sender of the frame the identifier shall also be provided. In an Ecu Extract for the receiver the identifier attribute shall be ignored if rxIdentifierRange is defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanFrameTriggering.identifier";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RX-IDENTIFIER-RANGE" type="AR:RX-IDENTIFIER-RANGE">
            <xsd:annotation>
               <xsd:documentation>Optional definition of a CanId range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="rxIdentifierRange.CanFrameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanCommunication::CanFrameTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>CAN specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME-TRIGGERING"/>
         <xsd:group ref="AR:CAN-FRAME-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::CanNmCluster -->
   <xsd:group name="CAN-NM-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>Can specific NmCluster attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-BUSLOAD-REDUCTION-ACTIVE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>It determines if bus load reduction for the respective CanNm channel is active or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmBusloadReductionActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CAR-WAKE-UP-BIT-POSITION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Specifies the bit position of the CarWakeUp within the NM-Message.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmCarWakeUpBitPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CAR-WAKE-UP-FILTER-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If this attribute is set to true the CareWakeUp filtering is supported. In this case only the CarWakeUp bit within the NM message with source node identifier nmCarWakeUpFilterNodeId is considered as CarWakeUp request.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmCarWakeUpFilterEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CAR-WAKE-UP-FILTER-NODE-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Source node identifier for CarWakeUp filtering. If CarWakeUp filtering is supported (nmCarWakeUpFilterEnabled), only the CarWakeUp bit within the NM message with source node identifier nmCarWakeUpFilterNodeId is considered as CarWakeUp request.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmCarWakeUpFilterNodeId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CAR-WAKE-UP-RX-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If set to true this attribute enables the support of CarWakeUp bit evaluation in received NM messages.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmCarWakeUpRxEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CBV-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Defines the position of the control bit vector within the NM PDU (Byte positon).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmCbvPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CHANNEL-ACTIVE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This switch determines if the respective CanNm channel is active or not. Indicates whether a particular CanNm channel shall be initialized (TRUE) or not (FALSE).
            If this parameter is set to FALSE the respective NM instance shall not be used during runtime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmChannelActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IMMEDIATE-NM-CYCLE-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Defines the immediate NM PDU cycle time in seconds which is used for nmImmediateNmTransmissions NM PDU transmissions. This parameter is only valid if CanNmImmediateNmTransmissions is greater one.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmImmediateNmCycleTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IMMEDIATE-NM-TRANSMISSIONS" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Defines the number of immediate NM PDUs which shall be transmitted. If the value is zero no immediate NM PDUs are transmitted. The cycle time of immeditate NM PDUs is defined by nmImmediateNmCycleTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmImmediateNmTransmissions";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MESSAGE-TIMEOUT-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout of a NM message in seconds. It determines how long the NM shall wait with notification of transmission failure while communication errors occur on the bus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmMessageTimeoutTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MSG-CYCLE-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Period of a CanNm message in seconds. It determines the periodic rate in the periodic transmission mode with bus load reduction and is the basis for transmit scheduling in the periodic transmission mode without bus load reduction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmMsgCycleTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NETWORK-TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Network Timeout for CanNm PDUs in seconds
            It denotes the time how long the CanNm shall stay in the Network Mode before transition into Prepare Bus-Sleep Mode shall take place.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmNetworkTimeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NID-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Defines the byte position of the source node identifier within the NM PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmNidPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REMOTE-SLEEP-INDICATION-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout for Remote Sleep Indication in seconds. It defines the time how long it shall take to recognize that all other nodes are ready to sleep.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmRemoteSleepIndicationTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MESSAGE-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout for Repeat Message State in seconds. Defines the time how long the NM shall stay in the Repeat Message State.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmRepeatMessageTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-USER-DATA-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Defines the length of the user data contained in the NM Pdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmUserDataLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-WAIT-BUS-SLEEP-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout for bus calm down phase in seconds. It denotes the time how long the CanNm shall stay in the Prepare Bus-Sleep Mode before transition into Bus-Sleep Mode shall take place.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster.nmWaitBusSleepTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::CanNmCluster -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-NM-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>Can specific NmCluster attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanNmCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NM-CLUSTER"/>
         <xsd:group ref="AR:CAN-NM-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CAN-NM-CLUSTER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-NM-CLUSTER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class NetworkManagement::CanNmClusterCoupling -->
   <xsd:group name="CAN-NM-CLUSTER-COUPLING">
      <xsd:annotation>
         <xsd:documentation>CAN attributes that are valid for each of the referenced (coupled) CAN clusters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanNmClusterCoupling"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUPLED-CLUSTER-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to coupled CAN Clusters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmClusterCoupling.coupledCluster";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COUPLED-CLUSTER-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CAN-NM-CLUSTER--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-BUSLOAD-REDUCTION-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables busload reduction support</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmClusterCoupling.nmBusloadReductionEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IMMEDIATE-RESTART-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables the asynchronous transmission of a CanNm PDU upon bus-communication request in Prepare-Bus-Sleep mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmClusterCoupling.nmImmediateRestartEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::CanNmClusterCoupling -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-NM-CLUSTER-COUPLING">
      <xsd:annotation>
         <xsd:documentation>CAN attributes that are valid for each of the referenced (coupled) CAN clusters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanNmClusterCoupling"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:NM-CLUSTER-COUPLING"/>
         <xsd:group ref="AR:CAN-NM-CLUSTER-COUPLING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::CanNmEcu -->
   <xsd:group name="CAN-NM-ECU">
      <xsd:annotation>
         <xsd:documentation>CAN specific attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanNmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MSG-INDICATION-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enable/disable the notification that a RepeatMessageRequest bit has been received. This attribute is deprecated and shall be not used. It will be removed in the future. The nmRepeatMsgIndEnabled attribute in NmEcu shall be used instead.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="CanNmEcu.nmRepeatMsgIndicationEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::CanNmEcu -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-NM-ECU">
      <xsd:annotation>
         <xsd:documentation>CAN specific attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanNmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BUSSPECIFIC-NM-ECU"/>
         <xsd:group ref="AR:CAN-NM-ECU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::CanNmNode -->
   <xsd:group name="CAN-NM-NODE">
      <xsd:annotation>
         <xsd:documentation>CAN specific NM Node attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanNmNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MSG-CYCLE-OFFSET" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Node specific time offset in the periodic transmission node. It determines the start delay of the transmission. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmNode.nmMsgCycleOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MSG-REDUCED-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Node specific bus cycle time in the periodic transmission mode with bus load reduction. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmNode.nmMsgReducedTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-RANGE-CONFIG" type="AR:CAN-NM-RANGE-CONFIG">
            <xsd:annotation>
               <xsd:documentation>Defines the CANID ranges that are used for Nm. 
            This range definition is redundant to the attribute "rxIdentifierRange" of CanFrameTriggering. For backward compatibility reasons this redundancy shall be preserved and both shall be defined. In future this element will be removed from the model.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="nmRangeConfig.CanNmNode";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::CanNmNode -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-NM-NODE">
      <xsd:annotation>
         <xsd:documentation>CAN specific NM Node attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanNmNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NM-NODE"/>
         <xsd:group ref="AR:CAN-NM-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::CanNmRangeConfig -->
   <xsd:group name="CAN-NM-RANGE-CONFIG">
      <xsd:annotation>
         <xsd:documentation>Defines the CANID ranges that are used for Nm. This range definition is redundant to the attribute "rxIdentifierRange" of CanFrameTriggering. For backward compatibility reasons this redundancy shall be preserved and both shall be defined.
      In future this element will be removed from the model.</xsd:documentation>
         <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="CanNmRangeConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-CAN-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Lower CAN Identifier of a receive CAN L-PDU for identifier range definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmRangeConfig.lowerCanId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-CAN-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Upper CAN Identifier of a receive CAN L-PDU for identifier range definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanNmRangeConfig.upperCanId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::CanNmRangeConfig -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-NM-RANGE-CONFIG">
      <xsd:annotation>
         <xsd:documentation>Defines the CANID ranges that are used for Nm. This range definition is redundant to the attribute "rxIdentifierRange" of CanFrameTriggering. For backward compatibility reasons this redundancy shall be preserved and both shall be defined.
      In future this element will be removed from the model.</xsd:documentation>
         <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="CanNmRangeConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CAN-NM-RANGE-CONFIG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanPhysicalChannel -->
   <xsd:group name="CAN-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific physical channel attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class CanTopology::CanPhysicalChannel -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific physical channel attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PHYSICAL-CHANNEL"/>
         <xsd:group ref="AR:ABSTRACT-CAN-PHYSICAL-CHANNEL"/>
         <xsd:group ref="AR:CAN-PHYSICAL-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::CanTpAddress -->
   <xsd:group name="CAN-TP-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpAddress.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS-EXTENSION-VALUE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>If the mixed addressing format is used, this parameter contains the transport protocol address extension value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpAddress.tpAddressExtensionValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::CanTpAddress -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-TP-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:CAN-TP-ADDRESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CAN-TP-ADDRESS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-TP-ADDRESS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::CanTpChannel -->
   <xsd:group name="CAN-TP-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>Configuration parameters of the CanTp channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The id of the channel. The value shall be unique for each channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpChannel.channelId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-MODE" type="AR:CAN-TP-CHANNEL-MODE-TYPE">
            <xsd:annotation>
               <xsd:documentation>The CAN Transport Layer supports half and full duplex channel modes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpChannel.channelMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::CanTpChannel -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-TP-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>Configuration parameters of the CanTp channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:CAN-TP-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CAN-TP-CHANNEL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-TP-CHANNEL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::CanTpConfig -->
   <xsd:group name="CAN-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one CAN TP Configuration. 

      One CanTpConfig element shall be created for each CAN Network in the System.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="CanTpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESSS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpAddress.CanTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-TP-ADDRESS" type="AR:CAN-TP-ADDRESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CHANNELS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpChannel.CanTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-TP-CHANNEL" type="AR:CAN-TP-CHANNEL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>Senders and receivers of CAN TP messages.

            atpVariation: Derived, because TpNode can vary.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpConnection.CanTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-TP-CONNECTION" type="AR:CAN-TP-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ECUS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpEcu.CanTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-TP-ECU" type="AR:CAN-TP-ECU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-NODES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpNode.CanTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-TP-NODE" type="AR:CAN-TP-NODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::CanTpConfig -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one CAN TP Configuration. 

      One CanTpConfig element shall be created for each CAN Network in the System.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="CanTpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:TP-CONFIG"/>
         <xsd:group ref="AR:CAN-TP-CONFIG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::CanTpConnection -->
   <xsd:group name="CAN-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection identifies the sender and the receiver of this particular communication. The CanTp module routes a Pdu through this connection. 

      atpVariation: Derived, because TpNode can vary.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADDRESSING-FORMAT" type="AR:CAN-TP-ADDRESSING-FORMAT-TYPE">
            <xsd:annotation>
               <xsd:documentation>Declares which communication addressing mode is supported.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.addressingFormat";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-TP-CHANNEL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the CanTpChannel on which this CanTpConnection is realized.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.canTpChannel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CAN-TP-CHANNEL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an Data NPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.dataPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the Flow Control NPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.flowControlPdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BLOCK-SIZE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The maximum number of N-PDUs the CanTp receiver allows the sender to send, before waiting for an authorization to continue transmission of the following N-PDUs. For further details on this parameter value see ISO 15765-2 specification.

            Note: For reasons of buffer length, the CAN Transport Layer can adapt the BS value within the limit of this maximum BS</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.maxBlockSize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-REF">
            <xsd:annotation>
               <xsd:documentation>TP address for 1:n connections.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.multicast";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CAN-TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PADDING-ACTIVATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This specifies wheter or not Sfs, FCs and the last CF shall be padded to 8 bytes length in case it contains less payload.

            true:
            The N-PDU received uses padding for SF, FC and the last CF. (N-PDU length is always 8 bytes)

            false:
            The N-PDU received does not use padding for SF, CF and the last CF. (N-PDU length is dynamic)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.paddingActivation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECEIVER-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.receiver";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CAN-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TA-TYPE" type="AR:NETWORK-TARGET-ADDRESS-TYPE">
            <xsd:annotation>
               <xsd:documentation>Network Target Address type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.taType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-BR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Value in seconds of the performance requirement for (N_Br + N_Ar). N_Br is the elapsed time between the receiving indication of a FF or CF or the transmit confirmation of a FC, until the transmit request of the next FC.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.timeoutBr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-BS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the timout for waiting for an FC or AF on the sender side in an 1:1 connection. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.timeoutBs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the timeout value for waiting for a CF or FF-x (in case of retry) after receiving the last CF or after sending an FC or AF on the receiver side. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.timeoutCr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The attribute timeoutCs represents the time (in seconds) which elapses between the transmit request of a CF N-PDU until the transmit request of the next CF N-PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.timeoutCs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an IPdu that is segmented by the Transport Protocol. 

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the CanTpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.tpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMIT-CANCELLATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>With this switch Transmit Cancellation can be turned on or off for this channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.transmitCancellation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMITTER-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection.transmitter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CAN-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::CanTpConnection -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection identifies the sender and the receiver of this particular communication. The CanTp module routes a Pdu through this connection. 

      atpVariation: Derived, because TpNode can vary.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CAN-TP-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::CanTpEcu -->
   <xsd:group name="CAN-TP-ECU">
      <xsd:annotation>
         <xsd:documentation>ECU specific TP configuration parameters. Each TpEcu element has a reference to exactly one ECUInstance in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-TIME-MAIN-FUNCTION" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The period between successive calls to the Main Function of the AUTOSAR TP. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpEcu.cycleTimeMainFunction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Connection to the ECUInstance in the Topology</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpEcu.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::CanTpEcu -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-TP-ECU">
      <xsd:annotation>
         <xsd:documentation>ECU specific TP configuration parameters. Each TpEcu element has a reference to exactly one ECUInstance in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CAN-TP-ECU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::CanTpNode -->
   <xsd:group name="CAN-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTOR-REF">
            <xsd:annotation>
               <xsd:documentation>Asscociation to a CommunicationConnector in the topology description. 
            In a System Description this reference is mandatory. In an ECU Extract this reference is optional (references to ECUs that are not part of the ECU Extract shall be avoided).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode.connector";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FC-WAIT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum number of flow control PDUs that can be consecutively be transmitted by a receiver.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode.maxFcWait";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ST-MIN" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Sets the duration of the minimum time the CanTp sender shall wait between the transmissions of two CF N-PDUs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode.stMin";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute states the timeout between the PDU transmit request of the Transport Layer to the Can Interface and the corresponding confirmation of the Can Interface on the receiver side (for FC or AF). Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode.timeoutAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute states the timeout between the PDU transmit request for the first PDU of the group used in the current connection of the Transport Layer to the Can Interface and the corresponding confirmation of the Can Interface (when having sent the last PDU of the group used in this connection) on the sender side (SF-x, FF-x, CF or FC (in case of Transmit Cancellation)). Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode.timeoutAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the TP Address that is used by the TpNode. This reference is optional in case that the multicast TP Address is used (reference from TpConnection).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CAN-TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::CanTpNode -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:CAN-TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CAN-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BlockElements::Caption -->
   <xsd:group name="CAPTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a caption which is a title, and a shortName.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Caption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class BlockElements::Caption -->
   <xsd:complexType abstract="false" mixed="false" name="CAPTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a caption which is a title, and a shortName.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Caption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:CAPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Chapters::Chapter -->
   <xsd:group name="CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a chapter of a document. Chapters are the primary structuring element in documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Chapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:CHAPTER-MODEL"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Chapters::Chapter -->
   <xsd:attributeGroup name="CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a chapter of a document. Chapters are the primary structuring element in documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Chapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="HELP-ENTRY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies an entry point in an online help system to be linked with the parent class. The syntax must be defined by the applied help system respectively help system generator.

         Maybe it is a concatenated Identifier, but as of now we leave it as an arbitrary string.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Chapter.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Chapters::Chapter -->
   <xsd:complexType abstract="false" mixed="false" name="CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a chapter of a document. Chapters are the primary structuring element in documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Chapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:CHAPTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:CHAPTER"/>
   </xsd:complexType>
   <!-- element group for class Chapters::ChapterContent -->
   <xsd:group name="CHAPTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This class represents the content which is directly in a chapter. It is basically the same as the one in a Topic but might have additional complex structures (e.g. Synopsis)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChapterContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
               <xsd:group ref="AR:TOPIC-CONTENT-OR-MSR-QUERY"/>
            </xsd:choice>
            <xsd:element name="PRMS" type="AR:PRMS">
               <xsd:annotation>
                  <xsd:documentation>This is a parameter table within a chapter.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="ChapterContent.prms";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="150"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class Chapters::ChapterContent -->
   <xsd:complexType abstract="false" mixed="false" name="CHAPTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This class represents the content which is directly in a chapter. It is basically the same as the one in a Topic but might have additional complex structures (e.g. Synopsis)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChapterContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CHAPTER-CONTENT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Chapters::ChapterModel -->
   <xsd:group name="CHAPTER-MODEL">
      <xsd:annotation>
         <xsd:documentation>This is the basic content model of a chapter except the Chapter title. This can be utilized in general chapters as well as in predefined chapters.

      A chapter has content on three levels:

      1. chapter content

      2. topics

      3. subchapters</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChapterModel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:CHAPTER-CONTENT"/>
         </xsd:choice>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:TOPIC-OR-MSR-QUERY"/>
         </xsd:choice>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:CHAPTER-OR-MSR-QUERY"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Chapters::ChapterModel -->
   <xsd:complexType abstract="false" mixed="false" name="CHAPTER-MODEL">
      <xsd:annotation>
         <xsd:documentation>This is the basic content model of a chapter except the Chapter title. This can be utilized in general chapters as well as in predefined chapters.

      A chapter has content on three levels:

      1. chapter content

      2. topics

      3. subchapters</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChapterModel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CHAPTER-MODEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Chapters::ChapterOrMsrQuery -->
   <xsd:group name="CHAPTER-OR-MSR-QUERY">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a particular chapter or a query returning a chapter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChapterOrMsrQuery"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="CHAPTER" type="AR:CHAPTER">
               <xsd:annotation>
                  <xsd:documentation>This establishes a subschapter.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="ChapterOrMsrQuery.chapter";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="210"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="MSR-QUERY-CHAPTER" type="AR:MSR-QUERY-CHAPTER">
               <xsd:annotation>
                  <xsd:documentation>This represents automatically contributed chapters provided by an msrquery.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="ChapterOrMsrQuery.msrQueryChapter";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="220"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class Chapters::ChapterOrMsrQuery -->
   <xsd:complexType abstract="false" mixed="false" name="CHAPTER-OR-MSR-QUERY">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a particular chapter or a query returning a chapter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChapterOrMsrQuery"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CHAPTER-OR-MSR-QUERY"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::ClientComSpec -->
   <xsd:group name="CLIENT-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Client-specific communication attributes (RPortPrototype typed by ClientServerInterface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the corresponding ClientServerOperation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientComSpec.operation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ClientComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Client-specific communication attributes (RPortPrototype typed by ClientServerInterface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:R-PORT-COM-SPEC"/>
         <xsd:group ref="AR:CLIENT-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientIdMapping -->
   <xsd:group name="CLIENT-ID-MAPPING">
      <xsd:annotation>
         <xsd:documentation>In case of a server on one ECU with multiple clients on other ECUs, the client server communication shall use different unique COM signals and signal groups for each client to allow the identification of the client associated with each system signal.

      The ClientId is mapped to the requestGroup and to the responseGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientIdMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the SystemSignal with the ClientID.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientIdMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientIdMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-ID-MAPPING">
      <xsd:annotation>
         <xsd:documentation>In case of a server on one ECU with multiple clients on other ECUs, the client server communication shall use different unique COM signals and signal groups for each client to allow the identification of the client associated with each system signal.

      The ClientId is mapped to the requestGroup and to the responseGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientIdMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CLIENT-ID-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::ClientServerAnnotation -->
   <xsd:group name="CLIENT-SERVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port regarding a certain Operation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the ClientServerOperation that the ClientServerAnnotation corresponds to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerAnnotation.operation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::ClientServerAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port regarding a certain Operation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:CLIENT-SERVER-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerArrayElementMapping -->
   <xsd:group name="CLIENT-SERVER-ARRAY-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The ApplicationArrayElement may be a primitive one or a composite one. If the element is primitive, it will be mapped to the "SystemSignal" (multiplicity 1). If the ArgumentDataPrototype that is referenced by ClientServerCompositeTypeMapping is typed by an ApplicationDataType the reference to the ApplicationArrayElement shall be used. If the VariableDataPrototype is typed by the ImplementationDataType the reference to the ImplementationArrayElement shall be used. 

      If the element is composite, there will be no mapping to the "SystemSignal" (multiplicity 0). In this case the "ArrayElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive array element is mapped the indexed array element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPLEX-TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>This aggregation will be used if the element is  composite.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="complexTypeMapping.ClientServerArrayElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ARRAY-TYPE-MAPPING" type="AR:CLIENT-SERVER-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="CLIENT-SERVER-RECORD-TYPE-MAPPING" type="AR:CLIENT-SERVER-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEXED-ARRAY-ELEMENT" type="AR:INDEXED-ARRAY-ELEMENT">
            <xsd:annotation>
               <xsd:documentation>Reference to an indexed array element in the context of the mappedOperation or in the context of a composite element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="indexedArrayElement.ClientServerArrayElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the primitive ApplicationArrayElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayElementMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerArrayElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-ARRAY-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The ApplicationArrayElement may be a primitive one or a composite one. If the element is primitive, it will be mapped to the "SystemSignal" (multiplicity 1). If the ArgumentDataPrototype that is referenced by ClientServerCompositeTypeMapping is typed by an ApplicationDataType the reference to the ApplicationArrayElement shall be used. If the VariableDataPrototype is typed by the ImplementationDataType the reference to the ImplementationArrayElement shall be used. 

      If the element is composite, there will be no mapping to the "SystemSignal" (multiplicity 0). In this case the "ArrayElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive array element is mapped the indexed array element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CLIENT-SERVER-ARRAY-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerArrayTypeMapping -->
   <xsd:group name="CLIENT-SERVER-ARRAY-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the ApplicationCompositeDataType is an Array, the "ArrayTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Each ApplicationArrayElement must be mapped on a SystemSignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="arrayElementMapping.ClientServerArrayTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ARRAY-ELEMENT-MAPPING" type="AR:CLIENT-SERVER-ARRAY-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerArrayTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-ARRAY-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the ApplicationCompositeDataType is an Array, the "ArrayTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CLIENT-SERVER-COMPOSITE-TYPE-MAPPING"/>
         <xsd:group ref="AR:CLIENT-SERVER-ARRAY-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerCompositeTypeMapping -->
   <xsd:group name="CLIENT-SERVER-COMPOSITE-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Two mappings exist for the composite data types: "ArrayTypeMapping" and "RecordTypeMapping".
      In both, a primitive datatype will be mapped to a system signal. 

      But it is also possible to combine the arrays and the records, so that an "array" could be an element of a "record" and in the same manner a "record" could be an element of an "array". Nesting these data types is also possible.

      If an element of a composite data type is again a composite one, the "CompositeTypeMapping" element will be used one more time (aggregation between the ArrayElementMapping and CompositeTypeMapping or aggregation between the RecordElementMapping and CompositeTypeMapping).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerCompositeTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an argument in the context of the mappedOperation. 
            Only ClientServerCompositeTypeMapping elements that are directly aggregated by the ClientServerToSignalGroupMapping shall contain this reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerCompositeTypeMapping.argument";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ARGUMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class PortInterface::ClientServerInterface -->
   <xsd:group name="CLIENT-SERVER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A client/server interface declares a number of operations that can be invoked on a server by a client.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="ClientServerInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:documentation>ClientServerOperation(s) of this ClientServerInterface.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="BlueprintDerivationTime";mmt.qualifiedName="operation.interface";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-OPERATION" type="AR:CLIENT-SERVER-OPERATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POSSIBLE-ERRORS">
            <xsd:annotation>
               <xsd:documentation>Application errors that are defined as part of this interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="possibleError.ClientServerInterface";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-ERROR" type="AR:APPLICATION-ERROR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ClientServerInterface -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A client/server interface declares a number of operations that can be invoked on a server by a client.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="ClientServerInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:CLIENT-SERVER-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ClientServerInterfaceMapping -->
   <xsd:group name="CLIENT-SERVER-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of ClientServerOperations in context of two different ClientServerInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Mapping of two ClientServerOperations in two different ClientServerInterfaces</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operationMapping.ClientServerInterfaceMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-OPERATION-MAPPING" type="AR:CLIENT-SERVER-OPERATION-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ClientServerInterfaceMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of ClientServerOperations in context of two different ClientServerInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-INTERFACE-MAPPING"/>
         <xsd:group ref="AR:CLIENT-SERVER-INTERFACE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ClientServerOperation -->
   <xsd:group name="CLIENT-SERVER-OPERATION">
      <xsd:annotation>
         <xsd:documentation>An operation declared within the scope of a client/server interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerOperation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENTS">
            <xsd:annotation>
               <xsd:documentation>The argument of this operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="argument.ClientServerOperation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ARGUMENT-DATA-PROTOTYPE" type="AR:ARGUMENT-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POSSIBLE-ERROR-REFS">
            <xsd:annotation>
               <xsd:documentation>Possible errors that may by raised by referring operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerOperation.possibleError";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="POSSIBLE-ERROR-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:APPLICATION-ERROR--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ClientServerOperation -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-OPERATION">
      <xsd:annotation>
         <xsd:documentation>An operation declared within the scope of a client/server interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerOperation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:CLIENT-SERVER-OPERATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CLIENT-SERVER-OPERATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLIENT-SERVER-OPERATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortInterface::ClientServerOperationMapping -->
   <xsd:group name="CLIENT-SERVER-OPERATION-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two particular ClientServerOperations in context of two different ClientServerInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerOperationMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Defines the mapping of two particular ArgumentDataPrototypes with unequal names or unequal semantic (resolution or range) in context of Operations.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="argumentMapping.ClientServerOperationMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-PROTOTYPE-MAPPING" type="AR:DATA-PROTOTYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIRST-OPERATION-REF">
            <xsd:annotation>
               <xsd:documentation>First to be mapped ClientServerOperation of a ClientServerInterface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerOperationMapping.firstOperation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECOND-OPERATION-REF">
            <xsd:annotation>
               <xsd:documentation>Second to be mapped ClientServerOperation of a ClientServerInterface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerOperationMapping.secondOperation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ClientServerOperationMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-OPERATION-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two particular ClientServerOperations in context of two different ClientServerInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerOperationMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CLIENT-SERVER-OPERATION-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerPrimitiveTypeMapping -->
   <xsd:group name="CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of an argument with a primitive datatype to a signal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerPrimitiveTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an argument in the context of the mappedOperation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerPrimitiveTypeMapping.argument";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ARGUMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the argument</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerPrimitiveTypeMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerPrimitiveTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of an argument with a primitive datatype to a signal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerPrimitiveTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerRecordElementMapping -->
   <xsd:group name="CLIENT-SERVER-RECORD-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a primitive record element to a SystemSignal. If the ArgumentDataPrototype that is referenced by ClientServerCompositeTypeMapping is typed by an ApplicationDataType the reference to the ApplicationRecordElement shall be used. If the VariableDataPrototype is typed by the ImplementationDataType the reference to the ImplementationRecordElement shall be used. 

      If the element is composite, there will be no mapping (multiplicity 0). In this case the "RecordElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive record element is mapped the record element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPLICATION-RECORD-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a applicationRecordElement in the context of the mappedOperation or in the context of a composite element. This reference shall only be used if the ArgumentDataPrototype that is referenced by the ClientServerCompositeTypeMapping is typed by an ApplicationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping.applicationRecordElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-RECORD-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPLEX-TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>This aggregation will be used if the element is  composite.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="complexTypeMapping.ClientServerRecordElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ARRAY-TYPE-MAPPING" type="AR:CLIENT-SERVER-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="CLIENT-SERVER-RECORD-TYPE-MAPPING" type="AR:CLIENT-SERVER-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-RECORD-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a ImplementationRecordElement in the context of the mappedOperation or in the context of a composite element. This reference shall only be used if the ArgumentDataPrototype that is referenced by the ClientServerCompositeTypeMapping is typed by an ImplementationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping.implementationRecordElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the primitive ApplicationRecordElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerRecordElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-RECORD-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a primitive record element to a SystemSignal. If the ArgumentDataPrototype that is referenced by ClientServerCompositeTypeMapping is typed by an ApplicationDataType the reference to the ApplicationRecordElement shall be used. If the VariableDataPrototype is typed by the ImplementationDataType the reference to the ImplementationRecordElement shall be used. 

      If the element is composite, there will be no mapping (multiplicity 0). In this case the "RecordElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive record element is mapped the record element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CLIENT-SERVER-RECORD-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerRecordTypeMapping -->
   <xsd:group name="CLIENT-SERVER-RECORD-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the ApplicationCompositeDataType is a Record, the "RecordTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECORD-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Each ApplicationRecordElement must be mapped on a SystemSignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="recordElementMapping.ClientServerRecordTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-RECORD-ELEMENT-MAPPING" type="AR:CLIENT-SERVER-RECORD-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerRecordTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-RECORD-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the ApplicationCompositeDataType is a Record, the "RecordTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CLIENT-SERVER-COMPOSITE-TYPE-MAPPING"/>
         <xsd:group ref="AR:CLIENT-SERVER-RECORD-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerToSignalGroupMapping -->
   <xsd:group name="CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of client server operation arguments to signals of a signal group. Arguments with a primitive datatype will be mapped via the "ClientServerPrimitiveTypeMapping" element. 
      Arguments with composite datatypes will be mapped via the "CompositeTypeMapping" element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPLICATION-ERROR" type="AR:APPLICATION-ERROR-MAPPING">
            <xsd:annotation>
               <xsd:documentation>In client server communication, the server may return any value within the application error range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="applicationError.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLIENT-ID" type="AR:CLIENT-ID-MAPPING">
            <xsd:annotation>
               <xsd:documentation>In case of a server on one ECU with multiple clients on other ECUs, the client server communication shall use different unique COM signals and signal groups for each client to allow the identification of the client associated with each system signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="clientID.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPOSITE-TYPE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Mapping of arguments with composite datatypes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="compositeTypeMapping.ClientServerToSignalGroupMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ARRAY-TYPE-MAPPING" type="AR:CLIENT-SERVER-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="CLIENT-SERVER-RECORD-TYPE-MAPPING" type="AR:CLIENT-SERVER-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EMPTY-SIGNAL" type="AR:EMPTY-SIGNAL-MAPPING">
            <xsd:annotation>
               <xsd:documentation>An emptySignal is created if no actual data is configured for a client-server communication, but if the RTE shall send a SignalGroup to initiate the communication.
            An EmptySignalMapping shall only reference a SystemSignal that is referenced by an ISignal with length equal to zero.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="emptySignal.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPED-OPERATION-IREF" type="AR:OPERATION-IN-SYSTEM-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a Operation, which is mapped to a signal group.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="mappedOperation.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PRIMITIVE-TYPE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Mapping of an argument with a primitive datatype to a signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="primitiveTypeMapping.ClientServerToSignalGroupMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING" type="AR:CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUEST-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the signal group which contains the references to request signals used to transport the IN and INOUT arguments of the operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping.requestGroup";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESPONSE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the signal group which contains the references to response signals used to transport the OUT and INOUT arguments of the operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping.responseGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEQUENCE-COUNTER" type="AR:SEQUENCE-COUNTER-MAPPING">
            <xsd:annotation>
               <xsd:documentation>The purpose of sequence counters is to map a response to the correct request of a known client.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="sequenceCounter.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerToSignalGroupMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of client server operation arguments to signals of a signal group. Arguments with a primitive datatype will be mapped via the "ClientServerPrimitiveTypeMapping" element. 
      Arguments with composite datatypes will be mapped via the "CompositeTypeMapping" element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DATA-MAPPING"/>
         <xsd:group ref="AR:CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Implementation::Code -->
   <xsd:group name="CODE">
      <xsd:annotation>
         <xsd:documentation>A generic code descriptor. The type of the code (source or object) is defined via the category attribute of the associated engineering object.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Code"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARTIFACT-DESCRIPTORS">
            <xsd:annotation>
               <xsd:documentation>Refers to the artifact belonging to this code descriptor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Code.artifactDescriptor";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AUTOSAR-ENGINEERING-OBJECT" type="AR:AUTOSAR-ENGINEERING-OBJECT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::Code -->
   <xsd:complexType abstract="false" mixed="false" name="CODE">
      <xsd:annotation>
         <xsd:documentation>A generic code descriptor. The type of the code (source or object) is defined via the category attribute of the associated engineering object.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Code"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:CODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ElementCollection::CollectableElement -->
   <xsd:group name="COLLECTABLE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies the ability to be part of an AUTOSAR collection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CollectableElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="COLLECTABLE-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AR-ELEMENT"/>
         <xsd:enumeration value="AR-PACKAGE"/>
         <xsd:enumeration value="ABSTRACT-CAN-CLUSTER"/>
         <xsd:enumeration value="ALIAS-NAME-SET"/>
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-TYPE"/>
         <xsd:enumeration value="BASE-TYPE"/>
         <xsd:enumeration value="BLUEPRINT-MAPPING-SET"/>
         <xsd:enumeration value="BSW-IMPLEMENTATION"/>
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
         <xsd:enumeration value="BSW-MODULE-ENTRY"/>
         <xsd:enumeration value="BSW-MODULE-TIMING"/>
         <xsd:enumeration value="CALIBRATION-PARAMETER-VALUE-SET"/>
         <xsd:enumeration value="CAN-CLUSTER"/>
         <xsd:enumeration value="CAN-FRAME"/>
         <xsd:enumeration value="CAN-TP-CONFIG"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="COLLECTABLE-ELEMENT"/>
         <xsd:enumeration value="COLLECTION"/>
         <xsd:enumeration value="COMMUNICATION-CLUSTER"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPU-METHOD"/>
         <xsd:enumeration value="CONSTANT-SPECIFICATION"/>
         <xsd:enumeration value="CONSTANT-SPECIFICATION-MAPPING-SET"/>
         <xsd:enumeration value="DATA-CONSTR"/>
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="DATA-TYPE-MAPPING-SET"/>
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="DOCUMENTATION"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECU-INSTANCE"/>
         <xsd:enumeration value="ECU-TIMING"/>
         <xsd:enumeration value="ECUC-DEFINITION-COLLECTION"/>
         <xsd:enumeration value="ECUC-MODULE-CONFIGURATION-VALUES"/>
         <xsd:enumeration value="ECUC-MODULE-DEF"/>
         <xsd:enumeration value="ECUC-VALUE-COLLECTION"/>
         <xsd:enumeration value="END-TO-END-PROTECTION-SET"/>
         <xsd:enumeration value="ETHERNET-CLUSTER"/>
         <xsd:enumeration value="ETHERNET-FRAME"/>
         <xsd:enumeration value="EVALUATED-VARIANT-SET"/>
         <xsd:enumeration value="FIBEX-ELEMENT"/>
         <xsd:enumeration value="FLAT-MAP"/>
         <xsd:enumeration value="FLEXRAY-AR-TP-CONFIG"/>
         <xsd:enumeration value="FLEXRAY-CLUSTER"/>
         <xsd:enumeration value="FLEXRAY-FRAME"/>
         <xsd:enumeration value="FLEXRAY-TP-CONFIG"/>
         <xsd:enumeration value="FRAME"/>
         <xsd:enumeration value="GATEWAY"/>
         <xsd:enumeration value="HW-CATEGORY"/>
         <xsd:enumeration value="HW-ELEMENT"/>
         <xsd:enumeration value="HW-TYPE"/>
         <xsd:enumeration value="I-PDU"/>
         <xsd:enumeration value="I-SIGNAL"/>
         <xsd:enumeration value="I-SIGNAL-GROUP"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU-GROUP"/>
         <xsd:enumeration value="IMPLEMENTATION"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
         <xsd:enumeration value="INTERPOLATION-ROUTINE-MAPPING-SET"/>
         <xsd:enumeration value="J-1939-TP-CONFIG"/>
         <xsd:enumeration value="KEYWORD-SET"/>
         <xsd:enumeration value="LIN-CLUSTER"/>
         <xsd:enumeration value="LIN-EVENT-TRIGGERED-FRAME"/>
         <xsd:enumeration value="LIN-FRAME"/>
         <xsd:enumeration value="LIN-SPORADIC-FRAME"/>
         <xsd:enumeration value="LIN-TP-CONFIG"/>
         <xsd:enumeration value="LIN-UNCONDITIONAL-FRAME"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
         <xsd:enumeration value="MODE-SWITCH-INTERFACE"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="NM-CONFIG"/>
         <xsd:enumeration value="NM-PDU"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="PACKAGEABLE-ELEMENT"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="PDU"/>
         <xsd:enumeration value="PDUR-I-PDU-GROUP"/>
         <xsd:enumeration value="PHYSICAL-DIMENSION"/>
         <xsd:enumeration value="PORT-INTERFACE"/>
         <xsd:enumeration value="PORT-INTERFACE-MAPPING-SET"/>
         <xsd:enumeration value="PORT-PROTOTYPE-BLUEPRINT"/>
         <xsd:enumeration value="POST-BUILD-VARIANT-CRITERION"/>
         <xsd:enumeration value="POST-BUILD-VARIANT-CRITERION-VALUE-SET"/>
         <xsd:enumeration value="PREDEFINED-VARIANT"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-ADDR-METHOD"/>
         <xsd:enumeration value="SW-AXIS-TYPE"/>
         <xsd:enumeration value="SW-BASE-TYPE"/>
         <xsd:enumeration value="SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-RECORD-LAYOUT"/>
         <xsd:enumeration value="SW-SYSTEMCONST"/>
         <xsd:enumeration value="SW-SYSTEMCONSTANT-VALUE-SET"/>
         <xsd:enumeration value="SWC-BSW-MAPPING"/>
         <xsd:enumeration value="SWC-IMPLEMENTATION"/>
         <xsd:enumeration value="SWC-TIMING"/>
         <xsd:enumeration value="SYSTEM"/>
         <xsd:enumeration value="SYSTEM-SIGNAL"/>
         <xsd:enumeration value="SYSTEM-SIGNAL-GROUP"/>
         <xsd:enumeration value="SYSTEM-TIMING"/>
         <xsd:enumeration value="TIMING-EXTENSION"/>
         <xsd:enumeration value="TP-CONFIG"/>
         <xsd:enumeration value="TRIGGER-INTERFACE"/>
         <xsd:enumeration value="TTCAN-CLUSTER"/>
         <xsd:enumeration value="UNIT"/>
         <xsd:enumeration value="UNIT-GROUP"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-PDU"/>
         <xsd:enumeration value="VFB-TIMING"/>
         <xsd:enumeration value="XCP-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ElementCollection::Collection -->
   <xsd:group name="COLLECTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies a collection of elements. A collection can be utilized to express additional aspects for a set of elements. 

      Note that Collection is an ARElement. Therefore it is applicable e.g. for CertifiedVariant, even if this is not obvious.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Collections";mmt.qualifiedName="Collection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>This is an element in the collection. Note that Collection itself is collectable. Therefore collections can be nested.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Collection.element";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:COLLECTABLE-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ElementCollection::Collection -->
   <xsd:complexType abstract="false" mixed="false" name="COLLECTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies a collection of elements. A collection can be utilized to express additional aspects for a set of elements. 

      Note that Collection is an ARElement. Therefore it is applicable e.g. for CertifiedVariant, even if this is not obvious.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Collections";mmt.qualifiedName="Collection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:COLLECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class OasisExchangeTable::Colspec -->
   <xsd:group name="COLSPEC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify the properties of a column in a  table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Colspec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class OasisExchangeTable::Colspec -->
   <xsd:attributeGroup name="COLSPEC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify the properties of a column in a  table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Colspec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ALIGN" type="AR:ALIGN-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies how the cell entries shall be horizontally aligned within the specified column.
         Default is "LEFT"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Colspec.align";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COLNAME" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies the name of the column.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Colspec.colname";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COLNUM" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>column number (allows to sort the columns).</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Colspec.colnum";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COLSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates whether a line should be displayed right of this column in the column specification.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Colspec.colsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COLWIDTH" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Width of the column.
         You can enter absolute values such as 4 cm, 
         or relative values marked with * (e.g.,  2* for column widths double those of other columns with 1*).</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Colspec.colwidth";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ROWSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates whether a line should be displayed at the bottom end of the cells of the column defined in the Colspec.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Colspec.rowsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class OasisExchangeTable::Colspec -->
   <xsd:complexType abstract="false" mixed="false" name="COLSPEC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify the properties of a column in a  table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Colspec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COLSPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:COLSPEC"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ComMgrUserNeeds -->
   <xsd:group name="COM-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Communication Manager for one "user".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-COMM-MODE" type="AR:MAX-COMM-MODE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Maximum communication mode requested by this ComM user.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComMgrUserNeeds.maxCommMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ComMgrUserNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="COM-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Communication Manager for one "user".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:COM-MGR-USER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CommConnectorPort -->
   <xsd:group name="COMM-CONNECTOR-PORT">
      <xsd:annotation>
         <xsd:documentation>The Ecu communication relationship defines which signals, Pdus and frames are actually received and transmitted by this ECU. 

      For each signal, Pdu or Frame that is transmitted or received and used by the Ecu an association between an ISignalPort, IPduPort or FramePort with the corresponding Triggering shall be created. 
      An ISignalPort shall be created only if the corresponding signal is handled by COM (RTE or Signal Gateway). If a Pdu Gateway ECU only routes the Pdu without being interested in the content only a FramePort and an IPduPort needs to be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommConnectorPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-DIRECTION" type="AR:COMMUNICATION-DIRECTION-TYPE">
            <xsd:annotation>
               <xsd:documentation>Communication Direction of the Connector Port (input or output Port).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommConnectorPort.communicationDirection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class SignalPaths::CommonSignalPath -->
   <xsd:group name="COMMON-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The CommonSignalPath describes that two or more SwcToSwcSignals and/or SwcToSwcOperationArguments must take the same way (Signal Path) in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommonSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.CommonSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNALS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcSignals that must take the same way (Signal Path) in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signal.CommonSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::CommonSignalPath -->
   <xsd:complexType abstract="false" mixed="false" name="COMMON-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The CommonSignalPath describes that two or more SwcToSwcSignals and/or SwcToSwcOperationArguments must take the same way (Signal Path) in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommonSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SIGNAL-PATH-CONSTRAINT"/>
         <xsd:group ref="AR:COMMON-SIGNAL-PATH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CommunicationCluster -->
   <xsd:group name="COMMUNICATION-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>The CommunicationCluster is the main element to describe the topological connection of communicating ECUs.

      A cluster describes the ensemble of ECUs, which are linked by a communication medium of arbitrary topology (bus, star, ring, ...). The nodes within the cluster share the same communication protocol, which may be event-triggered, time-triggered or a combination of both.

      A CommunicationCluster aggregates one or more physical channels. All physical channels that are aggregated by a communication cluster  are synchronized with each other.</xsd:documentation>
         <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="CommunicationCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="COMMUNICATION-CLUSTER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ABSTRACT-CAN-CLUSTER"/>
         <xsd:enumeration value="CAN-CLUSTER"/>
         <xsd:enumeration value="COMMUNICATION-CLUSTER"/>
         <xsd:enumeration value="ETHERNET-CLUSTER"/>
         <xsd:enumeration value="FLEXRAY-CLUSTER"/>
         <xsd:enumeration value="LIN-CLUSTER"/>
         <xsd:enumeration value="TTCAN-CLUSTER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreTopology::CommunicationClusterContent -->
   <xsd:group name="COMMUNICATION-CLUSTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNELS">
            <xsd:annotation>
               <xsd:documentation>This relationship defines which channel element belongs to which cluster. A channel must be assigned to exactly one cluster, whereas a cluster may have one or more channels.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="physicalChannel.CommunicationCluster";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-PHYSICAL-CHANNEL" type="AR:CAN-PHYSICAL-CHANNEL"/>
                  <xsd:element name="ETHERNET-PHYSICAL-CHANNEL" type="AR:ETHERNET-PHYSICAL-CHANNEL"/>
                  <xsd:element name="FLEXRAY-PHYSICAL-CHANNEL" type="AR:FLEXRAY-PHYSICAL-CHANNEL"/>
                  <xsd:element name="LIN-PHYSICAL-CHANNEL" type="AR:LIN-PHYSICAL-CHANNEL"/>
                  <xsd:element name="TTCAN-PHYSICAL-CHANNEL" type="AR:TTCAN-PHYSICAL-CHANNEL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTOCOL-NAME" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>The name of the protocol used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.protocolName";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTOCOL-VERSION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>The version of the protocol used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.protocolVersion";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SPEED" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Channels speed in kbps.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.speed";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class CoreTopology::CommunicationConnector -->
   <xsd:group name="COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>The connection between the referencing ECU and the referenced channel via the referenced controller.

      Connectors are used to describe the bus interfaces of the ECUs and to specify the sending/receiving behavior. 
      Each CommunicationConnector has a reference to exactly one communicationController. 

      The communicationController can be referenced by several CommunicationConnector elements. This is important for the FlexRay Bus. FlexRay communicates via two physical channels. But only one controller in an ECU is responsible for both channels. Thus, two connectors (for channel A and for channel B) must reference to the same controller. 

      Note: Several CommunicationConnectors can be assigned to one PhysicalChannel in the scope of one ECU Instance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMM-CONTROLLER-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the communication controller.
            The CommunicationConnector and referenced CommunicationController must be aggregated by the same ECUInstance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector.commController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONTROLLER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-COMM-PORT-INSTANCES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="ecuCommPortInstance.CommunicationConnector";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FRAME-PORT" type="AR:FRAME-PORT"/>
                  <xsd:element name="I-PDU-PORT" type="AR:I-PDU-PORT"/>
                  <xsd:element name="I-SIGNAL-PORT" type="AR:I-SIGNAL-PORT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-GATEWAY-TYPE" type="AR:PNC-GATEWAY-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines if this EcuInstance shall implement the PncGateway functionality on this CommunicationConnector and its respective PhysicalChannel. Several EcuInstances on the same PhysicalChannel can have the PncGateway functionality enabled, but only one of them shall have the pncGatewayType "active".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector.pncGatewayType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="COMMUNICATION-CONNECTOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ABSTRACT-CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="ETHERNET-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="LIN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="TTCAN-COMMUNICATION-CONNECTOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreTopology::CommunicationConnectorRefConditional -->
   <xsd:group name="COMMUNICATION-CONNECTOR-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CONNECTOR-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::CommunicationConnectorRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-CONNECTOR-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CommunicationController -->
   <xsd:group name="COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>The communication controller is a dedicated hardware device by means of which hosts are sending frames to and receiving frames from the communication medium.</xsd:documentation>
         <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="CommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="COMMUNICATION-CONTROLLER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ABSTRACT-CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="ETHERNET-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="LIN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="LIN-MASTER"/>
         <xsd:enumeration value="LIN-SLAVE"/>
         <xsd:enumeration value="TTCAN-COMMUNICATION-CONTROLLER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreTopology::CommunicationControllerContent -->
   <xsd:group name="COMMUNICATION-CONTROLLER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ECUResourceMapping::CommunicationControllerMapping -->
   <xsd:group name="COMMUNICATION-CONTROLLER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>CommunicationControllerMapping specifies the CommunicationPeripheral
      hardware (defined in the ECU Resource Template) to realize the specified CommunicationController in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationControllerMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CONTROLLER-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the CommunicationController in the System Template</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationControllerMapping.communicationController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONTROLLER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-COMMUNICATION-CONTROLLER-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the hwCommunicationController in the ECU Resource Template.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationControllerMapping.hwCommunicationController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceMapping::CommunicationControllerMapping -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-CONTROLLER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>CommunicationControllerMapping specifies the CommunicationPeripheral
      hardware (defined in the ECU Resource Template) to realize the specified CommunicationController in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationControllerMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CommunicationCycle -->
   <xsd:group name="COMMUNICATION-CYCLE">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is sent.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCycle"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class Implementation::Compiler -->
   <xsd:group name="COMPILER">
      <xsd:annotation>
         <xsd:documentation>Specifies the compiler attributes. In case of source code this specifies requirements how the compiler shall be invoked. In case of object code this documents the used compiler settings.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Compiler"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NAME" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Compiler name (like gcc).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compiler.name";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPTIONS" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies the compiler options.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compiler.options";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Vendor of compiler.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compiler.vendor";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VERSION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Exact version of compiler executable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compiler.version";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::Compiler -->
   <xsd:complexType abstract="false" mixed="false" name="COMPILER">
      <xsd:annotation>
         <xsd:documentation>Specifies the compiler attributes. In case of source code this specifies requirements how the compiler shall be invoked. In case of object code this documents the used compiler settings.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Compiler"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPILER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Components::ComplexDeviceDriverSwComponentType -->
   <xsd:group name="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ComplexDeviceDriverSwComponentType is a special AtomicSwComponentType that has direct access to hardware on an ECU and which is therefore linked to a specific ECU or specific hardware. The ComplexDeviceDriverSwComponentType introduces the possibility to link from the software representation to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ComplexDeviceDriverSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference from the ComplexDeviceDriverSwComponentType to the description of the used HwElements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComplexDeviceDriverSwComponentType.hardwareElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HARDWARE-ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-DESCRIPTION-ENTITY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::ComplexDeviceDriverSwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ComplexDeviceDriverSwComponentType is a special AtomicSwComponentType that has direct access to hardware on an ECU and which is therefore linked to a specific ECU or specific hardware. The ComplexDeviceDriverSwComponentType introduces the possibility to link from the software representation to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ComplexDeviceDriverSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::ComponentClustering -->
   <xsd:group name="COMPONENT-CLUSTERING">
      <xsd:annotation>
         <xsd:documentation>Constraint that forces the mapping of all referenced SW component instances to the same ECU</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLUSTERED-COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the components that have to be mapped together.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="clusteredComponent.ComponentClustering";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLUSTERED-COMPONENT-IREF" type="AR:COMPONENT-IN-SYSTEM-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::ComponentClustering -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-CLUSTERING">
      <xsd:annotation>
         <xsd:documentation>Constraint that forces the mapping of all referenced SW component instances to the same ECU</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MAPPING-CONSTRAINT"/>
         <xsd:group ref="AR:COMPONENT-CLUSTERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::ComponentInCompositionInstanceRef -->
   <xsd:group name="COMPONENT-IN-COMPOSITION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>The ComponentInCompositionInstanceRef points to a concrete SwComponentPrototype within a CompositionSwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInCompositionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInCompositionInstanceRef.contextComponent";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInCompositionInstanceRef.targetComponent";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::ComponentInCompositionInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-IN-COMPOSITION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>The ComponentInCompositionInstanceRef points to a concrete SwComponentPrototype within a CompositionSwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInCompositionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:COMPONENT-IN-COMPOSITION-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::ComponentInSystemInstanceRef -->
   <xsd:group name="COMPONENT-IN-SYSTEM-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInSystemInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInSystemInstanceRef.contextComposition";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ROOT-SW-COMPOSITION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInSystemInstanceRef.contextComponent";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInSystemInstanceRef.targetComponent";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::ComponentInSystemInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-IN-SYSTEM-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentInSystemInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:COMPONENT-IN-SYSTEM-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::ComponentSeparation -->
   <xsd:group name="COMPONENT-SEPARATION">
      <xsd:annotation>
         <xsd:documentation>Constraint that forces the two referenced SW components (called A and B in the following) not to be mapped to the same ECU. If a SW component (e.g. A) is a composition, none of the atomic SW components making up the A composition must be mapped together with any of the atomic SW components making up the B composition. Furthermore, A and B must be disjoint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEPARATED-COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>The two components that have to be mapped to different ECUs</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="separatedComponent.ComponentSeparation";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="SEPARATED-COMPONENT-IREF" type="AR:COMPONENT-IN-SYSTEM-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::ComponentSeparation -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-SEPARATION">
      <xsd:annotation>
         <xsd:documentation>Constraint that forces the two referenced SW components (called A and B in the following) not to be mapped to the same ECU. If a SW component (e.g. A) is a composition, none of the atomic SW components making up the A composition must be mapped together with any of the atomic SW components making up the B composition. Furthermore, A and B must be disjoint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MAPPING-CONSTRAINT"/>
         <xsd:group ref="AR:COMPONENT-SEPARATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Composition::CompositionSwComponentType -->
   <xsd:group name="COMPOSITION-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>A CompositionSwComponentType aggregates SwComponentPrototypes (that in turn are typed by SwComponentTypes) as well as SwConnectors for primarily connecting SwComponentPrototypes among each others and towards the surface of the CompositionSwComponentType. By this means hierarchical structures of software-components can be created.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="CompositionSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENTS">
            <xsd:annotation>
               <xsd:documentation>The instantiated components that are part of this composition.
            The aggregation of SwComponentPrototype is subject to variability with the purpose to support the conditional existence of a SwComponentPrototype. Please be aware; if the conditional existence of SwComponentPrototypes is resolved postbuild the deselected SwComponentPrototypes are still contained in the ECUs build but the instances are inactive in in that they are not scheduled by the RTE.

            The aggregation is marked as atpSplitable in order to allow the addition of service components to the ECU extract during the ECU integration.

            The use case for having 0 components owned by the CompositionSwComponentType could be to deliver an empty CompositionSwComponentType to e.g. a supplier for filling the internal structure.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="component.CompositionSwComponentType";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-COMPONENT-PROTOTYPE" type="AR:SW-COMPONENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTORS">
            <xsd:annotation>
               <xsd:documentation>SwConnectors have the principal ability to establish a connection among PortPrototypes. They can have many roles in the context of a CompositionSwComponentType. Details are refined by subclasses.

            The aggregation of SwConnectors is subject to variability with the purpose to support variant data flow.

            The aggregation is marked as atpSplitable in order to allow the extension of the ECU extract with AssemblySwConnectors between ApplicationSwComponentTypes and ServiceSwComponentTypes during the ECU integration.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="connector.composition";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASSEMBLY-SW-CONNECTOR" type="AR:ASSEMBLY-SW-CONNECTOR"/>
                  <xsd:element name="DELEGATION-SW-CONNECTOR" type="AR:DELEGATION-SW-CONNECTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSTANT-VALUE-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the ConstantSpecificationMapping to be applied for initValues of  PPortComSpecs and RPortComSpec.

            Background: when developing subsystems it may happen that ApplicationDataTypes
            are used on the surface of CompositionSwComponentTypes. In this case it would be reasonable to
            be able to also provide the intended mapping to the ImplementationDataTypes. However, this mapping shall be informal and not technically binding for the implementers mainly because the RTE generator is not concerned about the CompositionSwComponentTypes. 

            Rationale: if the mapping of ApplicationDataTypes on the delegated and inner
            PortPrototype matches then the mapping to ImplementationDataTypes is not impacting compatibility.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompositionSwComponentType.constantValueMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONSTANT-VALUE-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CONSTANT-SPECIFICATION-MAPPING-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-TYPE-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the DataTypeMapping to be applied for the used  ApplicationDataTypes in PortInterfaces.

            Background: when developing subsystems it may happen that ApplicationDataTypes are used on the surface of CompositionSwComponentTypes. In this case it would be reasonable to be able to also provide the intended mapping to the ImplementationDataTypes. However, this mapping shall be informal and not technically binding for the implementers mainly because the RTE generator is not concerned about the CompositionSwComponentTypes. 

            Rationale: if the mapping of ApplicationDataTypes on the delegated and inner
            PortPrototype matches then the mapping to ImplementationDataTypes is not impacting compatibility.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompositionSwComponentType.dataTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-TYPE-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:DATA-TYPE-MAPPING-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::CompositionSwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="COMPOSITION-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>A CompositionSwComponentType aggregates SwComponentPrototypes (that in turn are typed by SwComponentTypes) as well as SwConnectors for primarily connecting SwComponentPrototypes among each others and towards the surface of the CompositionSwComponentType. By this means hierarchical structures of software-components can be created.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="CompositionSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:COMPOSITION-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="COMPOSITION-SW-COMPONENT-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ComputationMethod::Compu -->
   <xsd:group name="COMPU">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express one particular computation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Compu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:COMPU-SCALES"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-DEFAULT-VALUE" type="AR:COMPU-CONST">
            <xsd:annotation>
               <xsd:documentation>This property can be used to specify an output value for a conversion formula, if the value to be converted lies outside the plausibility limit. Although this is possible for all conversion formulae, it is especially valid for variables with tabular conversion formulae.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compu.compuDefaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::Compu -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express one particular computation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Compu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuConst -->
   <xsd:group name="COMPU-CONST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the value of a computation method scale is constant.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConst"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:COMPU-CONST-FORMULA-CONTENT"/>
            <xsd:group ref="AR:COMPU-CONST-NUMERIC-CONTENT"/>
            <xsd:group ref="AR:COMPU-CONST-TEXT-CONTENT"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuConst -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-CONST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the value of a computation method scale is constant.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConst"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-CONST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuConstContent -->
   <xsd:group name="COMPU-CONST-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the constant value of the computation method can be numerical or textual.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ComputationMethod::CompuConstFormulaContent -->
   <xsd:group name="COMPU-CONST-FORMULA-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the constant value of the computation method is represented by a variation point. This difference is due to compatibility with ASAM HDO.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstFormulaContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VF" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Value calculated via a system constant. This element is included in every case where parameters should be generated from numerical values during compile time (not runtime!). 

            Thus for example, the influence of the cylinder number on conversion formulae can be introduced in a repeatable manner.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="CompuConstFormulaContent.vf";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuConstFormulaContent -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-CONST-FORMULA-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the constant value of the computation method is represented by a variation point. This difference is due to compatibility with ASAM HDO.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstFormulaContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-CONST-CONTENT"/>
         <xsd:group ref="AR:COMPU-CONST-FORMULA-CONTENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuConstNumericContent -->
   <xsd:group name="COMPU-CONST-NUMERIC-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the constant value of the computation method is a numerical value. It is separated from CompuConstFormulaContent to support compatibility with ASAM HDO.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstNumericContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="V" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This represents the numerical value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstNumericContent.v";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuConstNumericContent -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-CONST-NUMERIC-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the constant value of the computation method is a numerical value. It is separated from CompuConstFormulaContent to support compatibility with ASAM HDO.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstNumericContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-CONST-CONTENT"/>
         <xsd:group ref="AR:COMPU-CONST-NUMERIC-CONTENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuConstTextContent -->
   <xsd:group name="COMPU-CONST-TEXT-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the textual content of a scale.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstTextContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VT" type="AR:VERBATIM-STRING">
            <xsd:annotation>
               <xsd:documentation>This represents a textual constant in the computation method.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstTextContent.vt";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuConstTextContent -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-CONST-TEXT-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the textual content of a scale.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstTextContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-CONST-CONTENT"/>
         <xsd:group ref="AR:COMPU-CONST-TEXT-CONTENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuContent -->
   <xsd:group name="COMPU-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This abstract meta-class represents the various definition means of a computation method.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ComputationMethod::CompuGenericMath -->
   <xsd:group name="COMPU-GENERIC-MATH">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a generic formula expression.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuGenericMath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class ComputationMethod::CompuGenericMath -->
   <xsd:attributeGroup name="COMPU-GENERIC-MATH">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a generic formula expression.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuGenericMath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="LEVEL" type="AR:IDENTIFIER--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Placeholder to describe an indicator of a language level for the mathematics e.g. INFORMAL, ASAMHDO.
         May be refined by particular use-cases.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="CompuGenericMath.level";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class ComputationMethod::CompuGenericMath -->
   <xsd:complexType abstract="false" mixed="true" name="COMPU-GENERIC-MATH">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a generic formula expression.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuGenericMath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:COMPU-GENERIC-MATH"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:COMPU-GENERIC-MATH"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuMethod -->
   <xsd:group name="COMPU-METHOD">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express the relationship between a physical value and the mathematical representation. 

      Note that this is still independent of the technical implementation in data types. It only specifies the formula how the internal value corresponds to its physical pendant.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CompuMethods";mmt.qualifiedName="CompuMethod"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISPLAY-FORMAT" type="AR:DISPLAY-FORMAT-STRING">
            <xsd:annotation>
               <xsd:documentation>This property specifies, how the physical value shall be displayed e.g. in documents or measurement and calibration tools.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod.displayFormat";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>This is the physical unit of the Physical values for which the CompuMethod applies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod.unit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-INTERNAL-TO-PHYS" type="AR:COMPU">
            <xsd:annotation>
               <xsd:documentation>This specifies the computation from internal values to physical values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod.compuInternalToPhys";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-PHYS-TO-INTERNAL" type="AR:COMPU">
            <xsd:annotation>
               <xsd:documentation>This represents the computation from physical values to the internal values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod.compuPhysToInternal";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuMethod -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-METHOD">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express the relationship between a physical value and the mathematical representation. 

      Note that this is still independent of the technical implementation in data types. It only specifies the formula how the internal value corresponds to its physical pendant.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CompuMethods";mmt.qualifiedName="CompuMethod"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:COMPU-METHOD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="COMPU-METHOD--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COMPU-METHOD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ComputationMethod::CompuNominatorDenominator -->
   <xsd:group name="COMPU-NOMINATOR-DENOMINATOR">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to express a polynomial either as Nominator or as Denominator.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuNominatorDenominator"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="V" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>this is the list of polynomial factors. Note that the first vf represents the power=0.  The polynomial is v[0] * x^0 + v[1] * x^1 ...</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="CompuNominatorDenominator.v";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuNominatorDenominator -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-NOMINATOR-DENOMINATOR">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to express a polynomial either as Nominator or as Denominator.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuNominatorDenominator"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-NOMINATOR-DENOMINATOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuRationalCoeffs -->
   <xsd:group name="COMPU-RATIONAL-COEFFS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a rational function by specifying the coefficients of nominator and denominator.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuRationalCoeffs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-NUMERATOR" type="AR:COMPU-NOMINATOR-DENOMINATOR">
            <xsd:annotation>
               <xsd:documentation>This is the numerator of the rational expression.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuRationalCoeffs.compuNumerator";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-DENOMINATOR" type="AR:COMPU-NOMINATOR-DENOMINATOR">
            <xsd:annotation>
               <xsd:documentation>This is the denominator of the expression.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuRationalCoeffs.compuDenominator";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuRationalCoeffs -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-RATIONAL-COEFFS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a rational function by specifying the coefficients of nominator and denominator.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuRationalCoeffs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-RATIONAL-COEFFS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuScale -->
   <xsd:group name="COMPU-SCALE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify one segment of a segmented computation method.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This element specifies a short name for the particular scale. The name can for example be used to derive a programming language identifier.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL" type="AR:C-IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>The symbol, if provided, is used by code generators to get a C identifier for the CompuScale. The name will be used as is for the code generation, therefore it needs to be unique within the generation context.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.symbol";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="25"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>&lt;desc&gt; represents a general but brief description of the object in question.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASK" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>In difference to all the other computational methods every COMPU-SCALE will be applied including the bit MASK. Therefore it is allowed for this type of COMPU-METHOD, that COMPU-SCALES overlap. 

            To calculate the string reverse to a value, the string has to be split and the according value for each substring has to be summed up. The sum is finally transmitted.

            The processing has to be done in order of the COMPU-SCALE elements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.mask";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="35"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-INVERSE-VALUE" type="AR:COMPU-CONST">
            <xsd:annotation>
               <xsd:documentation>This is the inverse value of the constraint. This supports the case that the scale is not reversible per se.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.compuInverseValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:COMPU-SCALE-CONSTANT-CONTENTS"/>
            <xsd:group ref="AR:COMPU-SCALE-RATIONAL-FORMULA"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuScale -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify one segment of a segmented computation method.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-SCALE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuScaleConstantContents -->
   <xsd:group name="COMPU-SCALE-CONSTANT-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that a particular scale of the computation method is constant.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleConstantContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-CONST" type="AR:COMPU-CONST">
            <xsd:annotation>
               <xsd:documentation>This represents the fact that the scale is a constant. The use case is mainly a non interplolated scale. It is a simplification of the fact that a constant scale can also be expressed as Rational Function of oder 0.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleConstantContents.compuConst";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuScaleConstantContents -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALE-CONSTANT-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that a particular scale of the computation method is constant.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleConstantContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-SCALE-CONTENTS"/>
         <xsd:group ref="AR:COMPU-SCALE-CONSTANT-CONTENTS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuScaleContents -->
   <xsd:group name="COMPU-SCALE-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This abstract meta-class represents the content of one particular scale.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ComputationMethod::CompuScaleRationalFormula -->
   <xsd:group name="COMPU-SCALE-RATIONAL-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the computation in this scale is represented as rational term.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleRationalFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-RATIONAL-COEFFS" type="AR:COMPU-RATIONAL-COEFFS">
            <xsd:annotation>
               <xsd:documentation>This specifies the coefficients of the rational fomula.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleRationalFormula.compuRationalCoeffs";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="110"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuScaleRationalFormula -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALE-RATIONAL-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the fact that the computation in this scale is represented as rational term.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleRationalFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-SCALE-CONTENTS"/>
         <xsd:group ref="AR:COMPU-SCALE-RATIONAL-FORMULA"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuScales -->
   <xsd:group name="COMPU-SCALES">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to stepwise express a computation method.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScales"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-SCALES">
            <xsd:annotation>
               <xsd:documentation>This represents one scale within the compu method. Note it is variation in oder to support bluprints of enumerations.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="BlueprintDerivationTime";mmt.qualifiedName="CompuScales.compuScale";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPU-SCALE" type="AR:COMPU-SCALE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuScales -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALES">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to stepwise express a computation method.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScales"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMPU-CONTENT"/>
         <xsd:group ref="AR:COMPU-SCALES"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EventTriggeringConstraint::ConcretePatternEventTriggering -->
   <xsd:group name="CONCRETE-PATTERN-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The ConcretePatternEventTriggering describes the behavior of an event, which occurs following a precisely known pattern.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConcretePatternEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSETS">
            <xsd:annotation>
               <xsd:documentation>The offset for each occurrence of the event in the specified time interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConcretePatternEventTriggering.offset";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.name="TIME-VALUE";xml.roleElement="true";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TIME-VALUE" type="AR:MULTIDIMENSIONAL-TIME"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PATTERN-LENGTH" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The length of the observed time interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConcretePatternEventTriggering.patternLength";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EventTriggeringConstraint::ConcretePatternEventTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="CONCRETE-PATTERN-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The ConcretePatternEventTriggering describes the behavior of an event, which occurs following a precisely known pattern.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConcretePatternEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:EVENT-TRIGGERING-CONSTRAINT"/>
         <xsd:group ref="AR:CONCRETE-PATTERN-EVENT-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::ConditionByFormula -->
   <xsd:group name="CONDITION-BY-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This class represents a condition which is computed based on system constants according to the specified expression. The expected result is a considered as boolean value.

      The result of the expression is interpreted as a condition. 

      * "0" represents "false";  

      * a value greater than zero is considered "true"</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConditionByFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class VariantHandling::ConditionByFormula -->
   <xsd:attributeGroup name="CONDITION-BY-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This class represents a condition which is computed based on system constants according to the specified expression. The expected result is a considered as boolean value.

      The result of the expression is interpreted as a condition. 

      * "0" represents "false";  

      * a value greater than zero is considered "true"</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConditionByFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="BINDING-TIME" type="AR:BINDING-TIME-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute specifies the point in time when condition may be evaluated at earliest. At this point in time all referenced system constants must have a value.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="ConditionByFormula.bindingTime";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class VariantHandling::ConditionByFormula -->
   <xsd:complexType abstract="false" mixed="true" name="CONDITION-BY-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This class represents a condition which is computed based on system constants according to the specified expression. The expected result is a considered as boolean value.

      The result of the expression is interpreted as a condition. 

      * "0" represents "false";  

      * a value greater than zero is considered "true"</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConditionByFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-DEPENDENT-FORMULA"/>
         <xsd:group ref="AR:CONDITION-BY-FORMULA"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:CONDITION-BY-FORMULA"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::ConditionalChangeNad -->
   <xsd:group name="CONDITIONAL-CHANGE-NAD">
      <xsd:annotation>
         <xsd:documentation>Generates an conditional change NAD request. See LIN 2.1 protocol specification for more information.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConditionalChangeNad"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BYTE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Byte Position of Data Byte that should be used for the bitwise XOR with Invert and the bitwise AND with Mask.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConditionalChangeNad.byte";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Byte Position of Id.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConditionalChangeNad.id";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INVERT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Byte Position of Invert.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConditionalChangeNad.invert";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASK" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Byte Position of Mask.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConditionalChangeNad.mask";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NEW-NAD" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The newly assigned NAD value (Byte Position).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConditionalChangeNad.newNad";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::ConditionalChangeNad -->
   <xsd:complexType abstract="false" mixed="false" name="CONDITIONAL-CHANGE-NAD">
      <xsd:annotation>
         <xsd:documentation>Generates an conditional change NAD request. See LIN 2.1 protocol specification for more information.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConditionalChangeNad"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:LIN-CONFIGURATION-ENTRY"/>
         <xsd:group ref="AR:CONDITIONAL-CHANGE-NAD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EventTriggeringConstraint::ConfidenceInterval -->
   <xsd:group name="CONFIDENCE-INTERVAL">
      <xsd:annotation>
         <xsd:documentation>Additionally to the list of measured distances of event occurrences, a confidence interval can be specified for the expected distance of two consecutive event occurrences with a given probability.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConfidenceInterval"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-BOUND" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The lower bound of the expected distance of two consecutive event occurrences.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="lowerBound.ConfidenceInterval";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROPABILITY" type="AR:FLOAT">
            <xsd:annotation>
               <xsd:documentation>The probability for the measured lower and upper bound of the confidence interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConfidenceInterval.propability";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-BOUND" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The upper bound of the expected distance of two consecutive event occurrences.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="upperBound.ConfidenceInterval";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EventTriggeringConstraint::ConfidenceInterval -->
   <xsd:complexType abstract="false" mixed="false" name="CONFIDENCE-INTERVAL">
      <xsd:annotation>
         <xsd:documentation>Additionally to the list of measured distances of event occurrences, a confidence interval can be specified for the expected distance of two consecutive event occurrences with a given probability.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConfidenceInterval"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CONFIDENCE-INTERVAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::ConstantReference -->
   <xsd:group name="CONSTANT-REFERENCE">
      <xsd:annotation>
         <xsd:documentation>Instead of defining this value inline, a constant is referenced.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConstantReference"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSTANT-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced constant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConstantReference.constant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CONSTANT-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ConstantReference -->
   <xsd:complexType abstract="false" mixed="false" name="CONSTANT-REFERENCE">
      <xsd:annotation>
         <xsd:documentation>Instead of defining this value inline, a constant is referenced.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConstantReference"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-SPECIFICATION"/>
         <xsd:group ref="AR:CONSTANT-REFERENCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::ConstantSpecification -->
   <xsd:group name="CONSTANT-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specification of a constant that can be part of a package, i.e. it can be defined stand-alone.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ConstantSpecifications";mmt.qualifiedName="ConstantSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-SPEC">
            <xsd:annotation>
               <xsd:documentation>Specification of an expression leading to a value for this constant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConstantSpecification.valueSpec";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ConstantSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="CONSTANT-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specification of a constant that can be part of a package, i.e. it can be defined stand-alone.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ConstantSpecifications";mmt.qualifiedName="ConstantSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:CONSTANT-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CONSTANT-SPECIFICATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONSTANT-SPECIFICATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Constants::ConstantSpecificationMapping -->
   <xsd:group name="CONSTANT-SPECIFICATION-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class is used to create an association of two ConstantSpecifications. One ConstantSpecification is supposed to be defined in the application domain while the other should be defined in the implementation domain.

      Hence the ConstantSpecificationMapping needs to be used where a ConstantSpecification defined in one domain needs to be associated to a ConstantSpecification in the other domain.

      This information is crucial for the RTE generator.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConstantSpecificationMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPL-CONSTANT-REF">
            <xsd:annotation>
               <xsd:documentation>A ConstantSpecification defined in the application domain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConstantSpecificationMapping.applConstant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CONSTANT-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPL-CONSTANT-REF">
            <xsd:annotation>
               <xsd:documentation>A ConstantSpecification defined in the implementation domain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConstantSpecificationMapping.implConstant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CONSTANT-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ConstantSpecificationMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CONSTANT-SPECIFICATION-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class is used to create an association of two ConstantSpecifications. One ConstantSpecification is supposed to be defined in the application domain while the other should be defined in the implementation domain.

      Hence the ConstantSpecificationMapping needs to be used where a ConstantSpecification defined in one domain needs to be associated to a ConstantSpecification in the other domain.

      This information is crucial for the RTE generator.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConstantSpecificationMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CONSTANT-SPECIFICATION-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::ConstantSpecificationMappingSet -->
   <xsd:group name="CONSTANT-SPECIFICATION-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to map two ConstantSpecifications to each others. One ConstantSpecification is supposed to be described in the application domain and the other should be described in the implementation domain.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ConstantSpecificationMappingSets";mmt.qualifiedName="ConstantSpecificationMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>ConstantSpecificationMappings owned by the ConstantSpecificationMappingSet.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConstantSpecificationMappingSet.mapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONSTANT-SPECIFICATION-MAPPING" type="AR:CONSTANT-SPECIFICATION-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ConstantSpecificationMappingSet -->
   <xsd:complexType abstract="false" mixed="false" name="CONSTANT-SPECIFICATION-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to map two ConstantSpecifications to each others. One ConstantSpecification is supposed to be described in the application domain and the other should be described in the implementation domain.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ConstantSpecificationMappingSets";mmt.qualifiedName="ConstantSpecificationMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:CONSTANT-SPECIFICATION-MAPPING-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CONSTANT-SPECIFICATION-MAPPING-SET--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONSTANT-SPECIFICATION-MAPPING-SET"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ServiceNeeds::CryptoServiceNeeds -->
   <xsd:group name="CRYPTO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the needs on the configuration of the CryptoServiceManager for one ConfigID (see Specification AUTOSAR_SWS_CSM.doc). An instance of this class is used to find out which ports of an SWC belong to this ConfigID.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CryptoServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-KEY-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The maximum length of a cryptographic key, that is used by the SWC or module for this configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CryptoServiceNeeds.maximumKeyLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::CryptoServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="CRYPTO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the needs on the configuration of the CryptoServiceManager for one ConfigID (see Specification AUTOSAR_SWS_CSM.doc). An instance of this class is used to find out which ports of an SWC belong to this ConfigID.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CryptoServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:CRYPTO-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CycleCounter -->
   <xsd:group name="CYCLE-COUNTER">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is send is described by the attribute "cycleCounter".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleCounter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-COUNTER" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The communication cycle where the frame described by this timing is sent. If a timing is given in this way the referencing cluster must specify the NUMBER-OF-CYCLES as upper bound and point of total repetition. 

            This value is incremented at the beginning of each new cycle, ranging from 0 to
            63, and is reset to 0 after a sequence of 64 cycles.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleCounter.CycleCounter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::CycleCounter -->
   <xsd:complexType abstract="false" mixed="false" name="CYCLE-COUNTER">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is send is described by the attribute "cycleCounter".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleCounter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CYCLE"/>
         <xsd:group ref="AR:CYCLE-COUNTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CycleRepetition -->
   <xsd:group name="CYCLE-REPETITION">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is send is described by the
      attributes baseCycle and cycleRepetition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-CYCLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The first communication cycle where the frame is sent.

            This value is incremented at the beginning of each new cycle, ranging from 0 to
            63, and is reset to 0 after a sequence of 64 cycles.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetition.BaseCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-REPETITION" type="AR:CYCLE-REPETITION-TYPE">
            <xsd:annotation>
               <xsd:documentation>The number of communication cycles (after the first cycle) whenever the frame described by this timing is sent again.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetition.CycleRepetition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::CycleRepetition -->
   <xsd:complexType abstract="false" mixed="false" name="CYCLE-REPETITION">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is send is described by the
      attributes baseCycle and cycleRepetition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CYCLE"/>
         <xsd:group ref="AR:CYCLE-REPETITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::CyclicTiming -->
   <xsd:group name="CYCLIC-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a cyclic sending behavior.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CyclicTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-OFFSET" type="AR:TIME-RANGE-TYPE">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the time until first transmission of this I-PDU. This attribute defines the time between Com_IpduGroupStart and the first transmission of the cyclic part of this transmission request for this I-PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="timeOffset.CyclicTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-PERIOD" type="AR:TIME-RANGE-TYPE">
            <xsd:annotation>
               <xsd:documentation>Period of the repetition of cyclic transmissions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="timePeriod.CyclicTiming";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::CyclicTiming -->
   <xsd:complexType abstract="false" mixed="false" name="CYCLIC-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a cyclic sending behavior.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CyclicTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:CYCLIC-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GlobalConstraints::DataConstr -->
   <xsd:group name="DATA-CONSTR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify constraints on data.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="DataConstrs";mmt.qualifiedName="DataConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-CONSTR-RULES">
            <xsd:annotation>
               <xsd:documentation>This is one particular rule within the data constraints.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataConstr.dataConstrRule";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-CONSTR-RULE" type="AR:DATA-CONSTR-RULE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::DataConstr -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-CONSTR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify constraints on data.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="DataConstrs";mmt.qualifiedName="DataConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:DATA-CONSTR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DATA-CONSTR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DATA-CONSTR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class GlobalConstraints::DataConstrRule -->
   <xsd:group name="DATA-CONSTR-RULE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express one specific data constraint rule.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSTR-LEVEL" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute describes the category of a constraint. One of its functions is in the area of constraint violation, where it can be used from a certain level, to produce error messages.

            The lower the level, the more stringent the check. 

            Used to distinguish hard or soft limits;</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule.constrLevel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYS-CONSTRS" type="AR:PHYS-CONSTRS">
            <xsd:annotation>
               <xsd:documentation>Describes the limitiations applicapble on the physical domain (as opposed to the internal domain).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule.physConstrs";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERNAL-CONSTRS" type="AR:INTERNAL-CONSTRS">
            <xsd:annotation>
               <xsd:documentation>Describes the limitiations applicapble on the internal domain (as opposed to the physical domain).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule.internalConstrs";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::DataConstrRule -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-CONSTR-RULE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express one specific data constraint rule.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DATA-CONSTR-RULE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::DataDumpEntry -->
   <xsd:group name="DATA-DUMP-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This service is reserved for initial configuration of a slave node by the slave node supplier and the format of this message is supplier specific.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataDumpEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BYTE-VALUES">
            <xsd:complexType>
               <xsd:choice maxOccurs="5" minOccurs="0">
                  <xsd:element name="BYTE-VALUE" type="AR:INTEGER">
                     <xsd:annotation>
                        <xsd:documentation>Supplier specific format.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="DataDumpEntry.byteValue";pureMM.maxOccurs="5";pureMM.minOccurs="5"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::DataDumpEntry -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-DUMP-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This service is reserved for initial configuration of a slave node by the slave node supplier and the format of this message is supplier specific.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataDumpEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:LIN-CONFIGURATION-ENTRY"/>
         <xsd:group ref="AR:DATA-DUMP-ENTRY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Filter::DataFilter -->
   <xsd:group name="DATA-FILTER">
      <xsd:annotation>
         <xsd:documentation>Base class for data filters. The type of the filter is specified in attribute dataFilterType. Some of the filter types require additional arguments which are specified as attributes of this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-FILTER-TYPE" type="AR:DATA-FILTER-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the type of the filter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter.dataFilterType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASK" type="AR:UNLIMITED-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Mask for old and new value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter.mask";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="AR:UNLIMITED-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Value to specify the upper boundary</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter.max";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="AR:UNLIMITED-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Value to specify the lower boundary</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter.min";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Specifies the initial number of messages to occur before the first message is passed</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter.offset";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PERIOD" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Specifies number of messages to occur before the message is passed again</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter.period";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="X" type="AR:UNLIMITED-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Value to compare with</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter.x";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Filter::DataFilter -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-FILTER">
      <xsd:annotation>
         <xsd:documentation>Base class for data filters. The type of the filter is specified in attribute dataFilterType. Some of the filter types require additional arguments which are specified as attributes of this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataFilter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DATA-FILTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::DataInterface -->
   <xsd:group name="DATA-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>The purpose of this meta-class is to act as an abstract base class for subclasses that share the semantics of being concerned about data (as opposed to e.g. operations).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="DATA-INTERFACE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataMapping::DataMapping -->
   <xsd:group name="DATA-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of port elements (data elements and parameters) to frames and signals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents introductory documentation about the data mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataMapping.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class DataPrototypes::DataPrototype -->
   <xsd:group name="DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Base class for prototypical roles of any data type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This property allows to specify data defintion properties which apply on data prototype level.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototype.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="DATA-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ARRAY-ELEMENT"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-ELEMENT"/>
         <xsd:enumeration value="ARGUMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:enumeration value="DATA-PROTOTYPE"/>
         <xsd:enumeration value="PARAMETER-DATA-PROTOTYPE"/>
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortInterface::DataPrototypeMapping -->
   <xsd:group name="DATA-PROTOTYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two particular VariableDataPrototypes, ParameterDataPrototypes or ArgumentDataPrototypes with unequal names and/or unequal semantic (resolution or range) in context of two different SenderReceiverInterface, NvDataInterface or ParameterInterface or Operations.

      If the semantic is unequal following rules apply:
      The textTableMapping is only applicable if the referred DataPrototypes are typed by AutosarDataType referring to CompuMethods of category TEXTTABLE.

      In the case that the  DataPrototypes are typed by AutosarDataType either referring to CompuMethods of category LINEAR, IDENTICAL or referring to no CompuMethod (which is similar as  IDENTICAL) the linear conversion factor is calculated out of the factorSiToUnit and offsetSiToUnit attributes of the referred Units and the CompuRationalCoeffs of a compuInternalToPhys of the referred  CompuMethods.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIRST-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>First to be mapped DataPrototype in context of a  SenderReceiverInterface, NvDataInterface, ParameterInterface or Operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeMapping.firstDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:AUTOSAR-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECOND-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Second to be mapped DataPrototype in context of a  SenderReceiverInterface, NvDataInterface, ParameterInterface or Operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeMapping.secondDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:AUTOSAR-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>This represents the owned SubelementMapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeMapping.subElementMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SUB-ELEMENT-MAPPING" type="AR:SUB-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEXT-TABLE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Applied TextTableMapping(s)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="textTableMapping.DataPrototypeMapping";pureMM.maxOccurs="2";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="TEXT-TABLE-MAPPING" type="AR:TEXT-TABLE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::DataPrototypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-PROTOTYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two particular VariableDataPrototypes, ParameterDataPrototypes or ArgumentDataPrototypes with unequal names and/or unequal semantic (resolution or range) in context of two different SenderReceiverInterface, NvDataInterface or ParameterInterface or Operations.

      If the semantic is unequal following rules apply:
      The textTableMapping is only applicable if the referred DataPrototypes are typed by AutosarDataType referring to CompuMethods of category TEXTTABLE.

      In the case that the  DataPrototypes are typed by AutosarDataType either referring to CompuMethods of category LINEAR, IDENTICAL or referring to no CompuMethod (which is similar as  IDENTICAL) the linear conversion factor is calculated out of the factorSiToUnit and offsetSiToUnit attributes of the referred Units and the CompuRationalCoeffs of a compuInternalToPhys of the referred  CompuMethods.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DATA-PROTOTYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::DataReceiveErrorEvent -->
   <xsd:group name="DATA-RECEIVE-ERROR-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised by the RTE when the Com layer detects and notifies an error concerning the reception of the referenced data element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceiveErrorEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-IREF" type="AR:R-VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Data element referenced by event</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="data.event";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::DataReceiveErrorEvent -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-RECEIVE-ERROR-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised by the RTE when the Com layer detects and notifies an error concerning the reception of the referenced data element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceiveErrorEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:DATA-RECEIVE-ERROR-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::DataReceivedEvent -->
   <xsd:group name="DATA-RECEIVED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced data elements are received.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-IREF" type="AR:R-VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Data element referenced by event</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="data.event";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::DataReceivedEvent -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-RECEIVED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced data elements are received.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:DATA-RECEIVED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::DataSendCompletedEvent -->
   <xsd:group name="DATA-SEND-COMPLETED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced data elements have been sent or an error occurs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataSendCompletedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The variable access that triggers the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataSendCompletedEvent.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-ACCESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::DataSendCompletedEvent -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-SEND-COMPLETED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced data elements have been sent or an error occurs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataSendCompletedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:DATA-SEND-COMPLETED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::DataTypeMap -->
   <xsd:group name="DATA-TYPE-MAP">
      <xsd:annotation>
         <xsd:documentation>This class represents the relationship between ApplicationDataType and its implementing ImplementationDatatype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataTypeMap"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPLICATION-DATA-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the corresponding ApplicationDataType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataTypeMap.applicationDataType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-DATA-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the corresponding ImplementationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataTypeMap.implementationDataType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::DataTypeMap -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-TYPE-MAP">
      <xsd:annotation>
         <xsd:documentation>This class represents the relationship between ApplicationDataType and its implementing ImplementationDatatype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataTypeMap"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DATA-TYPE-MAP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::DataTypeMappingSet -->
   <xsd:group name="DATA-TYPE-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>This class represents a list of Mappings between ApplicationDataTypes and ImplementationDataTypes. In addition, it can contain mappings between ImplementationDataTypes and ModeDeclarationGroups.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="DataTypeMappingSets";mmt.qualifiedName="DataTypeMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-TYPE-MAPS">
            <xsd:annotation>
               <xsd:documentation>This is one particular association between an ApplicationDataType and its ImplementationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataTypeMappingSet.dataTypeMap";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-TYPE-MAP" type="AR:DATA-TYPE-MAP"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-REQUEST-TYPE-MAPS">
            <xsd:annotation>
               <xsd:documentation>This is one particular association between an ModeDeclarationGroup and its ImplementationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataTypeMappingSet.modeRequestTypeMap";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-REQUEST-TYPE-MAP" type="AR:MODE-REQUEST-TYPE-MAP"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::DataTypeMappingSet -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-TYPE-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>This class represents a list of Mappings between ApplicationDataTypes and ImplementationDataTypes. In addition, it can contain mappings between ImplementationDataTypes and ModeDeclarationGroups.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="DataTypeMappingSets";mmt.qualifiedName="DataTypeMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:DATA-TYPE-MAPPING-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DATA-TYPE-MAPPING-SET--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DATA-TYPE-MAPPING-SET"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RTEEvents::DataWriteCompletedEvent -->
   <xsd:group name="DATA-WRITE-COMPLETED-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised if an implicit write access was successful or an error occurred.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteCompletedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The variable access that triggers the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteCompletedEvent.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-ACCESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::DataWriteCompletedEvent -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-WRITE-COMPLETED-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised if an implicit write access was successful or an error occurred.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteCompletedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:DATA-WRITE-COMPLETED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::DcmIPdu -->
   <xsd:group name="DCM-I-PDU">
      <xsd:annotation>
         <xsd:documentation>Represents the IPdus handled by Dcm.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="DcmIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIAG-PDU-TYPE" type="AR:DIAG-PDU-TYPE">
            <xsd:annotation>
               <xsd:documentation>Attribute is used to distinguish a request from a response.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DcmIPdu.DiagPduType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::DcmIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="DCM-I-PDU">
      <xsd:annotation>
         <xsd:documentation>Represents the IPdus handled by Dcm.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="DcmIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDU"/>
         <xsd:group ref="AR:I-PDU"/>
         <xsd:group ref="AR:DCM-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ListElements::DefItem -->
   <xsd:group name="DEF-ITEM">
      <xsd:annotation>
         <xsd:documentation>This represents an entry in a definition list. The defined item is specified using shortName and longName.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefItem"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEF" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents the definition part of the DefItem.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DefItem.def";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class ListElements::DefItem -->
   <xsd:attributeGroup name="DEF-ITEM">
      <xsd:annotation>
         <xsd:documentation>This represents an entry in a definition list. The defined item is specified using shortName and longName.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefItem"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="HELP-ENTRY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies an entry point in an online help system to be linked with the parent class. The syntax must be defined by the applied help system respectively help system generator.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="DefItem.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class ListElements::DefItem -->
   <xsd:complexType abstract="false" mixed="false" name="DEF-ITEM">
      <xsd:annotation>
         <xsd:documentation>This represents an entry in a definition list. The defined item is specified using shortName and longName.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefItem"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:DEF-ITEM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:DEF-ITEM"/>
   </xsd:complexType>
   <!-- element group for class ListElements::DefList -->
   <xsd:group name="DEF-LIST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a list of definitions. Note that a definition list might be rendered similar to a labeled list but has a particular semantics to denote definitions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefList"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="DEF-ITEM" type="AR:DEF-ITEM">
            <xsd:annotation>
               <xsd:documentation>This is one entry in the definition list.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DefList.defItem";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ListElements::DefList -->
   <xsd:complexType abstract="false" mixed="false" name="DEF-LIST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a list of definitions. Note that a definition list might be rendered similar to a labeled list but has a particular semantics to denote definitions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefList"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:DEF-LIST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class Fibex4Multiplatform::DefaultValueElement -->
   <xsd:group name="DEFAULT-VALUE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>The default value consists of a number of elements. Each element is one byte long and the number of elements is specified by SduLength.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefaultValueElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENT-BYTE-VALUE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The integer value of a freely defined data byte.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DefaultValueElement.elementByteValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENT-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the byte position of the
            element within the default value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DefaultValueElement.elementPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::DefaultValueElement -->
   <xsd:complexType abstract="false" mixed="false" name="DEFAULT-VALUE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>The default value consists of a number of elements. Each element is one byte long and the number of elements is specified by SduLength.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefaultValueElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DEFAULT-VALUE-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::DelegatedPortAnnotation -->
   <xsd:group name="DELEGATED-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a "delegated port" to specify the Signal Fan In or Signal Fan Out inside the CompositionSwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegatedPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-FAN" type="AR:SIGNAL-FAN-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies the Signal Fan In or Signal Fan Out inside the Composition Type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DelegatedPortAnnotation.signalFan";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::DelegatedPortAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="DELEGATED-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a "delegated port" to specify the Signal Fan In or Signal Fan Out inside the CompositionSwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegatedPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:DELEGATED-PORT-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Composition::DelegationSwConnector -->
   <xsd:group name="DELEGATION-SW-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>A delegation connector delegates one inner PortPrototype  (a port of a component that is used inside the composition) to a outer PortPrototype of compatible type that belongs directly to the composition (a port that is owned by the composition).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegationSwConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INNER-PORT-IREF">
            <xsd:annotation>
               <xsd:documentation>The port that belongs to the ComponentPrototype in the composition</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="innerPort.DelegationSwConnector";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="P-PORT-IN-COMPOSITION-INSTANCE-REF" type="AR:P-PORT-IN-COMPOSITION-INSTANCE-REF"/>
                  <xsd:element name="R-PORT-IN-COMPOSITION-INSTANCE-REF" type="AR:R-PORT-IN-COMPOSITION-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OUTER-PORT-REF">
            <xsd:annotation>
               <xsd:documentation>The port that is located on the outside of the CompositionType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DelegationSwConnector.outerPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::DelegationSwConnector -->
   <xsd:complexType abstract="false" mixed="false" name="DELEGATION-SW-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>A delegation connector delegates one inner PortPrototype  (a port of a component that is used inside the composition) to a outer PortPrototype of compatible type that belongs directly to the composition (a port that is owned by the composition).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegationSwConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:SW-CONNECTOR"/>
         <xsd:group ref="AR:DELEGATION-SW-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Implementation::DependencyOnArtifact -->
   <xsd:group name="DEPENDENCY-ON-ARTIFACT">
      <xsd:annotation>
         <xsd:documentation>Dependency on the existence of another artifact, e.g. a library.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnArtifact"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARTIFACT-DESCRIPTOR" type="AR:AUTOSAR-ENGINEERING-OBJECT">
            <xsd:annotation>
               <xsd:documentation>The specified artifact needs to exist.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnArtifact.artifactDescriptor";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USAGES">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="USAGE" type="AR:DEPENDENCY-USAGE-ENUM">
                     <xsd:annotation>
                        <xsd:documentation>Specification for which process step(s) this dependency is required.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnArtifact.usage";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::DependencyOnArtifact -->
   <xsd:complexType abstract="false" mixed="false" name="DEPENDENCY-ON-ARTIFACT">
      <xsd:annotation>
         <xsd:documentation>Dependency on the existence of another artifact, e.g. a library.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnArtifact"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DEPENDENCY-ON-ARTIFACT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DEPENDENCY-ON-ARTIFACT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEPENDENCY-ON-ARTIFACT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Identifiable::Describable -->
   <xsd:group name="DESCRIBABLE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to add Desc and Introduction to non identifiable elements.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Describable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This represents a general but brief (one paragraph) description what the object in question is about. It is only one paragraph! Desc is intended to be collected into overview tables. This property helps a human reader to identify the object in question.

            More elaborate documentation, (in particlar how the object is built or used) should go to "introduction".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Describable.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents more information about how the object in question is built or is used. Therefore it is a DocumentationBlock.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Describable.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ServiceNeeds::DiagEventDebounceAlgorithm -->
   <xsd:group name="DIAG-EVENT-DEBOUNCE-ALGORITHM">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to specify the pre-debounce algorithm which is selected and/or required by the particular monitor.

      This class inherits from Identifiable in order to allow further documentation of the expected or implemented debouncing and to use the category for the identification of the expected / implemented debouncing.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceAlgorithm"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ServiceNeeds::DiagEventDebounceCounterBased -->
   <xsd:group name="DIAG-EVENT-DEBOUNCE-COUNTER-BASED">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to indicate that the counter-based pre-debounce algorithm shall be used by the DEM for this diagnostic monitor.

      This is related to set the ECUC choice container DemPrdebounceAlgorithmClass to DemPreDebounceCounterBased.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-DECREMENT-STEP-SIZE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This value shall be taken to decrement the internal debounce counter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased.counterDecrementStepSize";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-FAILED-THRESHOLD" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This value defines the event-specific limit that indicates the "failed" counter status.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased.counterFailedThreshold";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-INCREMENT-STEP-SIZE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This value shall be taken to increment the internal debounce counter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased.counterIncrementStepSize";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-JUMP-DOWN" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This value activates or deactivates the counter jump-down behavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased.counterJumpDown";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-JUMP-DOWN-VALUE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This value represents the initial value of the internal debounce counter if the counting direction changes from incrementing to decrementing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased.counterJumpDownValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-JUMP-UP" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This value activates or deactivates the counter jump-up behavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased.counterJumpUp";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-JUMP-UP-VALUE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This value represents the initial value of the internal debounce counter if the counting direction changes from decrementing to incrementing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased.counterJumpUpValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-PASSED-THRESHOLD" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This value defines the event-specific limit that indicates the "passed" counter status.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased.counterPassedThreshold";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagEventDebounceCounterBased -->
   <xsd:complexType abstract="false" mixed="false" name="DIAG-EVENT-DEBOUNCE-COUNTER-BASED">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to indicate that the counter-based pre-debounce algorithm shall be used by the DEM for this diagnostic monitor.

      This is related to set the ECUC choice container DemPrdebounceAlgorithmClass to DemPreDebounceCounterBased.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceCounterBased"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DIAG-EVENT-DEBOUNCE-ALGORITHM"/>
         <xsd:group ref="AR:DIAG-EVENT-DEBOUNCE-COUNTER-BASED"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::DiagEventDebounceMonitorInternal -->
   <xsd:group name="DIAG-EVENT-DEBOUNCE-MONITOR-INTERNAL">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to indicate that the pre-debounce algorithm shall be used by the DEM for this diagnostic monitor.

      This is related to setting the ECUC choice container DemPredebounceAlgorithmClass to DemPredebounceMonitorInternal.

      If the FaultDetectionAlogrithm is already known to be implemented by a specific BswModuleEntry the reference bswModuleEntry points to the function specification.

      If the FaultDetectionCounter value is accessible at a PortPrototype this PortPrototype shall be referenced by an assignedPort.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceMonitorInternal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagEventDebounceMonitorInternal -->
   <xsd:complexType abstract="false" mixed="false" name="DIAG-EVENT-DEBOUNCE-MONITOR-INTERNAL">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to indicate that the pre-debounce algorithm shall be used by the DEM for this diagnostic monitor.

      This is related to setting the ECUC choice container DemPredebounceAlgorithmClass to DemPredebounceMonitorInternal.

      If the FaultDetectionAlogrithm is already known to be implemented by a specific BswModuleEntry the reference bswModuleEntry points to the function specification.

      If the FaultDetectionCounter value is accessible at a PortPrototype this PortPrototype shall be referenced by an assignedPort.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceMonitorInternal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DIAG-EVENT-DEBOUNCE-ALGORITHM"/>
         <xsd:group ref="AR:DIAG-EVENT-DEBOUNCE-MONITOR-INTERNAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::DiagEventDebounceTimeBased -->
   <xsd:group name="DIAG-EVENT-DEBOUNCE-TIME-BASED">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to indicate that the time-based pre-debounce algorithm shall be used by the DEM for this diagnostic monitor.

      This is related to set the ECUC choice container DemPredebounceAlgorithmClass to DemPreDebounceTimeBase.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceTimeBased"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-FAILED-THRESHOLD" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This value represents the event-specific delay indicating the "failed" status.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceTimeBased.timeFailedThreshold";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-PASSED-THRESHOLD" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This value represents the event-specific delay indicating the "passed" status.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceTimeBased.timePassedThreshold";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagEventDebounceTimeBased -->
   <xsd:complexType abstract="false" mixed="false" name="DIAG-EVENT-DEBOUNCE-TIME-BASED">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to indicate that the time-based pre-debounce algorithm shall be used by the DEM for this diagnostic monitor.

      This is related to set the ECUC choice container DemPredebounceAlgorithmClass to DemPreDebounceTimeBase.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagEventDebounceTimeBased"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DIAG-EVENT-DEBOUNCE-ALGORITHM"/>
         <xsd:group ref="AR:DIAG-EVENT-DEBOUNCE-TIME-BASED"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::DiagnosticCapabilityElement -->
   <xsd:group name="DIAGNOSTIC-CAPABILITY-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>This class identifies the capability to provide generic information about diagnostic capabilities</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticCapabilityElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AUDIENCES">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AUDIENCE" type="AR:DIAGNOSTIC-AUDIENCE-ENUM">
                     <xsd:annotation>
                        <xsd:documentation>This specifies the intended audience for the diagnostic object. Note that this is not only for the documentation but also subsequent audience specific implementation.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticCapabilityElement.audience";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIAG-REQUIREMENT" type="AR:DIAG-REQUIREMENT-ID-STRING">
            <xsd:annotation>
               <xsd:documentation>This denotes the requirement identifier to which the object can be linked to.

            Note that with a generic tracing concept in AUTOSAR this might superseded.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticCapabilityElement.diagRequirement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECURITY-ACCESS-LEVEL" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute denotes the level of security which is touched by the diagnostic object. The higher the level the more relevance for the security exists.

            This level must be mapped to the security level in the ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticCapabilityElement.securityAccessLevel";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ServiceNeeds::DiagnosticCommunicationManagerNeeds -->
   <xsd:group name="DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Communication Manager (DCM) which are not related to a particular item (e.g. a PID or DiagnosticRoutineNeeds). The main use case is the mapping of service ports to the DCM which are not related to a particular item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticCommunicationManagerNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagnosticCommunicationManagerNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Communication Manager (DCM) which are not related to a particular item (e.g. a PID or DiagnosticRoutineNeeds). The main use case is the mapping of service ports to the DCM which are not related to a particular item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticCommunicationManagerNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::DiagnosticEventManagerNeeds -->
   <xsd:group name="DIAGNOSTIC-EVENT-MANAGER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Event Manager (DEM) which are not related to a particular item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventManagerNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagnosticEventManagerNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DIAGNOSTIC-EVENT-MANAGER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Event Manager (DEM) which are not related to a particular item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventManagerNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:DIAGNOSTIC-EVENT-MANAGER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::DiagnosticEventNeeds -->
   <xsd:group name="DIAGNOSTIC-EVENT-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Diagnostic Event Manager for one diagnostic event. Its name can be regarded as a symbol identifying the diagnostic event from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSIDER-PTO-STATUS" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>PTO (Power Take Off) has an impact on the respective emission-related event (OBD). This information shall be provided by SW-C description in order to consider the PTO relevance e.g. for readiness (PID $01) computation. For events with dtcKind set to 'nonEmmissionRelatedDtc' this attribute is typically false.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds.considerPtoStatus";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIAG-EVENT-DEBOUNCE-ALGORITHM">
            <xsd:annotation>
               <xsd:documentation>Specifies the abstract need on the Debounce Algorithm applied by the Diagnostic Event Manager.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds.diagEventDebounceAlgorithm";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="DIAG-EVENT-DEBOUNCE-COUNTER-BASED" type="AR:DIAG-EVENT-DEBOUNCE-COUNTER-BASED"/>
                  <xsd:element name="DIAG-EVENT-DEBOUNCE-MONITOR-INTERNAL" type="AR:DIAG-EVENT-DEBOUNCE-MONITOR-INTERNAL"/>
                  <xsd:element name="DIAG-EVENT-DEBOUNCE-TIME-BASED" type="AR:DIAG-EVENT-DEBOUNCE-TIME-BASED"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DTC-KIND" type="AR:DTC-KIND-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute indicates the kind of the diagnostic monitor according to the SWS Diagnostic Event Manger.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds.dtcKind";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DTC-NUMBER" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This represents a reasonable Diagnostic Trouble Code.
            This allows to predefine the Diagnostic Trouble Code if the a function developer has received a particular requirement from the OEM or from a standardization body.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds.dtcNumber";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INHIBITING-FID-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the primary Function Inhibition Identifier used for inhibition of the diagnostic monitor. The FID might either inhibit the monitoring of a symptom or the reporting of detected faults.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds.inhibitingFid";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FUNCTION-INHIBITION-NEEDS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INHIBITING-SECONDARY-FID-REFS">
            <xsd:annotation>
               <xsd:documentation>This represents the secondary Function Inhibition Identifier used for inhibition of the diagnostic monitor. The FID might either inhibit the monitoring of a symptom or the reporting of detected faults. The "primary" and all "secondary" FID inhibitions are combined by "OR".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds.inhibitingSecondaryFid";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INHIBITING-SECONDARY-FID-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FUNCTION-INHIBITION-NEEDS--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagnosticEventNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DIAGNOSTIC-EVENT-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Diagnostic Event Manager for one diagnostic event. Its name can be regarded as a symbol identifying the diagnostic event from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:DIAGNOSTIC-EVENT-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DIAGNOSTIC-EVENT-NEEDS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DIAGNOSTIC-EVENT-NEEDS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ServiceNeeds::DiagnosticIoControlNeeds -->
   <xsd:group name="DIAGNOSTIC-IO-CONTROL-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Communication Manager (DCM) which are not related to a particular item (e.g. a PID). The main use case is the mapping of service ports to the DCM which are not related to a particular item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticIoControlNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DID-NUMBER" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This represents a Data identifier for the diagnostic value.
            This allows to predefine the DID number if the a function developer has received a particular requirement from the OEM or from a standardization body.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticIoControlNeeds.didNumber";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FREEZE-CURRENT-STATE-SUPPORTED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute determines, if the referenced port  supports temporary freezing of  I/O value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticIoControlNeeds.freezeCurrentStateSupported";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-TERM-ADJUSTMENT-SUPPORTED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute determines, if the referenced port  supports temporarily setting  of  I/O value to a specific value provided by the diagnostic tester.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticIoControlNeeds.shortTermAdjustmentSupported";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagnosticIoControlNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DIAGNOSTIC-IO-CONTROL-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Communication Manager (DCM) which are not related to a particular item (e.g. a PID). The main use case is the mapping of service ports to the DCM which are not related to a particular item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticIoControlNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:DIAGNOSTIC-IO-CONTROL-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::DiagnosticRoutineNeeds -->
   <xsd:group name="DIAGNOSTIC-ROUTINE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Communication Manager (DCM) which are not related to a particular item (e.g. a PID). The main use case is the mapping of service ports to the DCM which are not related to a particular item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticRoutineNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIAG-ROUTINE-TYPE" type="AR:DIAGNOSTIC-ROUTINE-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>This denotes the type of diagnostic routine which is implemented by the referenced server port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticRoutineNeeds.diagRoutineType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RID-NUMBER" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This represents a routine identifier for the diagnostic routine.
            This allows to predefine the RID number if the a function developer has received a particular requirement from the OEM or from a standardization body.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticRoutineNeeds.ridNumber";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagnosticRoutineNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DIAGNOSTIC-ROUTINE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Communication Manager (DCM) which are not related to a particular item (e.g. a PID). The main use case is the mapping of service ports to the DCM which are not related to a particular item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticRoutineNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:DIAGNOSTIC-ROUTINE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::DiagnosticValueNeeds -->
   <xsd:group name="DIAGNOSTIC-VALUE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Communication Manager (DCM) which are not related to a particular item (e.g. a PID). The main use case is the mapping of service ports to the DCM which are not related to a particular item.

      In the case of using a sender receiver communicated value, the related value shall be taken via assignedData in the role "signalBasedDiagnostics".

      In case of using a client/server communicated value, the related value shall be communicated via the port referenced by asssignedPort. The details of this communication (e.g. appropriate naming conventions) are specified in the related software specifications (SWS).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticValueNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute is applicable only if the ServiceNeed is aggregated within BswModuleDependency.

            This attribute represents the length of data (in bytes) provided for this particular PID signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticValueNeeds.dataLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIAGNOSTIC-VALUE-ACCESS" type="AR:DIAGNOSTIC-VALUE-ACCESS-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls whether the data can be read and written or whether it is to be handled read-only.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticValueNeeds.DiagnosticValueAccess";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DID-NUMBER" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This represents a Data identifier for the diagnostic value.
            This allows to predefine the DID number if the a function developer has received a particular requirement from the OEM or from a standardization body.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticValueNeeds.didNumber";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DiagnosticValueNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DIAGNOSTIC-VALUE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the general needs on the configuration of the  Diagnostic Communication Manager (DCM) which are not related to a particular item (e.g. a PID). The main use case is the mapping of service ports to the DCM which are not related to a particular item.

      In the case of using a sender receiver communicated value, the related value shall be taken via assignedData in the role "signalBasedDiagnostics".

      In case of using a client/server communicated value, the related value shall be communicated via the port referenced by asssignedPort. The details of this communication (e.g. appropriate naming conventions) are specified in the related software specifications (SWS).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticValueNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:DIAGNOSTIC-VALUE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::DltUserNeeds -->
   <xsd:group name="DLT-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the needs on the configuration of the Diagnostic Log and Trace module for one SessionId. This class currently contains no attributes. An instance of this class is used to find out which ports of an SWC belong to this SessionId in order to group the request and response ports of the same SessionId. The actual SessionId value is stored in the PortDefinedArgumentValue of the respective port specification.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DltUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::DltUserNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DLT-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the needs on the configuration of the Diagnostic Log and Trace module for one SessionId. This class currently contains no attributes. An instance of this class is used to find out which ports of an SWC belong to this SessionId in order to group the request and response ports of the same SessionId. The actual SessionId value is stored in the PortDefinedArgumentValue of the respective port specification.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DltUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DLT-USER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class AdminData::DocRevision -->
   <xsd:group name="DOC-REVISION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to maintain information which relates to revision management of documents or objects.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision";xml.sequenceOffset="20"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVISION-LABEL" type="AR:REVISION-LABEL-STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute represents the version number of the object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.revisionLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVISION-LABEL-P-1" type="AR:REVISION-LABEL-STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute represents the version number of the first predecessor  of the object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.revisionLabelP1";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVISION-LABEL-P-2" type="AR:REVISION-LABEL-STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute represents the version number of the second predecessor of the object.

            This attribute is used if the object is the result of a merge process in which two branches are merged in to one new revision.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.revisionLabelP2";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATE" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>The attribute state represents the current state of the current file according to the configuration management plan. It is a NameToken until possible states are  standardized.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.state";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ISSUED-BY" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This is the name of an individual or an organization who issued the current revision of the document or document fragment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.issuedBy";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATE" type="AR:DATE">
            <xsd:annotation>
               <xsd:documentation>This specifies the date and time, when the object in question was released</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.date";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODIFICATIONS">
            <xsd:annotation>
               <xsd:documentation>This property represents one particular modification in comparison to its predecessor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.modification";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="100";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODIFICATION" type="AR:MODIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AdminData::DocRevision -->
   <xsd:complexType abstract="false" mixed="false" name="DOC-REVISION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to maintain information which relates to revision management of documents or objects.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision";xml.sequenceOffset="20"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOC-REVISION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PaginationAndView::DocumentViewSelectable -->
   <xsd:group name="DOCUMENT-VIEW-SELECTABLE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to be dedicated to a particular audience or document view.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocumentViewSelectable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class PaginationAndView::DocumentViewSelectable -->
   <xsd:attributeGroup name="DOCUMENT-VIEW-SELECTABLE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to be dedicated to a particular audience or document view.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocumentViewSelectable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="SI" type="AR:NMTOKENS-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute allows to denote a semantic information which is used to identify documentation objects to be selected in customizable document views. It shall be defined in agreement between the involved parties.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="DocumentViewSelectable.si";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="VIEW" type="AR:VIEW-TOKENS--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute lists the document views in which the object shall appear. If it is missing, the object appears in all document views.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="DocumentViewSelectable.view";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- element group for class DocumentationOnM1::Documentation -->
   <xsd:group name="DOCUMENTATION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to handle a so called standalone documentation. Standalone means, that such a documentation is not embedded in another ARElement or identifiable object.  The standalone documentation is an entity of its own which denotes its context by reference to other objects and instances.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Documentations";mmt.qualifiedName="Documentation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXTS">
            <xsd:annotation>
               <xsd:documentation>This is the context of the particular documentation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Documentation.context";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DOCUMENTATION-CONTEXT" type="AR:DOCUMENTATION-CONTEXT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DOCUMENTATION-CONTENT" type="AR:PREDEFINED-CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This is the content of the documentation related to the specified contexts.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Documentation.documentationContent";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="200"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DocumentationOnM1::Documentation -->
   <xsd:complexType abstract="false" mixed="false" name="DOCUMENTATION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to handle a so called standalone documentation. Standalone means, that such a documentation is not embedded in another ARElement or identifiable object.  The standalone documentation is an entity of its own which denotes its context by reference to other objects and instances.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Documentations";mmt.qualifiedName="Documentation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:DOCUMENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BlockElements::DocumentationBlock -->
   <xsd:group name="DOCUMENTATION-BLOCK">
      <xsd:annotation>
         <xsd:documentation>This class represents a documentation block. It is made of basic text structure elements which can be displayed in a table cell.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationBlock"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="P" type="AR:MULTI-LANGUAGE-PARAGRAPH">
               <xsd:annotation>
                  <xsd:documentation>This is one particular paragraph.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.p";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="VERBATIM" type="AR:MULTI-LANGUAGE-VERBATIM">
               <xsd:annotation>
                  <xsd:documentation>This represents one particular verbatim text.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.verbatim";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="LIST" type="AR:LIST">
               <xsd:annotation>
                  <xsd:documentation>This represents numbered or unnumbered list. 
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.list";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="DEF-LIST" type="AR:DEF-LIST">
               <xsd:annotation>
                  <xsd:documentation>This represents a definition list in the documentation block.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.defList";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="LABELED-LIST" type="AR:LABELED-LIST">
               <xsd:annotation>
                  <xsd:documentation>This represents a labeled list.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.labeledList";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="FORMULA" type="AR:ML-FORMULA">
               <xsd:annotation>
                  <xsd:documentation>This is a formula in the definition block.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.formula";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="FIGURE" type="AR:ML-FIGURE">
               <xsd:annotation>
                  <xsd:documentation>This represents a figure in the documentation block.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.figure";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="NOTE" type="AR:NOTE">
               <xsd:annotation>
                  <xsd:documentation>This represents a note in the text flow.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.note";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="TRACE" type="AR:TRACEABLE-TEXT">
               <xsd:annotation>
                  <xsd:documentation>This represents traceable text in the documentation block. This allows to specify requirements/constraints in any documentation block.

               The kind of the trace is specified in the category.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.trace";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="STRUCTURED-REQ" type="AR:STRUCTURED-REQ">
               <xsd:annotation>
                  <xsd:documentation>This aggregation supports structured requirements embedded in a documentation block.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="DocumentationBlock.structuredReq";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="100"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class BlockElements::DocumentationBlock -->
   <xsd:complexType abstract="false" mixed="false" name="DOCUMENTATION-BLOCK">
      <xsd:annotation>
         <xsd:documentation>This class represents a documentation block. It is made of basic text structure elements which can be displayed in a table cell.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationBlock"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENTATION-BLOCK"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DocumentationOnM1::DocumentationContext -->
   <xsd:group name="DOCUMENTATION-CONTEXT">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to denote a context of a so called standalone  documentation. Note that this is an &lt;&lt;atpMixed&gt;&gt;. The contents needs to be considered as ordered.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationContext"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FEATURE-IREF" type="AR:ANY-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This referes to a paricular feature (instance in the M0 model) to which is the context of the documentation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationContext.feature";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IDENTIFIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>This is an identifiable object which is part of the context of the documentation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationContext.identifiable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IDENTIFIABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DocumentationOnM1::DocumentationContext -->
   <xsd:complexType abstract="false" mixed="false" name="DOCUMENTATION-CONTEXT">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to denote a context of a so called standalone  documentation. Note that this is an &lt;&lt;atpMixed&gt;&gt;. The contents needs to be considered as ordered.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationContext"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:DOCUMENTATION-CONTEXT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::DynamicPart -->
   <xsd:group name="DYNAMIC-PART">
      <xsd:annotation>
         <xsd:documentation>Dynamic part of a multiplexed I-Pdu. 
      Reserved space which is used to transport varying SignalIPdus at the same position, controlled by the corresponding selectorFieldCode.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DYNAMIC-PART-ALTERNATIVES">
            <xsd:annotation>
               <xsd:documentation>Com IPdu alternatives that are transmitted  in the Dynamic Part of the MultiplexedIPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dynamicPartAlternative.DynamicPart";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DYNAMIC-PART-ALTERNATIVE" type="AR:DYNAMIC-PART-ALTERNATIVE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::DynamicPart -->
   <xsd:complexType abstract="false" mixed="false" name="DYNAMIC-PART">
      <xsd:annotation>
         <xsd:documentation>Dynamic part of a multiplexed I-Pdu. 
      Reserved space which is used to transport varying SignalIPdus at the same position, controlled by the corresponding selectorFieldCode.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MULTIPLEXED-PART"/>
         <xsd:group ref="AR:DYNAMIC-PART"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::DynamicPartAlternative -->
   <xsd:group name="DYNAMIC-PART-ALTERNATIVE">
      <xsd:annotation>
         <xsd:documentation>One of the Com IPdu alternatives that are transmitted in the Dynamic Part of the MultiplexedIPdu. The selectorFieldCode
      specifies which Com IPdu is contained in the DynamicPart within a
      certain transmission of a multiplexed PDU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a Com IPdu which is routed to the IPduM module and is combined to a multiplexedPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative.iPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INITIAL-DYNAMIC-PART" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Dynamic part that shall be used to initialize this multiplexed IPdu.

            Constraint: Only one "DynamicPartAlternative" in a "DynamicPart" shall
            be the initialDynamicPart.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative.initialDynamicPart";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SELECTOR-FIELD-CODE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The selector field is part of a multiplexed IPdu. It consists of contiguous bits. The value of the selector field selects the layout of the multiplexed part of the IPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative.selectorFieldCode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::DynamicPartAlternative -->
   <xsd:complexType abstract="false" mixed="false" name="DYNAMIC-PART-ALTERNATIVE">
      <xsd:annotation>
         <xsd:documentation>One of the Com IPdu alternatives that are transmitted in the Dynamic Part of the MultiplexedIPdu. The selectorFieldCode
      specifies which Com IPdu is contained in the DynamicPart within a
      certain transmission of a multiplexed PDU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DYNAMIC-PART-ALTERNATIVE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUResourceMapping::ECUMapping -->
   <xsd:group name="ECU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>ECUMapping allows to assign an ECU hardware type (defined in the ECU Resource Template) to an ECUInstance used in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECUMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMM-CONTROLLER-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The ECUMapping contains the mapping of all CommunicationControllers of the ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="commControllerMapping.ECUMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMMUNICATION-CONTROLLER-MAPPING" type="AR:COMMUNICATION-CONTROLLER-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the EcuInstance in the System Template</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ECUMapping.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the Ecu description in the ECU Resource Template.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ECUMapping.ecu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PORT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The ECUMapping contains the mapping of all HW Communication Ports of the ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hwPortMapping.ECUMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-PORT-MAPPING" type="AR:HW-PORT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceMapping::ECUMapping -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>ECUMapping allows to assign an ECU hardware type (defined in the ECU Resource Template) to an ECUInstance used in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECUMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECU-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ExecutionOrderConstraint::EOCExecutableEntityRef -->
   <xsd:group name="EOC-EXECUTABLE-ENTITY-REF">
      <xsd:annotation>
         <xsd:documentation>This is used to define a reference to an ExecutableEntity and its successors in the execution order.

      If the ExecutionOrderConstraint is defined on system level, a reference to the SwComponentPrototype (via the ComponentInCompositionInstanceRef) that the referenced ExecutableEntity belongs to, must be provided as context information.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EOCExecutableEntityRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREF" type="AR:COMPONENT-IN-COMPOSITION-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This defines the context of the referenced RunnableEntity on system level.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.EOCExecutableEntityRef";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTABLE-REF">
            <xsd:annotation>
               <xsd:documentation>The ExecutableEntity whose execution order is restricted by the contraint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EOCExecutableEntityRef.executable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:EXECUTABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUCCESSOR-REFS">
            <xsd:annotation>
               <xsd:documentation>The list of successors for the executable entity referenced by this.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EOCExecutableEntityRef.successor";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SUCCESSOR-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:EOC-EXECUTABLE-ENTITY-REF--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionOrderConstraint::EOCExecutableEntityRef -->
   <xsd:complexType abstract="false" mixed="false" name="EOC-EXECUTABLE-ENTITY-REF">
      <xsd:annotation>
         <xsd:documentation>This is used to define a reference to an ExecutableEntity and its successors in the execution order.

      If the ExecutionOrderConstraint is defined on system level, a reference to the SwComponentPrototype (via the ComponentInCompositionInstanceRef) that the referenced ExecutableEntity belongs to, must be provided as context information.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EOCExecutableEntityRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EOC-EXECUTABLE-ENTITY-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="EOC-EXECUTABLE-ENTITY-REF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EOC-EXECUTABLE-ENTITY-REF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Components::EcuAbstractionSwComponentType -->
   <xsd:group name="ECU-ABSTRACTION-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ECUAbstraction is a special AtomicSwComponentType that resides between a software-component that wants to access ECU periphery and the Microcontroller Abstraction. The EcuAbstractionSwComponentType introduces the possibility to link from the software representation to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="EcuAbstractionSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference from the EcuAbstractionComponentType to the description of the used HwElements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuAbstractionSwComponentType.hardwareElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HARDWARE-ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-DESCRIPTION-ENTITY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::EcuAbstractionSwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-ABSTRACTION-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ECUAbstraction is a special AtomicSwComponentType that resides between a software-component that wants to access ECU periphery and the Microcontroller Abstraction. The EcuAbstractionSwComponentType introduces the possibility to link from the software representation to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="EcuAbstractionSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::EcuInstance -->
   <xsd:group name="ECU-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>ECUInstances are used to define the ECUs used in the topology. The type of the ECU is defined by a reference to an ECU specified with the ECU resource description.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcuInstances";mmt.qualifiedName="EcuInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSOCIATED-COM-I-PDU-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>With this reference it is possible to identify which ISignalIPduGroups are applicable for which CommunicationConnector/ ECU. 

            Only top level ISignalIPduGroups shall be referenced by an EcuInstance. If an ISignalIPduGroup contains other ISignalIPduGroups than these contained ISignalIPduGroups shall not be referenced by the EcuInstance. Contained ISignalIPduGroups are associated to an EcuInstance via the top level ISignalIPduGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.associatedComIPduGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASSOCIATED-COM-I-PDU-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-SIGNAL-I-PDU-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSOCIATED-PDUR-I-PDU-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>With this reference it is possible to identify which PduR IPdu Groups are applicable for which CommunicationConnector/ ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.associatedPdurIPduGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASSOCIATED-PDUR-I-PDU-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PDUR-I-PDU-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-TP-ADDRESS-REFS">
            <xsd:annotation>
               <xsd:documentation>A Tp Address can be assigned to an ECU without an existing TP Configuration. If TpNodes are described this reference shall not be used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.canTpAddress";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-TP-ADDRESS-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CAN-TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COM-CONFIGURATION-GW-TIME-BASE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The period between successive calls to Com_MainFunctionRouteSignals of the AUTOSAR COM module in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.comConfigurationGwTimeBase";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COM-CONFIGURATION-RX-TIME-BASE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The period between successive calls to Com_MainFunctionRx of the AUTOSAR COM module in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.comConfigurationRxTimeBase";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COM-CONFIGURATION-TX-TIME-BASE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The period between successive calls to Com_MainFunctionTx of the AUTOSAR COM module in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.comConfigurationTxTimeBase";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COM-ENABLE-MDT-FOR-CYCLIC-TRANSMISSION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables for the Com module of this EcuInstance the minimum delay time monitoring for cyclic and repeated transmissions (TransmissionModeTiming has cyclicTiming assigned or eventControlledTiming with numberOfRepetitions &amp;gt; 0).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.comEnableMDTForCyclicTransmission";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMM-CONTROLLERS">
            <xsd:annotation>
               <xsd:documentation>CommunicationControllers of the ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="commController.EcuInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-COMMUNICATION-CONTROLLER" type="AR:CAN-COMMUNICATION-CONTROLLER"/>
                  <xsd:element name="ETHERNET-COMMUNICATION-CONTROLLER" type="AR:ETHERNET-COMMUNICATION-CONTROLLER"/>
                  <xsd:element name="FLEXRAY-COMMUNICATION-CONTROLLER" type="AR:FLEXRAY-COMMUNICATION-CONTROLLER"/>
                  <xsd:element name="LIN-MASTER" type="AR:LIN-MASTER"/>
                  <xsd:element name="LIN-SLAVE" type="AR:LIN-SLAVE"/>
                  <xsd:element name="TTCAN-COMMUNICATION-CONTROLLER" type="AR:TTCAN-COMMUNICATION-CONTROLLER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTORS">
            <xsd:annotation>
               <xsd:documentation>All channels controlled by a single controller.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="connector.EcuInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-COMMUNICATION-CONNECTOR" type="AR:CAN-COMMUNICATION-CONNECTOR"/>
                  <xsd:element name="ETHERNET-COMMUNICATION-CONNECTOR" type="AR:ETHERNET-COMMUNICATION-CONNECTOR"/>
                  <xsd:element name="FLEXRAY-COMMUNICATION-CONNECTOR" type="AR:FLEXRAY-COMMUNICATION-CONNECTOR"/>
                  <xsd:element name="LIN-COMMUNICATION-CONNECTOR" type="AR:LIN-COMMUNICATION-CONNECTOR"/>
                  <xsd:element name="TTCAN-COMMUNICATION-CONNECTOR" type="AR:TTCAN-COMMUNICATION-CONNECTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIAGNOSTIC-ADDRESS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>An ECU specific ID for responses of diagnostic routines.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.diagnosticAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARTITIONS">
            <xsd:annotation>
               <xsd:documentation>Optional definition of Partitions within an Ecu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="partition.EcuInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECU-PARTITION" type="AR:ECU-PARTITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SLEEP-MODE-SUPPORTED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Specifies whether the ECU instance may be put to a "low power mode" 
            TRUE: sleep mode is supported FALSE: sleep mode is not supported 

            Note: This flag may only be set to TRUE if the feature is supported by both hardware and basic software.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.sleepModeSupported";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS-REFS">
            <xsd:annotation>
               <xsd:documentation>A Tp Address can be assigned to an ECU without an existing TP Configuration. If TpNodes are described this reference shall not be used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.tpAddress";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TP-ADDRESS-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKE-UP-OVER-BUS-SUPPORTED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Driver support for wakeup over Bus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.wakeUpOverBusSupported";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::EcuInstance -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>ECUInstances are used to define the ECUs used in the topology. The type of the ECU is defined by a reference to an ECU specified with the ECU resource description.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcuInstances";mmt.qualifiedName="EcuInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:ECU-INSTANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECU-INSTANCE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECU-INSTANCE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SWmapping::EcuPartition -->
   <xsd:group name="ECU-PARTITION">
      <xsd:annotation>
         <xsd:documentation>Partitions are used as error containment regions. They permit the grouping of SWCs and resources and allow to describe recovery policies individually for each partition. Partitions can be terminated or restarted during run-time as a result of a detected error.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuPartition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXEC-IN-USER-MODE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>A partition can execute either in CPU user mode (execInUserMode = TRUE) or supervisor mode (execInUserMode = FALSE). In user mode, the partition has a limited access to memory, to memory mapped hardware and to CPU. In user mode, the partition is mapped to a non-trusted OS-Application.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuPartition.execInUserMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::EcuPartition -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-PARTITION">
      <xsd:annotation>
         <xsd:documentation>Partitions are used as error containment regions. They permit the grouping of SWCs and resources and allow to describe recovery policies individually for each partition. Partitions can be terminated or restarted during run-time as a result of a detected error.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuPartition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECU-PARTITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECU-PARTITION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECU-PARTITION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SWmapping::EcuResourceEstimation -->
   <xsd:group name="ECU-RESOURCE-ESTIMATION">
      <xsd:annotation>
         <xsd:documentation>Resource estimations for RTE and BSW of a single ECU instance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents introductory documentation about the ecu resource estimation</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-RESOURCE-ESTIMATION" type="AR:RESOURCE-CONSUMPTION">
            <xsd:annotation>
               <xsd:documentation>Estimation for the resource consumption of the basic software.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="bswResourceEstimation.EcuResourceEstimation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ECU this estimation is done for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RTE-RESOURCE-ESTIMATION" type="AR:RESOURCE-CONSUMPTION">
            <xsd:annotation>
               <xsd:documentation>Estimation for the resource consumption of the run time environment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="rteResourceEstimation.EcuResourceEstimation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-COMP-TO-ECU-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>References to  SwCompToEcuMappings that have been taken into account for the resource estimations. This way it is possible to define dfferent EcuResourceEstimations with different mappings, e.g. before and after mapping an additional SW component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation.swCompToEcuMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-COMP-TO-ECU-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SWC-TO-ECU-MAPPING--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::EcuResourceEstimation -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-RESOURCE-ESTIMATION">
      <xsd:annotation>
         <xsd:documentation>Resource estimations for RTE and BSW of a single ECU instance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECU-RESOURCE-ESTIMATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::EcuStateMgrUserNeeds -->
   <xsd:group name="ECU-STATE-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the ECU State  Manager for one "user". This class currently contains no attributes. Its name can be regarded as a symbol identifying the user  from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuStateMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::EcuStateMgrUserNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-STATE-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the ECU State  Manager for one "user". This class currently contains no attributes. Its name can be regarded as a symbol identifying the user  from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuStateMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:ECU-STATE-MGR-USER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Timing::EcuTiming -->
   <xsd:group name="ECU-TIMING">
      <xsd:annotation>
         <xsd:documentation>A model element used to define timing descriptions and constraints within the scope of one ECU configuration.

      TimingDescriptions aggregated by EcuTiming are allowed to use all events derived from the class TimingDescriptionEvent.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="EcuTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-CONFIGURATION-REF">
            <xsd:annotation>
               <xsd:documentation>This defines the scope of an EcuTiming. All corresponding timing descriptions and constraints must be defined within this scope.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuTiming.ecuConfiguration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-VALUE-COLLECTION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::EcuTiming -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-TIMING">
      <xsd:annotation>
         <xsd:documentation>A model element used to define timing descriptions and constraints within the scope of one ECU configuration.

      TimingDescriptions aggregated by EcuTiming are allowed to use all events derived from the class TimingDescriptionEvent.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="EcuTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:TIMING-EXTENSION"/>
         <xsd:group ref="AR:ECU-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucAbstractReferenceDef -->
   <xsd:group name="ECUC-ABSTRACT-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Common class to gather the attributes for the definition of references.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucAbstractReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="ECUC-ABSTRACT-REFERENCE-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-CHOICE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-FOREIGN-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-INSTANCE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-SYMBOLIC-NAME-REFERENCE-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCDescriptionTemplate::EcucAbstractReferenceValue -->
   <xsd:group name="ECUC-ABSTRACT-REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>Abstract class to be used as common parent for all reference values in the ECU Configuration Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucAbstractReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFINITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the definition of this EcuAbstractReferenceValue subclasses in the ECU Configuration Parameter Definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAbstractReferenceValue.definition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-ABSTRACT-REFERENCE-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Possibility to provide additional notes while defining a model element (e.g. the ECU Configuration Parameter Values). These are not intended as documentation but are mere design notes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAbstractReferenceValue.annotation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ANNOTATION" type="AR:ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::EcucAbstractStringParamDef -->
   <xsd:group name="ECUC-ABSTRACT-STRING-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Abstract class that is used to collect the common properties for StringParamDefs, LinkerSymbolDef, FunctionNameDef and MultilineStringParamDefs. 

      atpVariation: ECUC0082, ECUC0083</xsd:documentation>
         <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucAbstractStringParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::EcucAbstractStringParamDefContent -->
   <xsd:group name="ECUC-ABSTRACT-STRING-PARAM-DEF-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="AR:VERBATIM-STRING">
            <xsd:annotation>
               <xsd:documentation>Default value of the string configuration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAbstractStringParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Max length allowed for this string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAbstractStringParamDef.maxLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Min length allowed for this string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAbstractStringParamDef.minLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REGULAR-EXPRESSION" type="AR:REGULAR-EXPRESSION">
            <xsd:annotation>
               <xsd:documentation>This represents the regular expression which shall be used to validate the 
            string parameter value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAbstractStringParamDef.regularExpression";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::EcucAddInfoParamDef -->
   <xsd:group name="ECUC-ADD-INFO-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration Parameter Definition for the specification of formated text in the ECU Configuration Parameter Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucAddInfoParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucAddInfoParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-ADD-INFO-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration Parameter Definition for the specification of formated text in the ECU Configuration Parameter Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucAddInfoParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-ADD-INFO-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EcucAddInfoParamValue -->
   <xsd:group name="ECUC-ADD-INFO-PARAM-VALUE">
      <xsd:annotation>
         <xsd:documentation>This parameter corresponds to EcucAddInfoParamDef.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucAddInfoParamValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>Holds the content of the formated text.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAddInfoParamValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucAddInfoParamValue -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-ADD-INFO-PARAM-VALUE">
      <xsd:annotation>
         <xsd:documentation>This parameter corresponds to EcucAddInfoParamDef.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucAddInfoParamValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-INDEXABLE-VALUE"/>
         <xsd:group ref="AR:ECUC-PARAMETER-VALUE"/>
         <xsd:group ref="AR:ECUC-ADD-INFO-PARAM-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucBooleanParamDef -->
   <xsd:group name="ECUC-BOOLEAN-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Boolean. Allowed values are true and false.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucBooleanParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="AR:BOOLEAN-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Default value of the boolean configuration parameter.

            atpVariation: [ECUC00083]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucBooleanParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucBooleanParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-BOOLEAN-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Boolean. Allowed values are true and false.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucBooleanParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-BOOLEAN-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucChoiceContainerDef -->
   <xsd:group name="ECUC-CHOICE-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>Used to define configuration containers that provide a choice between several EcucParamConfContainerDef. But in the actual ECU Configuration Values only one instance from the choice list will be present.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucChoiceContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHOICES">
            <xsd:annotation>
               <xsd:documentation>The choices available in a EcucChoiceContainerDef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="choice.EcucChoiceContainerDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-PARAM-CONF-CONTAINER-DEF" type="AR:ECUC-PARAM-CONF-CONTAINER-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucChoiceContainerDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-CHOICE-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>Used to define configuration containers that provide a choice between several EcucParamConfContainerDef. But in the actual ECU Configuration Values only one instance from the choice list will be present.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucChoiceContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-CONTAINER-DEF"/>
         <xsd:group ref="AR:ECUC-CHOICE-CONTAINER-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucChoiceReferenceDef -->
   <xsd:group name="ECUC-CHOICE-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify alternative references where in the ECU Configuration description only one of the specified references will actually be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucChoiceReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-REFS">
            <xsd:annotation>
               <xsd:documentation>All the possible parameter containers for the reference are specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucChoiceReferenceDef.destination";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DESTINATION-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:ECUC-PARAM-CONF-CONTAINER-DEF--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucChoiceReferenceDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-CHOICE-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify alternative references where in the ECU Configuration description only one of the specified references will actually be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucChoiceReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:group ref="AR:ECUC-CHOICE-REFERENCE-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucCommonAttributes -->
   <xsd:group name="ECUC-COMMON-ATTRIBUTES">
      <xsd:annotation>
         <xsd:documentation>Attributes used by Configuration Parameters as well as References.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucCommonAttributes"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIGURATION-CLASS-AFFECTION" type="AR:ECUC-CONFIGURATION-CLASS-AFFECTION">
            <xsd:annotation>
               <xsd:documentation>Specifes whether changes on this parameter have some affection on other parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="configurationClassAffection.EcucCommonAttributes";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-CONFIG-CLASSES">
            <xsd:annotation>
               <xsd:documentation>Specifies in which ConfigurationClass this parameter or reference is available for which ConfigurationVariant. 
            This aggregation is optional if the surrounding EcucModuleDef has the category STANDARDIZED_MODULE_DEFINITION. If the category attribute of the EcucModuleDef is set to VENDOR_SPECIFIC_MODULE_DEFINITION then this aggregation is mandatory.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="implementationConfigClass.EcucCommonAttributes";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.namePlural="IMPLEMENTATION-CONFIG-CLASSES"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-IMPLEMENTATION-CONFIGURATION-CLASS" type="AR:ECUC-IMPLEMENTATION-CONFIGURATION-CLASS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ORIGIN" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>String specifying if this configuration parameter is an AUTOSAR standardized configuration parameter or if the parameter is hardware- or vendor-specific.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucCommonAttributes.origin";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRES-INDEX" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Used to define whether the value element for this definition shall be provided with an index.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucCommonAttributes.requiresIndex";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="ECUC-COMMON-ATTRIBUTES--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-ADD-INFO-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-CHOICE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-COMMON-ATTRIBUTES"/>
         <xsd:enumeration value="ECUC-ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FOREIGN-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-FUNCTION-NAME-DEF"/>
         <xsd:enumeration value="ECUC-INSTANCE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-LINKER-SYMBOL-DEF"/>
         <xsd:enumeration value="ECUC-MULTILINE-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-PARAMETER-DEF"/>
         <xsd:enumeration value="ECUC-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-SYMBOLIC-NAME-REFERENCE-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::EcucConditionFormula -->
   <xsd:group name="ECUC-CONDITION-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This formula must yield a boolean expression depending on ecuc queries. Note that the EcucConditionFormula is a mixed string. Therfore the properties have the uppermultiplicity 1.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucConditionFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="ECUC-QUERY-REF">
               <xsd:annotation>
                  <xsd:documentation>The EcucQuery serves as a argument for the formula.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="EcucConditionFormula.ecucQuery";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:ECUC-QUERY--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="ECUC-QUERY-STRING-REF">
               <xsd:annotation>
                  <xsd:documentation>This indicates that the referenced query shall return a string.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="EcucConditionFormula.ecucQueryString";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:ECUC-QUERY--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucConditionFormula -->
   <xsd:complexType abstract="false" mixed="true" name="ECUC-CONDITION-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This formula must yield a boolean expression depending on ecuc queries. Note that the EcucConditionFormula is a mixed string. Therfore the properties have the uppermultiplicity 1.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucConditionFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:ECUC-CONDITION-FORMULA"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucConditionSpecification -->
   <xsd:group name="ECUC-CONDITION-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Allows to define existence dependencies based on the value of  parameter values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucConditionSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONDITION-FORMULA" type="AR:ECUC-CONDITION-FORMULA">
            <xsd:annotation>
               <xsd:documentation>Definition of the formula used to define existence dependencies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="conditionFormula.EcucConditionSpecification";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-QUERYS">
            <xsd:annotation>
               <xsd:documentation>Query to the ECU Configuration Description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ecucQuery.EcucConditionSpecification";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-QUERY" type="AR:ECUC-QUERY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INFORMAL-FORMULA" type="AR:ML-FORMULA">
            <xsd:annotation>
               <xsd:documentation>Informal description of the condition used to to define existence dependencies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="informalFormula.EcucConditionSpecification";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucConditionSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-CONDITION-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Allows to define existence dependencies based on the value of  parameter values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucConditionSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-CONDITION-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucConfigurationClassAffection -->
   <xsd:group name="ECUC-CONFIGURATION-CLASS-AFFECTION">
      <xsd:annotation>
         <xsd:documentation>Specifies in the "VendorSpecificModuleDefinition" whether changes on this parameter do affect other parameters in a later configuration step.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationClassAffection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AFFECTED-REFS">
            <xsd:annotation>
               <xsd:documentation>Optional reference to parameters or references which are affected by the ConfigurationClassAffection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationClassAffection.affected";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AFFECTED-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:ECUC-COMMON-ATTRIBUTES--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="AFFECTION-KIND" type="AR:ECUC-AFFECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies which affect do changes in this parameter have on other parameters.  This attribute is deprecated and will be removed in future versions.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="EcucConfigurationClassAffection.affectionKind";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucConfigurationClassAffection -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-CONFIGURATION-CLASS-AFFECTION">
      <xsd:annotation>
         <xsd:documentation>Specifies in the "VendorSpecificModuleDefinition" whether changes on this parameter do affect other parameters in a later configuration step.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationClassAffection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-CONFIGURATION-CLASS-AFFECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucContainerDef -->
   <xsd:group name="ECUC-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>Base class used to gather common attributes of configuration container definitions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="POST-BUILD-CHANGEABLE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Specifies if the number of instances of this container may be changed post-build time. This parameter may only be set to true if all of the following conditions hold:
            - the container's upperMultiplicity &amp;gt; lowerMultiplicity
            - all parameters within the container and subContainers are post-build time changeable.
            If any of the aggregated parameters is either pre-compile time or link time this attribute is ignored and may be omitted.

            This attribute is optional if the surrounding EcucModuleDef has the category STANDARDIZED_MODULE_DEFINITION. If the category attribute of the EcucModuleDef is set to VENDOR_SPECIFIC_MODULE_DEFINITION then this attribute is mandatory.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucContainerDef.postBuildChangeable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="ECUC-CONTAINER-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-CHOICE-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-PARAM-CONF-CONTAINER-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCDescriptionTemplate::EcucContainerValue -->
   <xsd:group name="ECUC-CONTAINER-VALUE">
      <xsd:annotation>
         <xsd:documentation>Represents a Container definition in the ECU Configuration Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucContainerValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFINITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the definition of this Container in the ECU Configuration Parameter Definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucContainerValue.definition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-CONTAINER-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-VALUES">
            <xsd:annotation>
               <xsd:documentation>Aggregates all ECU Configuration Values within this Container.

            atpVariation: [ECUC0079]
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="definition, variationPoint.shortLabel";mmt.qualifiedName="parameterValue.EcucContainerValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-ADD-INFO-PARAM-VALUE" type="AR:ECUC-ADD-INFO-PARAM-VALUE"/>
                  <xsd:element name="ECUC-NUMERICAL-PARAM-VALUE" type="AR:ECUC-NUMERICAL-PARAM-VALUE"/>
                  <xsd:element name="ECUC-TEXTUAL-PARAM-VALUE" type="AR:ECUC-TEXTUAL-PARAM-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFERENCE-VALUES">
            <xsd:annotation>
               <xsd:documentation>Aggregates all References with this container.

            atpVariation: [ECUC0079]
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="definition, variationPoint.shortLabel";mmt.qualifiedName="referenceValue.EcucContainerValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-INSTANCE-REFERENCE-VALUE" type="AR:ECUC-INSTANCE-REFERENCE-VALUE"/>
                  <xsd:element name="ECUC-REFERENCE-VALUE" type="AR:ECUC-REFERENCE-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-CONTAINERS">
            <xsd:annotation>
               <xsd:documentation>Aggregates all sub-containers within this container.

            atpVariation: [ECUC0078]
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="definition, shortName, variationPoint.shortLabel";mmt.qualifiedName="subContainer.EcucContainerValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-CONTAINER-VALUE" type="AR:ECUC-CONTAINER-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucContainerValue -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-CONTAINER-VALUE">
      <xsd:annotation>
         <xsd:documentation>Represents a Container definition in the ECU Configuration Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucContainerValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-CONTAINER-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucDefinitionCollection -->
   <xsd:group name="ECUC-DEFINITION-COLLECTION">
      <xsd:annotation>
         <xsd:documentation>This represents the anchor point of an ECU Configuration Parameter Definition within the AUTOSAR templates structure.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcucDefinitionCollections";mmt.qualifiedName="EcucDefinitionCollection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODULE-REFS">
            <xsd:annotation>
               <xsd:documentation>References to  the module definitions of individual software modules.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucDefinitionCollection.module";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODULE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:ECUC-MODULE-DEF--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucDefinitionCollection -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-DEFINITION-COLLECTION">
      <xsd:annotation>
         <xsd:documentation>This represents the anchor point of an ECU Configuration Parameter Definition within the AUTOSAR templates structure.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcucDefinitionCollections";mmt.qualifiedName="EcucDefinitionCollection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-COLLECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucDefinitionElement -->
   <xsd:group name="ECUC-DEFINITION-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Common class used to express the commonalities of configuration parameters, references and containers.
      If not stated otherwise the default multiplicity is exactly one mandatory occurrence of the specified element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucDefinitionElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-COND" type="AR:ECUC-CONDITION-SPECIFICATION">
            <xsd:annotation>
               <xsd:documentation>If it evaluates to true the Ecu Parameter definition shall be processed as specified. Otherwise the parameter definition shall be ignored.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucDefinitionElement.ecucCond";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-MULTIPLICITY" type="AR:POSITIVE-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>The lower multiplicity of the specified element.
            0: optional
            1: at least one occurence
            n: at least n occurrences

            atpVariation: [ECUC00082]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucDefinitionElement.lowerMultiplicity";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-MULTIPLICITY" type="AR:POSITIVE-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of the specified element.
            0: no occurrence (used for VSMD)
            1: at most one occurrence
            m: at most m occurrences

            If upperMultiplicity is set than upperMultiplicityInfinite shall not be used. 

            atpVariation: [ECUC00082]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucDefinitionElement.upperMultiplicity";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-MULTIPLICITY-INFINITE" type="AR:BOOLEAN-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>To express an infinite number of occurrences of this element this attribute has to be set to true. 

            If upperMultiplicityInfinite is set than upperMultiplicity shall not be used.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucDefinitionElement.upperMultiplicityInfinite";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="ECUC-DEFINITION-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-ADD-INFO-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-CHOICE-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-CHOICE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-COMMON-ATTRIBUTES"/>
         <xsd:enumeration value="ECUC-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-DEFINITION-ELEMENT"/>
         <xsd:enumeration value="ECUC-ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FOREIGN-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-FUNCTION-NAME-DEF"/>
         <xsd:enumeration value="ECUC-INSTANCE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-LINKER-SYMBOL-DEF"/>
         <xsd:enumeration value="ECUC-MODULE-DEF"/>
         <xsd:enumeration value="ECUC-MULTILINE-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-PARAM-CONF-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-PARAMETER-DEF"/>
         <xsd:enumeration value="ECUC-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-SYMBOLIC-NAME-REFERENCE-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::EcucDerivationSpecification -->
   <xsd:group name="ECUC-DERIVATION-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Allows to define configuration items that are calculated based on the value of
      - other parameter values
      - elements (attributes/classes) defined in other AUTOSAR templates such as System template and SW component template</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucDerivationSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALCULATION-FORMULA" type="AR:ECUC-PARAMETER-DERIVATION-FORMULA">
            <xsd:annotation>
               <xsd:documentation>Definition of the formula used to calculate the value of the configuration element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucDerivationSpecification.calculationFormula";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-QUERYS">
            <xsd:annotation>
               <xsd:documentation>Query to the ECU Configuration Description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ecucQuery.EcucDerivationSpecification";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-QUERY" type="AR:ECUC-QUERY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INFORMAL-FORMULA" type="AR:ML-FORMULA">
            <xsd:annotation>
               <xsd:documentation>Informal description of the derivation used to calculate the value of the configuration element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucDerivationSpecification.informalFormula";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucDerivationSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-DERIVATION-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Allows to define configuration items that are calculated based on the value of
      - other parameter values
      - elements (attributes/classes) defined in other AUTOSAR templates such as System template and SW component template</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucDerivationSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-DERIVATION-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucEnumerationLiteralDef -->
   <xsd:group name="ECUC-ENUMERATION-LITERAL-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for enumeration literals definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucEnumerationLiteralDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-COND" type="AR:ECUC-CONDITION-SPECIFICATION">
            <xsd:annotation>
               <xsd:documentation>If it evaluates to true the literal definition shall be processed as specified. Otherwise the literal definition shall be ignored.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucEnumerationLiteralDef.ecucCond";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ORIGIN" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>String specifying if this literal is an AUTOSAR standardized literal or if the literal is vendor-specific.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucEnumerationLiteralDef.origin";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucEnumerationLiteralDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-ENUMERATION-LITERAL-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for enumeration literals definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucEnumerationLiteralDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-ENUMERATION-LITERAL-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucEnumerationParamDef -->
   <xsd:group name="ECUC-ENUMERATION-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Enumeration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucEnumerationParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Default value of the enumeration configuration parameter. This string needs to be one of the literals specified for this enumeration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="defaultValue.EcucEnumerationParamDef";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LITERALS">
            <xsd:annotation>
               <xsd:documentation>Aggregation on the literals used to define this enumeration parameter. 
            This aggregation is optional if the surrounding EcucModuleDef has the category STANDARDIZED_MODULE_DEFINITION. If the category attribute of the EcucModuleDef is set to VENDOR_SPECIFIC_MODULE_DEFINITION then this aggregation is mandatory.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="literal.EcucEnumerationParamDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-ENUMERATION-LITERAL-DEF" type="AR:ECUC-ENUMERATION-LITERAL-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucEnumerationParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-ENUMERATION-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Enumeration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucEnumerationParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-ENUMERATION-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucFloatParamDef -->
   <xsd:group name="ECUC-FLOAT-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Float.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucFloatParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="AR:FLOAT-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Default value of the float configuration parameter.

            atpVariation: [ECUC00083]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucFloatParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="AR:FLOAT-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Max value allowed for the parameter defined.

            atpVariation: [ECUC00084]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucFloatParamDef.max";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="AR:FLOAT-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Min value allowed for the parameter defined.

            atpVariation: [ECUC00084]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucFloatParamDef.min";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucFloatParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-FLOAT-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Float.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucFloatParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-FLOAT-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucForeignReferenceDef -->
   <xsd:group name="ECUC-FOREIGN-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify a reference to an XML description of an entity described in another AUTOSAR template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucForeignReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-TYPE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>The type in the AUTOSAR Metamodel to which instance this reference is allowed to point to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucForeignReferenceDef.destinationType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucForeignReferenceDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-FOREIGN-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify a reference to an XML description of an entity described in another AUTOSAR template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucForeignReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:group ref="AR:ECUC-FOREIGN-REFERENCE-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucFunctionNameDef -->
   <xsd:group name="ECUC-FUNCTION-NAME-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Function Names like those used to specify callback functions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucFunctionNameDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-FUNCTION-NAME-DEF-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-FUNCTION-NAME-DEF-CONDITIONAL" type="AR:ECUC-FUNCTION-NAME-DEF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucFunctionNameDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-FUNCTION-NAME-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Function Names like those used to specify callback functions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucFunctionNameDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:group ref="AR:ECUC-FUNCTION-NAME-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucFunctionNameDefConditional -->
   <xsd:group name="ECUC-FUNCTION-NAME-DEF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucFunctionNameDefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-FUNCTION-NAME-DEF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-STRING-PARAM-DEF-CONTENT"/>
         <xsd:group ref="AR:ECUC-FUNCTION-NAME-DEF-CONTENT"/>
         <xsd:group ref="AR:ECUC-FUNCTION-NAME-DEF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucFunctionNameDefContent -->
   <xsd:group name="ECUC-FUNCTION-NAME-DEF-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::EcucImplementationConfigurationClass -->
   <xsd:group name="ECUC-IMPLEMENTATION-CONFIGURATION-CLASS">
      <xsd:annotation>
         <xsd:documentation>Specifies which ConfigurationClass this parameter has in the individual ConfigurationVariants.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucImplementationConfigurationClass"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIG-CLASS" type="AR:ECUC-CONFIGURATION-CLASS-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies the ConfigurationClass for the given ConfigurationVariant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucImplementationConfigurationClass.configClass";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIG-VARIANT" type="AR:ECUC-CONFIGURATION-VARIANT-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies the ConfigurationVariant the ConfigurationClass is specified for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucImplementationConfigurationClass.configVariant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucImplementationConfigurationClass -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-IMPLEMENTATION-CONFIGURATION-CLASS">
      <xsd:annotation>
         <xsd:documentation>Specifies which ConfigurationClass this parameter has in the individual ConfigurationVariants.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucImplementationConfigurationClass"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-IMPLEMENTATION-CONFIGURATION-CLASS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EcucIndexableValue -->
   <xsd:group name="ECUC-INDEXABLE-VALUE">
      <xsd:annotation>
         <xsd:documentation>Used to allow specifying ordering of parameter values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucIndexableValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEX" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Used to allow specifying ordering of parameter values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucIndexableValue.index";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::EcucInstanceReferenceDef -->
   <xsd:group name="ECUC-INSTANCE-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template using the INSTANCE REFERENCE semantics.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucInstanceReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-CONTEXT" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>The context in the AUTOSAR Metamodel to which' this reference is allowed to point to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucInstanceReferenceDef.destinationContext";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-TYPE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>The type in the AUTOSAR Metamodel to which' instance this reference is allowed to point to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucInstanceReferenceDef.destinationType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucInstanceReferenceDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-INSTANCE-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template using the INSTANCE REFERENCE semantics.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucInstanceReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:group ref="AR:ECUC-INSTANCE-REFERENCE-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EcucInstanceReferenceValue -->
   <xsd:group name="ECUC-INSTANCE-REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>InstanceReference representation in the ECU Configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucInstanceReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-IREF" type="AR:ANY-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>InstanceReference representation in the ECU Configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="value.EcucInstanceReferenceValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucInstanceReferenceValue -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-INSTANCE-REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>InstanceReference representation in the ECU Configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucInstanceReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-INDEXABLE-VALUE"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-REFERENCE-VALUE"/>
         <xsd:group ref="AR:ECUC-INSTANCE-REFERENCE-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucIntegerParamDef -->
   <xsd:group name="ECUC-INTEGER-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Integer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucIntegerParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="AR:UNLIMITED-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Default value of the integer configuration parameter.

            atpVariation: [ECUC00083]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucIntegerParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="AR:UNLIMITED-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Max value allowed for the parameter defined.

            atpVariation: [ECUC00084]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucIntegerParamDef.max";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="AR:UNLIMITED-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Min value allowed for the parameter defined.

            atpVariation: [ECUC00084]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="EcucIntegerParamDef.min";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucIntegerParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-INTEGER-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Integer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucIntegerParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-INTEGER-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucLinkerSymbolDef -->
   <xsd:group name="ECUC-LINKER-SYMBOL-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Linker Symbol Names like those used to specify memory locations of variables and constants.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucLinkerSymbolDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-LINKER-SYMBOL-DEF-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-LINKER-SYMBOL-DEF-CONDITIONAL" type="AR:ECUC-LINKER-SYMBOL-DEF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucLinkerSymbolDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-LINKER-SYMBOL-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Linker Symbol Names like those used to specify memory locations of variables and constants.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucLinkerSymbolDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:group ref="AR:ECUC-LINKER-SYMBOL-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucLinkerSymbolDefConditional -->
   <xsd:group name="ECUC-LINKER-SYMBOL-DEF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucLinkerSymbolDefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-LINKER-SYMBOL-DEF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-STRING-PARAM-DEF-CONTENT"/>
         <xsd:group ref="AR:ECUC-LINKER-SYMBOL-DEF-CONTENT"/>
         <xsd:group ref="AR:ECUC-LINKER-SYMBOL-DEF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucLinkerSymbolDefContent -->
   <xsd:group name="ECUC-LINKER-SYMBOL-DEF-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ECUCDescriptionTemplate::EcucModuleConfigurationValues -->
   <xsd:group name="ECUC-MODULE-CONFIGURATION-VALUES">
      <xsd:annotation>
         <xsd:documentation>Head of the configuration of one Module. A Module can be a BSW module as well as the RTE and ECU Infrastructure.

      As part of tthe BSW module description, the EcucModuleConfigurationValues element has two different roles:

      The recommendedConfiguration contains parameter values recommended by the BSW module vendor. 

      The preconfiguredConfiguration contains values for those parameters which are fixed by the implementation and cannot be changed.

      These two EcucModuleConfigurationValues are used when the base EcucModuleConfigurationValues (as part of the base ECU configuration) is created to fill parameters with initial values.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcucModuleConfigurationValuess";mmt.qualifiedName="EcucModuleConfigurationValues"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFINITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the definition of this EcucModuleConfigurationValues element. Typically, this is a vendor specific module configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucModuleConfigurationValues.definition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-MODULE-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-DEF-EDITION" type="AR:REVISION-LABEL-STRING">
            <xsd:annotation>
               <xsd:documentation>This is the version info of the ModuleDef ECUC Parameter definition to which this values conform to / are based on.

            For the Definition of ModuleDef ECUC Parameters the ADMIN-DATA shall be used to express the semantical changes. The compatibility rules between the definition and value revision labels is up to the module's vendor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucModuleConfigurationValues.ecucDefEdition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-CONFIG-VARIANT" type="AR:ECUC-CONFIGURATION-VARIANT-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies the kind of deliverable this EcucModuleConfigurationValues element provides. If this element is not used in a particular role (e.g. preconfiguredConfiguration or recommendedConfiguration) then the value must be one of VariantPreCompile, VariantLinkTime, VariantPostBuild.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucModuleConfigurationValues.implementationConfigVariant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODULE-DESCRIPTION-REF">
            <xsd:annotation>
               <xsd:documentation>Referencing the BSW module description, which this EcucModuleConfigurationValues element is configuring. This is optional because the EcucModuleConfigurationValues element is also used to configure the ECU infrastructure (memory map) or Application SW-Cs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucModuleConfigurationValues.moduleDescription";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-IMPLEMENTATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTAINERS">
            <xsd:annotation>
               <xsd:documentation>Aggregates all containers that belong to this module configuration.

            atpVariation: [ECUC0078]
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="definition, shortName, variationPoint.shortLabel";mmt.qualifiedName="container.EcucModuleConfigurationValues";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-CONTAINER-VALUE" type="AR:ECUC-CONTAINER-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucModuleConfigurationValues -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-MODULE-CONFIGURATION-VALUES">
      <xsd:annotation>
         <xsd:documentation>Head of the configuration of one Module. A Module can be a BSW module as well as the RTE and ECU Infrastructure.

      As part of tthe BSW module description, the EcucModuleConfigurationValues element has two different roles:

      The recommendedConfiguration contains parameter values recommended by the BSW module vendor. 

      The preconfiguredConfiguration contains values for those parameters which are fixed by the implementation and cannot be changed.

      These two EcucModuleConfigurationValues are used when the base EcucModuleConfigurationValues (as part of the base ECU configuration) is created to fill parameters with initial values.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcucModuleConfigurationValuess";mmt.qualifiedName="EcucModuleConfigurationValues"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ECUC-MODULE-CONFIGURATION-VALUES"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECUC-MODULE-CONFIGURATION-VALUES--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-MODULE-CONFIGURATION-VALUES"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCDescriptionTemplate::EcucModuleConfigurationValuesRefConditional -->
   <xsd:group name="ECUC-MODULE-CONFIGURATION-VALUES-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-MODULE-CONFIGURATION-VALUES-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-MODULE-CONFIGURATION-VALUES--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucModuleConfigurationValuesRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-MODULE-CONFIGURATION-VALUES-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-MODULE-CONFIGURATION-VALUES-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucModuleDef -->
   <xsd:group name="ECUC-MODULE-DEF">
      <xsd:annotation>
         <xsd:documentation>Used as the top-level element for configuration definition for Software Modules, including BSW and RTE as well as ECU Infrastructure.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcucModuleDefs";mmt.qualifiedName="EcucModuleDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="API-SERVICE-PREFIX" type="AR:C-IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>For CDD modules this attribute holds the module abbreviation.

            The shortName of the module definition of a complex device driver is always "CDD". Therefore for CDD modules the module shortName shall be described with this apiServicePrefix attribute.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucModuleDef.apiServicePrefix";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFINED-MODULE-DEF-REF">
            <xsd:annotation>
               <xsd:documentation>Optional reference from the Vendor Specific Module Definition to the Standardized Module Definition it refines. 
            In case this EcucModuleDef has the category STANDARDIZED_MODULE_DEFINITION 
            this reference shall not be provided. In case this EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION this reference is mandatory.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucModuleDef.refinedModuleDef";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-MODULE-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTED-CONFIG-VARIANTS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SUPPORTED-CONFIG-VARIANT" type="AR:ECUC-CONFIGURATION-VARIANT-ENUM">
                     <xsd:annotation>
                        <xsd:documentation>Specifies which ConfigurationVariants are supported by this software module. 
                     This attribute is optional if the EcucModuleDef has the category STANDARDIZED_MODULE_DEFINITION. If the category attribute of the EcucModuleDef is set to VENDOR_SPECIFIC_MODULE_DEFINITION then this attribute is mandatory.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="EcucModuleDef.supportedConfigVariant";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTAINERS">
            <xsd:annotation>
               <xsd:documentation>Aggregates the top-level container definitions of this specific module definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="container.EcucModuleDef";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="11"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-CHOICE-CONTAINER-DEF" type="AR:ECUC-CHOICE-CONTAINER-DEF"/>
                  <xsd:element name="ECUC-PARAM-CONF-CONTAINER-DEF" type="AR:ECUC-PARAM-CONF-CONTAINER-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucModuleDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-MODULE-DEF">
      <xsd:annotation>
         <xsd:documentation>Used as the top-level element for configuration definition for Software Modules, including BSW and RTE as well as ECU Infrastructure.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcucModuleDefs";mmt.qualifiedName="EcucModuleDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-MODULE-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECUC-MODULE-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-MODULE-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::EcucMultilineStringParamDef -->
   <xsd:group name="ECUC-MULTILINE-STRING-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for multiline Strings (including "carriage return").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucMultilineStringParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-MULTILINE-STRING-PARAM-DEF-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-MULTILINE-STRING-PARAM-DEF-CONDITIONAL" type="AR:ECUC-MULTILINE-STRING-PARAM-DEF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucMultilineStringParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-MULTILINE-STRING-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for multiline Strings (including "carriage return").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucMultilineStringParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:group ref="AR:ECUC-MULTILINE-STRING-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucMultilineStringParamDefConditional -->
   <xsd:group name="ECUC-MULTILINE-STRING-PARAM-DEF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucMultilineStringParamDefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-MULTILINE-STRING-PARAM-DEF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-STRING-PARAM-DEF-CONTENT"/>
         <xsd:group ref="AR:ECUC-MULTILINE-STRING-PARAM-DEF-CONTENT"/>
         <xsd:group ref="AR:ECUC-MULTILINE-STRING-PARAM-DEF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucMultilineStringParamDefContent -->
   <xsd:group name="ECUC-MULTILINE-STRING-PARAM-DEF-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ECUCDescriptionTemplate::EcucNumericalParamValue -->
   <xsd:group name="ECUC-NUMERICAL-PARAM-VALUE">
      <xsd:annotation>
         <xsd:documentation>Holding the value which is subject to variant handling.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucNumericalParamValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Value which is subject to variant handling.

            atpVariation: [ECUC00080]</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="EcucNumericalParamValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucNumericalParamValue -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-NUMERICAL-PARAM-VALUE">
      <xsd:annotation>
         <xsd:documentation>Holding the value which is subject to variant handling.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucNumericalParamValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-INDEXABLE-VALUE"/>
         <xsd:group ref="AR:ECUC-PARAMETER-VALUE"/>
         <xsd:group ref="AR:ECUC-NUMERICAL-PARAM-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucParamConfContainerDef -->
   <xsd:group name="ECUC-PARAM-CONF-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>Used to define configuration containers that can hierarchically contain other containers and/or parameter definitions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucParamConfContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTIPLE-CONFIGURATION-CONTAINER" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Specifies whether this container is used to define multiple configuration sets. Only one container in the whole EcucModuleDef shall have this enabled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucParamConfContainerDef.multipleConfigurationContainer";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETERS">
            <xsd:annotation>
               <xsd:documentation>The parameters defined within the EcucParamConfContainerDef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="parameter.EcucParamConfContainerDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-ADD-INFO-PARAM-DEF" type="AR:ECUC-ADD-INFO-PARAM-DEF"/>
                  <xsd:element name="ECUC-BOOLEAN-PARAM-DEF" type="AR:ECUC-BOOLEAN-PARAM-DEF"/>
                  <xsd:element name="ECUC-ENUMERATION-PARAM-DEF" type="AR:ECUC-ENUMERATION-PARAM-DEF"/>
                  <xsd:element name="ECUC-FLOAT-PARAM-DEF" type="AR:ECUC-FLOAT-PARAM-DEF"/>
                  <xsd:element name="ECUC-FUNCTION-NAME-DEF" type="AR:ECUC-FUNCTION-NAME-DEF"/>
                  <xsd:element name="ECUC-INTEGER-PARAM-DEF" type="AR:ECUC-INTEGER-PARAM-DEF"/>
                  <xsd:element name="ECUC-LINKER-SYMBOL-DEF" type="AR:ECUC-LINKER-SYMBOL-DEF"/>
                  <xsd:element name="ECUC-MULTILINE-STRING-PARAM-DEF" type="AR:ECUC-MULTILINE-STRING-PARAM-DEF"/>
                  <xsd:element name="ECUC-STRING-PARAM-DEF" type="AR:ECUC-STRING-PARAM-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFERENCES">
            <xsd:annotation>
               <xsd:documentation>The references defined within the EcucParamConfContainerDef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="reference.EcucParamConfContainerDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-CHOICE-REFERENCE-DEF" type="AR:ECUC-CHOICE-REFERENCE-DEF"/>
                  <xsd:element name="ECUC-FOREIGN-REFERENCE-DEF" type="AR:ECUC-FOREIGN-REFERENCE-DEF"/>
                  <xsd:element name="ECUC-INSTANCE-REFERENCE-DEF" type="AR:ECUC-INSTANCE-REFERENCE-DEF"/>
                  <xsd:element name="ECUC-REFERENCE-DEF" type="AR:ECUC-REFERENCE-DEF"/>
                  <xsd:element name="ECUC-SYMBOLIC-NAME-REFERENCE-DEF" type="AR:ECUC-SYMBOLIC-NAME-REFERENCE-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-CONTAINERS">
            <xsd:annotation>
               <xsd:documentation>The containers defined within the EcucParamConfContainerDef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="subContainer.EcucParamConfContainerDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-CHOICE-CONTAINER-DEF" type="AR:ECUC-CHOICE-CONTAINER-DEF"/>
                  <xsd:element name="ECUC-PARAM-CONF-CONTAINER-DEF" type="AR:ECUC-PARAM-CONF-CONTAINER-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucParamConfContainerDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-PARAM-CONF-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>Used to define configuration containers that can hierarchically contain other containers and/or parameter definitions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucParamConfContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-CONTAINER-DEF"/>
         <xsd:group ref="AR:ECUC-PARAM-CONF-CONTAINER-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECUC-PARAM-CONF-CONTAINER-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-PARAM-CONF-CONTAINER-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::EcucParameterDef -->
   <xsd:group name="ECUC-PARAMETER-DEF">
      <xsd:annotation>
         <xsd:documentation>Abstract class used to define the similarities of all ECU Configuration Parameter types defined as subclasses.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DERIVATION" type="AR:ECUC-DERIVATION-SPECIFICATION">
            <xsd:annotation>
               <xsd:documentation>A derivation of a Configuration Parameter value can be specified by an informal Calculation Formula or by a formal language that can be used to specify the computational rules.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="derivation.EcucParameterDef";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOLIC-NAME-VALUE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Specifies that this parameter's value is used, together with the aggregating container, to derive a symbolic name definition. See chapter "Representation of Symbolic Names" in Ecuc specification for more details.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterDef.symbolicNameValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WITH-AUTO" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Specifies whether it shall be allowed on the value side to specify this parameter value as "AUTO".

            If withAuto is "true" it shall be possible to set the "isAutoValue" attribute of the respective parameter to "true". This means that the actual value will not be considered during ECU Configuration but will be (re-)calculated by the code generator and stored in the value attribute afterwards. These implicit updated values might require a re-generation of other modules which reference these values.

            If withAuto is "false" it shall not be possible to set the "isAutoValue" attribute of the respective parameter to "true".

            If withAuto is not present the default is "false".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterDef.withAuto";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="ECUC-PARAMETER-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-ADD-INFO-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FUNCTION-NAME-DEF"/>
         <xsd:enumeration value="ECUC-INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-LINKER-SYMBOL-DEF"/>
         <xsd:enumeration value="ECUC-MULTILINE-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-PARAMETER-DEF"/>
         <xsd:enumeration value="ECUC-STRING-PARAM-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::EcucParameterDerivationFormula -->
   <xsd:group name="ECUC-PARAMETER-DERIVATION-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This formula is intended to specify how an ecu parameter can be derived from other information in the Autosar Templates.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterDerivationFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="ECUC-QUERY-REF">
               <xsd:annotation>
                  <xsd:documentation>This is one particular EcucQuery used in the calculation formula.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterDerivationFormula.ecucQuery";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:ECUC-QUERY--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="ECUC-QUERY-STRING-REF">
               <xsd:annotation>
                  <xsd:documentation>This indicates that the referenced query shall return a string.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterDerivationFormula.ecucQueryString";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:ECUC-QUERY--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucParameterDerivationFormula -->
   <xsd:complexType abstract="false" mixed="true" name="ECUC-PARAMETER-DERIVATION-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This formula is intended to specify how an ecu parameter can be derived from other information in the Autosar Templates.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterDerivationFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DERIVATION-FORMULA"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EcucParameterValue -->
   <xsd:group name="ECUC-PARAMETER-VALUE">
      <xsd:annotation>
         <xsd:documentation>Common class to all types of configuration values</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFINITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the definition of this EcucParameterValue subclasses in the ECU Configuration Parameter Definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterValue.definition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-PARAMETER-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Possibility to provide additional notes while defining the ECU Configuration Parameter Values. These are not intended as documentation but are mere design notes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterValue.annotation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ANNOTATION" type="AR:ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-AUTO-VALUE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>When withAuto is set to "true" for this parameter definition the isAutoValue can be set to "true".
            If isAutoValue is set to "true" the actual value will not be considered during ECU Configuration but will be (re-)calculated by the code generator and stored in the value attribute afterwards. These implicit updated values might require a re-generation of other modules which reference these values.

            If isAutoValue is not present the default is "false".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucParameterValue.isAutoValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::EcucQuery -->
   <xsd:group name="ECUC-QUERY">
      <xsd:annotation>
         <xsd:documentation>Defines a query to the ECUC Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucQuery"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-QUERY-EXPRESSION" type="AR:ECUC-QUERY-EXPRESSION">
            <xsd:annotation>
               <xsd:documentation>This is the EcucQuery used in the calculation formula or the condition formula.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucQuery.ecucQueryExpression";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucQuery -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-QUERY">
      <xsd:annotation>
         <xsd:documentation>Defines a query to the ECUC Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucQuery"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-QUERY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECUC-QUERY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-QUERY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::EcucQueryExpression -->
   <xsd:group name="ECUC-QUERY-EXPRESSION">
      <xsd:annotation>
         <xsd:documentation>Defines a query expression to the ECUC Description and output the result as an numerical value. Due to the "mixedString" nature of the formula there can be several EcuQueryExpressions used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucQueryExpression"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="CONFIG-ELEMENT-DEF-GLOBAL-REF">
               <xsd:annotation>
                  <xsd:documentation>The EcucQueryExpression points to an EcucDefinitionElement that is used to find an element in the EcucDescription. In order to find the right element in the EcucDescription a search is necessary. If the complete EcucDescription needs to be searched this global reference shall be used. Due to the "mixedString" nature of the EcucQueryExpression several references to EcucDefintionElements can be used in one EcucQueryExpression.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="EcucQueryExpression.configElementDefGlobal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:ECUC-DEFINITION-ELEMENT--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="CONFIG-ELEMENT-DEF-LOCAL-REF">
               <xsd:annotation>
                  <xsd:documentation>The EcucQueryExpression points to an EcucDefinitionElement that is used to find an element in the EcucDescription. In order to find the right element in the EcucDescription a search is necessary. If the search is executed inside of the same module that contains the EcucQuery this local reference shall be used. Due to the "mixedString" nature of the EcucQueryExpression several references to EcucDefintionElements can be used in one EcucQueryExpression.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="EcucQueryExpression.configElementDefLocal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:ECUC-DEFINITION-ELEMENT--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucQueryExpression -->
   <xsd:complexType abstract="false" mixed="true" name="ECUC-QUERY-EXPRESSION">
      <xsd:annotation>
         <xsd:documentation>Defines a query expression to the ECUC Description and output the result as an numerical value. Due to the "mixedString" nature of the formula there can be several EcuQueryExpressions used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucQueryExpression"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-QUERY-EXPRESSION"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucReferenceDef -->
   <xsd:group name="ECUC-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify references within the ECU Configuration Description between parameter containers.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-REF">
            <xsd:annotation>
               <xsd:documentation>Exactly one reference to a parameter container is allowed as destination.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucReferenceDef.destination";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-PARAM-CONF-CONTAINER-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucReferenceDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify references within the ECU Configuration Description between parameter containers.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:group ref="AR:ECUC-REFERENCE-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EcucReferenceValue -->
   <xsd:group name="ECUC-REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>Used to represent a configuration value that has a parameter definition of type EcucAbstractReferenceDef(used for all of its specializations excluding EcucInstanceReferenceDef).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-REF">
            <xsd:annotation>
               <xsd:documentation>Specifes the destination of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucReferenceValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IDENTIFIABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucReferenceValue -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>Used to represent a configuration value that has a parameter definition of type EcucAbstractReferenceDef(used for all of its specializations excluding EcucInstanceReferenceDef).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-INDEXABLE-VALUE"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-REFERENCE-VALUE"/>
         <xsd:group ref="AR:ECUC-REFERENCE-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucStringParamDef -->
   <xsd:group name="ECUC-STRING-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for String.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucStringParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-STRING-PARAM-DEF-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-STRING-PARAM-DEF-CONDITIONAL" type="AR:ECUC-STRING-PARAM-DEF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucStringParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-STRING-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for String.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucStringParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-PARAMETER-DEF"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:group ref="AR:ECUC-STRING-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucStringParamDefConditional -->
   <xsd:group name="ECUC-STRING-PARAM-DEF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucStringParamDefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-STRING-PARAM-DEF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-STRING-PARAM-DEF-CONTENT"/>
         <xsd:group ref="AR:ECUC-STRING-PARAM-DEF-CONTENT"/>
         <xsd:group ref="AR:ECUC-STRING-PARAM-DEF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EcucStringParamDefContent -->
   <xsd:group name="ECUC-STRING-PARAM-DEF-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::EcucSymbolicNameReferenceDef -->
   <xsd:group name="ECUC-SYMBOLIC-NAME-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>This specialization of a EcucContainerReferenceDef specifies that the implementation of the reference is done using a symbolic name defined by the referenced Container's shortName.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucSymbolicNameReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-REF">
            <xsd:annotation>
               <xsd:documentation>Exactly one reference to a parameter container is allowed as destination.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucSymbolicNameReferenceDef.destination";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECUC-PARAM-CONF-CONTAINER-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcucSymbolicNameReferenceDef -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-SYMBOLIC-NAME-REFERENCE-DEF">
      <xsd:annotation>
         <xsd:documentation>This specialization of a EcucContainerReferenceDef specifies that the implementation of the reference is done using a symbolic name defined by the referenced Container's shortName.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucSymbolicNameReferenceDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECUC-DEFINITION-ELEMENT"/>
         <xsd:group ref="AR:ECUC-COMMON-ATTRIBUTES"/>
         <xsd:group ref="AR:ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:group ref="AR:ECUC-SYMBOLIC-NAME-REFERENCE-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EcucTextualParamValue -->
   <xsd:group name="ECUC-TEXTUAL-PARAM-VALUE">
      <xsd:annotation>
         <xsd:documentation>Holding a value which is not subject to variation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucTextualParamValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:VERBATIM-STRING">
            <xsd:annotation>
               <xsd:documentation>Value of the parameter, not subject to variant handling.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucTextualParamValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucTextualParamValue -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-TEXTUAL-PARAM-VALUE">
      <xsd:annotation>
         <xsd:documentation>Holding a value which is not subject to variation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucTextualParamValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ECUC-INDEXABLE-VALUE"/>
         <xsd:group ref="AR:ECUC-PARAMETER-VALUE"/>
         <xsd:group ref="AR:ECUC-TEXTUAL-PARAM-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EcucValueCollection -->
   <xsd:group name="ECUC-VALUE-COLLECTION">
      <xsd:annotation>
         <xsd:documentation>This represents the anchor point of the ECU configuration description.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcucValueCollections";mmt.qualifiedName="EcucValueCollection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-EXTRACT-REF">
            <xsd:annotation>
               <xsd:documentation>Represents the extract of the System Configuration that is relevant for the ECU configured with that ECU Configuration Description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucValueCollection.ecuExtract";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECUC-VALUES">
            <xsd:annotation>
               <xsd:documentation>References to the configuration of individual software modules that are present on this ECU.

            atpVariation: ECUC0078
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="EcucValueCollection.ecucValue";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECUC-MODULE-CONFIGURATION-VALUES-REF-CONDITIONAL" type="AR:ECUC-MODULE-CONFIGURATION-VALUES-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcucValueCollection -->
   <xsd:complexType abstract="false" mixed="false" name="ECUC-VALUE-COLLECTION">
      <xsd:annotation>
         <xsd:documentation>This represents the anchor point of the ECU configuration description.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EcucValueCollections";mmt.qualifiedName="EcucValueCollection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ECUC-VALUE-COLLECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECUC-VALUE-COLLECTION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECUC-VALUE-COLLECTION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InlineTextElements::EmphasisText -->
   <xsd:group name="EMPHASIS-TEXT">
      <xsd:annotation>
         <xsd:documentation>This is an emphasized text. As a compromise it contains some rendering oriented attributes such as color and font.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EmphasisText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="SUB" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>this is subscript text</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="EmphasisText.sub";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUP" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is superscript text</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="EmphasisText.sup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- attribute group for class InlineTextElements::EmphasisText -->
   <xsd:attributeGroup name="EMPHASIS-TEXT">
      <xsd:annotation>
         <xsd:documentation>This is an emphasized text. As a compromise it contains some rendering oriented attributes such as color and font.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EmphasisText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="COLOR" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This allows to recommend a color of the emphasis. It is specified either as color name or as hexadecimal number.

         The syntax is the one of CSS, even if it is modeled as a string.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="EmphasisText.color";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="FONT" type="AR:E-ENUM-FONT--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies the font style in which the emphasized text shall be rendered.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="EmphasisText.font";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="TYPE" type="AR:E-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates how the text may be emphasized. Note that this is only a proposal which can be overridden or ignored by particular formatting engines. Default is BOLD.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="EmphasisText.type";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class InlineTextElements::EmphasisText -->
   <xsd:complexType abstract="false" mixed="true" name="EMPHASIS-TEXT">
      <xsd:annotation>
         <xsd:documentation>This is an emphasized text. As a compromise it contains some rendering oriented attributes such as color and font.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EmphasisText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:EMPHASIS-TEXT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:EMPHASIS-TEXT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::EmptySignalMapping -->
   <xsd:group name="EMPTY-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If no actual data is configured for a client server communication the element EmptySignalMapping shall be used. 
      An EmptySignalMapping shall only reference a SystemSignal that is referenced by an ISignal with length equal to zero. In this case there shall be an "update-bit" configured. The EmptySignal can be mapped to the response group or to request group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EmptySignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a SystemSignal with "signalLength" = 0 and an UpdateBit.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EmptySignalMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::EmptySignalMapping -->
   <xsd:complexType abstract="false" mixed="false" name="EMPTY-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If no actual data is configured for a client server communication the element EmptySignalMapping shall be used. 
      An EmptySignalMapping shall only reference a SystemSignal that is referenced by an ISignal with length equal to zero. In this case there shall be an "update-bit" configured. The EmptySignal can be mapped to the response group or to request group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EmptySignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:EMPTY-SIGNAL-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndDescription -->
   <xsd:group name="END-TO-END-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class contains information about end-to-end protection. The set of applicable attributes depends on the actual value of the category attribute of EndToEndProtection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>The category represents the identification of the concrete E2E profile. The applicable values are specified in a semantic constraint and determine the applicable attributes of EndToEndDescription.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.category";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-IDS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-ID" type="AR:POSITIVE-INTEGER">
                     <xsd:annotation>
                        <xsd:documentation>This represents a unique numerical identifier. 
                     Note: ID is used for protection against masquerading. The details concerning the maximum number of values (this information is specific for each E2E profile) applicable for this attribute are controlled by a semantic constraint that depends on the category of the EndToEndProtection.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.dataId";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="-90"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ID-MODE" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>There are three inclusion modes how the implicit two-byte Data ID is included in the one-byte CRC:

            * dataIDMode = 0: Two bytes are included in the CRC (double ID configuration) This is used in variant 1A.
            * dataIDMode = 1: One of the two bytes byte is included, alternating high and low byte, depending on parity of the counter (alternating ID configuration). For even counter low byte is included; For odd counters the high byte is included. This is used in variant 1B.
            * dataIDMode = 2: Only low byte is included, high byte is never used. This is applicable if the IDs in a particular system are 8 bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.dataIdMode";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-85"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute represents the length of the Array representation of the Signal Group/VariableDataPrototype including CRC and Counter in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.dataLength";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-DELTA-COUNTER-INIT" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Initial maximum allowed gap between two counter values of two consecutively received valid Data, i.e. how many subsequent lost data is accepted. For example, if the receiver gets Data with counter 1 and MaxDeltaCounterInit is 1, then at the next reception the receiver can accept Counters with values 2 and 3, but not 4.

            Note that if the receiver does not receive new Data at a consecutive read, then the receiver increments the tolerance by 1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.maxDeltaCounterInit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CRC-OFFSET" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Bit offset of CRC from the beginning of the Array representation of the Signal Group/VariableDataPrototype (MSB order, bit numbering: bit 0 is the least important). The offset shall be a multiplicity of 8 and it should be 0 whenever possible. For example, offset 8 means that the CRC will take the byte 1, i.e. bits 8..15. If crcOffset is not present the value is defined by the selected profile.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.crcOffset";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-OFFSET" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Bit offset of Counter from the beginning of the Array representation of the Signal Group/VariableDataPrototype (MSB order, bit numbering: bit 0 is the least important). The offset shall be a multiplicity of 4 and it should be 8 whenever possible. For example, offset 8 means that the counter will take the low nibble of the byte 1, i.e. bits 8 .. 11. If counterOffset is not present the value is defined by the selected profile.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.counterOffset";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndDescription -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class contains information about end-to-end protection. The set of applicable attributes depends on the actual value of the category attribute of EndToEndProtection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:END-TO-END-DESCRIPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtection -->
   <xsd:group name="END-TO-END-PROTECTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to describe a particular end to end protection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="END-TO-END-PROFILE" type="AR:END-TO-END-DESCRIPTION">
            <xsd:annotation>
               <xsd:documentation>This represents the particular EndToEndDescription.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Splitkey="description";mmt.qualifiedName="EndToEndProtection.endToEndProfile";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="END-TO-END-PROTECTION-I-SIGNAL-I-PDUS">
            <xsd:annotation>
               <xsd:documentation>Defines to which ISignalIPdu - ISignalGroup pair this EndToEndProtection shall apply.

            In case several ISignalGroups are used to transport the data (e.g. fan-out in the RTE) there may exist several EndToEndProtectionISignalIPdu definitions.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="variationPoint.shortLabel";mmt.qualifiedName="EndToEndProtection.endToEndProtectionISignalIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="END-TO-END-PROTECTION-I-SIGNAL-I-PDU" type="AR:END-TO-END-PROTECTION-I-SIGNAL-I-PDU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="END-TO-END-PROTECTION-VARIABLE-PROTOTYPES">
            <xsd:annotation>
               <xsd:documentation>Defines to which VariableDataPrototypes in the roles of one sender and one or more receivers this EndToEndprotection applies.

            It shall be possible to aggregate several EndToEndProtectionVariablePrototype in case additional hierarchical decompositions are introduced subsequently. In this case one particular PortPrototype is split into multiple PortPrototypes and connectors, all representing the same data entity.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortLabel, variationPoint.shortLabel";mmt.qualifiedName="EndToEndProtection.endToEndProtectionVariablePrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="END-TO-END-PROTECTION-VARIABLE-PROTOTYPE" type="AR:END-TO-END-PROTECTION-VARIABLE-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtection -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to describe a particular end to end protection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:END-TO-END-PROTECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtectionISignalIPdu -->
   <xsd:group name="END-TO-END-PROTECTION-I-SIGNAL-I-PDU">
      <xsd:annotation>
         <xsd:documentation>It is possible to protect the inter-ECU data exchange of safety-related ISignalGroups at the level of COM IPdus using protection mechanisms provided by E2E Library. For each ISignalGroup to be protected, a separate EndToEndProtectionISignalIPdu element must be created within the EndToEndProtectionSet. 

      The EndToEndProtectionISignalIPdu element refers to the ISignalGroup that is to be protected and to the ISignalIPdu that transmits the protected ISignalGroup. The information how the referenced ISignalGroup shall be protected (through which E2E Profile and with which E2E settings) is defined in the EndToEndDescription element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-OFFSET" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the beginning offset (in bits) of the Array representation of the Signal Group (including CRC, counter and application
            signal group) in the IPdu. This attribute is mandatory and the dataOffset shall always be defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu.dataOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ISignalGroup that is to be protected.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu.iSignalGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ISignalIPdu that transmits the protected ISignalGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu.iSignalIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtectionISignalIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION-I-SIGNAL-I-PDU">
      <xsd:annotation>
         <xsd:documentation>It is possible to protect the inter-ECU data exchange of safety-related ISignalGroups at the level of COM IPdus using protection mechanisms provided by E2E Library. For each ISignalGroup to be protected, a separate EndToEndProtectionISignalIPdu element must be created within the EndToEndProtectionSet. 

      The EndToEndProtectionISignalIPdu element refers to the ISignalGroup that is to be protected and to the ISignalIPdu that transmits the protected ISignalGroup. The information how the referenced ISignalGroup shall be protected (through which E2E Profile and with which E2E settings) is defined in the EndToEndDescription element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:END-TO-END-PROTECTION-I-SIGNAL-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtectionSet -->
   <xsd:group name="END-TO-END-PROTECTION-SET">
      <xsd:annotation>
         <xsd:documentation>This represents a container for collection EndToEndProtectionInformation.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EndToEndProtectionSets";mmt.qualifiedName="EndToEndProtectionSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="END-TO-END-PROTECTIONS">
            <xsd:annotation>
               <xsd:documentation>This is one particular EndToEndProtection.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="EndToEndProtectionSet.endToEndProtection";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="END-TO-END-PROTECTION" type="AR:END-TO-END-PROTECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtectionSet -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION-SET">
      <xsd:annotation>
         <xsd:documentation>This represents a container for collection EndToEndProtectionInformation.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EndToEndProtectionSets";mmt.qualifiedName="EndToEndProtectionSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:END-TO-END-PROTECTION-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtectionVariablePrototype -->
   <xsd:group name="END-TO-END-PROTECTION-VARIABLE-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>It is possible to protect the data exchanged between software components. For this purpose, for each communication to be protected,  the user defines a separate EndToEndProtection (specifying a set of protection settings) and refers to a variableDataPrototype in the role of sender and to one or many variableDataPrototypes in the role of receiver. For details, see EndToEnd Library.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionVariablePrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECEIVER-IREFS">
            <xsd:annotation>
               <xsd:documentation>This represents the receiver. Note that 1:n communication is supported for this use case.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionVariablePrototype.receiver";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-IREF" type="AR:VARIABLE-DATA-PROTOTYPE-IN-SYSTEM-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SENDER-IREF" type="AR:VARIABLE-DATA-PROTOTYPE-IN-SYSTEM-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the sender.

            Can be optional if an ecu extract is provided and the sender is part of the extract.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionVariablePrototype.sender";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This serves as part of the split key in case of more than one EndToEndProtectionVariablePrototype is aggregated in the bound model.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionVariablePrototype.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtectionVariablePrototype -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION-VARIABLE-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>It is possible to protect the data exchanged between software components. For this purpose, for each communication to be protected,  the user defines a separate EndToEndProtection (specifying a set of protection settings) and refers to a variableDataPrototype in the role of sender and to one or many variableDataPrototypes in the role of receiver. For details, see EndToEnd Library.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionVariablePrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:END-TO-END-PROTECTION-VARIABLE-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EngineeringObject::EngineeringObject -->
   <xsd:group name="ENGINEERING-OBJECT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an engineering object. Usually such an object is represented by a file artifact. The properties of engineering object are such that the artifact can be found  by querying an ASAM catalog file.

      The engineering object is uniquely identified by domain+category+shortLabel+revisionLabel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EngineeringObject"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>This is the short name of the engineering object. Note that it is modeled as NameToken and not as Identifier since in ASAM-CC it is also a NameToken.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EngineeringObject.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>This denotes the role of the engineering object in the development cycle. 
            Categories are such as

            * SWSRC for source code
            * SWOBJ for object code
            * SWHDR for a C-header file

            Further roles need to be defined via Methodology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EngineeringObject.category";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVISION-LABELS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="REVISION-LABEL" type="AR:REVISION-LABEL-STRING">
                     <xsd:annotation>
                        <xsd:documentation>This is a revision label denoting a particular version of the engineering object.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="EngineeringObject.revisionLabel";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DOMAIN" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>This denotes the domain in which the engineering object is stored. This allows to indicate various segments in the repository keeping the engineering objects. The domain may segregate companies, as well as automotive domains. Details need to be defined by the Methodology.

            Attribute is optional to support a default domain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EngineeringObject.domain";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class OasisExchangeTable::Entry -->
   <xsd:group name="ENTRY">
      <xsd:annotation>
         <xsd:documentation>This represents one particular table cell.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Entry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:DOCUMENTATION-BLOCK"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class OasisExchangeTable::Entry -->
   <xsd:attributeGroup name="ENTRY">
      <xsd:annotation>
         <xsd:documentation>This represents one particular table cell.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Entry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ALIGN" type="AR:ALIGN-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies how the cell ENTRY shall be horizontally aligned.  Default is "LEFT"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.align";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COLNAME" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicate the name of the column, where the entry should appear.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.colname";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COLSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates whether a line should be displayed end of this entry.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.colsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="MOREROWS" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Number of additional rows. Default is "0"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.morerows";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="NAMEEND" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>When an entry spans multiple column this is the name of the last column.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.nameend";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="NAMEST" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>When an entry spans multiple column this is the name of the first column.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.namest";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ROTATE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the cellcontent shall be rotated. Default is 0; 1 would rotate the contents 90 degree counterclockwise. This attribute is defined by OASIS.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.rotate";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ROWSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates whether a line should be displayed at the bottom end of the cell.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.rowsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SPANNAME" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Capture the name of entry merging multiple columns.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.spanname";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="VALIGN" type="AR:VALIGN-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates how the content of the cell shall be aligned. Default is inherited from row or tbody, otherwise "TOP"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Entry.valign";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class OasisExchangeTable::Entry -->
   <xsd:complexType abstract="false" mixed="false" name="ENTRY">
      <xsd:annotation>
         <xsd:documentation>This represents one particular table cell.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Entry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ENTRY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ENTRY"/>
   </xsd:complexType>
   <!-- element group for class EthernetTopology::EthernetCluster -->
   <xsd:group name="ETHERNET-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="EthernetCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ETHERNET-CLUSTER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ETHERNET-CLUSTER-CONDITIONAL" type="AR:ETHERNET-CLUSTER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetTopology::EthernetCluster -->
   <xsd:complexType abstract="false" mixed="false" name="ETHERNET-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="EthernetCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
         <xsd:group ref="AR:ETHERNET-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class EthernetTopology::EthernetClusterConditional -->
   <xsd:group name="ETHERNET-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetTopology::EthernetClusterConditional -->
   <xsd:complexType abstract="false" mixed="false" name="ETHERNET-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:ETHERNET-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:ETHERNET-CLUSTER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EthernetTopology::EthernetClusterContent -->
   <xsd:group name="ETHERNET-CLUSTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class EthernetTopology::EthernetCommunicationConnector -->
   <xsd:group name="ETHERNET-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific attributes to the CommunicationConnector</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EthernetCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class EthernetTopology::EthernetCommunicationConnector -->
   <xsd:complexType abstract="false" mixed="false" name="ETHERNET-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific attributes to the CommunicationConnector</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EthernetCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:ETHERNET-COMMUNICATION-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ETHERNET-COMMUNICATION-CONNECTOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ETHERNET-COMMUNICATION-CONNECTOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class EthernetTopology::EthernetCommunicationController -->
   <xsd:group name="ETHERNET-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EthernetCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ETHERNET-COMMUNICATION-CONTROLLER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ETHERNET-COMMUNICATION-CONTROLLER-CONDITIONAL" type="AR:ETHERNET-COMMUNICATION-CONTROLLER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetTopology::EthernetCommunicationController -->
   <xsd:complexType abstract="false" mixed="false" name="ETHERNET-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EthernetCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:ETHERNET-COMMUNICATION-CONTROLLER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class EthernetTopology::EthernetCommunicationControllerConditional -->
   <xsd:group name="ETHERNET-COMMUNICATION-CONTROLLER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetTopology::EthernetCommunicationControllerConditional -->
   <xsd:complexType abstract="false" mixed="false" name="ETHERNET-COMMUNICATION-CONTROLLER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:ETHERNET-COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:ETHERNET-COMMUNICATION-CONTROLLER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EthernetTopology::EthernetCommunicationControllerContent -->
   <xsd:group name="ETHERNET-COMMUNICATION-CONTROLLER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-RECEIVE-BUFFER-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Determines the maximum receive buffer length (frame length) in bytes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EthernetCommunicationController.maximumReceiveBufferLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-TRANSMIT-BUFFER-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Determines the maximum transmit buffer length (frame length) in bytes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EthernetCommunicationController.maximumTransmitBufferLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class EthernetCommunication::EthernetFrame -->
   <xsd:group name="ETHERNET-FRAME">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific attributes to the Frame</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="EthernetFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class EthernetCommunication::EthernetFrame -->
   <xsd:complexType abstract="false" mixed="false" name="ETHERNET-FRAME">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific attributes to the Frame</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="EthernetFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:FRAME"/>
         <xsd:group ref="AR:ETHERNET-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class EthernetCommunication::EthernetFrameTriggering -->
   <xsd:group name="ETHERNET-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific Frame element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EthernetFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class EthernetCommunication::EthernetFrameTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="ETHERNET-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific Frame element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EthernetFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME-TRIGGERING"/>
         <xsd:group ref="AR:ETHERNET-FRAME-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class EthernetTopology::EthernetPhysicalChannel -->
   <xsd:group name="ETHERNET-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific attributes to the PhysicalChannel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EthernetPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SO-AD-CONFIG" type="AR:SO-AD-CONFIG">
            <xsd:annotation>
               <xsd:documentation>SoAd Configuration for one specific Physical Channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="soAdConfig.EthernetPhysicalChannel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetTopology::EthernetPhysicalChannel -->
   <xsd:complexType abstract="false" mixed="false" name="ETHERNET-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>Ethernet specific attributes to the PhysicalChannel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EthernetPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PHYSICAL-CHANNEL"/>
         <xsd:group ref="AR:ETHERNET-PHYSICAL-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::EvaluatedVariantSet -->
   <xsd:group name="EVALUATED-VARIANT-SET">
      <xsd:annotation>
         <xsd:documentation>This meta class represents the ability to express if a set of ArElements is able to support one or more particular variants.

      In other words, for a given set of evaluatedElements this meta class represents a table of evaluated variants, where each PredefinedVariant represents one column. In this colum each descendant swSystemconstantValue resp. postbuildVariantCriterionValue represents one entry.

      In a graphical representation each swSystemconstantValueSet / postBuildVariantCriterionValueSet could be used as an intermediate headline in the table column.

      If the approvalStatus is "APPROVED" it expresses that the collection of CollectableElements is known be valid for the given evaluatedVariants.

      Note that the EvaluatedVariantSet is a CollectableElement. This allows to establish a hierarchy of EvaluatedVariantSets.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EvaluatedVariantSets";mmt.qualifiedName="EvaluatedVariantSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPROVAL-STATUS" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>Defines the approval status of a predefined variant. Two values are predefined: "APPROVED" and "REJECTED":

            * Approved variants are known to work.
            * Rejected variants are known NOT to work.

            Further values can be approved on a per-company basis; within AUTOSAR only "APPROVED" and "REJECTED" should be recognized.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EvaluatedVariantSet.approvalStatus";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVALUATED-ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>This represents a particular element which is evaluated in context of the EvaluatedVariants. The approvalStatus applies to this element (and all of its descendants). In other words, the referenced elements are those that were considered when the predefined variant was evaluated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EvaluatedVariantSet.evaluatedElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EVALUATED-ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:COLLECTABLE-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVALUATED-VARIANT-REFS">
            <xsd:annotation>
               <xsd:documentation>This metaclass represents one particular variant which was evaluated. LowerMultiplicity is set to 0 to support a stepwise approach.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EvaluatedVariantSet.evaluatedVariant";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EVALUATED-VARIANT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PREDEFINED-VARIANT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::EvaluatedVariantSet -->
   <xsd:complexType abstract="false" mixed="false" name="EVALUATED-VARIANT-SET">
      <xsd:annotation>
         <xsd:documentation>This meta class represents the ability to express if a set of ArElements is able to support one or more particular variants.

      In other words, for a given set of evaluatedElements this meta class represents a table of evaluated variants, where each PredefinedVariant represents one column. In this colum each descendant swSystemconstantValue resp. postbuildVariantCriterionValue represents one entry.

      In a graphical representation each swSystemconstantValueSet / postBuildVariantCriterionValueSet could be used as an intermediate headline in the table column.

      If the approvalStatus is "APPROVED" it expresses that the collection of CollectableElements is known be valid for the given evaluatedVariants.

      Note that the EvaluatedVariantSet is a CollectableElement. This allows to establish a hierarchy of EvaluatedVariantSets.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="EvaluatedVariantSets";mmt.qualifiedName="EvaluatedVariantSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:EVALUATED-VARIANT-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Timing::EventControlledTiming -->
   <xsd:group name="EVENT-CONTROLLED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a event driven sending behavior. The PDU is sent n
      (numberOfRepeat + 1) times separated by the repetitionPeriod. If numberOfRepeats
      = 0, then the Pdu is sent just once.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EventControlledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-REPETITIONS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Defines the number of repetitions for the Direct/N-Times transmission mode and the event driven part of Mixed transmission mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EventControlledTiming.numberOfRepetitions";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REPETITION-PERIOD" type="AR:TIME-RANGE-TYPE">
            <xsd:annotation>
               <xsd:documentation>The repetitionPeriod specifies the time in seconds that elapses before the pdu can be sent the next time (Minimum repeat gap between two pdus). The repetitionPeriod is optional in case that no repetitions are configured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="repetitionPeriod.EventControlledTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::EventControlledTiming -->
   <xsd:complexType abstract="false" mixed="false" name="EVENT-CONTROLLED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a event driven sending behavior. The PDU is sent n
      (numberOfRepeat + 1) times separated by the repetitionPeriod. If numberOfRepeats
      = 0, then the Pdu is sent just once.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EventControlledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:EVENT-CONTROLLED-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EventTriggeringConstraint::EventTriggeringConstraint -->
   <xsd:group name="EVENT-TRIGGERING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>Describes the occurrence behavior of the referenced timing event.

      The occurrence behavior can only be determined when a mapping from the timing events to the implementation can be obtained. However, such an occurrence behavior can also be described by the modeler as an assumption or as a requirement about the occurrence of the event.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EventTriggeringConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced timing event</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EventTriggeringConstraint.event";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class InternalBehavior::ExclusiveArea -->
   <xsd:group name="EXCLUSIVE-AREA">
      <xsd:annotation>
         <xsd:documentation>Prevents an executable entity running in the area from being preempted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExclusiveArea"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InternalBehavior::ExclusiveArea -->
   <xsd:complexType abstract="false" mixed="false" name="EXCLUSIVE-AREA">
      <xsd:annotation>
         <xsd:documentation>Prevents an executable entity running in the area from being preempted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExclusiveArea"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXCLUSIVE-AREA"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="EXCLUSIVE-AREA--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EXCLUSIVE-AREA"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InternalBehavior::ExecutableEntity -->
   <xsd:group name="EXECUTABLE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>Abstraction of executable code.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutableEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-ENTER-EXCLUSIVE-AREA-REFS">
            <xsd:annotation>
               <xsd:documentation>This means that the executable entity can enter/leave the referenced exclusive area through explicit API calls.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutableEntity.canEnterExclusiveArea";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-ENTER-EXCLUSIVE-AREA-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:EXCLUSIVE-AREA--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-START-INTERVAL" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Specifies the time in seconds by which two consecutive starts of an ExecutableEntity are guaranteed to be separated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutableEntity.minimumStartInterval";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUNS-INSIDE-EXCLUSIVE-AREA-REFS">
            <xsd:annotation>
               <xsd:documentation>The executable entity runs completely inside the referenced exclusive area.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutableEntity.runsInsideExclusiveArea";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RUNS-INSIDE-EXCLUSIVE-AREA-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:EXCLUSIVE-AREA--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ADDR-METHOD-REF">
            <xsd:annotation>
               <xsd:documentation>Addressing method related to this code entity. Via an association to the same SwAddrMethod, it can be specified that several code entities (even of different modules or components)  shall be located in the same memory without already specifying the memory section itself.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutableEntity.swAddrMethod";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-ADDR-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="EXECUTABLE-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-CALLED-ENTITY"/>
         <xsd:enumeration value="BSW-INTERRUPT-ENTITY"/>
         <xsd:enumeration value="BSW-MODULE-ENTITY"/>
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
         <xsd:enumeration value="EXECUTABLE-ENTITY"/>
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ExecutionOrderConstraint::ExecutionOrderConstraint -->
   <xsd:group name="EXECUTION-ORDER-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>This constraint is used to restrict the order of execution for a set of ExecutableEntities.

      On software component level an ExecutionOrderConstraint can be defined for RunnableEntities as part of a SwcTiming. If the scope of the SwcTiming is an AtomicSwComponentType, the constrained RunnableEntities must be of the same SwcInternalBehavior (in this case, no InstanceRef is required for the definition of EOCExecutableEneityRef). If the scope of the SwcTiming is an CompositionSwComponentType, the constrained RunnableEntities must be of AtomicSwComponentTypes which belong to the composition.

      On BSW level, an ExectionOrderConstraint can be defined BSWModuleEntities of the same BswInternalBehavior as part of a BswModuleTiming.

      On system level an ExecutionOrderConstraint can be defined for RunnableEntities belonging to the same SoftwareComposition as part of a SystemTiming.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionOrderConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ORDERED-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>The list of references to ExecutableEntities which shall be ordered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionOrderConstraint.orderedElement";pureMM.maxOccurs="-1";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EOC-EXECUTABLE-ENTITY-REF" type="AR:EOC-EXECUTABLE-ENTITY-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionOrderConstraint::ExecutionOrderConstraint -->
   <xsd:complexType abstract="false" mixed="false" name="EXECUTION-ORDER-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>This constraint is used to restrict the order of execution for a set of ExecutableEntities.

      On software component level an ExecutionOrderConstraint can be defined for RunnableEntities as part of a SwcTiming. If the scope of the SwcTiming is an AtomicSwComponentType, the constrained RunnableEntities must be of the same SwcInternalBehavior (in this case, no InstanceRef is required for the definition of EOCExecutableEneityRef). If the scope of the SwcTiming is an CompositionSwComponentType, the constrained RunnableEntities must be of AtomicSwComponentTypes which belong to the composition.

      On BSW level, an ExectionOrderConstraint can be defined BSWModuleEntities of the same BswInternalBehavior as part of a BswModuleTiming.

      On system level an ExecutionOrderConstraint can be defined for RunnableEntities belonging to the same SoftwareComposition as part of a SystemTiming.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionOrderConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:EXECUTION-ORDER-CONSTRAINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::ExecutionTime -->
   <xsd:group name="EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Base class for several means how to describe the ExecutionTime of software. The required context information is provided through this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXCLUSIVE-AREA-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ExclusiveArea this execution time is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime.exclusiveArea";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:EXCLUSIVE-AREA--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTABLE-ENTITY-REF">
            <xsd:annotation>
               <xsd:documentation>The executable entity for which this execution time is described.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime.executableEntity";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:EXECUTABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION">
            <xsd:annotation>
               <xsd:documentation>Provides information on the HardwareConfiguration used to specify this ExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hardwareConfiguration.ExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>The hardware element (e.g. type of ECU) for which the execution time is specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime.hwElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INCLUDED-LIBRARY-REFS">
            <xsd:annotation>
               <xsd:documentation>If this dependency is specified, the execution
            time of the library code is included in the
            execution time data for the runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime.includedLibrary";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INCLUDED-LIBRARY-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:DEPENDENCY-ON-ARTIFACT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-SECTION-LOCATIONS">
            <xsd:annotation>
               <xsd:documentation>Provides information on the MemorySectionLocation which is involved in the ExecutionTime description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="memorySectionLocation.ExecutionTime";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEMORY-SECTION-LOCATION" type="AR:MEMORY-SECTION-LOCATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT">
            <xsd:annotation>
               <xsd:documentation>Provides information on the detailed SoftwareContext used to provide the ExecutionTime description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="softwareContext.ExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ExecutionTimeConstraint::ExecutionTimeConstraint -->
   <xsd:group name="EXECUTION-TIME-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>An ExecutionTimeConstraint is used to specify the execution time of the referenced ExecutableEntity in the referenced component. A minimum and maximum execution time can be defined.

      Two types of execution time semantics can be used. The desired semantics can be set by the attribute executionTimeType:
      &lt;ul&gt;
      	&lt;li&gt;The "net" execution time is the time used to execute the ExecutableEntity without interruption and without external calls.&lt;/li&gt;
      	&lt;li&gt;The "gross" execution time is the time used to execute the ExecutableEntity without interruption including external calls to other entities.&lt;/li&gt;
      &lt;/ul&gt;

      The time to execute the ExecutableEntity including interruptions by other entities and including external calls is commonly called "response time". The TimingExtensions provide the concept of event chains and latency constraints for that purpose. An event chain from the start of the entity to the termination of the entity with according latency constraint represents a response time constraint for that executable entity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTimeConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREF" type="AR:COMPONENT-IN-COMPOSITION-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The component that containts the referenced ExecutableEntity for the ExecutionTimeConstraint. If the entity is in a basic software module no component must be provided.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.ExecutionTimeConstraint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTABLE-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced ExecutableEntity for the ExecutionTimeConstraint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTimeConstraint.executable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:EXECUTABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTION-TIME-TYPE" type="AR:EXECUTION-TIME-TYPE-ENUM">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTimeConstraint.executionTimeType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="maximum.ExecutionTimeConstraint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The minimum execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="minimum.ExecutionTimeConstraint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTimeConstraint::ExecutionTimeConstraint -->
   <xsd:complexType abstract="false" mixed="false" name="EXECUTION-TIME-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>An ExecutionTimeConstraint is used to specify the execution time of the referenced ExecutableEntity in the referenced component. A minimum and maximum execution time can be defined.

      Two types of execution time semantics can be used. The desired semantics can be set by the attribute executionTimeType:
      &lt;ul&gt;
      	&lt;li&gt;The "net" execution time is the time used to execute the ExecutableEntity without interruption and without external calls.&lt;/li&gt;
      	&lt;li&gt;The "gross" execution time is the time used to execute the ExecutableEntity without interruption including external calls to other entities.&lt;/li&gt;
      &lt;/ul&gt;

      The time to execute the ExecutableEntity including interruptions by other entities and including external calls is commonly called "response time". The TimingExtensions provide the concept of event chains and latency constraints for that purpose. An event chain from the start of the entity to the termination of the entity with according latency constraint represents a response time constraint for that executable entity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTimeConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:EXECUTION-TIME-CONSTRAINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::ExternalTriggerOccurredEvent -->
   <xsd:group name="EXTERNAL-TRIGGER-OCCURRED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced trigger have been occurred.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExternalTriggerOccurredEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-IREF" type="AR:R-TRIGGER-IN-ATOMIC-SWC-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the applicable Trigger.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="trigger.event";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::ExternalTriggerOccurredEvent -->
   <xsd:complexType abstract="false" mixed="false" name="EXTERNAL-TRIGGER-OCCURRED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced trigger have been occurred.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExternalTriggerOccurredEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Trigger::ExternalTriggeringPoint -->
   <xsd:group name="EXTERNAL-TRIGGERING-POINT">
      <xsd:annotation>
         <xsd:documentation>If a RunnableEntity owns an ExternalTriggeringPoint it is entitled to raise an ExternalTriggerOccurredEvent.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExternalTriggeringPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-IREF">
            <xsd:annotation>
               <xsd:documentation>The trigger taken for the ExternalTriggeringPoint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="trigger.ExternalTriggeringPoint";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.namePlural="TRIGGER-IREF";xml.roleElement="false";xml.roleWrapperElement="true";xml.typeElement="true";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="P-TRIGGER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF" type="AR:P-TRIGGER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Trigger::ExternalTriggeringPoint -->
   <xsd:complexType abstract="false" mixed="false" name="EXTERNAL-TRIGGERING-POINT">
      <xsd:annotation>
         <xsd:documentation>If a RunnableEntity owns an ExternalTriggeringPoint it is entitled to raise an ExternalTriggerOccurredEvent.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExternalTriggeringPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:EXTERNAL-TRIGGERING-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FibexCore::FibexElement -->
   <xsd:group name="FIBEX-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>ASAM FIBEX elements specifying Communication and Topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FibexElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="FIBEX-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ABSTRACT-CAN-CLUSTER"/>
         <xsd:enumeration value="CAN-CLUSTER"/>
         <xsd:enumeration value="CAN-FRAME"/>
         <xsd:enumeration value="CAN-TP-CONFIG"/>
         <xsd:enumeration value="COMMUNICATION-CLUSTER"/>
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="ECU-INSTANCE"/>
         <xsd:enumeration value="ETHERNET-CLUSTER"/>
         <xsd:enumeration value="ETHERNET-FRAME"/>
         <xsd:enumeration value="FIBEX-ELEMENT"/>
         <xsd:enumeration value="FLEXRAY-AR-TP-CONFIG"/>
         <xsd:enumeration value="FLEXRAY-CLUSTER"/>
         <xsd:enumeration value="FLEXRAY-FRAME"/>
         <xsd:enumeration value="FLEXRAY-TP-CONFIG"/>
         <xsd:enumeration value="FRAME"/>
         <xsd:enumeration value="GATEWAY"/>
         <xsd:enumeration value="I-PDU"/>
         <xsd:enumeration value="I-SIGNAL"/>
         <xsd:enumeration value="I-SIGNAL-GROUP"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU-GROUP"/>
         <xsd:enumeration value="J-1939-TP-CONFIG"/>
         <xsd:enumeration value="LIN-CLUSTER"/>
         <xsd:enumeration value="LIN-EVENT-TRIGGERED-FRAME"/>
         <xsd:enumeration value="LIN-FRAME"/>
         <xsd:enumeration value="LIN-SPORADIC-FRAME"/>
         <xsd:enumeration value="LIN-TP-CONFIG"/>
         <xsd:enumeration value="LIN-UNCONDITIONAL-FRAME"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="NM-CONFIG"/>
         <xsd:enumeration value="NM-PDU"/>
         <xsd:enumeration value="PDU"/>
         <xsd:enumeration value="PDUR-I-PDU-GROUP"/>
         <xsd:enumeration value="TP-CONFIG"/>
         <xsd:enumeration value="TTCAN-CLUSTER"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-PDU"/>
         <xsd:enumeration value="XCP-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class FibexCore::FibexElementRefConditional -->
   <xsd:group name="FIBEX-ELEMENT-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIBEX-ELEMENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FIBEX-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FibexCore::FibexElementRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="FIBEX-ELEMENT-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlatMap::FlatInstanceDescriptor -->
   <xsd:group name="FLAT-INSTANCE-DESCRIPTOR">
      <xsd:annotation>
         <xsd:documentation>Represents exactly one node (e.g. a component instance or data element) of the instance tree of a software system. The purpose of this element is to map the various nested representations of this instance to a flat representation and assign a unique name (shortName) to it.

      Use cases: 
      * Specify unique names of measurable data to be used by MCD tools
      * Specify unique names of calibration data to be used by MCD tool
      * Specify a unique name for an instance of a component prototype in the ECU extract of the system description

      Note that in addition it is possible to assign alias names via AliasNameAssignment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlatInstanceDescriptor"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROLE" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>The role denotes the particular role of the downstream memory location described by this FlatInstanceDescriptor.

            It applies to use case where one upstream object results in multiple downstream objects, e.g. ModeDeclarationGroupPrototypes which are measurable. In this case the RTE will provide locations for current mode, previous mode and next mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlatInstanceDescriptor.role";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>The properties of this FlatInstanceDescriptor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlatInstanceDescriptor.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPSTREAM-REFERENCE-IREF" type="AR:ANY-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Refers to the instance in the context of an "upstream" descriptions, wich could be the system or system extract description, the basic software module description or (if a flat map is used in preliminary context) a description of an atomic component or composition. This reference is optional in case the flat map is used in ECU context.

            The reference must be such, that it uniquely defines the object instance in the given context. For example, if a data prototype is declared as a role within an SwcInternalBehavior, it is not enough to state the SwcInternalBehavior as context and the aggregated data prototype as target. In addition, the reference must also include the complete path identifying the instance of the component prototype that contains the particular instance of SwcInternalBehavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlatInstanceDescriptor.upstreamReference";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-EXTRACT-REFERENCE-IREF" type="AR:ANY-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Refers to the instance in the ECU extract. This is valid only, if the FlatMap is used in the context of an ECU extract.

            The reference must be such, that it uniquely defines the object instance. For example, if a data prototype is declared as a role within an SwcInternalBehavior, it is not enough to state the SwcInternalBehavior as context and the aggregated data prototype as target. In addition, the reference must also include the complete path identifying instance of the component prototype and the AtomicSoftwareComponentType, which is refered by the particular SwcInternalBehavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlatInstanceDescriptor.ecuExtractReference";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlatMap::FlatInstanceDescriptor -->
   <xsd:complexType abstract="false" mixed="false" name="FLAT-INSTANCE-DESCRIPTOR">
      <xsd:annotation>
         <xsd:documentation>Represents exactly one node (e.g. a component instance or data element) of the instance tree of a software system. The purpose of this element is to map the various nested representations of this instance to a flat representation and assign a unique name (shortName) to it.

      Use cases: 
      * Specify unique names of measurable data to be used by MCD tools
      * Specify unique names of calibration data to be used by MCD tool
      * Specify a unique name for an instance of a component prototype in the ECU extract of the system description

      Note that in addition it is possible to assign alias names via AliasNameAssignment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlatInstanceDescriptor"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FLAT-INSTANCE-DESCRIPTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLAT-INSTANCE-DESCRIPTOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLAT-INSTANCE-DESCRIPTOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class FlatMap::FlatMap -->
   <xsd:group name="FLAT-MAP">
      <xsd:annotation>
         <xsd:documentation>Contains a flat list of references to software objects. This list is used to identify instances and to resolve name conflicts. The scope is given by the RootSwCompositionPrototype for which it is used, i.e. it can be applied to a system, system extract or ECU-extract.

      An instance of FlatMap may also be used in a preliminary context, e.g. in the scope of a software component before integration into a system. In this case it is not referred by a RootSwCompositionPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="FlatMaps";mmt.qualifiedName="FlatMap"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INSTANCES">
            <xsd:annotation>
               <xsd:documentation>A descriptor instance aggregated in the flat map. 

            The variation point accounts for the fact, that the system in scope can be subject to variability, and thus the existence of some instances is variable.

            The aggregation has been made splitable because the content might be contributed by different stakeholders at different times in the workflow. Plus, the overall size might be so big that eventually it becomes more manageable if it is distributed over several files.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="FlatMap.instance";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLAT-INSTANCE-DESCRIPTOR" type="AR:FLAT-INSTANCE-DESCRIPTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlatMap::FlatMap -->
   <xsd:complexType abstract="false" mixed="false" name="FLAT-MAP">
      <xsd:annotation>
         <xsd:documentation>Contains a flat list of references to software objects. This list is used to identify instances and to resolve name conflicts. The scope is given by the RootSwCompositionPrototype for which it is used, i.e. it can be applied to a system, system extract or ECU-extract.

      An instance of FlatMap may also be used in a preliminary context, e.g. in the scope of a software component before integration into a system. In this case it is not referred by a RootSwCompositionPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="FlatMaps";mmt.qualifiedName="FlatMap"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:FLAT-MAP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLAT-MAP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLAT-MAP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class FlexrayCommunication::FlexrayAbsolutelyScheduledTiming -->
   <xsd:group name="FLEXRAY-ABSOLUTELY-SCHEDULED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Each frame in FlexRay is identified by its slot id and communication cycle. A description is provided by the usage of AbsolutelyScheduledTiming. 

      In the static segment a frame can be sent multiple times within one communication cycle. For describing this case multiple AbsolutelyScheduledTimings have to be used. The main use case would be that a frame is sent twice within one communication cycle.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayAbsolutelyScheduledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CYCLE">
            <xsd:annotation>
               <xsd:documentation>The communication cycle where the frame is sent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="communicationCycle.FlexrayAbsolutelyScheduledTiming";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CYCLE-COUNTER" type="AR:CYCLE-COUNTER"/>
                  <xsd:element name="CYCLE-REPETITION" type="AR:CYCLE-REPETITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SLOT-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>In the static part the SlotID defines the slot in which the frame is transmitted. 
            The SlotID also determines, in combination with FlexrayCluster::numberOfStaticSlots, whether the frame is sent in static or dynamic segment. 
            In the dynamic part, the slot id is equivalent to a priority. Lower dynamic slot ids are all sent until the end of the dynamic segment. Higher numbers, which were ignored that time, have to wait one cycle and then must try again.

            minValue: 1
            maxValue: 2047</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayAbsolutelyScheduledTiming.slotID";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayCommunication::FlexrayAbsolutelyScheduledTiming -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-ABSOLUTELY-SCHEDULED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Each frame in FlexRay is identified by its slot id and communication cycle. A description is provided by the usage of AbsolutelyScheduledTiming. 

      In the static segment a frame can be sent multiple times within one communication cycle. For describing this case multiple AbsolutelyScheduledTimings have to be used. The main use case would be that a frame is sent twice within one communication cycle.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayAbsolutelyScheduledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FLEXRAY-ABSOLUTELY-SCHEDULED-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayArTpChannel -->
   <xsd:group name="FLEXRAY-AR-TP-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A channel is a group of connections sharing several properties.

      The FlexRay AutosarTransport Layer supports several channels. These channels can work concurrently, thus each of them requires its own state machine and management data structures and its own PDU-IDs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACK-TYPE" type="AR:FR-AR-TP-ACK-TYPE">
            <xsd:annotation>
               <xsd:documentation>Type of Acknowledgement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.ackType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTENDED-ADDRESSING" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Adressing Type of this connection:
            true: Two Bytes
            false: One Byte</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.extendedAddressing";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the  Flow Control NPdu.

            The Flow Control network protocol data unit (FC N_PDU) is identified by the Flow Control protocol control information (FC N_PCI). The Flow Control network protocol data unit (FC N_PDU) instructs a sending network entity to start, stop or resume transmission of CF N_PDUs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.flowControlPdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-AR" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum number of trying to send a frame when a TIMEOUT AR occurs (depending on whether retry is configured).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.maxAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-AS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum number of trying to send a frame when a TIMEOUT AS occurs (depending on whether retry is configured).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.maxAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute limits the maximal block size the FrTp can choose in order to limit the amount of Tx buffer that will be requested at the sender side in a segmented transfer.
            range when retry is activated: 1-16
            range when retry is not activated: 0-255</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.maxBs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BUFFER-REQUEST" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum number of trying to get a buffer (Transmit / Receive), depending of the return value of PduR_FrTpProvideTxBuffer / PduR_FrTpProvideRxBuffer and on whether retry is configured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.maxBufferRequest";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FR-IF" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum number of trying to send a frame when the FrIf returns an error.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.maxFrIf";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-RETRIES" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum number of retries (if retry is configured for the particular channel).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.maxRetries";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-MESSAGE-LENGTH" type="AR:MAXIMUM-MESSAGE-LENGTH-TYPE">
            <xsd:annotation>
               <xsd:documentation>This specifies the maximum message length for the particular channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.maximumMessageLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-SEPARATION-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the minimum amount of time (separation Time) between two succeeding CFs. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.minimumSeparationTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-SEGMENTATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute defines whether segmentation within a 1:n connection is allowed or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.multicastSegmentation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-POOLS">
            <xsd:annotation>
               <xsd:documentation>A FlexRayTpChannel contains a pool of NPdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pduPool.FlexrayArTpChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="N-PDU" type="AR:N-PDU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the time in seconds between receiving the last CF of a block or an FF-x (or SF-x) and sending out an FC or AF.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.timeBr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BUFFER" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the time in seconds of waiting for the next try (if retry is activated) to get a Tx or Rx buffer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.timeBuffer";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-CS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the time in seconds between the sending of two consecutive frames or between a consecutive frame and a flow control (for Transmit Cancellation) or between reception of an flow control or Acknowledgement Frame and sending of the next consecutive frame or a  flow control (for Transmit Cancellation).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.timeCs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-FR-IF" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the time in seconds of waiting for the next try (if retry is activated) to send via FrIf_Transmit. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.timeFrIf";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute states the timeout in seconds between the PDU transmit request of the Transport Layer to the FlexRay Interface and the corresponding confirmation of the FlexRay Interface on the receiver side (for FC or AF).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.timeoutAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute states the timeout in seconds between the PDU transmit request for the first PDU of the group used in the current connection of the Transport Layer to the FlexRay Interface and the corresponding confirmation of the FlexRay Interface (when having sent the last PDU of the group used in this connection) on the sender side (SF-x, FF-x, CF).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.timeoutAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-BS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the timeout in seconds for waiting for an FC or AF on the sender side in a 1:1 connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.timeoutBs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the timeout value in seconds for waiting for a CF or FF-x (in case of retry) after receiving the last CF or after sending an FC or AF on the receiver side.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.timeoutCr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>Group of connections that can be used in this channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tpConnection.FlexrayArTpChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-AR-TP-CONNECTION" type="AR:FLEXRAY-AR-TP-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMIT-CANCELLATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute states whether Transmit Cancellation is supported on this channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel.transmitCancellation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayArTpChannel -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-AR-TP-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A channel is a group of connections sharing several properties.

      The FlexRay AutosarTransport Layer supports several channels. These channels can work concurrently, thus each of them requires its own state machine and management data structures and its own PDU-IDs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FLEXRAY-AR-TP-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayArTpConfig -->
   <xsd:group name="FLEXRAY-AR-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one FlexRay Autosar TP Configuration. 

      One FlexrayArTpConfig element shall be created for each FlexRay Network in the System that uses FlexRay Autosar TP.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="FlexrayArTpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESSS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpAddress.FlexrayArTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TP-ADDRESS" type="AR:TP-ADDRESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CHANNELS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpChannel.FlexrayArTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-AR-TP-CHANNEL" type="AR:FLEXRAY-AR-TP-CHANNEL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-NODES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpNode.FlexrayArTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-AR-TP-NODE" type="AR:FLEXRAY-AR-TP-NODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayArTpConfig -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-AR-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one FlexRay Autosar TP Configuration. 

      One FlexrayArTpConfig element shall be created for each FlexRay Network in the System that uses FlexRay Autosar TP.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="FlexrayArTpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:TP-CONFIG"/>
         <xsd:group ref="AR:FLEXRAY-AR-TP-CONFIG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayArTpConnection -->
   <xsd:group name="FLEXRAY-AR-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection within a channel identifies the sender and the receiver of this particular communication.

      The FlexRay Autosar Tp module routes a Pdu through this connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECT-TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 

            The source address of the transmitted NPdu is determined by the configured source CommunicationConnector.
            The target address of the transmitted NPdu is determined by the configured target CommunicationConnector.

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the FlexRayTpConnection shall not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection.directTpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the  Flow Control NPdu.

            The Flow Control network protocol data unit (FC N_PDU) is identified by the Flow Control protocol control information (FC N_PCI). The Flow Control network protocol data unit (FC N_PDU) instructs a sending network entity to start, stop or resume transmission of CF N_PDUs. The Flow Control network protocol data unit shall be sent by the receiving network layer entity to the sending network layer entity, when ready to receive more data, after correct reception of:

            a) First Frame network protocol data unit (FF N_PDU) 
            b) the last Consecutive Frame network protocol data unit (CF N_PDU) of a block of Consecutive Frames (CF N_PDU) if further Consecutive Frame network protocol data unit (CF N_PDU) need(s) to be sent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection.flowControlPdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-REF">
            <xsd:annotation>
               <xsd:documentation>TP address for 1:n connections.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection.multicast";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVERSED-TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 
            If support of both sending and receiving is used, this association references the IPdu used for the additional second direction.

            The source address of the transmitted NPdu is determined by the configured target CommunicationConnector.
            The target address of the transmitted NPdu is determined by the configured source CommunicationConnector.

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the FlexRayTpConnection shall not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection.reversedTpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection.source";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-AR-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection.target";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TARGET-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FLEXRAY-AR-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMIT-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to an NPdu (Single Frame, First Frame or Consecutive Frame).

            The Single Frame network protocol data unit (SF N_PDU) shall be sent out by the sending network entity and can be received by one or multiple receiving network entities.
            The Single Frame (SF N_PDU) shall be sent out to transfer a service data unit that can be transferred via a single service request to the data link layer. This network protocol data unit shall be sent to transfer unsegmented messages.

            The First Frame network protocol data unit (FF N_PDU) identifies the first network protocol data unit (N_PDU) of a segmented message transmitted by a network sending entity and received by a receiving network entity. 

            The Consecutive Frame network protocol data unit (CF N_PDU) transfers segments (N_Data) of the service data unit message data (&amp;lt;MessageData&amp;gt;). All network protocol data units (N_PDUs) transmitted by the sending entity after the First Frame network protocol data unit (FF N_PDU) shall be encoded as Consecutive Frames network protocol data units (CF N_PDUs).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection.transmitPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRANSMIT-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayArTpConnection -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-AR-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection within a channel identifies the sender and the receiver of this particular communication.

      The FlexRay Autosar Tp module routes a Pdu through this connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FLEXRAY-AR-TP-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayArTpNode -->
   <xsd:group name="FLEXRAY-AR-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTOR-REFS">
            <xsd:annotation>
               <xsd:documentation>Association  to one or more physical connectors (max number of connectors for FlexRay: 2).

            In a System Description this reference is mandatory. In an ECU Extract this reference is optional (references to ECUs that are not part of the ECU Extract shall be avoided).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpNode.connector";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONNECTOR-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FLEXRAY-COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the TP Address that is used by the TpNode. This reference is optional in case that the multicast TP Address is used (reference from TpConnection).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpNode.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayArTpNode -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-AR-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayArTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FLEXRAY-AR-TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-AR-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-AR-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class FlexrayTopology::FlexrayCluster -->
   <xsd:group name="FLEXRAY-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the physicalCluster</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="FlexrayCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLEXRAY-CLUSTER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-CLUSTER-CONDITIONAL" type="AR:FLEXRAY-CLUSTER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayCluster -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the physicalCluster</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="FlexrayCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
         <xsd:group ref="AR:FLEXRAY-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-CLUSTER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-CLUSTER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class FlexrayTopology::FlexrayClusterConditional -->
   <xsd:group name="FLEXRAY-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayClusterConditional -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:FLEXRAY-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:FLEXRAY-CLUSTER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayClusterContent -->
   <xsd:group name="FLEXRAY-CLUSTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTION-POINT-OFFSET" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The offset of the action point in networks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.actionPointOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BIT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Nominal bit time (= 1 / fx:SPEED). gdBit = cSamplesPerBit * gdSampleClockPeriod. Unit: seconds (gdBit)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.bit";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAS-RX-LOW-MAX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Upper limit of the Collision Avoidance Symbol (CAS) acceptance window. Unit:bitDuration</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.casRxLowMax";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COLD-START-ATTEMPTS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The maximum number of times that a node in this cluster is permitted to attempt to start the cluster by initiating schedule synchronization</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.coldStartAttempts";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Length of the cycle. Unit: seconds</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.cycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-COUNT-MAX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Maximum cycle counter value in a given cluster.
            Remark: Set to 63 for FlexRay Protocol 2.1 Rev. A compliance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.cycleCountMax";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DETECT-NIT-ERROR" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Indicates whether NIT error status of each cluster shall be detected or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.detectNitError";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DYNAMIC-SLOT-IDLE-PHASE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The duration of the dynamic slot idle phase in minislots.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.dynamicSlotIdlePhase";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IGNORE-AFTER-TX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Duration for which the bitstrobing is paused after transmission [gdBit].</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.ignoreAfterTx";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LISTEN-NOISE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Upper limit for the start up and wake up listen timeout in the presence of noise. Expressed as a multiple of the cluster constant pdListenTimeout. Unit microticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.listenNoise";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACRO-PER-CYCLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The number of macroticks in a communication cycle</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.macroPerCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACROTICK-DURATION" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Duration of the cluster wide nominal macrotick, expressed in s.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.macrotickDuration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-WITHOUT-CLOCK-CORRECTION-FATAL" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Threshold concerning vClockCorrectionFailedCounter. Defines the number of consecutive even/odd Cycle pairs with missing clock correction terms that will cause the protocol to transition from the POC:normal active or POC:normal passive state into the POC:halt state.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.maxWithoutClockCorrectionFatal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-WITHOUT-CLOCK-CORRECTION-PASSIVE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Threshold concerning vClockCorrectionFailedCounter. Defines the number of consecutive even/odd Cycle pairs with missing clock correction terms that will cause the protocol to transition from the POC:normal active state to the POC:normal passive state.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.maxWithoutClockCorrectionPassive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINISLOT-ACTION-POINT-OFFSET" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The Offset of the action point within a minislot. Unit: macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.minislotActionPointOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINISLOT-DURATION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The duration of a minislot (dynamic segment). Unit: macroticks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.minislotDuration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NETWORK-IDLE-TIME" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The duration of the network idle time in macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.networkIdleTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NETWORK-MANAGEMENT-VECTOR-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Length of the Network Management vector in a cluster [bytes]</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.networkManagementVectorLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-MINISLOTS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of Minislots in the dynamic segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.numberOfMinislots";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-STATIC-SLOTS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The number of static slots in the static segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.numberOfStaticSlots";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET-CORRECTION-START" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Start of the offset correction phase within the Network Idle Time (NIT), expressed as the number of macroticks from the start of cycle. Unit: macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.offsetCorrectionStart";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PAYLOAD-LENGTH-STATIC" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Globally configured payload length of a static frame. Unit: 16-bit WORDS.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.payloadLengthStatic";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SAFETY-MARGIN" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Additional timespan in macroticks which takes jitter into account to be able to set the JobListPointer to the next possible job which can be executed in case the FlexRay Job List Execution Function has be resynchronized.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.safetyMargin";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SAMPLE-CLOCK-PERIOD" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Sample clock period. Unit: seconds</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.sampleClockPeriod";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATIC-SLOT-DURATION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The duration of a slot in the static segment. Unit: macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.staticSlotDuration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL-WINDOW" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The duration of the symbol window. Unit: macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.symbolWindow";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL-WINDOW-ACTION-POINT-OFFSET" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of macroticks the action point offset is from the beginning of the symbol window [Macroticks].</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.symbolWindowActionPointOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYNC-FRAME-ID-COUNT-MAX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Maximum number of distinct syncframe identifiers present in a given cluster. This parameter maps to FlexRay Protocol 2.1  Rev. A parameter gSyncNodeMax.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.syncFrameIdCountMax";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-START-SEQUENCE-DURATION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of bits in the Transmission Start Sequence [gdBits].</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.transmissionStartSequenceDuration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-RX-IDLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of bits used by the node to test the duration of the 'idle' or HIGH phase of a received wakeup. 
            Unit:bitDuration
            Remarks: This parameter maps to FlexRay Protocol 2.1 Rev. A parameter gdWakeupSymbolRxIdle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupRxIdle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-RX-LOW" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of bits used by the node to test the duration of the LOW phase of a received wakeup. Unit:bitDuration 
            Remarks: This parameter maps to FlexRay Protocol 2.1 Rev. A parameter gdWakeupSymbolRxLow.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupRxLow";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-RX-WINDOW" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The size of the window used to detect wakeups [gdBit]. 
            Remarks: This parameter maps to FlexRay Protocol 2.1 Rev. A parameter gdWakeupSymbolRxWindow.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupRxWindow";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-TX-ACTIVE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of bits used by the node to transmit the LOW phase of awakeup symbol and  the HIGH and LOW phases of a WUDOP. Unit:bitDuration</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupTxActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-TX-IDLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of bits used by the node to transmit the 'idle' part of a
            wakeup symbol. 
            Unit: gDbit</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupTxIdle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class FlexrayTopology::FlexrayCommunicationConnector -->
   <xsd:group name="FLEXRAY-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the CommunicationConnector</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKE-UP-CHANNEL" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Referenced channel used by the node to send a wakeup pattern. (pWakeupChannel)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationConnector.wakeUpChannel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayCommunicationConnector -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the CommunicationConnector</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:FLEXRAY-COMMUNICATION-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-COMMUNICATION-CONNECTOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONNECTOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class FlexrayTopology::FlexrayCommunicationController -->
   <xsd:group name="FLEXRAY-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>FlexRay bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLEXRAY-COMMUNICATION-CONTROLLER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-COMMUNICATION-CONTROLLER-CONDITIONAL" type="AR:FLEXRAY-COMMUNICATION-CONTROLLER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayCommunicationController -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>FlexRay bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:FLEXRAY-COMMUNICATION-CONTROLLER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayCommunicationControllerConditional -->
   <xsd:group name="FLEXRAY-COMMUNICATION-CONTROLLER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayCommunicationControllerConditional -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-COMMUNICATION-CONTROLLER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:FLEXRAY-COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:FLEXRAY-COMMUNICATION-CONTROLLER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayCommunicationControllerContent -->
   <xsd:group name="FLEXRAY-COMMUNICATION-CONTROLLER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCEPTED-STARTUP-RANGE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Expanded range of measured clock deviation allowed for startup frames during integration. Unit:microtick</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.acceptedStartupRange";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALLOW-HALT-DUE-TO-CLOCK" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Boolean flag that controls the transition to the POC:halt state due to a clock synchronization errors. 
            If set to true, the Communication Controller is allowed to transition to POC:halt. 
            If set to false, the Communication Controller will not transition to the POC:halt state but will enter or remain in the normal POC (passive State).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.allowHaltDueToClock";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALLOW-PASSIVE-TO-ACTIVE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of consecutive even/odd cycle pairs that must have valid clock correction terms before the Communication Controller will be allowed to transition from the POC:normal passive state to POC:normal active state. If set to 0, the Communication Controller is not allowed to transition from POC:norm</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.allowPassiveToActive";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLUSTER-DRIFT-DAMPING" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The cluster drift damping factor used in clock synchronization rate correction in microticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.clusterDriftDamping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DECODING-CORRECTION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Value used by the receiver to calculate the difference between primary time reference point and secondary time reference point. Unit: Microticks (pDecodingCorrection)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.decodingCorrection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELAY-COMPENSATION-A" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Value used to compensate for reception delays on channel A Unit: Microticks. This optional parameter shall only be filled out if channel A is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.delayCompensationA";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELAY-COMPENSATION-B" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Value used to compensate for reception delays on channel B. Unit: Microticks. This optional parameter shall only be filled out if channel B is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.delayCompensationB";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERN-OFFSET-CORRECTION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Fixed amount added or subtracted to the calculated offset correction term to facilitate external offset correction, expressed in node-local microticks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.externOffsetCorrection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERN-RATE-CORRECTION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Fixed amount added or subtracted to the calculated rate correction term to facilitate external rate correction, expressed in node-local microticks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.externRateCorrection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERNAL-SYNC" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether the node is externally synchronized (operating as Time Gateway Sink in an TT-E Time Triggered External Sync cluster) or locally synchronized.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.externalSync";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FALL-BACK-INTERNAL" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether a Time Gateway Sink node will switch to local clock operation when synchronization with the Time Gateway Source node is lost (pFallBackInternal = true) or will instead go to POC:ready (pFallBackInternal = false).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.fallBackInternal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLEXRAY-FIFOS">
            <xsd:annotation>
               <xsd:documentation>One First In First Out (FIFO) queued receive structure, defining the admittance criteria to the FIFO.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="flexrayFifo.FlexrayCommunicationController";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-FIFO-CONFIGURATION" type="AR:FLEXRAY-FIFO-CONFIGURATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEY-SLOT-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>ID of the slot used to transmit the startup frame, sync frame, or designated single slot frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.keySlotID";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEY-SLOT-ONLY-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether or not the node shall enter key slot only mode following startup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.keySlotOnlyEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEY-SLOT-USED-FOR-START-UP" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether the Key Slot is used to transmit a startup frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.keySlotUsedForStartUp";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEY-SLOT-USED-FOR-SYNC" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether the Key Slot is used to transmit a sync frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.keySlotUsedForSync";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LATEST-TX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The number of the last minislot in which a transmission can start in the dynamic segment for the respective node</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.latestTX";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LISTEN-TIMEOUT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Value for the startup listen timeout and wakeup listen timeout. Although this is a node local parameter, the real time equivalent of this value should be the same for all nodes in the cluster. Unit: Microticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.listenTimeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACRO-INITIAL-OFFSET-A" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Integer number of macroticks between the static slot boundary and the closest macrotick boundary of the secondary time reference point based on the nominal macrotick duration. (pMacroInitialOffset). This optional parameter shall only be filled out if channel A is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.macroInitialOffsetA";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACRO-INITIAL-OFFSET-B" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Integer number of macroticks between the static slot boundary and the closest macrotick boundary of the secondary time reference point based on the nominal macrotick duration. (pMacroInitialOffset). This optional parameter shall only be filled out if channel B is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.macroInitialOffsetB";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-DYNAMIC-PAYLOAD-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Maximum payload length for the dynamic channel of a frame in 16 bit WORDS.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.maximumDynamicPayloadLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICRO-INITIAL-OFFSET-A" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of microticks between the closest macrotick boundary described by gMacroInitialOffset and the secondary time reference point.  The parameter depends on pDelayCompensationA and therefore it has to be set independently for each channel. This optional parameter shall only be filled out if channel A is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microInitialOffsetA";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICRO-INITIAL-OFFSET-B" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of microticks between the closest macrotick boundary described by gMacroInitialOffset and the secondary time reference point.  The parameter depends on pDelayCompensationB and therefore it has to be set independently for each channel. This optional parameter shall only be filled out if channel B is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microInitialOffsetB";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICRO-PER-CYCLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The nominal number of microticks in a communication cycle</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microPerCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICROTICK-DURATION" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Duration of a microtick. This attribute can be derived from samplePerMicrotick and gdSampleClockPeriod. 
            Unit: seconds</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microtickDuration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-VECTOR-EARLY-UPDATE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Flag indicating when the update of the Network Management Vector in the CHI shall take place. If set to false, the update shall take place after the NIT. If set to true, the update shall take place after the end of the static segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.nmVectorEarlyUpdate";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET-CORRECTION-OUT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Magnitude of the maximum permissible offset correction value. Unit:microtick (pOffsetCorrectionOut)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.offsetCorrectionOut";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RATE-CORRECTION-OUT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Magnitude of the maximum permissible rate correction value and the maximum drift offset between two nodes operating with unsynchronized clocks for one communication cycle. Unit:Microticks (pRateCorrectionOut)

            Remarks: This parameter maps to FlexRay 
            Protocol 2.1 Rev. A parameter pdMaxDrift.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.rateCorrectionOut";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SAMPLES-PER-MICROTICK" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of samples per microtick</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.samplesPerMicrotick";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECOND-KEY-SLOT-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>ID of the second Key slot, in which a second startup frame shall be sent in TT-L Time Triggered Local Master Sync or TT-E Time Triggered External Sync mode. If this parameter is set to zero the node does not have a second key slot.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.secondKeySlotId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TWO-KEY-SLOT-MODE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether node operates as a startup node in a TT-E Time Triggered External Sync or TT-L Time Triggered Local Master Sync cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.twoKeySlotMode";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKE-UP-PATTERN" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of repetitions of the Tx-wakeup symbol to be sent during the CC_WakeupSend state of this Node in the cluster</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.wakeUpPattern";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class FlexrayTopology::FlexrayFifoConfiguration -->
   <xsd:group name="FLEXRAY-FIFO-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>One First In First Out (FIFO) queued receive structure, defining the admittance criteria to the FIFO, and mandating the ability to admit messages into the FIFO based on Message Id filtering criteria.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADMIT-WITHOUT-MESSAGE-ID" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Boolean configuration which determines whether or not frames received in the dynamic segment that don't contain a message ID will be admitted into the FIFO.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.admitWithoutMessageId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-CYCLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>FIFO cycle counter acceptance criteria.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.baseCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-REF">
            <xsd:annotation>
               <xsd:documentation>Fifo channel admittance criteria.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.channel";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-REPETITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>FIFO cycle counter acceptance criteria.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.cycleRepetition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIFO-DEPTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Fifo Depth.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.fifoDepth";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIFO-RANGES">
            <xsd:annotation>
               <xsd:documentation>FIFO Frame Id range acceptance criteria.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="fifoRange.FlexrayFifoConfiguration";pureMM.maxOccurs="-1";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-FIFO-RANGE" type="AR:FLEXRAY-FIFO-RANGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSG-ID-MASK" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>FIFO message identifier acceptance criteria (Mask filter).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.msgIdMask";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSG-ID-MATCH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>FIFO message identifier acceptance criteria (Match filter).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.msgIdMatch";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayFifoConfiguration -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-FIFO-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>One First In First Out (FIFO) queued receive structure, defining the admittance criteria to the FIFO, and mandating the ability to admit messages into the FIFO based on Message Id filtering criteria.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FLEXRAY-FIFO-CONFIGURATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayFifoRange -->
   <xsd:group name="FLEXRAY-FIFO-RANGE">
      <xsd:annotation>
         <xsd:documentation>FIFO Frame Id range acceptance criteria.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RANGE-MAX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Max Range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoRange.rangeMax";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RANGE-MIN" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Min Range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoRange.rangeMin";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayFifoRange -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-FIFO-RANGE">
      <xsd:annotation>
         <xsd:documentation>FIFO Frame Id range acceptance criteria.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FLEXRAY-FIFO-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlexrayCommunication::FlexrayFrame -->
   <xsd:group name="FLEXRAY-FRAME">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific Frame element.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="FlexrayFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class FlexrayCommunication::FlexrayFrame -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-FRAME">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific Frame element.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="FlexrayFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:FRAME"/>
         <xsd:group ref="AR:FLEXRAY-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class FlexrayCommunication::FlexrayFrameTriggering -->
   <xsd:group name="FLEXRAY-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ABSOLUTELY-SCHEDULED-TIMINGS">
            <xsd:annotation>
               <xsd:documentation>Specification of a sending behaviour where the exact time for the frames transmission is guaranteed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="absolutelyScheduledTiming.FlexrayFrameTriggering";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-ABSOLUTELY-SCHEDULED-TIMING" type="AR:FLEXRAY-ABSOLUTELY-SCHEDULED-TIMING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALLOW-DYNAMIC-L-SDU-LENGTH" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Allows L-PDU length reduction and indicates that the related CC buffer has to be reconfigured for the actual length and Header-CRC before transmission of the L-PDU. 

            If this attribute is set to true than the referenced Frame length attribute defines the max. length.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFrameTriggering.allowDynamicLSduLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MESSAGE-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The first two bytes of the payload segment of the FlexRay frame format for frames transmitted in the dynamic segment can be used as receiver filterable data called the message ID.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFrameTriggering.messageId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PAYLOAD-PREAMBLE-INDICATOR" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Switching the Payload Preamble bit.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFrameTriggering.payloadPreambleIndicator";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayCommunication::FlexrayFrameTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME-TRIGGERING"/>
         <xsd:group ref="AR:FLEXRAY-FRAME-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::FlexrayNmCluster -->
   <xsd:group name="FLEXRAY-NM-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific NM cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CAR-WAKE-UP-BIT-POSITION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Specifies the bit position of the CarWakeUp within the NM-Message.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmCarWakeUpBitPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CAR-WAKE-UP-FILTER-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If this attribute is set to true the CareWakeUp filtering is supported. In this case only the CarWakeUp bit within the NM message with source node identifier nmCarWakeUpFilterNodeId is considered as CarWakeUp request.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmCarWakeUpFilterEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CAR-WAKE-UP-FILTER-NODE-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Source node identifier for CarWakeUp filtering. If CarWakeUp filtering is supported (nmCarWakeUpFilterEnabled), only the CarWakeUp bit within the NM message with source node identifier nmCarWakeUpFilterNodeId is considered as CarWakeUp request.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmCarWakeUpFilterNodeId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CAR-WAKE-UP-RX-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If set to true this attribute enables the support of CarWakeUp bit evaluation in received NM messages.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmCarWakeUpRxEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CONTROL-BIT-VECTOR-ACTIVE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Used to activate or deactivate the control bit vector support for a Fr Nm Channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmControlBitVectorActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-DATA-CYCLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of FlexRay Communication Cycles needed to transmit the Nm Data PDUs of all FlexRay Nm Ecus of this FlexRayNmCluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmDataCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-DATA-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Switch to enable the separated sending of NM-Data. 
            True: enables
            False: disables</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmDataEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-DETECTION-LOCK" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The time for which a node will not set the repeat message request bit even in the presence of a repeat message request (in seconds).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmDetectionLock";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MAIN-FUNCTION-PERIOD" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Defines the processing cycle of the main function of FrNm module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmMainFunctionPeriod";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MESSAGE-TIMEOUT-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout of a NM message in seconds. It determines how long the NM shall wait with notification of transmission failure while communication errors occur on the bus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmMessageTimeoutTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-READY-SLEEP-COUNT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Numbers of repetitions in the ready sleep state before NM switches to bus sleep mode. On a value of "1", the NM-State Machine will leave the Ready Sleep State after one NM Repetition Cycle with no "keep awake" votes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmReadySleepCount";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REMOTE-SLEEP-INDICATION-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout for Remote Sleep Indication in seconds. It defines the time how long it shall take to recognize that all other nodes are ready to sleep.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmRemoteSleepIndicationTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MESSAGE-BIT-ACTIVE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Used to activate or deactivate the repeat message bit support for a Fr Nm Channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmRepeatMessageBitActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MESSAGE-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout for Repeat Message State in seconds. Defines the time how long the NM shall stay in the Repeat Message State.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmRepeatMessageTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPETITION-CYCLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of FlexRay Communication Cycles used to repeat the transmission of the Nm vote PDUs of all FlexRay NmEcus of this FlexRayNmCluster.  This value must be an integral multiple of nmVotingCycle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmRepetitionCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-VOTING-CYCLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of FlexRay CommunicationCycles needed to transmit the Nm vote of Pdus of all FlexRay NmEcus of this FlexRayNmCluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster.nmVotingCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::FlexrayNmCluster -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-NM-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific NM cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NM-CLUSTER"/>
         <xsd:group ref="AR:FLEXRAY-NM-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-NM-CLUSTER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-NM-CLUSTER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class NetworkManagement::FlexrayNmClusterCoupling -->
   <xsd:group name="FLEXRAY-NM-CLUSTER-COUPLING">
      <xsd:annotation>
         <xsd:documentation>FlexRay attributes that are valid for each of the referenced (coupled) FlexRay clusters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmClusterCoupling"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUPLED-CLUSTER-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to coupled FlexRay Clusters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmClusterCoupling.coupledCluster";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COUPLED-CLUSTER-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FLEXRAY-NM-CLUSTER--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CONTROL-BIT-VECTOR-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables control bit vector support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmClusterCoupling.nmControlBitVectorEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-DATA-DISABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Disables the transmission of NM-Data.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmClusterCoupling.nmDataDisabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-SCHEDULE-VARIANT" type="AR:FLEXRAY-NM-SCHEDULE-VARIANT">
            <xsd:annotation>
               <xsd:documentation>FrNm schedule variant according to FrNm SWS.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmClusterCoupling.nmScheduleVariant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::FlexrayNmClusterCoupling -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-NM-CLUSTER-COUPLING">
      <xsd:annotation>
         <xsd:documentation>FlexRay attributes that are valid for each of the referenced (coupled) FlexRay clusters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmClusterCoupling"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:NM-CLUSTER-COUPLING"/>
         <xsd:group ref="AR:FLEXRAY-NM-CLUSTER-COUPLING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::FlexrayNmEcu -->
   <xsd:group name="FLEXRAY-NM-ECU">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-HW-VOTE-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Switch for enabling the processing of FlexRay Hardware aggregated NM-Votes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmEcu.nmHwVoteEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MAIN-FUNCTION-ACROSS-FR-CYCLE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Parameter describing if the execution of the FrNm_Main function crosses theFlexRay cycle boundary or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmEcu.nmMainFunctionAcrossFrCycle";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MESSAGE-BIT-ENABLE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables/disables the repeat message bit support</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmEcu.nmRepeatMessageBitEnable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::FlexrayNmEcu -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-NM-ECU">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BUSSPECIFIC-NM-ECU"/>
         <xsd:group ref="AR:FLEXRAY-NM-ECU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::FlexrayNmNode -->
   <xsd:group name="FLEXRAY-NM-NODE">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific NM Node attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-INSTANCE-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The NM instance identifier is used for reporting of development errors to DET. It must be unique for each NM instance within one ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmNode.nmInstanceId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::FlexrayNmNode -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-NM-NODE">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific NM Node attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NM-NODE"/>
         <xsd:group ref="AR:FLEXRAY-NM-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayPhysicalChannel -->
   <xsd:group name="FLEXRAY-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the physicalChannel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-NAME" type="AR:FLEXRAY-CHANNEL-NAME">
            <xsd:annotation>
               <xsd:documentation>Name of the channel (Channel A or Channel B).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayPhysicalChannel.channelName";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayPhysicalChannel -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the physicalChannel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PHYSICAL-CHANNEL"/>
         <xsd:group ref="AR:FLEXRAY-PHYSICAL-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-PHYSICAL-CHANNEL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-PHYSICAL-CHANNEL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::FlexrayTpConfig -->
   <xsd:group name="FLEXRAY-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one FlexRay ISO TP Configuration. 

      One FlexRayTpConfig element shall be created for each FlexRay Network in the System that uses FlexRay Iso Tp.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="FlexrayTpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-POOLS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="pduPool.FlexrayTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-TP-PDU-POOL" type="AR:FLEXRAY-TP-PDU-POOL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESSS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpAddress.FlexrayTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TP-ADDRESS" type="AR:TP-ADDRESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpConnection.FlexrayTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-TP-CONNECTION" type="AR:FLEXRAY-TP-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTION-CONTROLS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpConnectionControl.FlexrayTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-TP-CONNECTION-CONTROL" type="AR:FLEXRAY-TP-CONNECTION-CONTROL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ECUS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpEcu.FlexrayTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-TP-ECU" type="AR:FLEXRAY-TP-ECU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-NODES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpNode.FlexrayTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-TP-NODE" type="AR:FLEXRAY-TP-NODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayTpConfig -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one FlexRay ISO TP Configuration. 

      One FlexRayTpConfig element shall be created for each FlexRay Network in the System that uses FlexRay Iso Tp.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="FlexrayTpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:TP-CONFIG"/>
         <xsd:group ref="AR:FLEXRAY-TP-CONFIG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayTpConnection -->
   <xsd:group name="FLEXRAY-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection identifies the sender and the receiver of this particular communication. The FlexRayTp module routes a Pdu through this connection. 

      In a System Description the references to the PduPools are mandatory. In an ECU Extract these references can be optional:
      On unicast connections these references are always mandatory.
      On multicast the txPduPool is mandatory on the sender side. The rxPduPool is mandatory on the receiver side. On Gateway ECUs both references are mandatory.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BANDWIDTH-LIMITATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Specifies whether the connection requires a  bandwidth limitation or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.bandwidthLimitation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECT-TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the FlexrayTpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.directTpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-REF">
            <xsd:annotation>
               <xsd:documentation>TP address for 1:n connections.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.multicast";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECEIVER-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.receiver";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FLEXRAY-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVERSED-TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. If support of both sending and receiving is used, this association references the IPdu used for the additional second direction.

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the FlexrayTpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.reversedTpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RX-PDU-POOL-REF">
            <xsd:annotation>
               <xsd:documentation>A connection has a reference to a set of NPdus (FrTpRxPduPool) which are
            defined for receiving data via this particular connection. 

            The following constraint is valid only for the System Extract/ECU Extract:
            In case this connection is applied to the transmitter the rxPduPool holds the
            actually received NPdus. In case this connection is applied to the receiver the rxPduPool holds the actually sent NPdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.rxPduPool";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-TP-PDU-POOL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTION-CONTROL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the connection control.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.tpConnectionControl";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-TP-CONNECTION-CONTROL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMITTER-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.transmitter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TX-PDU-POOL-REF">
            <xsd:annotation>
               <xsd:documentation>A connection has a reference to a set of NPdus (FrTpTxPduPool) which are
            defined for sending data via this particular connection.

            The following constraint is valid only for the System Extract/ECU Extract:
            In case this connection is applied to the transmitter the txPduPool holds the
            actually sent NPdus. In case this connection is applied to the receiver the
            txPduPool holds the actually received NPdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection.txPduPool";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-TP-PDU-POOL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayTpConnection -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection identifies the sender and the receiver of this particular communication. The FlexRayTp module routes a Pdu through this connection. 

      In a System Description the references to the PduPools are mandatory. In an ECU Extract these references can be optional:
      On unicast connections these references are always mandatory.
      On multicast the txPduPool is mandatory on the sender side. The rxPduPool is mandatory on the receiver side. On Gateway ECUs both references are mandatory.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FLEXRAY-TP-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayTpConnectionControl -->
   <xsd:group name="FLEXRAY-TP-CONNECTION-CONTROL">
      <xsd:annotation>
         <xsd:documentation>Configuration parameters to control a FlexRay TP connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACK-TYPE" type="AR:TP-ACK-TYPE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the type of acknowledgement which is used for the specific channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.ackType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-AR" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when a TIMEOUT AR occurs (depending on whether retry is configured).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.maxAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-AS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when a TIMEOUT AS occurs (depending on whether retry is configured)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.maxAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BUFFER-SIZE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter is only relevant when having retry activated. It limits the maximal buffer size the FrTp can choose in order to limit the amount of Tx buffer that will be requested at the sender side in a segmented transfer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.maxBufferSize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FC-WAIT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum number of FlowControl N-PDUs with FlowState "WAIT".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.maxFcWait";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FR-IF" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when the FrIf returns an error</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.maxFrIf";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-NPDU-PER-CYCLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter limits the number of N-Pdus the sender is allowed to transmit within a FlexRay cycle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.maxNumberOfNpduPerCycle";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-RETRIES" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of retries (if retry is configured for the particular channel).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.maxRetries";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEPARATION-CYCLE-EXPONENT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Exponent to calculate the minimum number of "Separation Cycles" the sender has to wait for the next transmission of an FrTp N-Pdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.separationCycleExponent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Time (in seconds) until transmission of the next FlowControl N-PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.timeBr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BUFFER" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time of waiting for the next try to get a Tx or Rx buffer.

            This parameter is equivalent to the temporal distance between two FC.WT N-Pdus in case the buffer request returns busy.

            Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.timeBuffer";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-FR-IF" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time of waiting for the next try to send. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.timeFrIf";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This parameter states the timeout between the PDU transmit request of the Transport Layer to the FlexRay Interface and the corresponding confirmation of the FlexRay Interface on the receiver side (for FC or AF). Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.timeoutAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute states the timeout between the PDU transmit request for the first PDU of the group used in the current connection of the Transport Layer to the FlexRay Interface and the corresponding confirmation of the FlexRay Interface (when having sent the last PDU of the group used in this connection) on the sender side (SF-x, FF-x, CF or FC (in case of Transmit Cancellation)). Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.timeoutAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-BS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the timeout in seconds for waiting for an FC or AF on the sender side in a 1:1 connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.timeoutBs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the timeout value in seconds for waiting for a CF or FF-x (in case of retry) after receiving the last CF or after sending an FC or AF on the receiver side. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl.timeoutCr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayTpConnectionControl -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-TP-CONNECTION-CONTROL">
      <xsd:annotation>
         <xsd:documentation>Configuration parameters to control a FlexRay TP connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpConnectionControl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FLEXRAY-TP-CONNECTION-CONTROL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-TP-CONNECTION-CONTROL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-TP-CONNECTION-CONTROL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::FlexrayTpEcu -->
   <xsd:group name="FLEXRAY-TP-ECU">
      <xsd:annotation>
         <xsd:documentation>ECU specific TP configuration parameters. Each TpEcu element has a reference to exactly one ECUInstance in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-TIME-MAIN-FUNCTION" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The period between successive calls to the Main Function of the AUTOSAR TP. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpEcu.cycleTimeMainFunction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Connection to the ECUInstance in the Topology</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpEcu.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FULL-DUPLEX-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>The full duplex mechanisms is enabled if this attribute is set to true. Otherwise half duplex is enabled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpEcu.fullDuplexEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayTpEcu -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-TP-ECU">
      <xsd:annotation>
         <xsd:documentation>ECU specific TP configuration parameters. Each TpEcu element has a reference to exactly one ECUInstance in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FLEXRAY-TP-ECU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayTpNode -->
   <xsd:group name="FLEXRAY-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTOR-REFS">
            <xsd:annotation>
               <xsd:documentation>Asscociation  to one or more physical connectors (max number of connectors for FlexRay: 2).

            In a System Description this reference is mandatory. In an ECU Extract this reference is optional (references to ECUs that are not part of the ECU Extract shall be avoided).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpNode.connector";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONNECTOR-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the TP Address that is used by the TpNode. This reference is optional in case that the multicast TP Address is used (reference from TpConnection).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpNode.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayTpNode -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FLEXRAY-TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::FlexrayTpPduPool -->
   <xsd:group name="FLEXRAY-TP-PDU-POOL">
      <xsd:annotation>
         <xsd:documentation>FlexrayTpPduPool is a set of N-PDUs which are defined for FrTp sending or receiving purpose.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpPduPool"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="N-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to NPdus that are part of the PduPool.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpPduPool.nPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="N-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayTpPduPool -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-TP-PDU-POOL">
      <xsd:annotation>
         <xsd:documentation>FlexrayTpPduPool is a set of N-PDUs which are defined for FrTp sending or receiving purpose.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpPduPool"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FLEXRAY-TP-PDU-POOL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-TP-PDU-POOL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-TP-PDU-POOL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class VariantHandling::FloatValueVariationPoint -->
   <xsd:group name="FLOAT-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for Float attributes.

      Note that this class might be used in the extended meta-model only</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FloatValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class VariantHandling::FloatValueVariationPoint -->
   <xsd:complexType abstract="false" mixed="true" name="FLOAT-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for Float attributes.

      Note that this class might be used in the extended meta-model only</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FloatValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-DEPENDENT-FORMULA"/>
         <xsd:group ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
         <xsd:group ref="AR:FLOAT-VALUE-VARIATION-POINT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::FootnoteText -->
   <xsd:group name="FOOTNOTE-TEXT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express text rendered as footnote.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FootnoteText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="SUB" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>this is subscript text</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="FootnoteText.sub";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUP" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>this is superscript text</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="FootnoteText.sup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="TT" type="AR:TT">
               <xsd:annotation>
                  <xsd:documentation>This is a technical term.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="FootnoteText.tt";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="E" type="AR:EMPHASIS-TEXT">
               <xsd:annotation>
                  <xsd:documentation>This is an emphasized text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="FootnoteText.e";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class InlineTextElements::FootnoteText -->
   <xsd:complexType abstract="false" mixed="true" name="FOOTNOTE-TEXT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express text rendered as footnote.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FootnoteText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FOOTNOTE-TEXT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::ForbiddenSignalPath -->
   <xsd:group name="FORBIDDEN-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The ForbiddenSignalPath describes the physical channels which an element must not take in the topology. Such a signal path can be a constraint for the communication matrix,  because such a path has an effect on the frame generation and the frame path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ForbiddenSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:documentation>Reference to the operation arguments of one operation which must not take the predefined way in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.ForbiddenSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNEL-REFS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcSignal must not be transmitted on one of these physical channels.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ForbiddenSignalPath.physicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PHYSICAL-CHANNEL-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNALS">
            <xsd:annotation>
               <xsd:documentation>The data element which must not take the predefined way in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signal.ForbiddenSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::ForbiddenSignalPath -->
   <xsd:complexType abstract="false" mixed="false" name="FORBIDDEN-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The ForbiddenSignalPath describes the physical channels which an element must not take in the topology. Such a signal path can be a constraint for the communication matrix,  because such a path has an effect on the frame generation and the frame path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ForbiddenSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SIGNAL-PATH-CONSTRAINT"/>
         <xsd:group ref="AR:FORBIDDEN-SIGNAL-PATH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FormulaLanguage::FormulaExpression -->
   <xsd:group name="FORMULA-EXPRESSION">
      <xsd:annotation>
         <xsd:documentation>This class represents the syntax of the formula language. The class is modeled as an abstract class in order to be specialized into particular use cases. For each use case the referable objects might be specified in the specialization.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FormulaExpression"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class CoreCommunication::Frame -->
   <xsd:group name="FRAME">
      <xsd:annotation>
         <xsd:documentation>Data frame which is sent over a communication medium. This element describes the pure Layout of a frame sent on a channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Frame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The used length (in bytes)  of the referencing frame. Should not be confused with a static byte length reserved for each frame by some platforms (e.g. FlexRay). 

            The frameLength of zero bytes is allowed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Frame.frameLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-TO-FRAME-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="pduToFrameMapping.Frame";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PDU-TO-FRAME-MAPPING" type="AR:PDU-TO-FRAME-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="FRAME--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-FRAME"/>
         <xsd:enumeration value="ETHERNET-FRAME"/>
         <xsd:enumeration value="FLEXRAY-FRAME"/>
         <xsd:enumeration value="FRAME"/>
         <xsd:enumeration value="LIN-EVENT-TRIGGERED-FRAME"/>
         <xsd:enumeration value="LIN-FRAME"/>
         <xsd:enumeration value="LIN-SPORADIC-FRAME"/>
         <xsd:enumeration value="LIN-UNCONDITIONAL-FRAME"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::FrameMapping -->
   <xsd:group name="FRAME-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The entire source frame is mapped as it is onto the target frame (what in general is only possible inside of a common platform). In this case source and target frame should be the identical object.

      Each pair consists in a SOURCE and a TARGET referencing to a FrameTriggering.

      The Frame Mapping is not supported by the Autosar BSW. The existence is optional and has been incorporated into the System Template mainly for compatibility in order to allow interchange between FIBEX and AUTOSAR descriptions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents introductory documentation about the frame mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>Source destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping.sourceFrame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping.targetFrame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::FrameMapping -->
   <xsd:complexType abstract="false" mixed="false" name="FRAME-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The entire source frame is mapped as it is onto the target frame (what in general is only possible inside of a common platform). In this case source and target frame should be the identical object.

      Each pair consists in a SOURCE and a TARGET referencing to a FrameTriggering.

      The Frame Mapping is not supported by the Autosar BSW. The existence is optional and has been incorporated into the System Template mainly for compatibility in order to allow interchange between FIBEX and AUTOSAR descriptions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FRAME-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::FramePid -->
   <xsd:group name="FRAME-PID">
      <xsd:annotation>
         <xsd:documentation>Frame_PIDs that are included in the request. The "pid" attribute describes the value and the "index" attribute the position of the frame_PID in the request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FramePid"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute is used to order the frame_PIDs. The values of index shall be unique within one AssignFrameIdRange.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FramePid.index";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Frame_PID value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FramePid.pid";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::FramePid -->
   <xsd:complexType abstract="false" mixed="false" name="FRAME-PID">
      <xsd:annotation>
         <xsd:documentation>Frame_PIDs that are included in the request. The "pid" attribute describes the value and the "index" attribute the position of the frame_PID in the request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FramePid"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FRAME-PID"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::FramePort -->
   <xsd:group name="FRAME-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by a FrameTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FramePort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class CoreCommunication::FramePort -->
   <xsd:complexType abstract="false" mixed="false" name="FRAME-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by a FrameTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FramePort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMM-CONNECTOR-PORT"/>
         <xsd:group ref="AR:FRAME-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FRAME-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FRAME-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::FrameTriggering -->
   <xsd:group name="FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The FrameTriggering describes the instance of a frame sent on a channel and defines the manner of triggering (timing information) and identification of a frame on the channel, on which it is sent.

      For the same frame, if FrameTriggerings exist on more than one channel of the same cluster the fan-out/in is handled by the Bus interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>References to the FramePort on every ECU of the system which sends and/or
            receives the frame.

            References for both the sender and the receiver side shall be included when the system is completely defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameTriggering.framePort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FRAME-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FRAME-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>One frame can be triggered several times, e.g. on different channels. If a frame has no frame triggering, it won't be sent at all. A frame triggering has assigned exactly one frame, which it triggers.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameTriggering.frame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FRAME--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-TRIGGERINGS">
            <xsd:annotation>
               <xsd:documentation>This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="FrameTriggering.pduTriggering";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PDU-TRIGGERING-REF-CONDITIONAL" type="AR:PDU-TRIGGERING-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="FRAME-TRIGGERING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-FRAME-TRIGGERING"/>
         <xsd:enumeration value="ETHERNET-FRAME-TRIGGERING"/>
         <xsd:enumeration value="FLEXRAY-FRAME-TRIGGERING"/>
         <xsd:enumeration value="FRAME-TRIGGERING"/>
         <xsd:enumeration value="LIN-FRAME-TRIGGERING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinCommunication::FreeFormat -->
   <xsd:group name="FREE-FORMAT">
      <xsd:annotation>
         <xsd:documentation>Representing freely defined data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FreeFormat"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BYTE-VALUES">
            <xsd:complexType>
               <xsd:choice maxOccurs="8" minOccurs="0">
                  <xsd:element name="BYTE-VALUE" type="AR:INTEGER">
                     <xsd:annotation>
                        <xsd:documentation>The integer Value of a freely defined data byte.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="FreeFormat.byteValue";pureMM.maxOccurs="8";pureMM.minOccurs="8"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::FreeFormat -->
   <xsd:complexType abstract="false" mixed="false" name="FREE-FORMAT">
      <xsd:annotation>
         <xsd:documentation>Representing freely defined data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FreeFormat"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:FREE-FORMAT-ENTRY"/>
         <xsd:group ref="AR:FREE-FORMAT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::FreeFormatEntry -->
   <xsd:group name="FREE-FORMAT-ENTRY">
      <xsd:annotation>
         <xsd:documentation>FreeFormat transmits a fixed master request frame with the eight data bytes provided. This may for instance be used to issue user specific fixed frames.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FreeFormatEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ServiceNeeds::FunctionInhibitionNeeds -->
   <xsd:group name="FUNCTION-INHIBITION-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Function Inhibition Manager for one Function Identifier (FID). This class currently contains no attributes. Its name can be regarded as a symbol identifying the FID  from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FunctionInhibitionNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::FunctionInhibitionNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="FUNCTION-INHIBITION-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Function Inhibition Manager for one Function Identifier (FID). This class currently contains no attributes. Its name can be regarded as a symbol identifying the FID  from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FunctionInhibitionNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:FUNCTION-INHIBITION-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FUNCTION-INHIBITION-NEEDS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FUNCTION-INHIBITION-NEEDS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::Gateway -->
   <xsd:group name="GATEWAY">
      <xsd:annotation>
         <xsd:documentation>A gateway is an ECU that is connected to two or more clusters (channels, but not redundant), and performs a frame, Pdu or signal mapping between them.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Gateways";mmt.qualifiedName="Gateway"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to one ECU instance that implements the gateway.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Gateway.ecu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="frameMapping.Gateway";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FRAME-MAPPING" type="AR:FRAME-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="iPduMapping.Gateway";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-MAPPING" type="AR:I-PDU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="signalMapping.Gateway";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-MAPPING" type="AR:I-SIGNAL-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::Gateway -->
   <xsd:complexType abstract="false" mixed="false" name="GATEWAY">
      <xsd:annotation>
         <xsd:documentation>A gateway is an ECU that is connected to two or more clusters (channels, but not redundant), and performs a frame, Pdu or signal mapping between them.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Gateways";mmt.qualifiedName="Gateway"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:GATEWAY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class GeneralAnnotation::GeneralAnnotation -->
   <xsd:group name="GENERAL-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>This class represents textual comments (called annotations) which relate to the object in which it is aggregated. These annotations are intended for use during the development process for transferring information from one step of the development process to the next one. 

      The approach is similar to the "yellow pads" ...

      This abstract class can be specialized in order to add some further formal properties.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="GeneralAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LABEL" type="AR:MULTILANGUAGE-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This is the headline for the annotation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralAnnotation.label";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATION-ORIGIN" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute identifies the origin of the annotation. It is an arbitrary string since it can be an individual's name as well as the name of a tool or even the name of a process step.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralAnnotation.annotationOrigin";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATION-TEXT" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This is the text of the annotation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralAnnotation.annotationText";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class GerneralParameters::GeneralParameter -->
   <xsd:group name="GENERAL-PARAMETER">
      <xsd:annotation>
         <xsd:documentation>This represents a parameter in general e.g. an entry in a data sheet.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="GeneralParameter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="PRM-CHAR" type="AR:PRM-CHAR">
            <xsd:annotation>
               <xsd:documentation>This represents the characteristics of one parameter under one particular condition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralParameter.prmChar";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GerneralParameters::GeneralParameter -->
   <xsd:complexType abstract="false" mixed="false" name="GENERAL-PARAMETER">
      <xsd:annotation>
         <xsd:documentation>This represents a parameter in general e.g. an entry in a data sheet.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="GeneralParameter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:GENERAL-PARAMETER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Figure::Graphic -->
   <xsd:group name="GRAPHIC">
      <xsd:annotation>
         <xsd:documentation>This class represents an artifact containing the image to be inserted in the document</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Graphic"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class Figure::Graphic -->
   <xsd:attributeGroup name="GRAPHIC">
      <xsd:annotation>
         <xsd:documentation>This class represents an artifact containing the image to be inserted in the document</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Graphic"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="EDIT-HEIGHT" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies the height of the graphic when it is displayed in an editor.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.editHeight";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="EDIT-WIDTH" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies the width of the graphic when it is displayed in an editor.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.editWidth";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="EDITFIT" type="AR:GRAPHIC-FIT-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies how the graphic shall be displayed in an editor. If the attribute is missing,</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.editfit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="EDITSCALE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Set the proportional scale when displayed in an editor.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.editscale";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="FILENAME" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Name of the file that should be displayed. This attribute is supported in ASAM FSX and kept in AUTOSAR in order to support cut and paste.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.filename";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="FIT" type="AR:GRAPHIC-FIT-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>It determines the way in which the graphic should be inserted.

         Enter the attribute value "AS-IS" , to insert a graphic in its original dimensions.

         The graphic is adapted, if it is too big for the space for which it was intended. 
         Default is "AS-IS"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.fit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="GENERATOR" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute specifies the generator which is used to generate the image. 

         Use case is that when editing a documentation, a figure (to be delivered by the  modeling tool) is inserted by the authoring tool as reference (this is the role  of graphic). But the real figure maybe injected during document processing. To  be able to recognize this situation, this attribute can be applied.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.generator";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HEIGHT" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Define the displayed height of the figure.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.height";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HTML-FIT" type="AR:GRAPHIC-FIT-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>How to fit the graphic in an online media. Default is AS-IS.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.htmlFit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HTML-HEIGHT" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies the height of the graphic when it is displayed online.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.htmlHeight";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HTML-SCALE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Set the proportional scale when displayed online.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.htmlScale";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HTML-WIDTH" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies the width of the graphic when it is displayed online.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.htmlWidth";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="NOTATION" type="AR:GRAPHIC-NOTATION-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute captures the format used to represent the graphic.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.notation";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true";xml.id="GRAPHIC_TYPE__GRAPHIC_TYPE__NOTATION"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SCALE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>In this element the dimensions of the graphic can be altered proportionally.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.scale";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="WIDTH" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Define the displayed width of the figure.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Graphic.width";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Figure::Graphic -->
   <xsd:complexType abstract="false" mixed="false" name="GRAPHIC">
      <xsd:annotation>
         <xsd:documentation>This class represents an artifact containing the image to be inserted in the document</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Graphic"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ENGINEERING-OBJECT"/>
         <xsd:group ref="AR:GRAPHIC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:GRAPHIC"/>
   </xsd:complexType>
   <!-- element group for class ResourceConsumption::HardwareConfiguration -->
   <xsd:group name="HARDWARE-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>Describes in which mode the hardware is operating while needing this resource consumption.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADDITIONAL-INFORMATION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies additional information on the HardwareConfiguration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration.additionalInformation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROCESSOR-MODE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies in which mode the processor is operating.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration.processorMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROCESSOR-SPEED" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies the speed the processor is operating.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration.processorSpeed";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ResourceConsumption::HardwareConfiguration -->
   <xsd:complexType abstract="false" mixed="false" name="HARDWARE-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>Describes in which mode the hardware is operating while needing this resource consumption.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:HARDWARE-CONFIGURATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class HeapUsage::HeapUsage -->
   <xsd:group name="HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Describes the heap memory usage of a SW-Component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION">
            <xsd:annotation>
               <xsd:documentation>Contains information about the hardware context this heap usage is describing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hardwareConfiguration.HeapUsage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Specifies for which hardware element (e.g. ECU) this heap usage  usage is given.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HeapUsage.hwElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT">
            <xsd:annotation>
               <xsd:documentation>Contains details about the software context this heap usage is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="softwareContext.HeapUsage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class HwElementCategory::HwAttributeDef -->
   <xsd:group name="HW-ATTRIBUTE-DEF">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to define a particular hardware attribute.

      The category of this element defines the type of the attributeValue. If the category is Enumeration the hwAttributeEnumerationLiterals specify the available literals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ATTRIBUTE-LITERALS">
            <xsd:annotation>
               <xsd:documentation>The available EnumerationLiterals of the Enumeration definition. Only applicable if the category of the HwAttributeDef equals Enumeration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hwAttributeLiteral.HwAttributeDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-ATTRIBUTE-LITERAL-DEF" type="AR:HW-ATTRIBUTE-LITERAL-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-REQUIRED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies if the defined attribute value is required to be provided.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeDef.isRequired";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>This association specifies the physical unit of the defined hardware attribute. This is optional due to the fact that there are textual attributes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeDef.unit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HwElementCategory::HwAttributeDef -->
   <xsd:complexType abstract="false" mixed="false" name="HW-ATTRIBUTE-DEF">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to define a particular hardware attribute.

      The category of this element defines the type of the attributeValue. If the category is Enumeration the hwAttributeEnumerationLiterals specify the available literals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ATTRIBUTE-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="HW-ATTRIBUTE-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HW-ATTRIBUTE-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class HwElementCategory::HwAttributeLiteralDef -->
   <xsd:group name="HW-ATTRIBUTE-LITERAL-DEF">
      <xsd:annotation>
         <xsd:documentation>One available EnumerationLiteral of the Enumeration definition. Only applicable if the category of the HwAttributeDef equals Enumeration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeLiteralDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class HwElementCategory::HwAttributeLiteralDef -->
   <xsd:complexType abstract="false" mixed="false" name="HW-ATTRIBUTE-LITERAL-DEF">
      <xsd:annotation>
         <xsd:documentation>One available EnumerationLiteral of the Enumeration definition. Only applicable if the category of the HwAttributeDef equals Enumeration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeLiteralDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ATTRIBUTE-LITERAL-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class HwElementCategory::HwAttributeValue -->
   <xsd:group name="HW-ATTRIBUTE-VALUE">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to assign a hardware attribute value. Note that v and vt are mutually exclusive.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATION" type="AR:ANNOTATION">
            <xsd:annotation>
               <xsd:documentation>Optional annotation that can be added to each HwAttributeValue.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="annotation.Annotation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ATTRIBUTE-DEF-REF">
            <xsd:annotation>
               <xsd:documentation>This association represents the definition of the particular hardware attribute value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeValue.hwAttributeDef";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ATTRIBUTE-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="V" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This represents a numerical hardware attribute value.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwAttributeValue.v";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VT" type="AR:VERBATIM-STRING">
            <xsd:annotation>
               <xsd:documentation>This represents a textual hardware attribute value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeValue.vt";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HwElementCategory::HwAttributeValue -->
   <xsd:complexType abstract="false" mixed="false" name="HW-ATTRIBUTE-VALUE">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to assign a hardware attribute value. Note that v and vt are mutually exclusive.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwAttributeValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:HW-ATTRIBUTE-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class HwElementCategory::HwCategory -->
   <xsd:group name="HW-CATEGORY">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to declare hardware categories and its particular attributes.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="HwCategorys";mmt.qualifiedName="HwCategory"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ATTRIBUTE-DEFS">
            <xsd:annotation>
               <xsd:documentation>This aggregation describes particular hardware attribute definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwCategory.hwAttributeDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-ATTRIBUTE-DEF" type="AR:HW-ATTRIBUTE-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HwElementCategory::HwCategory -->
   <xsd:complexType abstract="false" mixed="false" name="HW-CATEGORY">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to declare hardware categories and its particular attributes.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="HwCategorys";mmt.qualifiedName="HwCategory"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:HW-CATEGORY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="HW-CATEGORY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HW-CATEGORY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class EcuResourceTemplate::HwDescriptionEntity -->
   <xsd:group name="HW-DESCRIPTION-ENTITY">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to describe a hardware entity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwDescriptionEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This association is used to assign an optional HwType which contains the common attribute values for all occurences of this HwDescriptionEntity. 
            Note that HwTypes can not be redefined and therefore must not have a hwType reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwDescriptionEntity.hwType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-CATEGORY-REFS">
            <xsd:annotation>
               <xsd:documentation>One of the associations representing one particular category of the hardware entity.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwDescriptionEntity.hwCategory";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-CATEGORY-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-CATEGORY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ATTRIBUTE-VALUES">
            <xsd:annotation>
               <xsd:documentation>This aggregation represents a particular hardware attribute value.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwDescriptionEntity.hwAttributeValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-ATTRIBUTE-VALUE" type="AR:HW-ATTRIBUTE-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="HW-DESCRIPTION-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HW-DESCRIPTION-ENTITY"/>
         <xsd:enumeration value="HW-ELEMENT"/>
         <xsd:enumeration value="HW-PIN"/>
         <xsd:enumeration value="HW-PIN-GROUP"/>
         <xsd:enumeration value="HW-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class EcuResourceTemplate::HwElement -->
   <xsd:group name="HW-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to describe Hardware Elements on an instance level. The particular types of hardware are distinguished by the category. This category determines the applicable attributes. The possible categories and attributes are defined in HwCategory.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="HwElements";mmt.qualifiedName="HwElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NESTED-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>This association is used to establish hierarchies of hw elements. Note that one particular HwElement can be target of this association only once. I.e. multiple instantiation of the same HwElement is not supported (at any hierarchy level).
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwElement.nestedElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-ELEMENT-REF-CONDITIONAL" type="AR:HW-ELEMENT-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PIN-GROUPS">
            <xsd:annotation>
               <xsd:documentation>This aggregation is used to describe the connection facilities of a hardware element. Note that hardware element has no pins but only pingroups. 
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwElement.hwPinGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-PIN-GROUP" type="AR:HW-PIN-GROUP"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ELEMENT-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>This represents one particular connection between two hardware elements.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwElement.hwElementConnection";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="110"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-ELEMENT-CONNECTOR" type="AR:HW-ELEMENT-CONNECTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EcuResourceTemplate::HwElement -->
   <xsd:complexType abstract="false" mixed="false" name="HW-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to describe Hardware Elements on an instance level. The particular types of hardware are distinguished by the category. This category determines the applicable attributes. The possible categories and attributes are defined in HwCategory.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="HwElements";mmt.qualifiedName="HwElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:HW-DESCRIPTION-ENTITY"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="HW-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HW-ELEMENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class EcuResourceTemplate::HwElementConnector -->
   <xsd:group name="HW-ELEMENT-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to connect two hardware elements. 
      The details of the connection can be refined by hwPinGroupConnection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwElementConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>This association connects two hardware elements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwElementConnector.hwElement";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="HW-ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PIN-GROUP-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>This represents one particular connection between two hardware pin groups.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwElementConnector.hwPinGroupConnection";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-PIN-GROUP-CONNECTOR" type="AR:HW-PIN-GROUP-CONNECTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PIN-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>This represents one particular connection between two hardware pins. This connection shall be used if pin-to-pin-connection is to be described but no description of the connection between the hierarchical composition of HwPinGroups (using HwPinGroupConnector) is required.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwElementConnector.hwPinConnection";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-PIN-CONNECTOR" type="AR:HW-PIN-CONNECTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EcuResourceTemplate::HwElementConnector -->
   <xsd:complexType abstract="false" mixed="false" name="HW-ELEMENT-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to connect two hardware elements. 
      The details of the connection can be refined by hwPinGroupConnection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwElementConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DESCRIBABLE"/>
         <xsd:group ref="AR:HW-ELEMENT-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EcuResourceTemplate::HwElementRefConditional -->
   <xsd:group name="HW-ELEMENT-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ELEMENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EcuResourceTemplate::HwElementRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="HW-ELEMENT-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:HW-ELEMENT-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EcuResourceTemplate::HwPin -->
   <xsd:group name="HW-PIN">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the possibility to describe a hardware pin.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPin"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PIN-NUMBER" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute contains the physical pin number.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwPin.pinNumber";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EcuResourceTemplate::HwPin -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PIN">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the possibility to describe a hardware pin.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPin"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-DESCRIPTION-ENTITY"/>
         <xsd:group ref="AR:HW-PIN"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="HW-PIN--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HW-PIN"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class EcuResourceTemplate::HwPinConnector -->
   <xsd:group name="HW-PIN-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to connect two pins.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPinConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PIN-REFS">
            <xsd:annotation>
               <xsd:documentation>This association connects two hardware pins.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwPinConnector.hwPin";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="HW-PIN-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-PIN--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EcuResourceTemplate::HwPinConnector -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PIN-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to connect two pins.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPinConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DESCRIBABLE"/>
         <xsd:group ref="AR:HW-PIN-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EcuResourceTemplate::HwPinGroup -->
   <xsd:group name="HW-PIN-GROUP">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to describe groups of pins which are used to connect hardware elements. This group acts as a bundle of pins. Thereby they allow to describe high level connections. Pin groups can even be nested.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPinGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PIN-GROUP-CONTENT" type="AR:HW-PIN-GROUP-CONTENT">
            <xsd:annotation>
               <xsd:documentation>This aggregation describes the contained pins/pin groups.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwPinGroup.hwPinGroupContent";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EcuResourceTemplate::HwPinGroup -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PIN-GROUP">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to describe groups of pins which are used to connect hardware elements. This group acts as a bundle of pins. Thereby they allow to describe high level connections. Pin groups can even be nested.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPinGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-DESCRIPTION-ENTITY"/>
         <xsd:group ref="AR:HW-PIN-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="HW-PIN-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HW-PIN-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class EcuResourceTemplate::HwPinGroupConnector -->
   <xsd:group name="HW-PIN-GROUP-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to connect two pin groups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPinGroupConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PIN-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>This represents one particular connection between two hardware pins. The connected pins must match the connection provided by the parent hwPinGroupConnection.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwPinGroupConnector.hwPinConnection";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-PIN-CONNECTOR" type="AR:HW-PIN-CONNECTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PIN-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>This association connects two hardware pin groups.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwPinGroupConnector.hwPinGroup";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="HW-PIN-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-PIN-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EcuResourceTemplate::HwPinGroupConnector -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PIN-GROUP-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to connect two pin groups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPinGroupConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DESCRIBABLE"/>
         <xsd:group ref="AR:HW-PIN-GROUP-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EcuResourceTemplate::HwPinGroupContent -->
   <xsd:group name="HW-PIN-GROUP-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies a mixture of hwPins and hwPinGroups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPinGroupContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="HW-PIN" type="AR:HW-PIN">
               <xsd:annotation>
                  <xsd:documentation>This aggregation represents a hardware pin in a hardware pin group. 
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwPinGroupContent.hwPin";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleWrapperElement="false"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="HW-PIN-GROUP" type="AR:HW-PIN-GROUP">
               <xsd:annotation>
                  <xsd:documentation>This aggregation represents a nested hardware pin group.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="HwPinGroupContent.hwPinGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleWrapperElement="false"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class EcuResourceTemplate::HwPinGroupContent -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PIN-GROUP-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies a mixture of hwPins and hwPinGroups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPinGroupContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:HW-PIN-GROUP-CONTENT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUResourceMapping::HwPortMapping -->
   <xsd:group name="HW-PORT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>HWPortMapping specifies the hwCommunicationPort (defined in the ECU Resource Template) to realize the specified CommunicationConnector in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPortMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CONNECTOR-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the CommunicationConnector in the System Template</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwPortMapping.communicationConnector";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-COMMUNICATION-PORT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the HwPinPortGroup of category CommunicationPort. The connection to the HwCommunicationController is described in the Ecu Resource Description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HwPortMapping.hwCommunicationPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-PIN-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceMapping::HwPortMapping -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PORT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>HWPortMapping specifies the hwCommunicationPort (defined in the ECU Resource Template) to realize the specified CommunicationConnector in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HwPortMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:HW-PORT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class HwElementCategory::HwType -->
   <xsd:group name="HW-TYPE">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to describe Hardware types on an abstract level. The particular types of hardware are distinguished by the category. This category determines the applicable attributes. The possible categories and attributes are defined in HwCategory.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="HwTypes";mmt.qualifiedName="HwType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class HwElementCategory::HwType -->
   <xsd:complexType abstract="false" mixed="false" name="HW-TYPE">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to describe Hardware types on an abstract level. The particular types of hardware are distinguished by the category. This category determines the applicable attributes. The possible categories and attributes are defined in HwCategory.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="HwTypes";mmt.qualifiedName="HwType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:HW-DESCRIPTION-ENTITY"/>
         <xsd:group ref="AR:HW-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="HW-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HW-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::IPdu -->
   <xsd:group name="I-PDU">
      <xsd:annotation>
         <xsd:documentation>The IPdu (Interaction Layer Protocol Data Unit) element is used to sum up the IPdus of AUTOSAR COM, DCM and IPduM. These Pdus are routed by the PduR. 

      In the AUTOSAR Layered Architecture the NPdu is not a specialization of an IPdu. The NPdu is located under the IPdu to support the low-level routing of NPdus. More details can be found in the NPdu class description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="I-PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="I-PDU"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::IPduMapping -->
   <xsd:group name="I-PDU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Arranges those IPdus that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents introductory documentation about the IPdu mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduMapping.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDUR-TP-CHUNK-SIZE" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Optionally defines the to be configured Pdu Router TpChunkSize for this routing relation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduMapping.pdurTpChunkSize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Source destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduMapping.sourceIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PDU-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-I-PDU" type="AR:TARGET-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="targetIPdu.IPduMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::IPduMapping -->
   <xsd:complexType abstract="false" mixed="false" name="I-PDU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Arranges those IPdus that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:I-PDU-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::IPduPort -->
   <xsd:group name="I-PDU-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by a PduTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class CoreCommunication::IPduPort -->
   <xsd:complexType abstract="false" mixed="false" name="I-PDU-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by a PduTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMM-CONNECTOR-PORT"/>
         <xsd:group ref="AR:I-PDU-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-PDU-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-PDU-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::IPduTiming -->
   <xsd:group name="I-PDU-TIMING">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR COM provides the possibility to define two different TRANSMISSION MODES for each IPdu.

      The Transmission Mode of an IPdu that is valid at a specific point in time is selected using the values of the signals that are mapped to this IPdu. For each IPdu a Transmission Mode Selector is defined. The Transmission Mode Selector is calculated by evaluating the conditions for a subset of signals  (class TransmissionModeCondition in the System Template).

      The Transmission Mode Selector is defined to be true, if at least one Condition evaluates to true and is defined to be false, if all Conditions evaluate to false.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-DELAY" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Minimum Delay in seconds between successive transmissions of this I-PDU, independent of the Transmission Mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduTiming.minimumDelay";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-MODE-DECLARATION" type="AR:TRANSMISSION-MODE-DECLARATION">
            <xsd:annotation>
               <xsd:documentation>AUTOSAR COM allows configuring statically two different transmission modes for each
            I-PDU (True and False). The Transmission Mode Selector evaluates the conditions for a subset of signals and decides the transmission mode. It is possible to switch between the transmission modes during runtime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionModeDeclaration.IPduTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::IPduTiming -->
   <xsd:complexType abstract="false" mixed="false" name="I-PDU-TIMING">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR COM provides the possibility to define two different TRANSMISSION MODES for each IPdu.

      The Transmission Mode of an IPdu that is valid at a specific point in time is selected using the values of the signals that are mapped to this IPdu. For each IPdu a Transmission Mode Selector is defined. The Transmission Mode Selector is calculated by evaluating the conditions for a subset of signals  (class TransmissionModeCondition in the System Template).

      The Transmission Mode Selector is defined to be true, if at least one Condition evaluates to true and is defined to be false, if all Conditions evaluate to false.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:I-PDU-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::ISignal -->
   <xsd:group name="I-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>Signal of the Interaction Layer. The RTE supports a "signal fan-out" where the same System Signal is sent in different SignalIPdus to multiple receivers. 

      The System Signal is unique per System. To support the RTE "signal fan-out" each SignalIPdu  contains ISignals. If the same System Signal is to be mapped into several SignalIPdus there is one ISignal needed for each ISignalToIPduMapping. 

      ISignals describe the Interface between the Precompile configured RTE and the potentially Postbuild configured Com Stack (see ECUC Parameter Mapping). 

      In case of the SystemSignalGroup an ISignal must be created for each SystemSignal contained in the SystemSignalGroup.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ISignals";mmt.qualifiedName="ISignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-TYPE-POLICY" type="AR:DATA-TYPE-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>With the aggregation of SwDataDefProps an ISignal specifies how it is represented on the network. This representation follows a particular policy. 

            Note that this causes some redundancy which is intended and can be used to support flexible development methodology as well as subsequent integrity checks. 

            In particular, if the policy "portInterfaceDefinition" is chosen the network representation needs to be compatible to the default datatype specified in the interface. If the policy "networkRepresentationFromComSpec" is chosen the network representation needs to be compatible to the network representation of the ComSpec that is aggregated by the PortPrototype. 

            If the "override" policy is chosen the requirements specified in the PortInterface and in the ComSpec are not fulfilled by the networkRepresentationProps. In case the System Description doesn't use a complete Software Component Description (VFB View) the "legacy" policy can be chosen.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignal.dataTypePolicy";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-PROPS" type="AR:I-SIGNAL-PROPS">
            <xsd:annotation>
               <xsd:documentation>Additional optional ISignal properties that may be stored in different files.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="iSignalProps.ISignal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>Optional definition of a ISignal's initValue in case the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy system signals. 

            This value can be used to configure the Signal's "InitValue". 

            If a full DataMapping exist for the SystemSignal this information may be available from a configured SenderComSpec and ReceiverComSpec. 
            In this case the initvalues in SenderComSpec and/or ReceiverComSpec override this optional value specification. Further restrictions apply from the RTE specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignal.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Size of the signal in bits. The size needs to be derived from the mapped VariableDataPrototype according to the mapping of primitive DataTypes to BaseTypes as used in the RTE.
            Indicates maximum size for dynamic length signals. 

            The ISignal length of zero bits is allowed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignal.length";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NETWORK-REPRESENTATION-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>Specification of the actual network representation. The usage of SwDataDefProps for this purpose is restricted to the attributes compuMethod and baseType. The optional baseType attributes "memAllignment" and "byteOrder" shall not be used. 

            The attribute "dataTypePolicy" in the SystemTemplate element defines whether this network representation is compatible to the default datatype specified in the PortInterface or to the network representation of the comspec. 

            If "override" is chosen by the system integrator the network representation can violate against the requirments defined in the PortInterface and in the network representation of the comspec. 

            In case that the System Description doesn't use a complete Software Component Description (VFB View) this element is used to configure "ComSignalDataInvalidValue" and the Data Semantics. 

            If a full DataMapping exist for the SystemSignal this information is additionally available from the mapped VariableDataElement. In this case the referenced datatypes needs to be compatible. Note that this redundancy is intended and can be used to support flexible development methodology as well as subsequent integrity checks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="networkRepresentationProps.ISignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the System Signal that is supposed to be transmitted in the ISignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignal.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignal -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>Signal of the Interaction Layer. The RTE supports a "signal fan-out" where the same System Signal is sent in different SignalIPdus to multiple receivers. 

      The System Signal is unique per System. To support the RTE "signal fan-out" each SignalIPdu  contains ISignals. If the same System Signal is to be mapped into several SignalIPdus there is one ISignal needed for each ISignalToIPduMapping. 

      ISignals describe the Interface between the Precompile configured RTE and the potentially Postbuild configured Com Stack (see ECUC Parameter Mapping). 

      In case of the SystemSignalGroup an ISignal must be created for each SystemSignal contained in the SystemSignalGroup.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ISignals";mmt.qualifiedName="ISignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:I-SIGNAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalGroup -->
   <xsd:group name="I-SIGNAL-GROUP">
      <xsd:annotation>
         <xsd:documentation>SignalGroup of the Interaction Layer. The RTE supports a "signal fan-out" where the same System Signal Group is sent in different SignalIPdus to multiple receivers.   

      An ISignalGroup refers to a set of ISignals that must always be kept together. A ISignalGroup represents a COM Signal Group.  

      Therefore it is recommended to put the ISignalGroup in the same Package as ISignals (see atp.recommendedPackage)</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ISignalGroup";mmt.qualifiedName="ISignalGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to a set of ISignals that must always be kept together.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalGroup.iSignal";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-SIGNAL--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the SystemSignalGroup that is defined on VFB level and that is supposed to be transmitted in the ISignalGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalGroup.systemSignalGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalGroup -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-GROUP">
      <xsd:annotation>
         <xsd:documentation>SignalGroup of the Interaction Layer. The RTE supports a "signal fan-out" where the same System Signal Group is sent in different SignalIPdus to multiple receivers.   

      An ISignalGroup refers to a set of ISignals that must always be kept together. A ISignalGroup represents a COM Signal Group.  

      Therefore it is recommended to put the ISignalGroup in the same Package as ISignals (see atp.recommendedPackage)</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ISignalGroup";mmt.qualifiedName="ISignalGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:I-SIGNAL-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalIPdu -->
   <xsd:group name="I-SIGNAL-I-PDU">
      <xsd:annotation>
         <xsd:documentation>Represents the IPdus handled by Com. The ISignalIPdu assembled and disassembled in AUTOSAR COM consists of one or more signals.
      In case no multiplexing is performed this IPdu is routed to/from the Interface Layer.

      A maximum of one dynamic length signal per IPdu is allowed.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="ISignalIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-TIMING-SPECIFICATIONS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="iPduTimingSpecification.ISignalIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-TIMING" type="AR:I-PDU-TIMING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-TO-PDU-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="iSignalToPduMapping.ISignalIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-TO-I-PDU-MAPPING" type="AR:I-SIGNAL-TO-I-PDU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-COUNTERS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="pduCounter.ISignalIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SIGNAL-I-PDU-COUNTER" type="AR:SIGNAL-I-PDU-COUNTER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-REPLICATIONS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="pduReplication.ISignalIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SIGNAL-I-PDU-REPLICATION" type="AR:SIGNAL-I-PDU-REPLICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNUSED-BIT-PATTERN" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>AUTOSAR COM and AUTOSAR IPDUM are filling not used areas of an IPDU with this bit-pattern. This attribute is mandatory to avoid undefined behavior. This byte-pattern will be repeated throughout the IPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalIPdu.unusedBitPattern";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-I-PDU">
      <xsd:annotation>
         <xsd:documentation>Represents the IPdus handled by Com. The ISignalIPdu assembled and disassembled in AUTOSAR COM consists of one or more signals.
      In case no multiplexing is performed this IPdu is routed to/from the Interface Layer.

      A maximum of one dynamic length signal per IPdu is allowed.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="ISignalIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDU"/>
         <xsd:group ref="AR:I-PDU"/>
         <xsd:group ref="AR:I-SIGNAL-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL-I-PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-I-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalIPduGroup -->
   <xsd:group name="I-SIGNAL-I-PDU-GROUP">
      <xsd:annotation>
         <xsd:documentation>The AUTOSAR COM Layer is able to start and to stop sending and receiving  configurable groups of I-Pdus during runtime. An ISignalIPduGroup contains either ISignalIPdus or ISignalIPduGroups.

      When an ISignalIPduGroup containing one or more other ISignalIPduGroups is started the containedISignalIPduGroups shall also be started. When an ISignalIPduGroup containing one or more other ISignalIPduGroups is stopped the contained ISignalIPduGroups shall also be stopped.

      Only a two level hierarchy of ISignalIPdu groups is allowed. An ISignalIPdu group that is part of an ISignalIPdu group must not contain ISignalIPduGroups.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ISignaliPduGroup";mmt.qualifiedName="ISignalIPduGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-DIRECTION" type="AR:COMMUNICATION-DIRECTION-TYPE">
            <xsd:annotation>
               <xsd:documentation>This attribute determines in which direction IPdus that are contained in this IPduGroup will be transmitted (communication direction can be either In or Out).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalIPduGroup.communicationDirection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-MODE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the use-case for this ISignalIPduGroup (e.g. diagnostic, debugging etc.). For example, in a diagnostic mode all IPdus - which are not involved in diagnostic - are disabled. The use cases are not limited to a fixed enumeration and can be specified as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalIPduGroup.communicationMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTAINED-I-SIGNAL-I-PDU-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>An I-Pdu group can be included in other I-Pdu groups. Contained I-Pdu groups shall not be referenced by the EcuInstance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalIPduGroup.containedISignalIPduGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONTAINED-I-SIGNAL-I-PDU-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-SIGNAL-I-PDU-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-I-PDUS">
            <xsd:annotation>
               <xsd:documentation>This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="ISignalIPduGroup.iSignalIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-I-PDU-REF-CONDITIONAL" type="AR:I-SIGNAL-I-PDU-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalIPduGroup -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-I-PDU-GROUP">
      <xsd:annotation>
         <xsd:documentation>The AUTOSAR COM Layer is able to start and to stop sending and receiving  configurable groups of I-Pdus during runtime. An ISignalIPduGroup contains either ISignalIPdus or ISignalIPduGroups.

      When an ISignalIPduGroup containing one or more other ISignalIPduGroups is started the containedISignalIPduGroups shall also be started. When an ISignalIPduGroup containing one or more other ISignalIPduGroups is stopped the contained ISignalIPduGroups shall also be stopped.

      Only a two level hierarchy of ISignalIPdu groups is allowed. An ISignalIPdu group that is part of an ISignalIPdu group must not contain ISignalIPduGroups.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ISignaliPduGroup";mmt.qualifiedName="ISignalIPduGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:I-SIGNAL-I-PDU-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL-I-PDU-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-I-PDU-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalIPduRefConditional -->
   <xsd:group name="I-SIGNAL-I-PDU-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-I-PDU-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalIPduRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-I-PDU-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:I-SIGNAL-I-PDU-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Fibex4Multiplatform::ISignalMapping -->
   <xsd:group name="I-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Arranges those signals (or SignalGroups) that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.
      Each pair consists in a source and a target referencing to a ISignalTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents introductory documentation about the ISignal mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalMapping.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Source destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalMapping.sourceSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalMapping.targetSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::ISignalMapping -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Arranges those signals (or SignalGroups) that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.
      Each pair consists in a source and a target referencing to a ISignalTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:I-SIGNAL-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::ISignalPort -->
   <xsd:group name="I-SIGNAL-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by an ISignalTriggering. 
      If different timeouts or DataFilters for ISignals need to be specified several ISignalPorts may be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-FILTER" type="AR:DATA-FILTER">
            <xsd:annotation>
               <xsd:documentation>Optional specification of  a signal COM filter at the receiver side in case that  the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy system signals. If a full DataMapping exist for the SystemSignal this information may be available from a configured ReceiverComSpec. In this case the ReceiverComSpec overrides this optional specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataFilter.ISignalPort";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Optional timeout value in seconds for the reception of the ISignal.
            In case the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy system signals.

            If a full DataMapping exist for the SystemSignal this information may be available from a configured ReceiverComSpec, in this case the timeout value in ReceiverComSpec override this optional timeout specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalPort.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalPort -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by an ISignalTriggering. 
      If different timeouts or DataFilters for ISignals need to be specified several ISignalPorts may be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMM-CONNECTOR-PORT"/>
         <xsd:group ref="AR:I-SIGNAL-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalProps -->
   <xsd:group name="I-SIGNAL-PROPS">
      <xsd:annotation>
         <xsd:documentation>Additional ISignal properties that may be stored in different files.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-OUT-OF-RANGE" type="AR:HANDLE-OUT-OF-RANGE-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the outOfRangeHandling for received and sent signals.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalProps.handleOutOfRange";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalProps -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-PROPS">
      <xsd:annotation>
         <xsd:documentation>Additional ISignal properties that may be stored in different files.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:I-SIGNAL-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::ISignalToIPduMapping -->
   <xsd:group name="I-SIGNAL-TO-I-PDU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>An ISignalToIPduMapping describes the mapping of ISignals to ISignalIPdus and defines the position of the ISignal within an ISignalIPdu.

      This element does NOT describe signal or IPdu fan-out but is used to describe the COM Signal Gateway fan-out.  
      In case the ISignal/ISignalGroup is not part of the Signal Gateway the ISignal/ISignalGroup can only be mapped into one ISignalIPdu.
      In case the ISignal/ISignalGroup is part of the Signal Gateway several ISignalToIPduMappings of the same ISignal are supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an ISignalGroup that is mapped into the SignalIPdu. 
            If an ISignalToIPduMapping for an ISignalGroup is defined, only the UpdateIndicationBitPosition and the transferProperty is relevant. The startPosition and the packingByteOrder shall be ignored. 

            Each ISignal contained in the ISignalGroup shall be mapped into an IPdu by an own ISignalToIPduMapping. The references to the ISignal and to the ISignalGroup in an ISignalToIPduMapping are mutually exclusive.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.iSignalGroup";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a ISignal that is mapped into the ISignalIPdu. 

            Several ISignalToPduMappings to the same ISignal are only relevant when the ECU handles the signal gateway. Each ISignal contained in the ISignalGroup shall be mapped into an IPdu by an own ISignalToIPduMapping. The references to the ISignal and to the ISignalGroup in an ISignalToIPduMapping are mutually exclusive.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.iSignal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PACKING-BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the order of the bytes of the signal and the packing into the SignalIPdu. The byte ordering "Little Endian" (MostSignificantByteLast), "Big Endian" (MostSignificantByteFirst) and "Opaque" can be selected. For opaque data endianness conversion shall be configured to Opaque.
            The value of this attribute impacts the absolute position of the signal into the SignalIPdu (see the startPosition attribute description). 

            For an ISignalGroup the packingByteOrder is irrelevant and shall be ignored.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.packingByteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="START-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter is necessary to describe the bitposition of a signal within an SignalIPdu.
            It denotes the least significant bit for "Little Endian" and the most significant bit for "Big Endian" packed signals within the IPdu (see the description of the packingByteOrder attribute). In AUTOSAR the bit counting is always set to "sawtooth" and the bit order is set to "Decreasing".

            Please note that the way the bytes will be actually sent on the bus does not impact this representation: they will always be seen by the software as a byte array.

            If a mapping for the ISignalGroup is defined, this attribute is irrelevant and shall be ignored.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.startPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSFER-PROPERTY" type="AR:TRANSFER-PROPERTY-ENUM">
            <xsd:annotation>
               <xsd:documentation>The triggered or triggeredOnChange,  triggeredWithoutRepetition and triggeredOnChangeWithoutRepetition transferProperty causes immediate transmission of the IPdu, except if transmission mode Periodic or transmission mode NONE is defined for the IPdu. The Pending transfer property does not cause transmission of an I-PDU.

            The immediate transmission of the IPdu is caused even if only one Signal of an IPdu has the transferProperty triggered or triggeredWithoutRepetition or triggeredOnChange or triggeredOnChangeWithoutRepetition and all other Signals have the transferProperty pending.

            Also for ISignals of an ISignalGroup (GroupSignals) this attribute is relevant and shall be evaluated:
            - If none of the ISignals belonging to the ISignalGroup have a transferProperty defined the transferProperty of the ISignalToPduMapping referring to the ISignalGroup is considered.
            - If at least one of the ISignals belonging to the ISignalGroup has a transferProperty defined all other ISignals belonging to the same ISignalGroup shall have a transferProperty defined as well. All of the transferProperties of the GroupSignals are considered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.transferProperty";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPDATE-INDICATION-BIT-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The UpdateIndicationBit indicates to the receivers that the signal (or the signal group) was updated by the sender. Length is always one bit. The UpdateIndicationBitPosition attribute describes the position of the update bit within the SignalIPdu. For Signals of a ISignalGroup this attribute is irrelevant and shall be ignored. 

            Note that the exact bit position of the updateIndicationBitPosition is linked to the value of the attribute packingByteOrder because the method of finding the bit position is different for the values mostSignificantByteFirst and mostSignificantByteLast. This means that if the value of packingByteOrder is changed while the value of updateIndicationBitPosition remains unchanged the exact bit position of updateIndicationBitPosition within the enclosing ISignalIPdu still undergoes a change.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.updateIndicationBitPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalToIPduMapping -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-TO-I-PDU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>An ISignalToIPduMapping describes the mapping of ISignals to ISignalIPdus and defines the position of the ISignal within an ISignalIPdu.

      This element does NOT describe signal or IPdu fan-out but is used to describe the COM Signal Gateway fan-out.  
      In case the ISignal/ISignalGroup is not part of the Signal Gateway the ISignal/ISignalGroup can only be mapped into one ISignalIPdu.
      In case the ISignal/ISignalGroup is part of the Signal Gateway several ISignalToIPduMappings of the same ISignal are supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-SIGNAL-TO-I-PDU-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL-TO-I-PDU-MAPPING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-TO-I-PDU-MAPPING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalTriggering -->
   <xsd:group name="I-SIGNAL-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>A ISignalTriggering allows an assignment of ISignals to physical channels.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>This reference shall be used if an ISignalGroup is transported on the PhysicalChannel. This reference forms an XOR relationship with the ISignalTriggering-ISignal reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering.iSignalGroup";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>References to the ISignalPort on every ECU of the system which sends and/or receives the ISignal.

            References for both the sender and the receiver side shall be included when the system is completely defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering.iSignalPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-SIGNAL-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>This reference shall be used if an ISignal is transported on the PhysicalChannel. This reference forms an XOR relationship with the ISignalTriggering-ISignalGroup reference. ISignalTriggerings for Group Signals (ISignals contained in the ISignalGroup) shall not be defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering.iSignal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>A ISignalTriggering allows an assignment of ISignals to physical channels.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-SIGNAL-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL-TRIGGERING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-TRIGGERING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalTriggeringRefConditional -->
   <xsd:group name="I-SIGNAL-TRIGGERING-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalTriggeringRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-TRIGGERING-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:I-SIGNAL-TRIGGERING-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Identifiable::Identifiable -->
   <xsd:group name="IDENTIFIABLE">
      <xsd:annotation>
         <xsd:documentation>Instances of this class can be referred to by their identifier (within the namespace borders). In addition to this, Identifiables are objects  which contribute significantly to the overall structure of an AUTOSAR description. In particular, Identifiables might contain Identifiables.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This represents a general but brief (one paragraph) description what the object in question is about. It is only one paragraph! Desc is intended to be collected into overview tables. This property helps a human reader to identify the object in question.

            More elaborate documentation, (in particlar how the object is built or used) should go to "introduction".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:CATEGORY-STRING">
            <xsd:annotation>
               <xsd:documentation>This element assigns a category to the parent element. The category is intended to specialize the usage and/or the content identifiable object. Such a specialization may also impose particular semantic constraints on the entire substructure (not only the identifiable itself).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.category";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADMIN-DATA" type="AR:ADMIN-DATA">
            <xsd:annotation>
               <xsd:documentation>This represents the administrative data for the identifiable object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.adminData";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents more information about how the object in question is built or is used. Therefore it is a DocumentationBlock.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Possibility to provide additional notes while defining a model element (e.g. the ECU Configuration Parameter Values). These are not intended as documentation but are mere design notes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.annotation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="-25"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ANNOTATION" type="AR:ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Identifiable::Identifiable -->
   <xsd:attributeGroup name="IDENTIFIABLE">
      <xsd:annotation>
         <xsd:documentation>Instances of this class can be referred to by their identifier (within the namespace borders). In addition to this, Identifiables are objects  which contribute significantly to the overall structure of an AUTOSAR description. In particular, Identifiables might contain Identifiables.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="UUID" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The purpose of this attribute is to provide a globally unique identifier for an instance of a meta-class. The values of this attribute should be globally unique strings prefixed by the type of identifier.  For example, to include a
         DCE UUID as defined by The Open Group, the UUID would be preceded by "DCE:". The values of this attribute may be used to support merging of different AUTOSAR models. 
         The form of the UUID (Universally Unique Identifier) is taken from a standard defined by the Open Group (was Open Software Foundation). This standard is widely used, including by Microsoft for COM (GUIDs) and by many companies for DCE, which is based on CORBA. The method for generating these 128-bit IDs is published in the standard and the effectiveness and uniqueness of the IDs is not in practice disputed.
         If the id namespace is omitted, DCE is assumed. 
         An example is "DCE:2fac1234-31f8-11b4-a222-08002b34c003".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.uuid";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <xsd:simpleType name="IDENTIFIABLE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AR-ELEMENT"/>
         <xsd:enumeration value="AR-PACKAGE"/>
         <xsd:enumeration value="ABSTRACT-CAN-CLUSTER"/>
         <xsd:enumeration value="ABSTRACT-CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="ABSTRACT-CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="ABSTRACT-CAN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="AGE-CONSTRAINT"/>
         <xsd:enumeration value="ALIAS-NAME-SET"/>
         <xsd:enumeration value="ANALYZED-EXECUTION-TIME"/>
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-ARRAY-ELEMENT"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-ERROR"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-ELEMENT"/>
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ARBITRARY-EVENT-TRIGGERING"/>
         <xsd:enumeration value="ARGUMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="ASSEMBLY-SW-CONNECTOR"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-POINT"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RESULT-POINT"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATP-BLUEPRINT"/>
         <xsd:enumeration value="ATP-BLUEPRINTABLE"/>
         <xsd:enumeration value="ATP-CLASSIFIER"/>
         <xsd:enumeration value="ATP-FEATURE"/>
         <xsd:enumeration value="ATP-PROTOTYPE"/>
         <xsd:enumeration value="ATP-STRUCTURE-ELEMENT"/>
         <xsd:enumeration value="ATP-TYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-TYPE"/>
         <xsd:enumeration value="AUTOSAR-OPERATION-ARGUMENT-INSTANCE"/>
         <xsd:enumeration value="AUTOSAR-VARIABLE-INSTANCE"/>
         <xsd:enumeration value="BACKGROUND-EVENT"/>
         <xsd:enumeration value="BASE-TYPE"/>
         <xsd:enumeration value="BLUEPRINT-MAPPING-SET"/>
         <xsd:enumeration value="BSW-BACKGROUND-EVENT"/>
         <xsd:enumeration value="BSW-CALLED-ENTITY"/>
         <xsd:enumeration value="BSW-DEBUG-INFO"/>
         <xsd:enumeration value="BSW-EVENT"/>
         <xsd:enumeration value="BSW-EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="BSW-IMPLEMENTATION"/>
         <xsd:enumeration value="BSW-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="BSW-INTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="BSW-INTERNAL-TRIGGERING-POINT"/>
         <xsd:enumeration value="BSW-INTERRUPT-ENTITY"/>
         <xsd:enumeration value="BSW-MGR-NEEDS"/>
         <xsd:enumeration value="BSW-MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="BSW-MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="BSW-MODULE-DEPENDENCY"/>
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
         <xsd:enumeration value="BSW-MODULE-ENTITY"/>
         <xsd:enumeration value="BSW-MODULE-ENTRY"/>
         <xsd:enumeration value="BSW-MODULE-TIMING"/>
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
         <xsd:enumeration value="BSW-TIMING-EVENT"/>
         <xsd:enumeration value="BURST-PATTERN-EVENT-TRIGGERING"/>
         <xsd:enumeration value="CALIBRATION-PARAMETER-VALUE-SET"/>
         <xsd:enumeration value="CAN-CLUSTER"/>
         <xsd:enumeration value="CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="CAN-FRAME"/>
         <xsd:enumeration value="CAN-FRAME-TRIGGERING"/>
         <xsd:enumeration value="CAN-NM-CLUSTER"/>
         <xsd:enumeration value="CAN-NM-NODE"/>
         <xsd:enumeration value="CAN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="CAN-TP-ADDRESS"/>
         <xsd:enumeration value="CAN-TP-CHANNEL"/>
         <xsd:enumeration value="CAN-TP-CONFIG"/>
         <xsd:enumeration value="CAN-TP-NODE"/>
         <xsd:enumeration value="CHAPTER"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE-MAPPING"/>
         <xsd:enumeration value="CLIENT-SERVER-OPERATION"/>
         <xsd:enumeration value="CODE"/>
         <xsd:enumeration value="COLLECTABLE-ELEMENT"/>
         <xsd:enumeration value="COLLECTION"/>
         <xsd:enumeration value="COM-MGR-USER-NEEDS"/>
         <xsd:enumeration value="COMM-CONNECTOR-PORT"/>
         <xsd:enumeration value="COMMUNICATION-CLUSTER"/>
         <xsd:enumeration value="COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="COMPILER"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPU-METHOD"/>
         <xsd:enumeration value="CONCRETE-PATTERN-EVENT-TRIGGERING"/>
         <xsd:enumeration value="CONSTANT-SPECIFICATION"/>
         <xsd:enumeration value="CONSTANT-SPECIFICATION-MAPPING-SET"/>
         <xsd:enumeration value="CRYPTO-SERVICE-NEEDS"/>
         <xsd:enumeration value="DATA-CONSTR"/>
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="DATA-PROTOTYPE"/>
         <xsd:enumeration value="DATA-RECEIVE-ERROR-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVED-EVENT"/>
         <xsd:enumeration value="DATA-SEND-COMPLETED-EVENT"/>
         <xsd:enumeration value="DATA-TYPE-MAPPING-SET"/>
         <xsd:enumeration value="DATA-WRITE-COMPLETED-EVENT"/>
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="DELEGATION-SW-CONNECTOR"/>
         <xsd:enumeration value="DEPENDENCY-ON-ARTIFACT"/>
         <xsd:enumeration value="DIAG-EVENT-DEBOUNCE-ALGORITHM"/>
         <xsd:enumeration value="DIAG-EVENT-DEBOUNCE-COUNTER-BASED"/>
         <xsd:enumeration value="DIAG-EVENT-DEBOUNCE-MONITOR-INTERNAL"/>
         <xsd:enumeration value="DIAG-EVENT-DEBOUNCE-TIME-BASED"/>
         <xsd:enumeration value="DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:enumeration value="DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-EVENT-MANAGER-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-EVENT-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-IO-CONTROL-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-ROUTINE-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-VALUE-NEEDS"/>
         <xsd:enumeration value="DLT-USER-NEEDS"/>
         <xsd:enumeration value="DOCUMENTATION"/>
         <xsd:enumeration value="ECU-MAPPING"/>
         <xsd:enumeration value="EOC-EXECUTABLE-ENTITY-REF"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECU-INSTANCE"/>
         <xsd:enumeration value="ECU-PARTITION"/>
         <xsd:enumeration value="ECU-STATE-MGR-USER-NEEDS"/>
         <xsd:enumeration value="ECU-TIMING"/>
         <xsd:enumeration value="ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-ADD-INFO-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-CHOICE-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-CHOICE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-COMMON-ATTRIBUTES"/>
         <xsd:enumeration value="ECUC-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-CONTAINER-VALUE"/>
         <xsd:enumeration value="ECUC-DEFINITION-COLLECTION"/>
         <xsd:enumeration value="ECUC-DEFINITION-ELEMENT"/>
         <xsd:enumeration value="ECUC-ENUMERATION-LITERAL-DEF"/>
         <xsd:enumeration value="ECUC-ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FOREIGN-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-FUNCTION-NAME-DEF"/>
         <xsd:enumeration value="ECUC-INSTANCE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-LINKER-SYMBOL-DEF"/>
         <xsd:enumeration value="ECUC-MODULE-CONFIGURATION-VALUES"/>
         <xsd:enumeration value="ECUC-MODULE-DEF"/>
         <xsd:enumeration value="ECUC-MULTILINE-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-PARAM-CONF-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-PARAMETER-DEF"/>
         <xsd:enumeration value="ECUC-QUERY"/>
         <xsd:enumeration value="ECUC-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-SYMBOLIC-NAME-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-VALUE-COLLECTION"/>
         <xsd:enumeration value="END-TO-END-PROTECTION"/>
         <xsd:enumeration value="END-TO-END-PROTECTION-SET"/>
         <xsd:enumeration value="ETHERNET-CLUSTER"/>
         <xsd:enumeration value="ETHERNET-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="ETHERNET-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="ETHERNET-FRAME"/>
         <xsd:enumeration value="ETHERNET-FRAME-TRIGGERING"/>
         <xsd:enumeration value="ETHERNET-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="EVALUATED-VARIANT-SET"/>
         <xsd:enumeration value="EVENT-TRIGGERING-CONSTRAINT"/>
         <xsd:enumeration value="EXCLUSIVE-AREA"/>
         <xsd:enumeration value="EXECUTABLE-ENTITY"/>
         <xsd:enumeration value="EXECUTION-ORDER-CONSTRAINT"/>
         <xsd:enumeration value="EXECUTION-TIME"/>
         <xsd:enumeration value="EXECUTION-TIME-CONSTRAINT"/>
         <xsd:enumeration value="EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="FIBEX-ELEMENT"/>
         <xsd:enumeration value="FLAT-INSTANCE-DESCRIPTOR"/>
         <xsd:enumeration value="FLAT-MAP"/>
         <xsd:enumeration value="FLEXRAY-AR-TP-CONFIG"/>
         <xsd:enumeration value="FLEXRAY-AR-TP-NODE"/>
         <xsd:enumeration value="FLEXRAY-CLUSTER"/>
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="FLEXRAY-FRAME"/>
         <xsd:enumeration value="FLEXRAY-FRAME-TRIGGERING"/>
         <xsd:enumeration value="FLEXRAY-NM-CLUSTER"/>
         <xsd:enumeration value="FLEXRAY-NM-NODE"/>
         <xsd:enumeration value="FLEXRAY-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="FLEXRAY-TP-CONFIG"/>
         <xsd:enumeration value="FLEXRAY-TP-CONNECTION-CONTROL"/>
         <xsd:enumeration value="FLEXRAY-TP-NODE"/>
         <xsd:enumeration value="FLEXRAY-TP-PDU-POOL"/>
         <xsd:enumeration value="FRAME"/>
         <xsd:enumeration value="FRAME-PORT"/>
         <xsd:enumeration value="FRAME-TRIGGERING"/>
         <xsd:enumeration value="FUNCTION-INHIBITION-NEEDS"/>
         <xsd:enumeration value="GATEWAY"/>
         <xsd:enumeration value="GENERAL-PARAMETER"/>
         <xsd:enumeration value="HEAP-USAGE"/>
         <xsd:enumeration value="HW-ATTRIBUTE-DEF"/>
         <xsd:enumeration value="HW-ATTRIBUTE-LITERAL-DEF"/>
         <xsd:enumeration value="HW-CATEGORY"/>
         <xsd:enumeration value="HW-ELEMENT"/>
         <xsd:enumeration value="HW-PIN"/>
         <xsd:enumeration value="HW-PIN-GROUP"/>
         <xsd:enumeration value="HW-TYPE"/>
         <xsd:enumeration value="I-PDU"/>
         <xsd:enumeration value="I-PDU-PORT"/>
         <xsd:enumeration value="I-SIGNAL"/>
         <xsd:enumeration value="I-SIGNAL-GROUP"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU-GROUP"/>
         <xsd:enumeration value="I-SIGNAL-PORT"/>
         <xsd:enumeration value="I-SIGNAL-TO-I-PDU-MAPPING"/>
         <xsd:enumeration value="I-SIGNAL-TRIGGERING"/>
         <xsd:enumeration value="IDENTIFIABLE"/>
         <xsd:enumeration value="IMPLEMENTATION"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE-ELEMENT"/>
         <xsd:enumeration value="INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="INTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="INTERNAL-TRIGGERING-POINT"/>
         <xsd:enumeration value="INTERPOLATION-ROUTINE-MAPPING-SET"/>
         <xsd:enumeration value="J-1939-TP-CONFIG"/>
         <xsd:enumeration value="J-1939-TP-NODE"/>
         <xsd:enumeration value="KEYWORD"/>
         <xsd:enumeration value="KEYWORD-SET"/>
         <xsd:enumeration value="LATENCY-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="LIN-CLUSTER"/>
         <xsd:enumeration value="LIN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="LIN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="LIN-EVENT-TRIGGERED-FRAME"/>
         <xsd:enumeration value="LIN-FRAME"/>
         <xsd:enumeration value="LIN-FRAME-TRIGGERING"/>
         <xsd:enumeration value="LIN-MASTER"/>
         <xsd:enumeration value="LIN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="LIN-SCHEDULE-TABLE"/>
         <xsd:enumeration value="LIN-SLAVE"/>
         <xsd:enumeration value="LIN-SPORADIC-FRAME"/>
         <xsd:enumeration value="LIN-TP-CONFIG"/>
         <xsd:enumeration value="LIN-TP-NODE"/>
         <xsd:enumeration value="LIN-UNCONDITIONAL-FRAME"/>
         <xsd:enumeration value="LINKER"/>
         <xsd:enumeration value="LOGIC-ADDRESS"/>
         <xsd:enumeration value="MC-DATA-INSTANCE"/>
         <xsd:enumeration value="MEASURED-EXECUTION-TIME"/>
         <xsd:enumeration value="MEASURED-HEAP-USAGE"/>
         <xsd:enumeration value="MEASURED-STACK-USAGE"/>
         <xsd:enumeration value="MEMORY-SECTION"/>
         <xsd:enumeration value="MODE-DECLARATION"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP-PROTOTYPE"/>
         <xsd:enumeration value="MODE-INTERFACE-MAPPING"/>
         <xsd:enumeration value="MODE-SWITCH-INTERFACE"/>
         <xsd:enumeration value="MODE-SWITCH-POINT"/>
         <xsd:enumeration value="MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="NM-CLUSTER"/>
         <xsd:enumeration value="NM-CONFIG"/>
         <xsd:enumeration value="NM-ECU"/>
         <xsd:enumeration value="NM-NODE"/>
         <xsd:enumeration value="NM-PDU"/>
         <xsd:enumeration value="NV-BLOCK-DESCRIPTOR"/>
         <xsd:enumeration value="NV-BLOCK-NEEDS"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="OBD-CONTROL-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-INFO-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-MONITOR-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-PID-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-RATIO-SERVICE-NEEDS"/>
         <xsd:enumeration value="OFFSET-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="OPERATION-INVOKED-EVENT"/>
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
         <xsd:enumeration value="PACKAGEABLE-ELEMENT"/>
         <xsd:enumeration value="PARAMETER-ACCESS"/>
         <xsd:enumeration value="PARAMETER-DATA-PROTOTYPE"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="PDU"/>
         <xsd:enumeration value="PDU-TO-FRAME-MAPPING"/>
         <xsd:enumeration value="PDU-TRIGGERING"/>
         <xsd:enumeration value="PDUR-I-PDU-GROUP"/>
         <xsd:enumeration value="PER-INSTANCE-MEMORY"/>
         <xsd:enumeration value="PERIODIC-EVENT-TRIGGERING"/>
         <xsd:enumeration value="PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="PHYSICAL-DIMENSION"/>
         <xsd:enumeration value="PORT-GROUP"/>
         <xsd:enumeration value="PORT-INTERFACE"/>
         <xsd:enumeration value="PORT-INTERFACE-MAPPING"/>
         <xsd:enumeration value="PORT-INTERFACE-MAPPING-SET"/>
         <xsd:enumeration value="PORT-PROTOTYPE"/>
         <xsd:enumeration value="PORT-PROTOTYPE-BLUEPRINT"/>
         <xsd:enumeration value="POST-BUILD-VARIANT-CRITERION"/>
         <xsd:enumeration value="POST-BUILD-VARIANT-CRITERION-VALUE-SET"/>
         <xsd:enumeration value="PREDEFINED-VARIANT"/>
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
         <xsd:enumeration value="RTE-EVENT"/>
         <xsd:enumeration value="RESOURCE-CONSUMPTION"/>
         <xsd:enumeration value="ROOT-SW-COMPOSITION-PROTOTYPE"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-HEAP-USAGE"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-STACK-USAGE"/>
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVER-CALL-POINT"/>
         <xsd:enumeration value="SERVICE-NEEDS"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SIMULATED-EXECUTION-TIME"/>
         <xsd:enumeration value="SOCKET-ADDRESS"/>
         <xsd:enumeration value="SPORADIC-EVENT-TRIGGERING"/>
         <xsd:enumeration value="STACK-USAGE"/>
         <xsd:enumeration value="SUPERVISED-ENTITY-NEEDS"/>
         <xsd:enumeration value="SW-ADDR-METHOD"/>
         <xsd:enumeration value="SW-AXIS-TYPE"/>
         <xsd:enumeration value="SW-BASE-TYPE"/>
         <xsd:enumeration value="SW-COMPONENT-PROTOTYPE"/>
         <xsd:enumeration value="SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-CONNECTOR"/>
         <xsd:enumeration value="SW-GENERIC-AXIS-PARAM-TYPE"/>
         <xsd:enumeration value="SW-RECORD-LAYOUT"/>
         <xsd:enumeration value="SW-SERVICE-ARG"/>
         <xsd:enumeration value="SW-SYSTEMCONST"/>
         <xsd:enumeration value="SW-SYSTEMCONSTANT-VALUE-SET"/>
         <xsd:enumeration value="SWC-BSW-MAPPING"/>
         <xsd:enumeration value="SWC-IMPLEMENTATION"/>
         <xsd:enumeration value="SWC-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="SWC-MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="SWC-SERVICE-DEPENDENCY"/>
         <xsd:enumeration value="SWC-TIMING"/>
         <xsd:enumeration value="SWC-TO-ECU-MAPPING"/>
         <xsd:enumeration value="SWC-TO-IMPL-MAPPING"/>
         <xsd:enumeration value="SYNC-TIME-BASE-MGR-USER-NEEDS"/>
         <xsd:enumeration value="SYNCHRONIZATION-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="SYNCHRONOUS-SERVER-CALL-POINT"/>
         <xsd:enumeration value="SYSTEM"/>
         <xsd:enumeration value="SYSTEM-MAPPING"/>
         <xsd:enumeration value="SYSTEM-SIGNAL"/>
         <xsd:enumeration value="SYSTEM-SIGNAL-GROUP"/>
         <xsd:enumeration value="SYSTEM-TIMING"/>
         <xsd:enumeration value="TD-EVENT-BSW"/>
         <xsd:enumeration value="TD-EVENT-BSW-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="TD-EVENT-BSW-MODE-DECLARATION"/>
         <xsd:enumeration value="TD-EVENT-BSW-MODULE"/>
         <xsd:enumeration value="TD-EVENT-COM"/>
         <xsd:enumeration value="TD-EVENT-COMPLEX"/>
         <xsd:enumeration value="TD-EVENT-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-FR-CLUSTER-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-FRAME"/>
         <xsd:enumeration value="TD-EVENT-I-PDU"/>
         <xsd:enumeration value="TD-EVENT-I-SIGNAL"/>
         <xsd:enumeration value="TD-EVENT-MODE-DECLARATION"/>
         <xsd:enumeration value="TD-EVENT-OPERATION"/>
         <xsd:enumeration value="TD-EVENT-SWC-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="TD-EVENT-TT-CAN-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-VARIABLE-DATA-PROTOTYPE"/>
         <xsd:enumeration value="TD-EVENT-VFB"/>
         <xsd:enumeration value="TIMING-CONSTRAINT"/>
         <xsd:enumeration value="TIMING-DESCRIPTION"/>
         <xsd:enumeration value="TIMING-DESCRIPTION-EVENT"/>
         <xsd:enumeration value="TIMING-DESCRIPTION-EVENT-CHAIN"/>
         <xsd:enumeration value="TIMING-EVENT"/>
         <xsd:enumeration value="TIMING-EXTENSION"/>
         <xsd:enumeration value="TOPIC-1"/>
         <xsd:enumeration value="TP-ADDRESS"/>
         <xsd:enumeration value="TP-CONFIG"/>
         <xsd:enumeration value="TRIGGER"/>
         <xsd:enumeration value="TRIGGER-INTERFACE"/>
         <xsd:enumeration value="TRIGGER-INTERFACE-MAPPING"/>
         <xsd:enumeration value="TTCAN-CLUSTER"/>
         <xsd:enumeration value="TTCAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="TTCAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="TTCAN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="UDP-NM-CLUSTER"/>
         <xsd:enumeration value="UDP-NM-NODE"/>
         <xsd:enumeration value="UNIT"/>
         <xsd:enumeration value="UNIT-GROUP"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-PDU"/>
         <xsd:enumeration value="VARIABLE-ACCESS"/>
         <xsd:enumeration value="VARIABLE-AND-PARAMETER-INTERFACE-MAPPING"/>
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE"/>
         <xsd:enumeration value="VARIATION-POINT-PROXY"/>
         <xsd:enumeration value="VFB-TIMING"/>
         <xsd:enumeration value="WAIT-POINT"/>
         <xsd:enumeration value="WORST-CASE-HEAP-USAGE"/>
         <xsd:enumeration value="WORST-CASE-STACK-USAGE"/>
         <xsd:enumeration value="XCP-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="IDENTIFIER">
      <xsd:annotation>
         <xsd:documentation>An Identifier is a string with a number of constraints on its appearance, satisfying the requirements typical programming languages define for their Identifiers.

      This datatype represents a string, that can be used as a c-Identifier.

      It needs to start with a letter, may consist of letters, digits and underscore. It shall not have two consecutive underscores (to support subsequent name mangling based on "__").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Identifier";xml.xsd.customType="IDENTIFIER";xml.xsd.maxLength="128";xml.xsd.pattern="[a-zA-Z]([a-zA-Z0-9]|_[a-zA-Z0-9])*_?";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:IDENTIFIER--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:IDENTIFIER"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- attribute group for class IDENTIFIER -->
   <xsd:attributeGroup name="IDENTIFIER">
      <xsd:annotation/>
      <xsd:attribute name="NAME-PATTERN" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute represents a pattern which shall be used to define the value of the identifier if the identifier in question is part of a blueprint. 

         For more details refer to TPS_StandardizationTemplate.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Identifier.namePattern";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <xsd:simpleType name="IDENTIFIER--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:maxLength value="128"/>
         <xsd:pattern value="[a-zA-Z]([a-zA-Z0-9]|_[a-zA-Z0-9])*_?"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Implementation::Implementation -->
   <xsd:group name="IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Description of an implementation a single software component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Implementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CODE-DESCRIPTORS">
            <xsd:annotation>
               <xsd:documentation>Specifies the provided implementation code.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="codeDescriptor.Implementation";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CODE" type="AR:CODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPILERS">
            <xsd:annotation>
               <xsd:documentation>Specifies the compiler for which this implementation has been released</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="compiler.Implementation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPILER" type="AR:COMPILER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="GENERATED-ARTIFACTS">
            <xsd:annotation>
               <xsd:documentation>Relates to an artifact that will be generated during the integration of this Implementation by an associated generator tool. Note that this is an optional information since it might  not always be in the scope of a single module or component  to provide this information.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="Implementation.generatedArtifact";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DEPENDENCY-ON-ARTIFACT" type="AR:DEPENDENCY-ON-ARTIFACT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>The hardware elements (e.g. the processor) required for this implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.hwElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LINKERS">
            <xsd:annotation>
               <xsd:documentation>Specifies the linker for which this implementation has been released.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="linker.Implementation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LINKER" type="AR:LINKER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MC-SUPPORT" type="AR:MC-SUPPORT-DATA">
            <xsd:annotation>
               <xsd:documentation>The measurement &amp; calibration support data belonging to this implementation. The aggregtion is &lt;&lt;atpSplitable&gt;&gt; because in case of an already exisiting BSW Implementation model, this description will be added later in the process, namely at code generation time.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Splitkey="mcSupport";mmt.qualifiedName="Implementation.mcSupport";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROGRAMMING-LANGUAGE" type="AR:PROGRAMMINGLANGUAGE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Programming language the implementation was created in.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.programmingLanguage";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-ARTIFACTS">
            <xsd:annotation>
               <xsd:documentation>Specifies that this Implementation depends on the existance of another artifact (e.g. a library). This aggregation of DependencyOnArtifact is subject to variability with the purpose to support variability in the implementations. Different algorithms in the implementation might cause different dependencies, e.g. the number of used libraries.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="Implementation.requiredArtifact";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DEPENDENCY-ON-ARTIFACT" type="AR:DEPENDENCY-ON-ARTIFACT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-GENERATOR-TOOLS">
            <xsd:annotation>
               <xsd:documentation>Relates this Implementation to a generator tool in order to generate additional artifacts during integration.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="Implementation.requiredGeneratorTool";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DEPENDENCY-ON-ARTIFACT" type="AR:DEPENDENCY-ON-ARTIFACT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOURCE-CONSUMPTION" type="AR:RESOURCE-CONSUMPTION">
            <xsd:annotation>
               <xsd:documentation>All static and dynamic resources for each implementation are described  within the ResourceConsumption class.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="resourceConsumption.Implementation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VERSION" type="AR:REVISION-LABEL-STRING">
            <xsd:annotation>
               <xsd:documentation>Software version of this implementation. The numbering contains three levels (like major, minor, patch), its values are vendor specific.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.swVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SWC-BSW-MAPPING-REF">
            <xsd:annotation>
               <xsd:documentation>This allows a mapping between an SWC and  a BSW behavior to be attached to an implementation description (for service, ECU abstraction and complex driver components).  It is up to the methodology to define whether this reference has to be set for the Swc- or BswImplementtion or for both.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.swcBswMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SWC-BSW-MAPPING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-CODE-GENERATOR" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Optional: code generator used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.usedCodeGenerator";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Vendor ID of this Implementation according to the AUTOSAR vendor list</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.vendorId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ImplementationDataTypes::ImplementationDataType -->
   <xsd:group name="IMPLEMENTATION-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>Describes a reusable data type on the implementation level. This will typically correspond to a typedef in C-code.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ImplementationDataTypes";mmt.qualifiedName="ImplementationDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>Specifies an element of an arrray or a struct type.

            The aggregation of ImplementionDataTypeElement is subject to variability with the purpose to support the conditional existence of elements inside a ImplementationDataType representing a structure. 
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ImplementationDataType.subElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="IMPLEMENTATION-DATA-TYPE-ELEMENT" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL-PROPS" type="AR:SYMBOL-PROPS">
            <xsd:annotation>
               <xsd:documentation>This represents the SymbolProps for the ImplementationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Splitkey="shortName";mmt.qualifiedName="ImplementationDataType.symbolProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-EMITTER" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute is used to control which part of the AUTOSAR toolchain is supposed to trigger data type definitions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationDataType.typeEmitter";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ImplementationDataTypes::ImplementationDataType -->
   <xsd:complexType abstract="false" mixed="false" name="IMPLEMENTATION-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>Describes a reusable data type on the implementation level. This will typically correspond to a typedef in C-code.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ImplementationDataTypes";mmt.qualifiedName="ImplementationDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:AUTOSAR-DATA-TYPE"/>
         <xsd:group ref="AR:IMPLEMENTATION-DATA-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="IMPLEMENTATION-DATA-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ImplementationDataTypes::ImplementationDataTypeElement -->
   <xsd:group name="IMPLEMENTATION-DATA-TYPE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Declares a data object which is locally aggregated. Such an element can only be used within the scope, where it is aggregated. This element either consists of further subElements or it is further defined via its swDataDefProps.
      There are several use cases within the system of ImplementationDataTypes fur such a local declaration:
      * It can represent the elements of an array, defining the element type and array size
      * It can represent an element of a struct, defining its type
      * It can be the local declaration of a debug element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationDataTypeElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-SIZE" type="AR:POSITIVE-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>The existence of this attributes (if bigger than 0) defines the size of an array and declares that this ImplementationDataTypeElement represents the type of each single array element.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ImplementationDataTypeElement.arraySize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-SIZE-SEMANTICS" type="AR:ARRAY-SIZE-SEMANTICS-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls the meaning of the value of the array size.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationDataTypeElement.arraySizeSemantics";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>Element of an array or struct in case of a nested declaration (i.e. without using "typedefs").

            The aggregation of ImplementionDataTypeElement is subject to variability with the purpose to support the conditional existence of elements inside a ImplementationDataType representing a structure. 
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ImplementationDataTypeElement.subElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="IMPLEMENTATION-DATA-TYPE-ELEMENT" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>The properties of this data type element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationDataTypeElement.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ImplementationDataTypes::ImplementationDataTypeElement -->
   <xsd:complexType abstract="false" mixed="false" name="IMPLEMENTATION-DATA-TYPE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Declares a data object which is locally aggregated. Such an element can only be used within the scope, where it is aggregated. This element either consists of further subElements or it is further defined via its swDataDefProps.
      There are several use cases within the system of ImplementationDataTypes fur such a local declaration:
      * It can represent the elements of an array, defining the element type and array size
      * It can represent an element of a struct, defining its type
      * It can be the local declaration of a debug element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationDataTypeElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="IMPLEMENTATION-DATA-TYPE-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE-ELEMENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortInterface::ImplementationDataTypeSubElementRef -->
   <xsd:group name="IMPLEMENTATION-DATA-TYPE-SUB-ELEMENT-REF">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the specialization of SubElementMapping with respect to ImplementationDataTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationDataTypeSubElementRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-DATA-TYPE-ELEMENT" type="AR:AR-VARIABLE-IN-IMPLEMENTATION-DATA-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the referenced implementationDataTypeElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationDataTypeSubElementRef.implementationDataTypeElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ImplementationDataTypeSubElementRef -->
   <xsd:complexType abstract="false" mixed="false" name="IMPLEMENTATION-DATA-TYPE-SUB-ELEMENT-REF">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the specialization of SubElementMapping with respect to ImplementationDataTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationDataTypeSubElementRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SUB-ELEMENT-REF"/>
         <xsd:group ref="AR:IMPLEMENTATION-DATA-TYPE-SUB-ELEMENT-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MeasurementCalibrationSupport::ImplementationElementInParameterInstanceRef -->
   <xsd:group name="IMPLEMENTATION-ELEMENT-IN-PARAMETER-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>Describes a reference to a particular ImplementationDataTypeElement instance in the context of a given ParameterDataPrototype.
      Thus it refers to a particular element in the implementation description of a software data structure.

      Use Case:
      The RTE generator publishes its generated structure of calibration parameters in its BSW module description using the "constantMemory" role of ParameterDataPrototypes. Each ParameterDataPrototype describes a group of single calibration parameters. In order to point to these single parameters, this "instance ref" is needed.

      Note that this class follows the pattern of an InstanceRef but is not implemented based on the abstract classes because the ImplementationDataType isn't either, especially because ImplementationDataTypeElement isn't derived from AtpPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationElementInParameterInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-REF">
            <xsd:annotation>
               <xsd:documentation>The context for the referred element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationElementInParameterInstanceRef.context";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PARAMETER-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REF">
            <xsd:annotation>
               <xsd:documentation>The referred data element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationElementInParameterInstanceRef.target";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MeasurementCalibrationSupport::ImplementationElementInParameterInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="IMPLEMENTATION-ELEMENT-IN-PARAMETER-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>Describes a reference to a particular ImplementationDataTypeElement instance in the context of a given ParameterDataPrototype.
      Thus it refers to a particular element in the implementation description of a software data structure.

      Use Case:
      The RTE generator publishes its generated structure of calibration parameters in its BSW module description using the "constantMemory" role of ParameterDataPrototypes. Each ParameterDataPrototype describes a group of single calibration parameters. In order to point to these single parameters, this "instance ref" is needed.

      Note that this class follows the pattern of an InstanceRef but is not implemented based on the abstract classes because the ImplementationDataType isn't either, especially because ImplementationDataTypeElement isn't derived from AtpPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationElementInParameterInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:IMPLEMENTATION-ELEMENT-IN-PARAMETER-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Implementation::ImplementationProps -->
   <xsd:group name="IMPLEMENTATION-PROPS">
      <xsd:annotation>
         <xsd:documentation>Defines a symbol to be used as prefix when generating code artifacts.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL" type="AR:C-IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>The symbol to be used as prefix.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationProps.symbol";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class IncludedDataTypes::IncludedDataTypeSet -->
   <xsd:group name="INCLUDED-DATA-TYPE-SET">
      <xsd:annotation>
         <xsd:documentation>An includedDataTypeSet declares that a set of AutosarDataType is used by the software component for its implementation and the AutosarDataType becomes part of the contract. 

      This information is required if the AutosarDataType is not used for any DataPrototype owned by this software component or if the enumeration literals, lowerLimit and upperLimit constants shall be generated with a literalPrefix.

      The optional literalPrefix is used to add a common prefix on enumeration literals, lowerLimit and upperLimit constants created by the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IncludedDataTypeSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-TYPE-REFS">
            <xsd:annotation>
               <xsd:documentation>AutosarDataType belonging to the includedDataTypeSet</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IncludedDataTypeSet.dataType";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-TYPE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:AUTOSAR-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LITERAL-PREFIX" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>LiteralPrefix defines a common prefix for all AutosarDataTypes of the includedDataTypeSet to be added on enumeration literals, lowerLimit and upperLimit constants created by the RTE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IncludedDataTypeSet.literalPrefix";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class IncludedDataTypes::IncludedDataTypeSet -->
   <xsd:complexType abstract="false" mixed="false" name="INCLUDED-DATA-TYPE-SET">
      <xsd:annotation>
         <xsd:documentation>An includedDataTypeSet declares that a set of AutosarDataType is used by the software component for its implementation and the AutosarDataType becomes part of the contract. 

      This information is required if the AutosarDataType is not used for any DataPrototype owned by this software component or if the enumeration literals, lowerLimit and upperLimit constants shall be generated with a literalPrefix.

      The optional literalPrefix is used to add a common prefix on enumeration literals, lowerLimit and upperLimit constants created by the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IncludedDataTypeSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INCLUDED-DATA-TYPE-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ModeDeclarationGroup::IncludedModeDeclarationGroupSet -->
   <xsd:group name="INCLUDED-MODE-DECLARATION-GROUP-SET">
      <xsd:annotation>
         <xsd:documentation>An IncludedModeDeclarationGroupSet declares that a set of ModeDeclarationGroups used by the software component for its implementation and consequently these ModeDeclarationGroups become part of the contract.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IncludedModeDeclarationGroupSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATION-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>This represents the referenced ModeDeclarationGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IncludedModeDeclarationGroupSet.modeDeclarationGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PREFIX" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>The prefix shall be used by the RTE generator as a prefix for the creation of symbols related to the referenced ModeDeclarationGroups, e.g 
            RTE_TRANSITION_&amp;lt;ModeDeclarationGroup&amp;gt;.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IncludedModeDeclarationGroupSet.prefix";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclarationGroup::IncludedModeDeclarationGroupSet -->
   <xsd:complexType abstract="false" mixed="false" name="INCLUDED-MODE-DECLARATION-GROUP-SET">
      <xsd:annotation>
         <xsd:documentation>An IncludedModeDeclarationGroupSet declares that a set of ModeDeclarationGroups used by the software component for its implementation and consequently these ModeDeclarationGroups become part of the contract.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IncludedModeDeclarationGroupSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INCLUDED-MODE-DECLARATION-GROUP-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ListElements::IndentSample -->
   <xsd:group name="INDENT-SAMPLE">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to specify indentation of a labeled list by providing a sample content. This content can be measured by the rendering system in order to determine the width of indentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndentSample"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-2" type="AR:L-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This represents the indent sample in one particular language.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IndentSample.l2";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class ListElements::IndentSample -->
   <xsd:attributeGroup name="INDENT-SAMPLE">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to specify indentation of a labeled list by providing a sample content. This content can be measured by the rendering system in order to determine the width of indentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndentSample"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ITEM-LABEL-POS" type="AR:ITEM-LABEL-POS-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The position of the label in case the label is too long. The default is  "NO-NEWLINE"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="IndentSample.itemLabelPos";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class ListElements::IndentSample -->
   <xsd:complexType abstract="false" mixed="false" name="INDENT-SAMPLE">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to specify indentation of a labeled list by providing a sample content. This content can be measured by the rendering system in order to determine the width of indentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndentSample"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INDENT-SAMPLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:INDENT-SAMPLE"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::IndexEntry -->
   <xsd:group name="INDEX-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This class represents an index entry.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndexEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="SUP" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is superscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="IndexEntry.sup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUB" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is subscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="IndexEntry.sub";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class InlineTextElements::IndexEntry -->
   <xsd:complexType abstract="false" mixed="true" name="INDEX-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This class represents an index entry.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndexEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INDEX-ENTRY"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::IndexedArrayElement -->
   <xsd:group name="INDEXED-ARRAY-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>This element represents exactly one indexed element in the array.  Either the applicationArrayElement or implementationArrayElement reference shall be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPLICATION-ARRAY-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an ApplicationArrayElement in an array. This reference shall only be used if the referenced context element ( VariableDataPrototype that is referenced by the SenderReceiverToSignalGroupMapping or ArgumentDataPrototype that is referenced by the ClientServerCompositeTypeMapping) is typed by an ApplicationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement.applicationArrayElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-ARRAY-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-ARRAY-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an ImplementationDataTypeElement in an array. This reference shall only be used if the referenced context element (VariableDataPrototype that is referenced by the SenderReceiverToSignalGroupMapping or ArgumentDataPrototype that is referenced by the ClientServerCompositeTypeMapping) is typed by an ImplementationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement.implementationArrayElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Position of an element in an array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement.index";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::IndexedArrayElement -->
   <xsd:complexType abstract="false" mixed="false" name="INDEXED-ARRAY-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>This element represents exactly one indexed element in the array.  Either the applicationArrayElement or implementationArrayElement reference shall be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INDEXED-ARRAY-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::InnerPortGroupInCompositionInstanceRef -->
   <xsd:group name="INNER-PORT-GROUP-IN-COMPOSITION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InnerPortGroupInCompositionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InnerPortGroupInCompositionInstanceRef.context";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REF">
            <xsd:annotation>
               <xsd:documentation>Links a PortGroup in a composition to another PortGroup, that is defined in a component which is part of this CompositionSwComponentType. There shall be at most one innerGroup per contained SwComponentPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InnerPortGroupInCompositionInstanceRef.target";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::InnerPortGroupInCompositionInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="INNER-PORT-GROUP-IN-COMPOSITION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InnerPortGroupInCompositionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:INNER-PORT-GROUP-IN-COMPOSITION-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstantiationDataDefProps::InstantiationDataDefProps -->
   <xsd:group name="INSTANTIATION-DATA-DEF-PROPS">
      <xsd:annotation>
         <xsd:documentation>This is a general class allowing to apply additional SwDataDefProps to particular instantiations of a DataPrototype.

      Typically the accessibility and further information like alias names for a  particular data is modeled on the level of DataPrototypes (especially  VariableDataPrototypes, ParameterDataPrototypes). But due to the recursive  structure of the meta-model concerning data types (a composite (data) type consists  out of data prototypes) a part of the MCD information is described in the data  type (in case of ApplicationCompositeDataType).

      This is a strong restriction in the reuse of data typed because the data type should be re-used  for different VariableDataPrototypes and ParameterDataPrototypes to guarantee type  compatibility on C-implementation level (e.g. data of a Port is stored in PIM  or NvRom Block shall be from same data type as NvRAM Block).

      This class overcomes such a restriction if applied properly.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InstantiationDataDefProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-INSTANCE" type="AR:AUTOSAR-PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>This is the particular ParameterDataPrototypes on which the swDataDefProps shall be applied.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InstantiationDataDefProps.parameterInstance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>These are the particular data definition properties which shall be applied</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InstantiationDataDefProps.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIABLE-INSTANCE" type="AR:AUTOSAR-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the particular VariableDataPrototypes on which the swDataDefProps shall be applied.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InstantiationDataDefProps.variableInstance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstantiationDataDefProps::InstantiationDataDefProps -->
   <xsd:complexType abstract="false" mixed="false" name="INSTANTIATION-DATA-DEF-PROPS">
      <xsd:annotation>
         <xsd:documentation>This is a general class allowing to apply additional SwDataDefProps to particular instantiations of a DataPrototype.

      Typically the accessibility and further information like alias names for a  particular data is modeled on the level of DataPrototypes (especially  VariableDataPrototypes, ParameterDataPrototypes). But due to the recursive  structure of the meta-model concerning data types (a composite (data) type consists  out of data prototypes) a part of the MCD information is described in the data  type (in case of ApplicationCompositeDataType).

      This is a strong restriction in the reuse of data typed because the data type should be re-used  for different VariableDataPrototypes and ParameterDataPrototypes to guarantee type  compatibility on C-implementation level (e.g. data of a Port is stored in PIM  or NvRom Block shall be from same data type as NvRAM Block).

      This class overcomes such a restriction if applied properly.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InstantiationDataDefProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INSTANTIATION-DATA-DEF-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::IntegerValueVariationPoint -->
   <xsd:group name="INTEGER-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for Integer attributes.

      Note that this class might be used in the extended meta-model only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class VariantHandling::IntegerValueVariationPoint -->
   <xsd:complexType abstract="false" mixed="true" name="INTEGER-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for Integer attributes.

      Note that this class might be used in the extended meta-model only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-DEPENDENT-FORMULA"/>
         <xsd:group ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
         <xsd:group ref="AR:INTEGER-VALUE-VARIATION-POINT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
   </xsd:complexType>
   <!-- element group for class InternalBehavior::InternalBehavior -->
   <xsd:group name="INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>Common base class (abstract) for the internal behavior of both software components and basic software modules/clusters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSTANT-MEMORYS">
            <xsd:annotation>
               <xsd:documentation>Describes a read only memory object containing characteristic value(s)  implemented by this InternalBehavior. The shortName of ParameterElementPrototype has to be equal to the ''C' identifier of the described constant.
            The characteristic value(s) might be shared between
            SwComponentPrototypes of the same SwComponentType.
            The aggregation of constantMemory is subject to variability with the purpose to support variability in the software component or module implementations. Typically different algorithms in the implementation are requiring different number of memory objects.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="InternalBehavior.constantMemory";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAMETER-DATA-PROTOTYPE" type="AR:PARAMETER-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSTANT-VALUE-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the ConstanSpecificationMapping to be applied for the particular InternalBehavior</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior.constantValueMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONSTANT-VALUE-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CONSTANT-SPECIFICATION-MAPPING-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-TYPE-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the DataTypeMapping to be applied for the particular InternalBehavior</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior.dataTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-TYPE-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:DATA-TYPE-MAPPING-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXCLUSIVE-AREAS">
            <xsd:annotation>
               <xsd:documentation>This specifies an ExclusiveArea for this InternalBehavior. The exclusiveArea is local to the component resp. module.
            The aggregation of ExclusiveAreas is subject to variability.
            Note: the number of ExclusiveAreas might vary due to the conditional existence of RunnableEntities or BswModuleEntities.

            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="InternalBehavior.exclusiveArea";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EXCLUSIVE-AREA" type="AR:EXCLUSIVE-AREA"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATIC-MEMORYS">
            <xsd:annotation>
               <xsd:documentation>Describes a read and writeable static memory object representing measurment variables implemented by this software component. Static is used in the meaning of non temporary and does not necessarily specify a linker encapsulation. This kind of memory is only supported if supportsMultipleInstantiation is FALSE.
            The shortName of DataElementPrototype has to be equal with the ''C' identifier of the described variable.
            The aggregation of staticMemory is subject to variability with the purpose to support variability in the software components implementations. Typically different algorithms in the implementation are requiring different number of memory objects.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="InternalBehavior.staticMemory";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-DATA-PROTOTYPE" type="AR:VARIABLE-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class GlobalConstraints::InternalConstrs -->
   <xsd:group name="INTERNAL-CONSTRS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express internal constraints.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCALE-CONSTRS">
            <xsd:annotation>
               <xsd:documentation>This is one particular scale in which contributes to the data constraints.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.scaleConstr";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SCALE-CONSTR" type="AR:SCALE-CONSTR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-GRADIENT" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This element specifies the maximum slope that may be used in maps and curves.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.maxGradient";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-DIFF" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>Maximum difference that is permitted between two consecutive values if the constraint is applied to an axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.maxDiff";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MONOTONY" type="AR:MONOTONY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This element specifies the monotony characteristics of the current internal or physical limits. The following table shows the monotony characteristics which are to be filled through the corresponding values. 

            If the element has no contents or if it is omitted, "no-monotony" is the default content.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.monotony";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::InternalConstrs -->
   <xsd:complexType abstract="false" mixed="false" name="INTERNAL-CONSTRS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express internal constraints.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INTERNAL-CONSTRS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::InternalTriggerOccurredEvent -->
   <xsd:group name="INTERNAL-TRIGGER-OCCURRED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced internal trigger have been occurred.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalTriggerOccurredEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>Internal Triggering Point that triggers the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="event.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:INTERNAL-TRIGGERING-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::InternalTriggerOccurredEvent -->
   <xsd:complexType abstract="false" mixed="false" name="INTERNAL-TRIGGER-OCCURRED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced internal trigger have been occurred.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalTriggerOccurredEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:INTERNAL-TRIGGER-OCCURRED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Trigger::InternalTriggeringPoint -->
   <xsd:group name="INTERNAL-TRIGGERING-POINT">
      <xsd:annotation>
         <xsd:documentation>If a RunnableEntity owns a InternalTriggeringPoint it is entitled to trigger the execution of RunnableEntities of the corresponding software-component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalTriggeringPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IMPL-POLICY" type="AR:SW-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute, when set to value queued, allows for a queued processing of Triggers.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalTriggeringPoint.swImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Trigger::InternalTriggeringPoint -->
   <xsd:complexType abstract="false" mixed="false" name="INTERNAL-TRIGGERING-POINT">
      <xsd:annotation>
         <xsd:documentation>If a RunnableEntity owns a InternalTriggeringPoint it is entitled to trigger the execution of RunnableEntities of the corresponding software-component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalTriggeringPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:INTERNAL-TRIGGERING-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="INTERNAL-TRIGGERING-POINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INTERNAL-TRIGGERING-POINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InterpolationRoutineMappingSet::InterpolationRoutine -->
   <xsd:group name="INTERPOLATION-ROUTINE">
      <xsd:annotation>
         <xsd:documentation>This represents an interpolation routine taken to evaluate the contents of a curve or map against a specific input value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutine"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This is the name of the interpolation method which is implemented by the referenced bswModuleEntry. It corresponds to swInterpolationMethod in SwDataDefProps.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutine.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-DEFAULT" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This specifies if the current interpolationMethod is the default for the referenced record layout.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutine.isDefault";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERPOLATION-ROUTINE-REF">
            <xsd:annotation>
               <xsd:documentation>This specifies a BswModuleEntry which implements the current interpolation method for the given record layout.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutine.interpolationRoutine";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InterpolationRoutineMappingSet::InterpolationRoutine -->
   <xsd:complexType abstract="false" mixed="false" name="INTERPOLATION-ROUTINE">
      <xsd:annotation>
         <xsd:documentation>This represents an interpolation routine taken to evaluate the contents of a curve or map against a specific input value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutine"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INTERPOLATION-ROUTINE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InterpolationRoutineMappingSet::InterpolationRoutineMapping -->
   <xsd:group name="INTERPOLATION-ROUTINE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class provides a mapping between one record layout and its matching interpolation routines. This allows to formally specify the semantics of the interpolation routines. 

      The use case is such that the curves/Maps define an interpolation method. This mapping table specifies which interpolation routine implements methods for a particular record layout. Using this information, the implementer of an SWC can select the appropriate interpolation routine.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutineMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERPOLATION-ROUTINES">
            <xsd:annotation>
               <xsd:documentation>This is one particular interpolation routine which is mapped to the record layout.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutineMapping.interpolationRoutine";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INTERPOLATION-ROUTINE" type="AR:INTERPOLATION-ROUTINE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-REF">
            <xsd:annotation>
               <xsd:documentation>This refers to the record layout which is mapped to interpolation routines.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutineMapping.swRecordLayout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-RECORD-LAYOUT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InterpolationRoutineMappingSet::InterpolationRoutineMapping -->
   <xsd:complexType abstract="false" mixed="false" name="INTERPOLATION-ROUTINE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class provides a mapping between one record layout and its matching interpolation routines. This allows to formally specify the semantics of the interpolation routines. 

      The use case is such that the curves/Maps define an interpolation method. This mapping table specifies which interpolation routine implements methods for a particular record layout. Using this information, the implementer of an SWC can select the appropriate interpolation routine.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutineMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INTERPOLATION-ROUTINE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InterpolationRoutineMappingSet::InterpolationRoutineMappingSet -->
   <xsd:group name="INTERPOLATION-ROUTINE-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies a set of interpolation routine mappings.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="InterpolationRoutineMappingSets";mmt.qualifiedName="InterpolationRoutineMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERPOLATION-ROUTINE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>This specifies one particular mapping of recordlayout and its matching interpolationRoutines.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterpolationRoutineMappingSet.interpolationRoutineMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INTERPOLATION-ROUTINE-MAPPING" type="AR:INTERPOLATION-ROUTINE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InterpolationRoutineMappingSet::InterpolationRoutineMappingSet -->
   <xsd:complexType abstract="false" mixed="false" name="INTERPOLATION-ROUTINE-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies a set of interpolation routine mappings.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="InterpolationRoutineMappingSets";mmt.qualifiedName="InterpolationRoutineMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:INTERPOLATION-ROUTINE-MAPPING-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::InvalidationPolicy -->
   <xsd:group name="INVALIDATION-POLICY">
      <xsd:annotation>
         <xsd:documentation>Specifies whether the component can actively invalidate a particular dataElement.

      If no invalidationPolicy points to a dataElement this is considered to yield the identical result as if the handleInvalid attribute was set to dontInvalidate.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InvalidationPolicy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the dataElement for which the InvalidationPolicy applies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InvalidationPolicy.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-INVALID" type="AR:HANDLE-INVALID-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the action performed upon a reception timeout violation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InvalidationPolicy.handleInvalid";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::InvalidationPolicy -->
   <xsd:complexType abstract="false" mixed="false" name="INVALIDATION-POLICY">
      <xsd:annotation>
         <xsd:documentation>Specifies whether the component can actively invalidate a particular dataElement.

      If no invalidationPolicy points to a dataElement this is considered to yield the identical result as if the handleInvalid attribute was set to dontInvalidate.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InvalidationPolicy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:INVALIDATION-POLICY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::IoHwAbstractionServerAnnotation -->
   <xsd:group name="IO-HW-ABSTRACTION-SERVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>The IoHwAbstractionPort Annotation will only be used from a sensor- or an actuator component while interacting with the IoHwAbstraction layer</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AGE" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>In case of a SET operation, the age will be interpreted as Delay while in a GET operation (input) it specifies the Lifetime of the signal within the IoHwAbstraction Layer</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.age";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the corresponding ArgumentDataPrototype. The IoHwAbstractionServerAnnotation can be applied either to sender-receiver or to client-server communication. This association only applies in the latter case</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.argument";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ARGUMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-RESOLUTION" type="AR:FLOAT">
            <xsd:annotation>
               <xsd:documentation>This value is determined by an appropriate combination of the range, the unit as well as the data-elements type, i.e. (ecuSignalRange.upperLimit-ecuSignalRange.lowerLimit) / (2^datatypelength - 1)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.bswResolution";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the corresponding VariableDataPrototype. The IoHwAbstractionServerAnnotation can be applied either to sender-receiver or to client-server communication. This association only applies in the former case</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FAILURE-MONITORING-REF">
            <xsd:annotation>
               <xsd:documentation>This is only applicable in SET operations. If it is enabled, the IoHwAbstraction layer will monitor the result of the operation and issue an diagnostic signal. This means especially, that an additional client-server port has to be created. Tools can use this information to cross-check whether for each data-element in a SET operation with FailureMonitoring enabled an additional port is created

            The referenced port monitors a failure in the to be monitored VariableDataPrototype of the IoHwAbstraction layer. The referenced port has to be another port of the same Actuator or Sensor Component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.failureMonitoring";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FILTERING-DEBOUNCING" type="AR:FILTER-DEBOUNCING-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute is used to indicate what kind of filtering/debouncing has been put to the signal in the IoHwAbstraction layer. 

            rawData means that no modification of the signal has been applied. This is the default value
            debounceData means that the signal is a mean value
            waitTimeData means that the signal is delivered by a GET operation after a certain amount of time</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.filteringDebouncing";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PULSE-TEST" type="AR:PULSE-TEST-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute indicates to the connected SensorActuatorSwComponentType whether the VariableDataPrototype can be used to generate pulse test sequences using the IoHwAbstraction layer</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.pulseTest";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::IoHwAbstractionServerAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="IO-HW-ABSTRACTION-SERVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>The IoHwAbstractionPort Annotation will only be used from a sensor- or an actuator component while interacting with the IoHwAbstraction layer</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ListElements::Item -->
   <xsd:group name="ITEM">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents one particular item in a list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Item"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:DOCUMENTATION-BLOCK"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ListElements::Item -->
   <xsd:complexType abstract="false" mixed="false" name="ITEM">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents one particular item in a list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Item"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:ITEM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::J1939TpConfig -->
   <xsd:group name="J-1939-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one J1939 TP Configuration. 

      One J1939TpConfig element shall be created for each J1939 Network in the System.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="J1939TpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESSS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpAddress.J1939TpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TP-ADDRESS" type="AR:TP-ADDRESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpConnection.J1939TpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="J-1939-TP-CONNECTION" type="AR:J-1939-TP-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-NODES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpNode.J1939TpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="J-1939-TP-NODE" type="AR:J-1939-TP-NODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::J1939TpConfig -->
   <xsd:complexType abstract="false" mixed="false" name="J-1939-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one J1939 TP Configuration. 

      One J1939TpConfig element shall be created for each J1939 Network in the System.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="J1939TpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:TP-CONFIG"/>
         <xsd:group ref="AR:J-1939-TP-CONFIG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::J1939TpConnection -->
   <xsd:group name="J-1939-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A J1939TpConnection represents an internal path for the transmission or reception of a Pdu via J1939Tp and describes the the sender and the receiver of this particular communication. The J1939Tp module routes a Pdu (J1939 PGN) through the connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BROADCAST" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>BAM (Broadcast Announce Message)  is a broadcast protocol. If this attribute is set to true broadcast is used. Since address FF is the only broadcast address, there's no reason to configure it.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection.broadcast";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>There are two transport protocols defined for J1939: BAM (Broadcast Announce Message), which is a broadcast protocol, and CMDT (Connection Mode Data Transfer), which is a
            point-to-point protocol with flow control. 

            BAM uses one Data NPdu for transport, TP.DT (Transport Protocol Data) and one FlowControlNpdu, TP.CM (Transport Protocol Command).

            CMDT uses three CAN frames (one Data NPdu and two FlowControlNPdus) because an additional TP.CM in reverse direction is needed for flow control. The DataNPdu has a fixed length of 8 bytes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection.dataPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECT-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>In case of variable length IPdus (with system signals of variable length), an additional NPdu (with the PGN in the CAN ID) is used for messages with up to 8 bytes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection.directPdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the Flow Control NPdus that are used in the CMDT (Connection Mode Data Transfer) for TP.CM in both directions. 
            BAM uses one TP.CM (Transport Protocol Command). 
            The flowControlNPdu has a fixed length of 8 bytes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection.flowControlPdu";pureMM.maxOccurs="2";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="FLOW-CONTROL-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECEIVER-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection.receiver";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:J-1939-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-SDU-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to IPdus that are segmented by the Transport Protocol. 

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the J1939TpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection.tpSdu";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TP-SDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMITTER-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection.transmitter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:J-1939-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::J1939TpConnection -->
   <xsd:complexType abstract="false" mixed="false" name="J-1939-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A J1939TpConnection represents an internal path for the transmission or reception of a Pdu via J1939Tp and describes the the sender and the receiver of this particular communication. The J1939Tp module routes a Pdu (J1939 PGN) through the connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:J-1939-TP-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::J1939TpNode -->
   <xsd:group name="J-1939-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTOR-REF">
            <xsd:annotation>
               <xsd:documentation>Asscociation to a CommunicationConnector in the topology description. In a System Description this reference is mandatory. In an ECU Extract this reference is optional (references to ECUs that are not part of the ECU Extract shall be avoided).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpNode.connector";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the TP Address that is used by the TpNode. This reference is optional only when no TP is sent and only BAM is received.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpNode.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::J1939TpNode -->
   <xsd:complexType abstract="false" mixed="false" name="J-1939-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="J1939TpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:J-1939-TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="J-1939-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="J-1939-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Keyword::Keyword -->
   <xsd:group name="KEYWORD">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to predefine keywords which may subsequently be used to construct names following a given naming convention, e.g. the AUTOSAR naming conventions.

      Note that such names is not only shortName. It could be symbol, or even longName. Application of keywords is not limited to particular names.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Keyword"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ABBR-NAME" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies an abbreviated name of a keyword. This abbreviation may e.g. be used for constructing valid shortNames according to  the AUTOSAR naming conventions. 

            Unlike shortName, it may contain any name token. E.g. it may consist of digits only.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Keyword.abbrName";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLASSIFICATIONS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLASSIFICATION" type="AR:NMTOKEN-STRING">
                     <xsd:annotation>
                        <xsd:documentation>This attribute allows to attach classification to the Keyword such as MEAN, ACTION, CONDITION, INDEX, PREPOSITION</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="Keyword.classification";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Keyword::Keyword -->
   <xsd:complexType abstract="false" mixed="false" name="KEYWORD">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to predefine keywords which may subsequently be used to construct names following a given naming convention, e.g. the AUTOSAR naming conventions.

      Note that such names is not only shortName. It could be symbol, or even longName. Application of keywords is not limited to particular names.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Keyword"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:KEYWORD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Keyword::KeywordSet -->
   <xsd:group name="KEYWORD-SET">
      <xsd:annotation>
         <xsd:documentation>This meta--class represents the ability to collect a set of predefined keywords.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="KeywordSets";mmt.qualifiedName="KeywordSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEYWORDS">
            <xsd:annotation>
               <xsd:documentation>This is one particular keyword in the keyword set.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="KeywordSet.keyword";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="KEYWORD" type="AR:KEYWORD"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Keyword::KeywordSet -->
   <xsd:complexType abstract="false" mixed="false" name="KEYWORD-SET">
      <xsd:annotation>
         <xsd:documentation>This meta--class represents the ability to collect a set of predefined keywords.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="KeywordSets";mmt.qualifiedName="KeywordSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:KEYWORD-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Figure::LGraphic -->
   <xsd:group name="L-GRAPHIC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the figure in one particular language.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LGraphic"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="GRAPHIC" type="AR:GRAPHIC">
            <xsd:annotation>
               <xsd:documentation>Reference to the actual graphic represented in the figure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LGraphic.graphic";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAP" type="AR:MAP">
            <xsd:annotation>
               <xsd:documentation>Image maps enable authors to specify regions of an image or object and assign a specific action to each region.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LGraphic.map";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Figure::LGraphic -->
   <xsd:complexType abstract="false" mixed="false" name="L-GRAPHIC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the figure in one particular language.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LGraphic"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LANGUAGE-SPECIFIC"/>
         <xsd:group ref="AR:L-GRAPHIC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:LANGUAGE-SPECIFIC"/>
   </xsd:complexType>
   <!-- element group for class LanguageDataModel::LLongName -->
   <xsd:group name="L-LONG-NAME">
      <xsd:annotation>
         <xsd:documentation>MixedContentForLongNames  in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LLongName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class LanguageDataModel::LLongName -->
   <xsd:complexType abstract="false" mixed="true" name="L-LONG-NAME">
      <xsd:annotation>
         <xsd:documentation>MixedContentForLongNames  in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LLongName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LANGUAGE-SPECIFIC"/>
         <xsd:group ref="AR:MIXED-CONTENT-FOR-LONG-NAME"/>
         <xsd:group ref="AR:L-LONG-NAME"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:LANGUAGE-SPECIFIC"/>
   </xsd:complexType>
   <!-- element group for class LanguageDataModel::LOverviewParagraph -->
   <xsd:group name="L-OVERVIEW-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>MixedContentForOverviewParagraph in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LOverviewParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class LanguageDataModel::LOverviewParagraph -->
   <xsd:complexType abstract="false" mixed="true" name="L-OVERVIEW-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>MixedContentForOverviewParagraph in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LOverviewParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LANGUAGE-SPECIFIC"/>
         <xsd:group ref="AR:MIXED-CONTENT-FOR-OVERVIEW-PARAGRAPH"/>
         <xsd:group ref="AR:L-OVERVIEW-PARAGRAPH"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:LANGUAGE-SPECIFIC"/>
   </xsd:complexType>
   <!-- element group for class LanguageDataModel::LParagraph -->
   <xsd:group name="L-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This is the text for a paragraph in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class LanguageDataModel::LParagraph -->
   <xsd:complexType abstract="false" mixed="true" name="L-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This is the text for a paragraph in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LANGUAGE-SPECIFIC"/>
         <xsd:group ref="AR:MIXED-CONTENT-FOR-PARAGRAPH"/>
         <xsd:group ref="AR:L-PARAGRAPH"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:LANGUAGE-SPECIFIC"/>
   </xsd:complexType>
   <!-- element group for class LanguageDataModel::LPlainText -->
   <xsd:group name="L-PLAIN-TEXT">
      <xsd:annotation>
         <xsd:documentation>MixedContentForPlainText in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LPlainText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class LanguageDataModel::LPlainText -->
   <xsd:complexType name="L-PLAIN-TEXT">
      <xsd:annotation>
         <xsd:documentation>MixedContentForPlainText in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LPlainText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:VERBATIM-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:LANGUAGE-SPECIFIC"/>
            <xsd:attributeGroup ref="AR:WHITESPACE-CONTROLLED"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- element group for class LanguageDataModel::LVerbatim -->
   <xsd:group name="L-VERBATIM">
      <xsd:annotation>
         <xsd:documentation>MixedContentForVerbatim in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LVerbatim"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class LanguageDataModel::LVerbatim -->
   <xsd:complexType abstract="false" mixed="true" name="L-VERBATIM">
      <xsd:annotation>
         <xsd:documentation>MixedContentForVerbatim in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LVerbatim"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LANGUAGE-SPECIFIC"/>
         <xsd:group ref="AR:WHITESPACE-CONTROLLED"/>
         <xsd:group ref="AR:MIXED-CONTENT-FOR-VERBATIM"/>
         <xsd:group ref="AR:L-VERBATIM"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:LANGUAGE-SPECIFIC"/>
      <xsd:attributeGroup ref="AR:WHITESPACE-CONTROLLED"/>
   </xsd:complexType>
   <!-- element group for class ListElements::LabeledItem -->
   <xsd:group name="LABELED-ITEM">
      <xsd:annotation>
         <xsd:documentation>this represents an item of a labeled list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LabeledItem"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ITEM-LABEL" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This is the label of the item.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LabeledItem.itemLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:DOCUMENTATION-BLOCK"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class ListElements::LabeledItem -->
   <xsd:attributeGroup name="LABELED-ITEM">
      <xsd:annotation>
         <xsd:documentation>this represents an item of a labeled list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LabeledItem"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="HELP-ENTRY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies an entry point in an online help system to be linked with the parent class. The syntax must be defined by the applied help system respectively help system generator.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="LabeledItem.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class ListElements::LabeledItem -->
   <xsd:complexType abstract="false" mixed="false" name="LABELED-ITEM">
      <xsd:annotation>
         <xsd:documentation>this represents an item of a labeled list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LabeledItem"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:LABELED-ITEM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:LABELED-ITEM"/>
   </xsd:complexType>
   <!-- element group for class ListElements::LabeledList -->
   <xsd:group name="LABELED-LIST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a labeled list, in which items have a label and a content. The policy how to render such items is specified in the labeled list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LabeledList"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDENT-SAMPLE" type="AR:INDENT-SAMPLE">
            <xsd:annotation>
               <xsd:documentation>This is a sample item. This sample is used by a rendering system to measure out the width of indentation. Since this depends on the particular fontsize etc. the indentation cannot be specified e.g. in mm.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LabeledList.indentSample";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="LABELED-ITEM" type="AR:LABELED-ITEM">
            <xsd:annotation>
               <xsd:documentation>This represents one particular item in the labeled list.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="LabeledList.labeledItem";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ListElements::LabeledList -->
   <xsd:complexType abstract="false" mixed="false" name="LABELED-LIST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a labeled list, in which items have a label and a content. The policy how to render such items is specified in the labeled list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LabeledList"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:LABELED-LIST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class LanguageDataModel::LanguageSpecific -->
   <xsd:group name="LANGUAGE-SPECIFIC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a particular language for which an object is applicable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LanguageSpecific"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class LanguageDataModel::LanguageSpecific -->
   <xsd:attributeGroup name="LANGUAGE-SPECIFIC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a particular language for which an object is applicable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LanguageSpecific"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="L" type="AR:L-ENUM--SIMPLE" use="required">
         <xsd:annotation>
            <xsd:documentation>'This attribute denotes the language in which the language specific document entity is given. Note that "FOR-ALL" means, that the entity is applicable to all languages. It is language neutral.

         It follows ISO 639-1:2002 and is specified in upper case.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="LanguageSpecific.l";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true";xml.enforceMinMultiplicity="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- element group for class LatencyTimingConstraint::LatencyTimingConstraint -->
   <xsd:group name="LATENCY-TIMING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>This constraint type restricts the time duration between the occurrence of the stimulus and the occurrence of the corresponding response of that chain.

      Two latency constraint types are of interest for automotive systems. These are the age of a certain response and the reaction to a certain stimulus.

      In contrast to OffsetTimingConstraint, a causal dependency between the stimulus and response event of the associated event chain is required.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LatencyTimingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LATENCY-CONSTRAINT-TYPE" type="AR:LATENCY-CONSTRAINT-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this latency constraint</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LatencyTimingConstraint.latencyConstraintType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCOPE-REF">
            <xsd:annotation>
               <xsd:documentation>The event chain that defines the scope of the constraint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LatencyTimingConstraint.scope";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT-CHAIN--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The minimum latency between the occurrence of the stimulus and the occureence of the corresponding response of the associatied event chain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LatencyTimingConstraint.minimum";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum latency between the occurrence of the stimulus and the occureence of the corresponding response of the associatied event chain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LatencyTimingConstraint.maximum";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NOMINAL" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The nominal latency between the occurrence of the stimulus and the occureence of the corresponding response of the associatied event chain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LatencyTimingConstraint.nominal";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LatencyTimingConstraint::LatencyTimingConstraint -->
   <xsd:complexType abstract="false" mixed="false" name="LATENCY-TIMING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>This constraint type restricts the time duration between the occurrence of the stimulus and the occurrence of the corresponding response of that chain.

      Two latency constraint types are of interest for automotive systems. These are the age of a certain response and the reaction to a certain stimulus.

      In contrast to OffsetTimingConstraint, a causal dependency between the stimulus and response event of the associated event chain is required.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LatencyTimingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:LATENCY-TIMING-CONSTRAINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LocalConstraints::Limit -->
   <xsd:group name="LIMIT">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to express a numerical limit.  Note that this is in fact a NumericalValuationPoint but has the additional attribute intervalType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Limit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class LocalConstraints::Limit -->
   <xsd:attributeGroup name="LIMIT">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to express a numerical limit.  Note that this is in fact a NumericalValuationPoint but has the additional attribute intervalType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Limit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="INTERVAL-TYPE" type="AR:INTERVAL-TYPE-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies the type of the interval. If the attribute is missing the interval shall be considered as "CLOSED".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Limit.intervalType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class LocalConstraints::Limit -->
   <xsd:complexType abstract="false" mixed="true" name="LIMIT">
      <xsd:annotation>
         <xsd:documentation>This class represents the ability to express a numerical limit.  Note that this is in fact a NumericalValuationPoint but has the additional attribute intervalType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Limit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-DEPENDENT-FORMULA"/>
         <xsd:group ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
         <xsd:group ref="AR:ABSTRACT-NUMERICAL-VARIATION-POINT"/>
         <xsd:group ref="AR:LIMIT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
      <xsd:attributeGroup ref="AR:LIMIT"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinCluster -->
   <xsd:group name="LIN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>LIN specific attributes</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="LinCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-CLUSTER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-CLUSTER-CONDITIONAL" type="AR:LIN-CLUSTER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinCluster -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>LIN specific attributes</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="LinCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
         <xsd:group ref="AR:LIN-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinClusterConditional -->
   <xsd:group name="LIN-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinClusterConditional -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:LIN-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:LIN-CLUSTER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinClusterContent -->
   <xsd:group name="LIN-CLUSTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class LinTopology::LinCommunicationConnector -->
   <xsd:group name="LIN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>LIN bus specific communication connector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INITIAL-NAD" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Initial NAD of the LIN slave.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinCommunicationConnector.initialNad";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-CONFIGURABLE-FRAMES">
            <xsd:annotation>
               <xsd:documentation>LinConfigurableFrames shall list all frames (unconditional frames, event-triggered frames and sporadic frames) processed by the slave node. This element is necessary for the LIN 2.0 Assign-Frame command.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="linConfigurableFrame.LinCommunicationConnector";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-CONFIGURABLE-FRAME" type="AR:LIN-CONFIGURABLE-FRAME"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-ORDERED-CONFIGURABLE-FRAMES">
            <xsd:annotation>
               <xsd:documentation>LinOrderedConfigurableFrames shall list all frames (unconditional frames, event-triggered frames and sporadic frames) processed by the slave node. This element is necessary for the LIN 2.1 Assign-Frame-PID-Range command.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="linOrderedConfigurableFrame.LinCommunicationConnector";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-ORDERED-CONFIGURABLE-FRAME" type="AR:LIN-ORDERED-CONFIGURABLE-FRAME"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinCommunicationConnector -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>LIN bus specific communication connector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:LIN-COMMUNICATION-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinCommunicationController -->
   <xsd:group name="LIN-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>LIN bus specific communication controller attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class LinTopology::LinCommunicationControllerContent -->
   <xsd:group name="LIN-COMMUNICATION-CONTROLLER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTOCOL-VERSION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Version specifier for a communication protocol.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinCommunicationController.protocolVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LinTopology::LinConfigurableFrame -->
   <xsd:group name="LIN-CONFIGURABLE-FRAME">
      <xsd:annotation>
         <xsd:documentation>Assignment of messageIds to Frames. 
      This element shall be used for the LIN 2.0 Assign-Frame command.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinConfigurableFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a Frame that is processed by the slave node.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinConfigurableFrame.frame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MESSAGE-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>MessageId for the referenced frame</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinConfigurableFrame.messageId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinConfigurableFrame -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-CONFIGURABLE-FRAME">
      <xsd:annotation>
         <xsd:documentation>Assignment of messageIds to Frames. 
      This element shall be used for the LIN 2.0 Assign-Frame command.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinConfigurableFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LIN-CONFIGURABLE-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::LinConfigurationEntry -->
   <xsd:group name="LIN-CONFIGURATION-ENTRY">
      <xsd:annotation>
         <xsd:documentation>A ScheduleTableEntry which contains LIN specific assignments.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinConfigurationEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-CONTROLLER-REF">
            <xsd:annotation>
               <xsd:documentation>The LIN slaves controller who is target of this assignment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinConfigurationEntry.assignedController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-SLAVE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LinCommunication::LinErrorResponse -->
   <xsd:group name="LIN-ERROR-RESPONSE">
      <xsd:annotation>
         <xsd:documentation>Each slave node shall publish a one bit signal, named response_error, to the master node in one of its transmitted unconditional frames. The response_error signal shall be set whenever a frame (except for event triggered frame responses) that is transmitted or received by the slave node contains an error in the frame response. The response_error signal shall be cleared when the unconditional frame containing the response_error signal is successfully transmitted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinErrorResponse"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an unconditional frame  that transmits the response error.
            The referenced LinFrameTriggering shall contain a reference to an unconditionalFrame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinErrorResponse.frameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESPONSE-ERROR-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Specifies the position of the ResponseError bit in the frame. Each slave node shall publish one response error in one of its transmitted unconditional frames.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinErrorResponse.responseErrorPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinErrorResponse -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-ERROR-RESPONSE">
      <xsd:annotation>
         <xsd:documentation>Each slave node shall publish a one bit signal, named response_error, to the master node in one of its transmitted unconditional frames. The response_error signal shall be set whenever a frame (except for event triggered frame responses) that is transmitted or received by the slave node contains an error in the frame response. The response_error signal shall be cleared when the unconditional frame containing the response_error signal is successfully transmitted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinErrorResponse"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LIN-ERROR-RESPONSE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::LinEventTriggeredFrame -->
   <xsd:group name="LIN-EVENT-TRIGGERED-FRAME">
      <xsd:annotation>
         <xsd:documentation>An event triggered frame is used as a placeholder to allow multiple slave nodes to provide its response.

      The header of an event triggered frame is transmitted when a frame slot allocated to the event triggered frame is processed. The publisher of an associated unconditional frame shall only transmit the response if at least one of the signals carried in its unconditional frame is updated. The LIN Master discovers and purges collisions with the collisionResolvingScheduleTable. 

      The event controlled frame shall not contain any Pdus.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="LinEventTriggeredFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COLLISION-RESOLVING-SCHEDULE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the schedule table, which resolves a collision.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinEventTriggeredFrame.collisionResolvingSchedule";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-SCHEDULE-TABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-UNCONDITIONAL-FRAME-REFS">
            <xsd:annotation>
               <xsd:documentation>A list of slaves can respond to the master request if at least one of the signals carried in its unconditional frame is updated. 

            For each response a LinFrameTriggering and a LinUnconditionalFrame shall be defined. Within a channel a LIN Frame shall be referenced by only one FrameTriggering. This allows a derivation of the identifier of a substituted Frame. The identifier is specified in FrameTriggering element. 

            The Unconditional frames associated with an event triggered frame shall:
            - have equal length.
            - use the same checksum model (i.e. mixing LIN 1.x and LIN 2.x frames is not allowed).
            - reserve the first data field to its protected identifier (even if the associated unconditional frame is scheduled as a unconditional frame in the same or another schedule table).
            - be published by different slave nodes.
            - shall not be included directly in the same schedule table as the event triggered frame is scheduled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinEventTriggeredFrame.linUnconditionalFrame";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-UNCONDITIONAL-FRAME-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:LIN-UNCONDITIONAL-FRAME--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinEventTriggeredFrame -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-EVENT-TRIGGERED-FRAME">
      <xsd:annotation>
         <xsd:documentation>An event triggered frame is used as a placeholder to allow multiple slave nodes to provide its response.

      The header of an event triggered frame is transmitted when a frame slot allocated to the event triggered frame is processed. The publisher of an associated unconditional frame shall only transmit the response if at least one of the signals carried in its unconditional frame is updated. The LIN Master discovers and purges collisions with the collisionResolvingScheduleTable. 

      The event controlled frame shall not contain any Pdus.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="LinEventTriggeredFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:FRAME"/>
         <xsd:group ref="AR:LIN-FRAME"/>
         <xsd:group ref="AR:LIN-EVENT-TRIGGERED-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::LinFrame -->
   <xsd:group name="LIN-FRAME">
      <xsd:annotation>
         <xsd:documentation>Lin specific Frame element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="LIN-FRAME--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-EVENT-TRIGGERED-FRAME"/>
         <xsd:enumeration value="LIN-FRAME"/>
         <xsd:enumeration value="LIN-SPORADIC-FRAME"/>
         <xsd:enumeration value="LIN-UNCONDITIONAL-FRAME"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinCommunication::LinFrameTriggering -->
   <xsd:group name="LIN-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>LIN specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="IDENTIFIER" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>To describe a frames identifier on the communication system, usually with a fixed identifierValue. For LinSporadicFrames the attribute shall be ignored.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinFrameTriggering.identifier";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-CHECKSUM" type="AR:LIN-CHECKSUM-TYPE">
            <xsd:annotation>
               <xsd:documentation>Type of checksum that the frame is using.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinFrameTriggering.linChecksum";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinFrameTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>LIN specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME-TRIGGERING"/>
         <xsd:group ref="AR:LIN-FRAME-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-FRAME-TRIGGERING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-FRAME-TRIGGERING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinTopology::LinMaster -->
   <xsd:group name="LIN-MASTER">
      <xsd:annotation>
         <xsd:documentation>Describing the properties of the refering ecu as a LIN master.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinMaster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-MASTER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-MASTER-CONDITIONAL" type="AR:LIN-MASTER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinMaster -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-MASTER">
      <xsd:annotation>
         <xsd:documentation>Describing the properties of the refering ecu as a LIN master.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinMaster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:LIN-COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:LIN-MASTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinMasterConditional -->
   <xsd:group name="LIN-MASTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinMasterConditional -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-MASTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:LIN-COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:LIN-MASTER-CONTENT"/>
         <xsd:group ref="AR:LIN-MASTER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinMasterContent -->
   <xsd:group name="LIN-MASTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BASE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Time base is mandatory for the master. It is not used for slaves. 
            LIN 2.0 Spec states: "The time_base value specifies the used time base in the master node to generate the maximum allowed frame transfer time." 
            The time base shall be specified AUTOSAR conform in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinMaster.timeBase";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BASE-JITTER" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The attribute timeBaseJitter is a mandatory attribute for the master and not used for slaves. 
            LIN 2.0 Spec states: "The jitter value specifies the differences between the maximum and minimum delay from time base start point to the frame header sending start point (falling edge of BREAK signal)." 
            The jitter shall be specified AUTOSAR conform in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinMaster.timeBaseJitter";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LinTopology::LinOrderedConfigurableFrame -->
   <xsd:group name="LIN-ORDERED-CONFIGURABLE-FRAME">
      <xsd:annotation>
         <xsd:documentation>With the assignment of the index to a frame a mapping of Pids to Frames is possible. This element shall be used for the LIN 2.1 Assign-Frame-PID-Range command.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinOrderedConfigurableFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a Frame that is processed by the slave node.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinOrderedConfigurableFrame.frame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute is used to order the elements and allows an assignment of Pids to
            ConfigurableFrames that are defined in the slave.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinOrderedConfigurableFrame.index";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinOrderedConfigurableFrame -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-ORDERED-CONFIGURABLE-FRAME">
      <xsd:annotation>
         <xsd:documentation>With the assignment of the index to a frame a mapping of Pids to Frames is possible. This element shall be used for the LIN 2.1 Assign-Frame-PID-Range command.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinOrderedConfigurableFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LIN-ORDERED-CONFIGURABLE-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinPhysicalChannel -->
   <xsd:group name="LIN-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>LIN specific attributes to the physicalChannel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCHEDULE-TABLES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="scheduleTable.LinPhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-SCHEDULE-TABLE" type="AR:LIN-SCHEDULE-TABLE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinPhysicalChannel -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>LIN specific attributes to the physicalChannel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PHYSICAL-CHANNEL"/>
         <xsd:group ref="AR:LIN-PHYSICAL-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::LinScheduleTable -->
   <xsd:group name="LIN-SCHEDULE-TABLE">
      <xsd:annotation>
         <xsd:documentation>The master task (in the master node) transmits frame headers based on a schedule table. The schedule table specifies the identifiers for each header and the interval between the start of a frame and the start of the following frame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinScheduleTable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESUME-POSITION" type="AR:RESUME-POSITION">
            <xsd:annotation>
               <xsd:documentation>Defines, where a schedule table shall be proceeded in case if it has been interrupted by a run-once table or MRF/SRF.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinScheduleTable.resumePosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUN-MODE" type="AR:RUN-MODE">
            <xsd:annotation>
               <xsd:documentation>The schedule table can be executed in two different modes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinScheduleTable.runMode";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TABLE-ENTRYS">
            <xsd:annotation>
               <xsd:documentation>The scheduling table consists of table entries, which contain Frame slots.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tableEntry.LinScheduleTable";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-ENTRY" type="AR:APPLICATION-ENTRY"/>
                  <xsd:element name="ASSIGN-FRAME-ID" type="AR:ASSIGN-FRAME-ID"/>
                  <xsd:element name="ASSIGN-FRAME-ID-RANGE" type="AR:ASSIGN-FRAME-ID-RANGE"/>
                  <xsd:element name="ASSIGN-NAD" type="AR:ASSIGN-NAD"/>
                  <xsd:element name="CONDITIONAL-CHANGE-NAD" type="AR:CONDITIONAL-CHANGE-NAD"/>
                  <xsd:element name="DATA-DUMP-ENTRY" type="AR:DATA-DUMP-ENTRY"/>
                  <xsd:element name="FREE-FORMAT" type="AR:FREE-FORMAT"/>
                  <xsd:element name="SAVE-CONFIGURATION-ENTRY" type="AR:SAVE-CONFIGURATION-ENTRY"/>
                  <xsd:element name="UNASSIGN-FRAME-ID" type="AR:UNASSIGN-FRAME-ID"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinScheduleTable -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-SCHEDULE-TABLE">
      <xsd:annotation>
         <xsd:documentation>The master task (in the master node) transmits frame headers based on a schedule table. The schedule table specifies the identifiers for each header and the interval between the start of a frame and the start of the following frame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinScheduleTable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:LIN-SCHEDULE-TABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-SCHEDULE-TABLE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-SCHEDULE-TABLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinTopology::LinSlave -->
   <xsd:group name="LIN-SLAVE">
      <xsd:annotation>
         <xsd:documentation>Describing the properties of the referring ecu as a LIN slave.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-SLAVE-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-SLAVE-CONDITIONAL" type="AR:LIN-SLAVE-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinSlave -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-SLAVE">
      <xsd:annotation>
         <xsd:documentation>Describing the properties of the referring ecu as a LIN slave.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:LIN-COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:LIN-SLAVE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-SLAVE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-SLAVE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinTopology::LinSlaveConditional -->
   <xsd:group name="LIN-SLAVE-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinSlaveConditional -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-SLAVE-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:LIN-COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:LIN-SLAVE-CONTENT"/>
         <xsd:group ref="AR:LIN-SLAVE-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinSlaveContent -->
   <xsd:group name="LIN-SLAVE-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIGURED-NAD" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>To distinguish LIN slaves that are used twice or more within the same cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave.configuredNad";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FUNCTION-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>LIN function ID</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave.functionId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-ERROR-RESPONSE" type="AR:LIN-ERROR-RESPONSE">
            <xsd:annotation>
               <xsd:documentation>Each slave node shall publish one response error in one of its transmitted unconditional frames.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="linErrorResponse.LinSlave";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPLIER-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>LIN Supplier ID</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave.supplierId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIANT-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Specifies the Variant ID</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave.variantId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LinCommunication::LinSporadicFrame -->
   <xsd:group name="LIN-SPORADIC-FRAME">
      <xsd:annotation>
         <xsd:documentation>A sporadic frame is a group of unconditional frames that share the same frame slot. The sporadic frame shall not contain any Pdus.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="LinSporadicFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUBSTITUTED-FRAME-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to a group of unconditional frames that share the same frame slot. In case that more than one of the declared frames needs to be transferred, the one first listed shall be chosen. 

            Within a channel a LIN Frame shall be referenced by only one FrameTriggering. This allows a derivation of the identifier of a substituted Frame. The identifier is specified in FrameTriggering element. 

            A LinUnconditionalFrame associated with a LinSporadicFrame may not be allocated in the same LinScheduleTable as the sporadic frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinSporadicFrame.substitutedFrame";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SUBSTITUTED-FRAME-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:LIN-UNCONDITIONAL-FRAME--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinSporadicFrame -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-SPORADIC-FRAME">
      <xsd:annotation>
         <xsd:documentation>A sporadic frame is a group of unconditional frames that share the same frame slot. The sporadic frame shall not contain any Pdus.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="LinSporadicFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:FRAME"/>
         <xsd:group ref="AR:LIN-FRAME"/>
         <xsd:group ref="AR:LIN-SPORADIC-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::LinTpConfig -->
   <xsd:group name="LIN-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one Lin TP Configuration. 

      One LinTpConfig element shall be created for each Lin Network in the System.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="LinTpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESSS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpAddress.LinTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TP-ADDRESS" type="AR:TP-ADDRESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 2.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpConnection.LinTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-TP-CONNECTION" type="AR:LIN-TP-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-NODES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="tpNode.LinTpConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-TP-NODE" type="AR:LIN-TP-NODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::LinTpConfig -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>This element defines exactly one Lin TP Configuration. 

      One LinTpConfig element shall be created for each Lin Network in the System.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TpConfigs";mmt.qualifiedName="LinTpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:TP-CONFIG"/>
         <xsd:group ref="AR:LIN-TP-CONFIG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::LinTpConnection -->
   <xsd:group name="LIN-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A LinTP channel represents an internal path for the transmission or reception of a Pdu via LinTp and describes the the sender and the receiver of this particular communication. 

      Two LinTpConnections can be specified: one LinTpConnection to describe the transmission of data from master to slave, using MasterRequestFrame and one LinTpConnection to describe the transmission of data from slave to master, using the SlaveResponseFrame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an NPdu (Single Frame, First Frame or Consecutive Frame).

            The Single Frame network protocol data unit (SF N_PDU) shall be sent out by the sending network entity and can be received by one or multiple receiving network entities.
            The Single Frame (SF N_PDU) shall be sent out to transfer a service data unit that can be transferred via a single service request to the data link layer. This network protocol data unit shall be sent to transfer unsegmented messages.

            The First Frame network protocol data unit (FF N_PDU) identifies the first network protocol data unit (N_PDU) of a segmented message transmitted by a network sending entity and received by a receiving network entity. 

            The Consecutive Frame network protocol data unit (CF N_PDU) transfers segments (N_Data) of the service data unit message data (&lt;MessageData&gt;). All network protocol data units (N_PDUs) transmitted by the sending entity after the First Frame network protocol data unit (FF N_PDU) shall be encoded as Consecutive Frames network protocol data units (CF N_PDUs).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.dataPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DROP-NOT-REQUESTED-NAD" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Configures if TP Frames of not requested LIN-Slaves are dropped or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.dropNotRequestedNad";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the  Flow Control NPdu.

            The Flow Control network protocol data unit (FC N_PDU) is identified by the Flow Control protocol control information (FC N_PCI). The Flow Control network protocol data unit (FC N_PDU) instructs a sending network entity to start, stop or resume transmission of CF N_PDUs. The Flow Control network protocol data unit shall be sent by the receiving network layer entity to the sending network layer entity, when ready to receive more data, after correct reception of:

            a) First Frame network protocol data unit (FF N_PDU) 
            b) the last Consecutive Frame network protocol data unit (CF N_PDU) of a block of Consecutive Frames (CF N_PDU) if further Consecutive Frame network protocol data unit (CF N_PDU) need(s) to be sent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.flowControl";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-TP-N-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the LinTpConnection must not reference a NPdu with this linTpNSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.linTpNSdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-REF">
            <xsd:annotation>
               <xsd:documentation>TP address for 1:n connections.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.multicast";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECEIVER-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.receiver";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:LIN-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Time for transmission of the LIN frame (any N-PDU) on the sender side. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.timeoutAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CR" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the timeout value for waiting for a CF or FF-x (in case of retry) after receiving the last CF or after sending an FC or AF on the receiver side. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.timeoutCr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CS" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The attribute timeoutCs represents the time (in seconds) which elapses between the transmit request of a CF N-PDU until the transmit request of the next CF N-PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.timeoutCs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMITTER-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection.transmitter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::LinTpConnection -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A LinTP channel represents an internal path for the transmission or reception of a Pdu via LinTp and describes the the sender and the receiver of this particular communication. 

      Two LinTpConnections can be specified: one LinTpConnection to describe the transmission of data from master to slave, using MasterRequestFrame and one LinTpConnection to describe the transmission of data from slave to master, using the SlaveResponseFrame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:LIN-TP-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::LinTpNode -->
   <xsd:group name="LIN-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTOR-REF">
            <xsd:annotation>
               <xsd:documentation>Asscociation to a CommunicationConnector in the topology description. 

            In a System Description this reference is mandatory. In an ECU Extract this reference is optional (references to ECUs that are not part of the ECU Extract shall be avoided).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpNode.connector";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-RESP-PENDING-FRAMES" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Configures the maximum number of allowed response pending frames.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpNode.maxNumberOfRespPendingFrames";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="P-2-MAX" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>After reception of a response pending frame the P2 timeout counter is reloaded with the timeout time P2max.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpNode.p2Max";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="P-2-TIMING" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>P2 timeout observation parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpNode.p2Timing";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the TP Address that is used by the TpNode. This reference is optional in case that the multicast TP Address is used (reference from TpConnection).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpNode.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::LinTpNode -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:LIN-TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinCommunication::LinUnconditionalFrame -->
   <xsd:group name="LIN-UNCONDITIONAL-FRAME">
      <xsd:annotation>
         <xsd:documentation>Unconditional frames carry signals. The master sends a frame header in a scheduled frame slot and the designated slave node fills the frame with data.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="LinUnconditionalFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinUnconditionalFrame -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-UNCONDITIONAL-FRAME">
      <xsd:annotation>
         <xsd:documentation>Unconditional frames carry signals. The master sends a frame header in a scheduled frame slot and the designated slave node fills the frame with data.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Frames";mmt.qualifiedName="LinUnconditionalFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:FRAME"/>
         <xsd:group ref="AR:LIN-FRAME"/>
         <xsd:group ref="AR:LIN-UNCONDITIONAL-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-UNCONDITIONAL-FRAME--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-UNCONDITIONAL-FRAME"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Implementation::Linker -->
   <xsd:group name="LINKER">
      <xsd:annotation>
         <xsd:documentation>Specifies the linker attributes used to describe how the linker shall be invoked.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Linker"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NAME" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Linker name.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Linker.name";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPTIONS" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies the linker options.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Linker.options";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Vendor of linker.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Linker.vendor";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VERSION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Exact version of linker executable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Linker.version";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::Linker -->
   <xsd:complexType abstract="false" mixed="false" name="LINKER">
      <xsd:annotation>
         <xsd:documentation>Specifies the linker attributes used to describe how the linker shall be invoked.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Linker"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:LINKER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ListElements::List -->
   <xsd:group name="LIST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a list. The kind of list is specified in the attribute.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="List"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="ITEM" type="AR:ITEM">
            <xsd:annotation>
               <xsd:documentation>this represents a particular list item. Note that this is again a documentation block.Therefore lists can be arbitrarily nested. It is discouraged to have a very deep nesting.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="List.item";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class ListElements::List -->
   <xsd:attributeGroup name="LIST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a list. The kind of list is specified in the attribute.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="List"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="TYPE" type="AR:LIST-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The type of the list. Default is "UNNUMBER"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="List.type";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class ListElements::List -->
   <xsd:complexType abstract="false" mixed="false" name="LIST">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a list. The kind of list is specified in the attribute.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="List"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:LIST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:LIST"/>
   </xsd:complexType>
   <!-- element group for class EthernetCommunication::LogicAddress -->
   <xsd:group name="LOGIC-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>The logical DoIP address. This element shall only be used for DoIP (Diagnosis over IP).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LogicAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADDRESS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The logical DoIP address.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LogicAddress.address";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetCommunication::LogicAddress -->
   <xsd:complexType abstract="false" mixed="false" name="LOGIC-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>The logical DoIP address. This element shall only be used for DoIP (Diagnosis over IP).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LogicAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:LOGIC-ADDRESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LOGIC-ADDRESS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LOGIC-ADDRESS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Figure::Map -->
   <xsd:group name="MAP">
      <xsd:annotation>
         <xsd:documentation>Image maps enable authors to specify regions of an image or object and assign a specific action to each region (e.g., retrieve a document, run a program, etc.) When the region is activated by the user, the action is executed.

      The class follows the html approach and is intended to support interactive documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Map"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="AREA" type="AR:AREA">
            <xsd:annotation>
               <xsd:documentation>This element specifies a region in an image map. Image maps enable authors to specify regions in an object (e.g. a graphic) and to assign a specific activity to each region (e.g. load a document, launch a program etc.).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Map.area";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Figure::Map -->
   <xsd:attributeGroup name="MAP">
      <xsd:annotation>
         <xsd:documentation>Image maps enable authors to specify regions of an image or object and assign a specific action to each region (e.g., retrieve a document, run a program, etc.) When the region is activated by the user, the action is executed.

      The class follows the html approach and is intended to support interactive documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Map"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="CLASS" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute assigns a class name or set of class names to an element. Any number of elements may be assigned the same class name or set of class names. Multiple class names must be separated by white space characters. Class names are typically used to apply CSS formatting rules to an element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.class";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="NAME" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute assigns a name to the image map in the MAP element. This name can be used to be referenced in an HTML image through the attribute USEMAP. Although this is not actually necessary in the
         MSR model, it was inserted in order to support the MAPs which were created for HTML.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.name";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONCLICK" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONCLICK-Event occurs, if the current element is clicked on. A script can be stored in
         this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onclick";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONDBLCLICK" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONDBLCLICK-Event occurs, if the current Event is "double" clicked-on. 
         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.ondblclick";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONKEYDOWN" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONKEYDOWN-Event occurs, if a button on the current element is pressed down. 

         A script can be stored in this attribute to be performed in the event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onkeydown";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONKEYPRESS" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONKEYPRESS-Event occurs, if a button on the current element is pressed down and released. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onkeypress";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONKEYUP" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONKEYUP-Event occurs, if a button on the current element is released. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onkeyup";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEDOWN" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEDOWN-Event occurs, if the mouse button used for clicking is held down on the current element. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onmousedown";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEMOVE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEMOVE-Event occurs, if the mouse pointer is moved on the current 
         element (i.e. it is located on the current element). 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onmousemove";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEOUT" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEOUT-Event occurs, if the mouse pointer is moved from the current element.

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onmouseout";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEOVER" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEOVER-Event occurs, if the mouse pointer is moved to the current element
         from another location outside it. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onmouseover";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ONMOUSEUP" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>The ONMOUSEUP-Event occurs if the mouse button used for clicking is released on the
         current element. 

         A script can be stored in this attribute to be performed in the Event.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.onmouseup";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="STYLE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute specifies formatting style information for the current element. The content of this attribute is called inline CSS. The style attribute is deprecated (considered outdated), because it fuses together content and formatting.</xsd:documentation>
            <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="Map.style";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="TITLE" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute offers advisory information. Some Web browsers will display this information as tooltips. Authoring tools may make this information available to users as additional information about the element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Map.title";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Figure::Map -->
   <xsd:complexType abstract="false" mixed="false" name="MAP">
      <xsd:annotation>
         <xsd:documentation>Image maps enable authors to specify regions of an image or object and assign a specific action to each region (e.g., retrieve a document, run a program, etc.) When the region is activated by the user, the action is executed.

      The class follows the html approach and is intended to support interactive documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Map"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MAP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:MAP"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::MappingConstraint -->
   <xsd:group name="MAPPING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>Different constraints that may be used to limit the mapping of SW components to ECUs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MappingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents introductory documentation about the mapping constraint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MappingConstraint.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class MeasurementCalibrationSupport::McDataInstance -->
   <xsd:group name="MC-DATA-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>Describes the specific properties of one data instance in order to support measurement and/or calibration of this data instance.

      The most important attributes are:
      * Its shortName is copied from the ECU Flat map and will be used as identifier and for display by the MC system.
      * The category is copied from the corresponding data type (ApplicationDataType if defined, otherwise ImplementationDataType) as far as applicable.
      * The symbol is the one used in the programming language. It will be used to find out the actual memory address by the final generation tool with the help of linker generated information.

      It is assumed that in the M1 model this part and all the aggregated and referred elements (with the exception of the Flat Map) are completely generated from "upstream" information. This means, that even if an element like e.g. a CompuMethod is only used via reference here, it will be copied into the M1 artifact which holds the complete McSupportData for a given Implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="McDataInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-SIZE" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The existence of this attribute turns the data instance into an array of data. The attribute determines the size of the array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McDataInstance.arraySize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLAT-MAP-ENTRY-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the corresponding entry in the ECU Flat Map. This allows to trace back to the original specification of the generated data instance. This link shall be added by the RTE generator mainly for documentation purposes.

            The reference is optional because the McDataInstance may represent an array or struct in which only the subElements correspond to FlatMap entries.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McDataInstance.flatMapEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLAT-INSTANCE-DESCRIPTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INSTANCE-IN-MEMORY" type="AR:IMPLEMENTATION-ELEMENT-IN-PARAMETER-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the corresponding data instance in the description of calibration data structures published by the RTE generator. This is used to support emulation methods inside the ECU, it is not required for A2L generation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McDataInstance.instanceInMemory";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESULTING-PROPERTIES" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>These are the generated properties resulting from decisions taken by the RTE  generator for the actually implemented data instance. Only those properties are relevant here, which are needed for the measurement and calibration system.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McDataInstance.resultingProperties";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>This relation indicates, that the target element is part of a "struct" which is given by the source element. This information will be used by the final generator to set up the correct addressing scheme.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="McDataInstance.subElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MC-DATA-INSTANCE" type="AR:MC-DATA-INSTANCE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL" type="AR:C-IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This symbolic name is used to determine the memory address during final generation of the MC configuration data (e.g. "A2L" file). It must be the name of the variable used by the linker. This name can differ from the shortName in case of generated C data declarations.

            It is an optional attribute since it may be missing in case the instance represents an element (e.g. a single array element) which has no name in the linker map.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McDataInstance.symbol";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MeasurementCalibrationSupport::McDataInstance -->
   <xsd:complexType abstract="false" mixed="false" name="MC-DATA-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>Describes the specific properties of one data instance in order to support measurement and/or calibration of this data instance.

      The most important attributes are:
      * Its shortName is copied from the ECU Flat map and will be used as identifier and for display by the MC system.
      * The category is copied from the corresponding data type (ApplicationDataType if defined, otherwise ImplementationDataType) as far as applicable.
      * The symbol is the one used in the programming language. It will be used to find out the actual memory address by the final generation tool with the help of linker generated information.

      It is assumed that in the M1 model this part and all the aggregated and referred elements (with the exception of the Flat Map) are completely generated from "upstream" information. This means, that even if an element like e.g. a CompuMethod is only used via reference here, it will be copied into the M1 artifact which holds the complete McSupportData for a given Implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="McDataInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:MC-DATA-INSTANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MC-DATA-INSTANCE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MC-DATA-INSTANCE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class MeasurementCalibrationSupport::McParameterElementGroup -->
   <xsd:group name="MC-PARAMETER-ELEMENT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Denotes a group of calibration parameters which are handled by the RTE as one data structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="McParameterElementGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Assigns a name to this element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McParameterElementGroup.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RAM-LOCATION-REF">
            <xsd:annotation>
               <xsd:documentation>Refers to the RAM location of this parameter group. To be used for the init-RAM method.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McParameterElementGroup.ramLocation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROM-LOCATION-REF">
            <xsd:annotation>
               <xsd:documentation>Refers to the ROM location of this parameter group. To be used for the init-RAM method.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McParameterElementGroup.romLocation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PARAMETER-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MeasurementCalibrationSupport::McParameterElementGroup -->
   <xsd:complexType abstract="false" mixed="false" name="MC-PARAMETER-ELEMENT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Denotes a group of calibration parameters which are handled by the RTE as one data structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="McParameterElementGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MC-PARAMETER-ELEMENT-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MeasurementCalibrationSupport::McSupportData -->
   <xsd:group name="MC-SUPPORT-DATA">
      <xsd:annotation>
         <xsd:documentation>Root element for all measurement and calibration support data related to one Implementation artifact on an ECU. There shall be one such element related to the RTE implementation (if it owns MC data) and a separate one for each module or component, which owns private MC data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="McSupportData"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EMULATION-SUPPORTS">
            <xsd:annotation>
               <xsd:documentation>Describes the calibration method used by the RTE. This information is not needed for A2L generation, but to setup software emulation in the ECU.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="McSupportData.emulationSupport";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MC-SW-EMULATION-METHOD-SUPPORT" type="AR:MC-SW-EMULATION-METHOD-SUPPORT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MC-PARAMETER-INSTANCES">
            <xsd:annotation>
               <xsd:documentation>A data instance to be used for calibration.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="McSupportData.mcParameterInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MC-DATA-INSTANCE" type="AR:MC-DATA-INSTANCE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MC-VARIABLE-INSTANCES">
            <xsd:annotation>
               <xsd:documentation>A data instance to be used for measurement.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="McSupportData.mcVariableInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MC-DATA-INSTANCE" type="AR:MC-DATA-INSTANCE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEASURABLE-SYSTEM-CONSTANT-VALUES-REFS">
            <xsd:annotation>
               <xsd:documentation>Sets of system constant values to be transferred to the MCD system, because the system constants have been specified with 
            "swCalibrationAccess" = readonly.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McSupportData.measurableSystemConstantValues";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEASURABLE-SYSTEM-CONSTANT-VALUES-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SW-SYSTEMCONSTANT-VALUE-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MeasurementCalibrationSupport::McSupportData -->
   <xsd:complexType abstract="false" mixed="false" name="MC-SUPPORT-DATA">
      <xsd:annotation>
         <xsd:documentation>Root element for all measurement and calibration support data related to one Implementation artifact on an ECU. There shall be one such element related to the RTE implementation (if it owns MC data) and a separate one for each module or component, which owns private MC data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="McSupportData"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MC-SUPPORT-DATA"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MeasurementCalibrationSupport::McSwEmulationMethodSupport -->
   <xsd:group name="MC-SW-EMULATION-METHOD-SUPPORT">
      <xsd:annotation>
         <xsd:documentation>This denotes the method used by the RTE to handle the calibration data. It is published by the RTE generator and can be used e.g. to generate the corresponding emulation method in a complex device driver.

      According to the actual method given by the category attribute,  not all attributes are always needed:

      * double pointered method: only baseReference is mandatory
      * single pointered method: only referenceTable is mandatory
      * initRam method: only elementGroup(s) are mandatory

      Note: For single/double pointered method the group locations are implicitly accessed via the reference table and their location can be found from the initial values in the M1 model of the respective pointers. Therefore, the description of elementGroups is not needed in these cases.  Likewise, for double pointered method the reference table description can be accessed via the M1 model under baseReference.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="McSwEmulationMethodSupport"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Assigns a name to this element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McSwEmulationMethodSupport.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Identifies the actual method. The possible names shall correspond to the symbols of the ECU configuration parameter for the calibration method of the RTE, and can include vendor specific methods.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McSwEmulationMethodSupport.category";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-REFERENCE-REF">
            <xsd:annotation>
               <xsd:documentation>Refers to the base pointer in case of the double-pointered method.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McSwEmulationMethodSupport.baseReference";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENT-GROUPS">
            <xsd:annotation>
               <xsd:documentation>Denotes the grouping of calibration parameters in the actual RTE code. Depending on the category, this information maybe required to set up the emulation code.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McSwEmulationMethodSupport.elementGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MC-PARAMETER-ELEMENT-GROUP" type="AR:MC-PARAMETER-ELEMENT-GROUP"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFERENCE-TABLE-REF">
            <xsd:annotation>
               <xsd:documentation>Refers to the pointer table in case of the single-pointered method.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="McSwEmulationMethodSupport.referenceTable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MeasurementCalibrationSupport::McSwEmulationMethodSupport -->
   <xsd:complexType abstract="false" mixed="false" name="MC-SW-EMULATION-METHOD-SUPPORT">
      <xsd:annotation>
         <xsd:documentation>This denotes the method used by the RTE to handle the calibration data. It is published by the RTE generator and can be used e.g. to generate the corresponding emulation method in a complex device driver.

      According to the actual method given by the category attribute,  not all attributes are always needed:

      * double pointered method: only baseReference is mandatory
      * single pointered method: only referenceTable is mandatory
      * initRam method: only elementGroup(s) are mandatory

      Note: For single/double pointered method the group locations are implicitly accessed via the reference table and their location can be found from the initial values in the M1 model of the respective pointers. Therefore, the description of elementGroups is not needed in these cases.  Likewise, for double pointered method the reference table description can be accessed via the M1 model under baseReference.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="McSwEmulationMethodSupport"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MC-SW-EMULATION-METHOD-SUPPORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::MeasuredExecutionTime -->
   <xsd:group name="MEASURED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Specifies the ExecutionTime which has been gathered using measurement means.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum measured execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime.maximumExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The minimum measured execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime.minimumExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NOMINAL-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The nominal measured execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime.nominalExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::MeasuredExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="MEASURED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Specifies the ExecutionTime which has been gathered using measurement means.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
         <xsd:group ref="AR:MEASURED-EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class HeapUsage::MeasuredHeapUsage -->
   <xsd:group name="MEASURED-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>The heap usage has been measured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AVERAGE-MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The average heap usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage.averageMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The maximum heap usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage.maximumMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The minimum heap usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage.minimumMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEST-PATTERN" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Description of the test pattern used to acquire the measured values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage.testPattern";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HeapUsage::MeasuredHeapUsage -->
   <xsd:complexType abstract="false" mixed="false" name="MEASURED-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>The heap usage has been measured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HEAP-USAGE"/>
         <xsd:group ref="AR:MEASURED-HEAP-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class StackUsage::MeasuredStackUsage -->
   <xsd:group name="MEASURED-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>The stack usage has been measured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AVERAGE-MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The average stack usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage.averageMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The maximum stack usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage.maximumMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The minimum stack usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage.minimumMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEST-PATTERN" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Description of the test pattern used to acquire the measured values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage.testPattern";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class StackUsage::MeasuredStackUsage -->
   <xsd:complexType abstract="false" mixed="false" name="MEASURED-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>The stack usage has been measured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:STACK-USAGE"/>
         <xsd:group ref="AR:MEASURED-STACK-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class MemorySectionUsage::MemorySection -->
   <xsd:group name="MEMORY-SECTION">
      <xsd:annotation>
         <xsd:documentation>Provides a description of an abstract memory section used in the Implementation for code or data. It must be declared by the Implementation Description of the module or component, which actually allocates the memory in its code. This means in case of data prototypes which are allocated by the RTE, that the generated Implementation Description of the RTE must contain the corresponding MemorySections.

      The attribute "symbol" (if symbol is missing: "shortName") defines the module or component specific section name used in the code. For details see the document "Specification of Memory Mapping".
      Typically the section name is build according the pattern:

      &amp;lt;SwAddrMethod shortName&amp;gt;[_&amp;lt;further specialization nominator&amp;gt;][_&amp;lt;alignment&amp;gt;] 
      where
      * '''[&amp;lt;SwAddrMethod shortName&amp;gt;]''' is the shortName of the referenced SwAddrMethod
      * '''[_&amp;lt;further specialization nominator&amp;gt;]''' is an optional infix to indicate the specialization in the case that several MemorySections for different purpose of the same Implementation Description referring to the same or equally named SwAddrMethods. 
      * '''[_&amp;lt;alignment&amp;gt;]''' is the alignment attributes value and is only applicable in the case that the memoryAllocationKeywordPolicy value of the referenced SwAddrMethod is set to AddrMethodShortNameAndAlignment 

      MemorySection used to Implement the code of RunnableEntitys and BswSchedulableEntitys shall have a symbol (if missing: shortName) identical to the referred SwAddrMethod to conform to the generated RTE header files.   

      In addition to the section name described above, a prefix is used in the corresponding macro code in order to define a name space. This prefix is by default given by the shortName of the BswModuleDescription resp. the SwcComponentType. It can be superseded by  the prefix attribute.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALIGNMENT" type="AR:ALIGNMENT-TYPE">
            <xsd:annotation>
               <xsd:documentation>The attribute describes the alignment of objects within this memory section.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.alignment";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTABLE-ENTITY-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the ExecutableEntitites located in this section. This allows to locate different ExecutableEntitities in different sections even if the associated SwAddrmethod is the same.

            This is applicable to code sections only.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.executableEntity";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EXECUTABLE-ENTITY-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:EXECUTABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPTIONS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="OPTION" type="AR:IDENTIFIER">
                     <xsd:annotation>
                        <xsd:documentation>This attribute introduces the ability to specify further intended properties of this MemorySection.
                     The following two values are standardized (to be used for code sections only and exclusively to each other):

                     * INLINE - The code section is declared with the compiler abstraction macro INLINE.

                     * LOCAL_INLINE  - The code section is declared with the compiler abstraction macro LOCAL_INLINE

                     In both cases (INLINE and LOCAL_INLINE) the inline expansion depends on the compiler specific implementation of these macros. Depending on this, the code section either corresponds to an actual section in memory or is put into the section of the caller. See AUTOSAR_SWS_CompilerAbstraction for more details.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.option";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PREFIX-REF">
            <xsd:annotation>
               <xsd:documentation>The prefix used to set the memory section's namespace in the code. The existence of a prefix element supersedes rules for a default prefix (such as the BswModuleDescription's shortName). This allows the user to define several name spaces for memory sections within the scope of one module, cluster or SWC.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.prefix";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SECTION-NAME-PREFIX--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIZE" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The size in bytes of the section.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.size";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ADDRMETHOD-REF">
            <xsd:annotation>
               <xsd:documentation>This assocation indicates that this module specific (abstract) memory section is part of an overal SwAddrMethod, referred by the upsream declarations (e.g. calibration parameters, data element prototypes, code entities) which share a common addressing strategy. This can be evaulated for the ECU configuration of the build support. 

            This association must always be declared by the Implementation description of the module or component, which allocates the memory in its code. This means in case of data prototypes which are allocated by the RTE, that the software components only declare the grouping of its data prototypes to SwAddrMethods, and the generated Implementation Description of the RTE actually sets up this association.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.swAddrmethod";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-ADDR-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Defines the section name as explained in the main description. By using this attribute for code generation (instead of the shortName) it is possible to define several different MemorySections having the same name - e.g. symbol = CODE - but using different sectionNamePrefixes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.symbol";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MemorySectionUsage::MemorySection -->
   <xsd:complexType abstract="false" mixed="false" name="MEMORY-SECTION">
      <xsd:annotation>
         <xsd:documentation>Provides a description of an abstract memory section used in the Implementation for code or data. It must be declared by the Implementation Description of the module or component, which actually allocates the memory in its code. This means in case of data prototypes which are allocated by the RTE, that the generated Implementation Description of the RTE must contain the corresponding MemorySections.

      The attribute "symbol" (if symbol is missing: "shortName") defines the module or component specific section name used in the code. For details see the document "Specification of Memory Mapping".
      Typically the section name is build according the pattern:

      &amp;lt;SwAddrMethod shortName&amp;gt;[_&amp;lt;further specialization nominator&amp;gt;][_&amp;lt;alignment&amp;gt;] 
      where
      * '''[&amp;lt;SwAddrMethod shortName&amp;gt;]''' is the shortName of the referenced SwAddrMethod
      * '''[_&amp;lt;further specialization nominator&amp;gt;]''' is an optional infix to indicate the specialization in the case that several MemorySections for different purpose of the same Implementation Description referring to the same or equally named SwAddrMethods. 
      * '''[_&amp;lt;alignment&amp;gt;]''' is the alignment attributes value and is only applicable in the case that the memoryAllocationKeywordPolicy value of the referenced SwAddrMethod is set to AddrMethodShortNameAndAlignment 

      MemorySection used to Implement the code of RunnableEntitys and BswSchedulableEntitys shall have a symbol (if missing: shortName) identical to the referred SwAddrMethod to conform to the generated RTE header files.   

      In addition to the section name described above, a prefix is used in the corresponding macro code in order to define a name space. This prefix is by default given by the shortName of the BswModuleDescription resp. the SwcComponentType. It can be superseded by  the prefix attribute.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:MEMORY-SECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MEMORY-SECTION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MEMORY-SECTION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ExecutionTime::MemorySectionLocation -->
   <xsd:group name="MEMORY-SECTION-LOCATION">
      <xsd:annotation>
         <xsd:documentation>Specifies in which hardware ProvidedMemorySegment the softwareMemorySection is located.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionLocation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-MEMORY-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the hardware ProvidedMemorySegment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionLocation.providedMemory";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-MEMORY-SECTION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the MemorySection which is mapped on a certain hardware memory segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionLocation.softwareMemorySection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MEMORY-SECTION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::MemorySectionLocation -->
   <xsd:complexType abstract="false" mixed="false" name="MEMORY-SECTION-LOCATION">
      <xsd:annotation>
         <xsd:documentation>Specifies in which hardware ProvidedMemorySegment the softwareMemorySection is located.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionLocation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MEMORY-SECTION-LOCATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InlineTextModel::MixedContentForLongName -->
   <xsd:group name="MIXED-CONTENT-FOR-LONG-NAME">
      <xsd:annotation>
         <xsd:documentation>This is the model for titles and long-names. It allows some emphasis and index entries but no reference target (which is provided by the identifiable in question). It is intended that the content model can also be rendered as plain text.

      The abstract class can be used for single language as well as for multi language elements.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForLongName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="TT" type="AR:TT">
               <xsd:annotation>
                  <xsd:documentation>This is a technical term.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForLongName.tt";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="E" type="AR:EMPHASIS-TEXT">
               <xsd:annotation>
                  <xsd:documentation>This is emphasized text</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForLongName.e";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUP" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is superscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForLongName.sup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUB" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is subscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForLongName.sub";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="60"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="IE" type="AR:INDEX-ENTRY">
               <xsd:annotation>
                  <xsd:documentation>This is an index entry.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForLongName.ie";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="70"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- element group for class InlineTextModel::MixedContentForOverviewParagraph -->
   <xsd:group name="MIXED-CONTENT-FOR-OVERVIEW-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This is the text model of a restricted paragraph item within a documentation. Such restricted paragraphs are used mainly for overview items, e.g. desc.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="BR" type="AR:BR">
               <xsd:annotation>
                  <xsd:documentation>This element is the same as function here as in a HTML document i.e. it forces a line break.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.br";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="TT" type="AR:TT">
               <xsd:annotation>
                  <xsd:documentation>This is a technical term.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.tt";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="XREF" type="AR:XREF">
               <xsd:annotation>
                  <xsd:documentation>This is a cross reference.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.xref";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="XREF-TARGET" type="AR:XREF-TARGET">
               <xsd:annotation>
                  <xsd:documentation>This element specifies a reference target which can be scattered throughout the text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.xrefTarget";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="E" type="AR:EMPHASIS-TEXT">
               <xsd:annotation>
                  <xsd:documentation>This is emphasis text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.e";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="60"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="FT" type="AR:FOOTNOTE-TEXT">
               <xsd:annotation>
                  <xsd:documentation>This is text printed as footnote.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.ft";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="70"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUP" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is subscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.sup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="80"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUB" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is superscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.sub";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="90"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="IE" type="AR:INDEX-ENTRY">
               <xsd:annotation>
                  <xsd:documentation>This is an index entry.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForOverviewParagraph.ie";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="100"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- element group for class InlineTextModel::MixedContentForParagraph -->
   <xsd:group name="MIXED-CONTENT-FOR-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This mainly represents the text model of a full blown paragraph within a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="TT" type="AR:TT">
               <xsd:annotation>
                  <xsd:documentation>This is a technical term.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.tt";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="BR" type="AR:BR">
               <xsd:annotation>
                  <xsd:documentation>This element is the same as function here as in a HTML document i.e. it forces a line break.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.br";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="XREF" type="AR:XREF">
               <xsd:annotation>
                  <xsd:documentation>This is a cross reference.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.xref";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="XREF-TARGET" type="AR:XREF-TARGET">
               <xsd:annotation>
                  <xsd:documentation>This element specifies a reference target which can be scattered throughout the text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.xrefTarget";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="60"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="E" type="AR:EMPHASIS-TEXT">
               <xsd:annotation>
                  <xsd:documentation>This is emphasized text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.e";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="70"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="FT" type="AR:FOOTNOTE-TEXT">
               <xsd:annotation>
                  <xsd:documentation>This is a footnote within a parapgraph.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.ft";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="80"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUP" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is superscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.sup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="90"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUB" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is subscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.sub";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="100"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="IE" type="AR:INDEX-ENTRY">
               <xsd:annotation>
                  <xsd:documentation>This is an index entry.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.ie";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="110"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="STD" type="AR:STD">
               <xsd:annotation>
                  <xsd:documentation>This is a refeernce to a standard.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.std";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="120"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="XDOC" type="AR:XDOC">
               <xsd:annotation>
                  <xsd:documentation>This is a reference to a printable external document.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.xdoc";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="130"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="XFILE" type="AR:XFILE">
               <xsd:annotation>
                  <xsd:documentation>This represents a reference to an external file which usually cannot be printed.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForParagraph.xfile";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="140"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- element group for class InlineTextModel::MixedContentForPlainText -->
   <xsd:group name="MIXED-CONTENT-FOR-PLAIN-TEXT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForPlainText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTENTS" type="AR:VERBATIM-STRING--SIMPLE">
            <xsd:annotation>
               <xsd:documentation>This is the contents of the language specific text.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForPlainText.contents";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="false";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class InlineTextModel::MixedContentForUnitNames -->
   <xsd:group name="MIXED-CONTENT-FOR-UNIT-NAMES">
      <xsd:annotation>
         <xsd:documentation>This is the text model for items with subscript and superscripts such as measurement unit designations. It is intended, that such models can easily be transcribed to a plain text model either by using appropriate characters or by transcribing like m^2.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForUnitNames"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="SUP" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is superscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForUnitNames.sup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SUB" type="AR:SUPSCRIPT">
               <xsd:annotation>
                  <xsd:documentation>This is subscript text.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForUnitNames.sub";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- element group for class InlineTextModel::MixedContentForVerbatim -->
   <xsd:group name="MIXED-CONTENT-FOR-VERBATIM">
      <xsd:annotation>
         <xsd:documentation>This is the text model for preformatted (verbatim) text. It mainly consists of attributes which do not change the length on rendering.

      This class represents multilingual verbatim. Verbatim, sometimes called preformatted text, means that white-space is maintained. When verbatim is rendered in PDF or Online media, it is rendered using a monospaced font while white-space is obeyed. Blanks are rendered as well as newline characters.

      Even if there are inline elements, the length of the data must not be influenced by formatting.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForVerbatim"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="TT" type="AR:TT">
               <xsd:annotation>
                  <xsd:documentation>This represents a technical term in verbatim. Note that it's the responibility of the user not to take a tt that would add additional character to the text (such as SgmlElement).</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForVerbatim.tt";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="E" type="AR:EMPHASIS-TEXT">
               <xsd:annotation>
                  <xsd:documentation>This is emphsized text. Note that in verbatim, the attribute font should not be considered since verbatim is always rendered as monospace font.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForVerbatim.e";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="XREF" type="AR:XREF">
               <xsd:annotation>
                  <xsd:documentation>This is a crossreference within a verbatim text. The attributes may disturb the arrangement of the text. It is subject to the author to keep this under control.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForVerbatim.xref";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="BR" type="AR:BR">
               <xsd:annotation>
                  <xsd:documentation>This element is the same as function here as in a HTML document i.e. it forces a line break.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContentForVerbatim.br";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- element group for class Figure::MlFigure -->
   <xsd:group name="ML-FIGURE">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to embed a figure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlFigure"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIGURE-CAPTION" type="AR:CAPTION">
            <xsd:annotation>
               <xsd:documentation>This element specifies the title of an illustration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlFigure.figureCaption";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset=""</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="L-GRAPHIC" type="AR:L-GRAPHIC"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VERBATIM" type="AR:MULTI-LANGUAGE-VERBATIM">
            <xsd:annotation>
               <xsd:documentation>&lt;verbatim&gt; is a paragraph in which white-space (in particular blanks and line feeds) is obeyed. This enables basic preformatting to be carried out, which can even be displayed on simple devices. Behavior is the same as PRE in HTML .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlFigure.verbatim";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Figure::MlFigure -->
   <xsd:attributeGroup name="ML-FIGURE">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to embed a figure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlFigure"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="FRAME" type="AR:FRAME-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Used to defined the frame line around a figure. It can assume the following values:

         * TOP - Border at the top of the figure
         * BOTTOM - Border at the bottom of the figure
         * TOPBOT - Borders at the top and bottom of  the figure
         * ALL - Borders all around the figure
         * SIDES - Borders at the sides of the figure
         * NONE - No borders around the figure</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlFigure.frame";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HELP-ENTRY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies an entry point in an online help system to be linked with the parent class. The syntax must be defined by the applied help system respectively help system generator.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlFigure.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="PGWIDE" type="AR:PGWIDE-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Used to indicate wether the figure should take the complete page width (value = "pgwide") or not (value = "noPgwide").</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlFigure.pgwide";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Figure::MlFigure -->
   <xsd:complexType abstract="false" mixed="false" name="ML-FIGURE">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to embed a figure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlFigure"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:ML-FIGURE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:ML-FIGURE"/>
   </xsd:complexType>
   <!-- element group for class Formula::MlFormula -->
   <xsd:group name="ML-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a formula in a documentation. The formula can be expressed by various means. If more than one representation is available, they need to be consistent. The rendering system can use the representation which is most appropriate.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FORMULA-CAPTION" type="AR:CAPTION">
            <xsd:annotation>
               <xsd:documentation>This element specifies the identification or heading of a formula.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlFormula.formulaCaption";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="L-GRAPHIC" type="AR:L-GRAPHIC"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VERBATIM" type="AR:MULTI-LANGUAGE-VERBATIM">
            <xsd:annotation>
               <xsd:documentation>this represents a formula using only text and white-space. It can be used to denote the formula in a kind of pseudo code or whatever appears approprate.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlFormula.verbatim";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEX-MATH" type="AR:MULTI-LANGUAGE-PLAIN-TEXT">
            <xsd:annotation>
               <xsd:documentation>this is the TeX representation of TeX formula. A TeX formula can be processed by a TeX or a LaTeX processor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlFormula.texMath";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="GENERIC-MATH" type="AR:MULTI-LANGUAGE-PLAIN-TEXT">
            <xsd:annotation>
               <xsd:documentation>this rpresents the semantic and mathematical descriptions which are processed by a math-processor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlFormula.genericMath";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Formula::MlFormula -->
   <xsd:complexType abstract="false" mixed="false" name="ML-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a formula in a documentation. The formula can be expressed by various means. If more than one representation is available, they need to be consistent. The rendering system can use the representation which is most appropriate.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:ML-FORMULA"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class ModeDeclarationGroup::ModeAccessPoint -->
   <xsd:group name="MODE-ACCESS-POINT">
      <xsd:annotation>
         <xsd:documentation>A ModeAccessPoint is required by a RunnableEntity owned by a Mode Manager or Mode User.
      Its semantics implies the ability to access the current mode (provided by the RTE)  of a ModeDeclarationGroupPrototype's ModeDeclarationGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeAccessPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP-IREF">
            <xsd:annotation>
               <xsd:documentation>The mode declaration group that is accessed by this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeGroup.ModeAccessPoint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="P-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF" type="AR:P-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF"/>
                  <xsd:element name="R-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF" type="AR:R-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclarationGroup::ModeAccessPoint -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-ACCESS-POINT">
      <xsd:annotation>
         <xsd:documentation>A ModeAccessPoint is required by a RunnableEntity owned by a Mode Manager or Mode User.
      Its semantics implies the ability to access the current mode (provided by the RTE)  of a ModeDeclarationGroupPrototype's ModeDeclarationGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeAccessPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MODE-ACCESS-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ModeDeclaration::ModeDeclaration -->
   <xsd:group name="MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>Declaration of one Mode. The name and semantics of a special mode is not defined in the meta-model.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The RTE shall take the value of this attribute for generating the source code representation of this ModeDeclaration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclaration.value";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclaration::ModeDeclaration -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>Declaration of one Mode. The name and semantics of a special mode is not defined in the meta-model.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:MODE-DECLARATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODE-DECLARATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-DECLARATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ModeDeclaration::ModeDeclarationGroup -->
   <xsd:group name="MODE-DECLARATION-GROUP">
      <xsd:annotation>
         <xsd:documentation>A collection of Mode Declarations. Also, the initial mode is explicitly identified.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ModeDeclarationGroups";mmt.qualifiedName="ModeDeclarationGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INITIAL-MODE-REF">
            <xsd:annotation>
               <xsd:documentation>The initial mode of the ModeDeclarationGroup. This mode is active before any mode switches occurred.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroup.initialMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATIONS">
            <xsd:annotation>
               <xsd:documentation>The ModeDeclarations collected in this ModeDeclarationGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeDeclaration.ModeDeclarationGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION" type="AR:MODE-DECLARATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ON-TRANSITION-VALUE" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The value of this attribute shall be taken into account by the RTE generator for programmatically representing a value used for the transition between two Statuus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroup.onTransitionValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclaration::ModeDeclarationGroup -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DECLARATION-GROUP">
      <xsd:annotation>
         <xsd:documentation>A collection of Mode Declarations. Also, the initial mode is explicitly identified.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="ModeDeclarationGroups";mmt.qualifiedName="ModeDeclarationGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:MODE-DECLARATION-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODE-DECLARATION-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ModeDeclaration::ModeDeclarationGroupPrototype -->
   <xsd:group name="MODE-DECLARATION-GROUP-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>The ModeDeclarationGroupPrototype specifies a set of Modes (ModeDeclarationGroup) which is provided or required in the given context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALIBRATION-ACCESS" type="AR:SW-CALIBRATION-ACCESS-ENUM">
            <xsd:annotation>
               <xsd:documentation>This allows for specifying whether or not the enclosing ModeDeclarationGroupPrototype can be measured at run-time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototype.swCalibrationAccess";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-TREF">
            <xsd:annotation>
               <xsd:documentation>The "collection of ModeDeclarations" ( = ModeDeclarationGroup) supported by a component</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototype.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclaration::ModeDeclarationGroupPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DECLARATION-GROUP-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>The ModeDeclarationGroupPrototype specifies a set of Modes (ModeDeclarationGroup) which is provided or required in the given context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:MODE-DECLARATION-GROUP-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-DECLARATION-GROUP-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ModeDeclaration::ModeDeclarationGroupPrototypeMapping -->
   <xsd:group name="MODE-DECLARATION-GROUP-PROTOTYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two particular unequally named but otherwise compatible ModeDeclarationGroupPrototypes in the given context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIRST-MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>ModeDeclarationGroupPrototype to be mapped.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototypeMapping.firstModeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECOND-MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>ModeDeclarationGroupPrototype to be mapped.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototypeMapping.secondModeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclaration::ModeDeclarationGroupPrototypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DECLARATION-GROUP-PROTOTYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two particular unequally named but otherwise compatible ModeDeclarationGroupPrototypes in the given context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MODE-DECLARATION-GROUP-PROTOTYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ModeDeclaration::ModeDeclarationGroupPrototypeRefConditional -->
   <xsd:group name="MODE-DECLARATION-GROUP-PROTOTYPE-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATION-GROUP-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclaration::ModeDeclarationGroupPrototypeRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DECLARATION-GROUP-PROTOTYPE-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MODE-DECLARATION-GROUP-PROTOTYPE-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::ModeDrivenTransmissionModeCondition -->
   <xsd:group name="MODE-DRIVEN-TRANSMISSION-MODE-CONDITION">
      <xsd:annotation>
         <xsd:documentation>The condition defined by this class evaluates to true if one of the referenced modeDeclarations (OR associated) is active. All referenced modeDeclarations shall be from the same ModeDeclarationGroup.

      The condition is used to define which TransmissionMode shall be activated using Com_SwitchIpduTxMode.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDrivenTransmissionModeCondition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATION-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to one modeDeclaration which is OR associated in the context of the ModeDrivenTransmissionModeCondition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDrivenTransmissionModeCondition.modeDeclaration";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::ModeDrivenTransmissionModeCondition -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DRIVEN-TRANSMISSION-MODE-CONDITION">
      <xsd:annotation>
         <xsd:documentation>The condition defined by this class evaluates to true if one of the referenced modeDeclarations (OR associated) is active. All referenced modeDeclarations shall be from the same ModeDeclarationGroup.

      The condition is used to define which TransmissionMode shall be activated using Com_SwitchIpduTxMode.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDrivenTransmissionModeCondition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MODE-DRIVEN-TRANSMISSION-MODE-CONDITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::ModeGroupInAtomicSwcInstanceRef -->
   <xsd:group name="MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeGroupInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <!-- Association <<atpDerived>>contextPort skipped -->
         <!-- Association <<atpDerived>>target skipped -->
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class InstanceRefs::ModeInBswModuleDescriptionInstanceRef -->
   <xsd:group name="MODE-IN-BSW-MODULE-DESCRIPTION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeInBswModuleDescriptionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-MODE-DECLARATION-GROUP-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeInBswModuleDescriptionInstanceRef.contextModeDeclarationGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-MODE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeInBswModuleDescriptionInstanceRef.targetMode";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::ModeInBswModuleDescriptionInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-IN-BSW-MODULE-DESCRIPTION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeInBswModuleDescriptionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:MODE-IN-BSW-MODULE-DESCRIPTION-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ModeInterfaceMapping -->
   <xsd:group name="MODE-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of unequal named ModeDeclarationGroupPrototypes in context of two different ModeInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-MAPPING" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>Mapping of two ModeDeclarationGroupPrototypes in two different ModeInterfaces</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeMapping.ModeInterfaceMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ModeInterfaceMapping -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of unequal named ModeDeclarationGroupPrototypes in context of two different ModeInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-INTERFACE-MAPPING"/>
         <xsd:group ref="AR:MODE-INTERFACE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::ModePortAnnotation -->
   <xsd:group name="MODE-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port used for calibration regarding a certain ModeDeclarationGroupPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModePortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>The instance of annotated ModeDeclarationGroupPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModePortAnnotation.modeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::ModePortAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port used for calibration regarding a certain ModeDeclarationGroupPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModePortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:MODE-PORT-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ModeDeclaration::ModeRequestTypeMap -->
   <xsd:group name="MODE-REQUEST-TYPE-MAP">
      <xsd:annotation>
         <xsd:documentation>Specifies a mapping between a ModeDeclarationGroup and an ImplementationDataType. This ImplementationDataType shall be used to implement the ModeDeclarationGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeRequestTypeMap"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-DATA-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the corresponding ImplementationDataType. It shall be modeled along the idea of an "unsigned integer-like" data type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeRequestTypeMap.implementationDataType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>This is the corresponding ModeDeclarationGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeRequestTypeMap.modeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclaration::ModeRequestTypeMap -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-REQUEST-TYPE-MAP">
      <xsd:annotation>
         <xsd:documentation>Specifies a mapping between a ModeDeclarationGroup and an ImplementationDataType. This ImplementationDataType shall be used to implement the ModeDeclarationGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeRequestTypeMap"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MODE-REQUEST-TYPE-MAP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ModeSwitchInterface -->
   <xsd:group name="MODE-SWITCH-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A mode switch interface declares a ModeDeclarationGroupPrototype to be sent and received.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="ModeSwitchInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE">
            <xsd:annotation>
               <xsd:documentation>The ModeDeclarationGroupPrototype of this mode interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeGroup.interface";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ModeSwitchInterface -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A mode switch interface declares a ModeDeclarationGroupPrototype to be sent and received.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="ModeSwitchInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:MODE-SWITCH-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ModeDeclarationGroup::ModeSwitchPoint -->
   <xsd:group name="MODE-SWITCH-POINT">
      <xsd:annotation>
         <xsd:documentation>A ModeSwitchPoint is required by a RunnableEntity owned a Mode Manager. Its semantics implies the ability to initiate a mode switch.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP-IREF" type="AR:P-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The mode declaration group that is switched by this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeGroup.ModeSwitchPoint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclarationGroup::ModeSwitchPoint -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-POINT">
      <xsd:annotation>
         <xsd:documentation>A ModeSwitchPoint is required by a RunnableEntity owned a Mode Manager. Its semantics implies the ability to initiate a mode switch.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:MODE-SWITCH-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODE-SWITCH-POINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-SWITCH-POINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Communication::ModeSwitchReceiverComSpec -->
   <xsd:group name="MODE-SWITCH-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of RPortPrototypes with respect to mode communication</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENHANCED-MODE-API" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This controls the creation of the enhanced mode API that returns information about the previous mode and the next mode. If set to TRUE the enhanced mode API is supposed to be generated. For more details please refer to the SWS_RTE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchReceiverComSpec.enhancedModeApi";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTS-ASYNCHRONOUS-MODE-SWITCH" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute controls the behavior of the corresponding RPortPrototype with respect to the question whether it can deal with asynchronous mode switch requests, i.e. if set to true, the RPortPrototype is able to deal with an asynchronous mode switch request.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchReceiverComSpec.supportsAsynchronousModeSwitch";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ModeSwitchReceiverComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of RPortPrototypes with respect to mode communication</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:R-PORT-COM-SPEC"/>
         <xsd:group ref="AR:MODE-SWITCH-RECEIVER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::ModeSwitchSenderComSpec -->
   <xsd:group name="MODE-SWITCH-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of PPortPrototypes with respect to mode communication</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENHANCED-MODE-API" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This controls the creation of the enhanced mode API that returns information about the previous mode and the next mode. If set to TRUE the enhanced mode API is supposed to be generated. For more details please refer to the SWS_RTE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchSenderComSpec.enhancedModeApi";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Mode Declaration Group (of the same Port Interface) to which these communication attributes apply.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchSenderComSpec.modeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-SWITCHED-ACK" type="AR:MODE-SWITCHED-ACK-REQUEST">
            <xsd:annotation>
               <xsd:documentation>If this aggregation exists an acknowledgement for the successful processing of the mode switch request is required.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeSwitchedAck.ModeSwitchSenderComSpec";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="QUEUE-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Length of call queue on the mode user side. The queue is implemented by the RTE. The value must be greater or equal to 1. Setting the value of queueLength to 1 implies that incoming requests are rejected while another request that arrived earlier is being processed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchSenderComSpec.queueLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ModeSwitchSenderComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of PPortPrototypes with respect to mode communication</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:P-PORT-COM-SPEC"/>
         <xsd:group ref="AR:MODE-SWITCH-SENDER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::ModeSwitchedAckEvent -->
   <xsd:group name="MODE-SWITCHED-ACK-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced modes have been received or an error occurs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>Mode switch point that triggers the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="event.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-SWITCH-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::ModeSwitchedAckEvent -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCHED-ACK-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced modes have been received or an error occurs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:MODE-SWITCHED-ACK-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Communication::ModeSwitchedAckRequest -->
   <xsd:group name="MODE-SWITCHED-ACK-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests acknowledgements that a mode switch has been proceeded successfully</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Number of seconds before an error is reported or in case of allowed redundancy, the value is sent again.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckRequest.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ModeSwitchedAckRequest -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCHED-ACK-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests acknowledgements that a mode switch has been proceeded successfully</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MODE-SWITCHED-ACK-REQUEST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class AdminData::Modification -->
   <xsd:group name="MODIFICATION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability  to record what has changed in a document in comparison to its predecessor.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Modification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANGE" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This property denotes the one particular change which was performed on the object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Modification.change";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REASON" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This property represents the rationale for the particular change.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Modification.reason";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AdminData::Modification -->
   <xsd:complexType abstract="false" mixed="false" name="MODIFICATION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability  to record what has changed in a document in comparison to its predecessor.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Modification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MODIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MsrQuery::MsrQueryArg -->
   <xsd:group name="MSR-QUERY-ARG">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryArg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARG" type="AR:STRING--SIMPLE">
            <xsd:annotation>
               <xsd:documentation>This is the value of the argument.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryArg.arg";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="false";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class MsrQuery::MsrQueryArg -->
   <xsd:attributeGroup name="MSR-QUERY-ARG">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryArg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="SI" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This denotes the name of the query argument (semantic information)</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryArg.si";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class MsrQuery::MsrQueryArg -->
   <xsd:complexType name="MSR-QUERY-ARG">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryArg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:MSR-QUERY-ARG"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- element group for class MsrQuery::MsrQueryChapter -->
   <xsd:group name="MSR-QUERY-CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a query which yields a set of chapters as a result.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryChapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSR-QUERY-PROPS" type="AR:MSR-QUERY-PROPS">
            <xsd:annotation>
               <xsd:documentation>This is argument and properties of the chapter query.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryChapter.msrQueryProps";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSR-QUERY-RESULT-CHAPTER" type="AR:MSR-QUERY-RESULT-CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This represents the result of the query.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryChapter.msrQueryResultChapter";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MsrQuery::MsrQueryChapter -->
   <xsd:complexType abstract="false" mixed="false" name="MSR-QUERY-CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a query which yields a set of chapters as a result.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryChapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:MSR-QUERY-CHAPTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class MsrQuery::MsrQueryP1 -->
   <xsd:group name="MSR-QUERY-P-1">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a query wihich yelds the content of a topic as a result.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryP1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSR-QUERY-PROPS" type="AR:MSR-QUERY-PROPS">
            <xsd:annotation>
               <xsd:documentation>This is argument and properties of the paragraph query.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryP1.msrQueryProps";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSR-QUERY-RESULT-P-1" type="AR:TOPIC-CONTENT">
            <xsd:annotation>
               <xsd:documentation>This represents the result of the query.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryP1.msrQueryResultP1";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MsrQuery::MsrQueryP1 -->
   <xsd:complexType abstract="false" mixed="false" name="MSR-QUERY-P-1">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a query wihich yelds the content of a topic as a result.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryP1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:MSR-QUERY-P-1"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class MsrQuery::MsrQueryProps -->
   <xsd:group name="MSR-QUERY-PROPS">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to specificy a query which yields some documentation text. The qualities of the result are determined by the context in which the query is used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSR-QUERY-NAME" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This element specifies the name of the MSR-QUERY triggered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryProps.msrQueryName";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="MSR-QUERY-ARG" type="AR:MSR-QUERY-ARG">
            <xsd:annotation>
               <xsd:documentation>This element specifies an argument within an MsrQuery.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryProps.msrQueryArg";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMENT" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This element contains a commentary in text form.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryProps.comment";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MsrQuery::MsrQueryProps -->
   <xsd:complexType abstract="false" mixed="false" name="MSR-QUERY-PROPS">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to specificy a query which yields some documentation text. The qualities of the result are determined by the context in which the query is used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MSR-QUERY-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MsrQuery::MsrQueryResultChapter -->
   <xsd:group name="MSR-QUERY-RESULT-CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the result of an msrquery which is a set of chapters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryResultChapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CHAPTER" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This is one particular chapter in the query result.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryResultChapter.chapter";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MsrQuery::MsrQueryResultChapter -->
   <xsd:complexType abstract="false" mixed="false" name="MSR-QUERY-RESULT-CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the result of an msrquery which is a set of chapters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryResultChapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MSR-QUERY-RESULT-CHAPTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MsrQuery::MsrQueryResultTopic1 -->
   <xsd:group name="MSR-QUERY-RESULT-TOPIC-1">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to express the result of a query which is a set of topics.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryResultTopic1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="TOPIC-1" type="AR:TOPIC-1">
            <xsd:annotation>
               <xsd:documentation>This represents one particular topic in the query result.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryResultTopic1.topic1";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MsrQuery::MsrQueryResultTopic1 -->
   <xsd:complexType abstract="false" mixed="false" name="MSR-QUERY-RESULT-TOPIC-1">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to express the result of a query which is a set of topics.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryResultTopic1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MSR-QUERY-RESULT-TOPIC-1"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MsrQuery::MsrQueryTopic1 -->
   <xsd:group name="MSR-QUERY-TOPIC-1">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a query which yields a set of topics as a result.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryTopic1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSR-QUERY-PROPS" type="AR:MSR-QUERY-PROPS">
            <xsd:annotation>
               <xsd:documentation>This is argument and properties of the topic query.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryTopic1.msrQueryProps";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSR-QUERY-RESULT-TOPIC-1" type="AR:MSR-QUERY-RESULT-TOPIC-1">
            <xsd:annotation>
               <xsd:documentation>This represents the result of the query.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryTopic1.msrQueryResultTopic1";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MsrQuery::MsrQueryTopic1 -->
   <xsd:complexType abstract="false" mixed="false" name="MSR-QUERY-TOPIC-1">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a query which yields a set of topics as a result.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MsrQueryTopic1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:MSR-QUERY-TOPIC-1"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class MultilanguageData::MultiLanguageOverviewParagraph -->
   <xsd:group name="MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This is the content of a multilingual paragraph in an overview item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageOverviewParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-2" type="AR:L-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This represents the text in one particular language.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageOverviewParagraph.l2";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MultilanguageData::MultiLanguageOverviewParagraph -->
   <xsd:complexType abstract="false" mixed="false" name="MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This is the content of a multilingual paragraph in an overview item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageOverviewParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MultilanguageData::MultiLanguageParagraph -->
   <xsd:group name="MULTI-LANGUAGE-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This is the content model of a multilingual paragraph in a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-1" type="AR:L-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This is the paragraph content in one partiucular language.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageParagraph.l1";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class MultilanguageData::MultiLanguageParagraph -->
   <xsd:attributeGroup name="MULTI-LANGUAGE-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This is the content model of a multilingual paragraph in a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="HELP-ENTRY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies an entry point in an online help system to be linked with the parent class. The syntax must be defined by the applied help system respectively help system generator.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageParagraph.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class MultilanguageData::MultiLanguageParagraph -->
   <xsd:complexType abstract="false" mixed="false" name="MULTI-LANGUAGE-PARAGRAPH">
      <xsd:annotation>
         <xsd:documentation>This is the content model of a multilingual paragraph in a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageParagraph"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:MULTI-LANGUAGE-PARAGRAPH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:MULTI-LANGUAGE-PARAGRAPH"/>
   </xsd:complexType>
   <!-- element group for class MultilanguageData::MultiLanguagePlainText -->
   <xsd:group name="MULTI-LANGUAGE-PLAIN-TEXT">
      <xsd:annotation>
         <xsd:documentation>This is a multilingual plaint Text.It is intended to be rendered as a paragraph.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguagePlainText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-10" type="AR:L-PLAIN-TEXT">
            <xsd:annotation>
               <xsd:documentation>This is the plain text in one particular language.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguagePlainText.l10";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MultilanguageData::MultiLanguagePlainText -->
   <xsd:complexType abstract="false" mixed="false" name="MULTI-LANGUAGE-PLAIN-TEXT">
      <xsd:annotation>
         <xsd:documentation>This is a multilingual plaint Text.It is intended to be rendered as a paragraph.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguagePlainText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MULTI-LANGUAGE-PLAIN-TEXT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MultilanguageData::MultiLanguageVerbatim -->
   <xsd:group name="MULTI-LANGUAGE-VERBATIM">
      <xsd:annotation>
         <xsd:documentation>This class represents multilingual Verbatim. Verbatim means, that white-space is maintained. When Verbatim is rendered in PDF or Online media, white-space is obeyed. Blanks are rendered as well as newline characters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageVerbatim"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-5" type="AR:L-VERBATIM">
            <xsd:annotation>
               <xsd:documentation>This the text in one particular language.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageVerbatim.l5";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class MultilanguageData::MultiLanguageVerbatim -->
   <xsd:attributeGroup name="MULTI-LANGUAGE-VERBATIM">
      <xsd:annotation>
         <xsd:documentation>This class represents multilingual Verbatim. Verbatim means, that white-space is maintained. When Verbatim is rendered in PDF or Online media, white-space is obeyed. Blanks are rendered as well as newline characters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageVerbatim"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ALLOW-BREAK" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This indicates if the verbatim text might be split on multiple pages. Default is "1".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageVerbatim.allowBreak";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="FLOAT" type="AR:FLOAT-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicate whether it is allowed to break the element. The following values are allowed:</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageVerbatim.float";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HELP-ENTRY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies an entry point in an online help system to be linked with the parent class. The syntax must be defined by the applied help system respectively help system generator.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageVerbatim.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="PGWIDE" type="AR:PGWIDE-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Used to indicate wether the figure should take the complete page width (value = "pgwide") or not (value = "noPgwide").</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageVerbatim.pgwide";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class MultilanguageData::MultiLanguageVerbatim -->
   <xsd:complexType abstract="false" mixed="false" name="MULTI-LANGUAGE-VERBATIM">
      <xsd:annotation>
         <xsd:documentation>This class represents multilingual Verbatim. Verbatim means, that white-space is maintained. When Verbatim is rendered in PDF or Online media, white-space is obeyed. Blanks are rendered as well as newline characters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiLanguageVerbatim"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:MULTI-LANGUAGE-VERBATIM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:MULTI-LANGUAGE-VERBATIM"/>
   </xsd:complexType>
   <!-- element group for class MultidimensionalTime::MultidimensionalTime -->
   <xsd:group name="MULTIDIMENSIONAL-TIME">
      <xsd:annotation>
         <xsd:documentation>This is used to specify a multidimensional time value based on ASAM CSE codes. It is specified by a code which defined the basis of the time and a scaling factor which finally determines the time value.

      If for example the the cseCode is 100 and the cseCodeFactor is 360, it represents 360 angular degrees.
      If the cseCode is 2 and the cseCodeFactor is 50 it represents 50 microseconds</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultidimensionalTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CSE-CODE" type="AR:CSE-CODE-TYPE-STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies the time base by means of CSE codes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultidimensionalTime.cseCode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CSE-CODE-FACTOR" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The scaling factor for the time value based on the specified CSE code.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultidimensionalTime.cseCodeFactor";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MultidimensionalTime::MultidimensionalTime -->
   <xsd:complexType abstract="false" mixed="false" name="MULTIDIMENSIONAL-TIME">
      <xsd:annotation>
         <xsd:documentation>This is used to specify a multidimensional time value based on ASAM CSE codes. It is specified by a code which defined the basis of the time and a scaling factor which finally determines the time value.

      If for example the the cseCode is 100 and the cseCodeFactor is 360, it represents 360 angular degrees.
      If the cseCode is 2 and the cseCodeFactor is 50 it represents 50 microseconds</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultidimensionalTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MULTIDIMENSIONAL-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MultilanguageData::MultilanguageLongName -->
   <xsd:group name="MULTILANGUAGE-LONG-NAME">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a long name which acts in the role of a headline. It is intended for human readers. Per language it should be around max 80 characters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultilanguageLongName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-4" type="AR:L-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This is the long name in one particular language.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultilanguageLongName.l4";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MultilanguageData::MultilanguageLongName -->
   <xsd:complexType abstract="false" mixed="false" name="MULTILANGUAGE-LONG-NAME">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a long name which acts in the role of a headline. It is intended for human readers. Per language it should be around max 80 characters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultilanguageLongName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MULTILANGUAGE-LONG-NAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Identifiable::MultilanguageReferrable -->
   <xsd:group name="MULTILANGUAGE-REFERRABLE">
      <xsd:annotation>
         <xsd:documentation>Instances of this class can be referred to by their identifier (while adhering to namespace borders). They also may have a longName. But they are not considered to contribute substantially to the overall structure of an AUTOSAR description. In particular it does not contain other Referrables.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultilanguageReferrable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LONG-NAME" type="AR:MULTILANGUAGE-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This specifies the long name of the object. Long name is targeted to human readers and acts like a headline.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultilanguageReferrable.longName";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class CoreCommunication::MultiplexedIPdu -->
   <xsd:group name="MULTIPLEXED-I-PDU">
      <xsd:annotation>
         <xsd:documentation>A MultiplexedPdu (i.e. NOT a COM I-PDU) contains a DynamicPart, an optional StaticPart and a selectorField. In case of multiplexing this IPdu is routed between the Pdu Multiplexer and the Interface Layer. 

      A multiplexer is used to define variable parts within an IPdu that may carry different signals. The receivers of such a IPdu can determine which signalPdus are transmitted by evaluating the selector field, which carries a unique selector code for each sub-part.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="MultiplexedIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DYNAMIC-PARTS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="dynamicPart.MultiplexedIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DYNAMIC-PART" type="AR:DYNAMIC-PART"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SELECTOR-FIELD-BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the order of the bytes of the selectorField and the packing into the MultiplexedIPdu. The byte ordering "Little Endian" (MostSignificantByteLast) and "Big Endian" (MostSignificantByteFirst) can be selected.
            A mix between Little Endian and Big Endian within a MultiplexedIPdu (staticPart, dynamicPart, selectorField) is not allowed. 

            In a complete System Description this attribute is mandatory. If a MultiplexedPdu is received by a Pdu Gateway and is not delivered to the IPduM but routed directly to a bus interface then the content of the MulitplexedPdu doesn't need to be described in the System Extract/Ecu Extract. To support this use case the multiplicity is set to 0..1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.selectorFieldByteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SELECTOR-FIELD-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The size in bits of the selector field shall be configurable in a range of 0-2031 bits. 
            In a complete System Description this attribute is mandatory. If a MultiplexedPdu is received by a Pdu Gateway and is not delivered to the IPduM but routed directly to a bus interface then the content of the MulitplexedPdu doesn't need to be described in the System Extract/Ecu Extract. To support this use case the multiplicity is set to 0..1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.selectorFieldLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SELECTOR-FIELD-START-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter is necessary to describe the position of the selector field within the IPdu.

            Note that the absolute position of the selectorField in the MultiplexedIPdu is determined by the definition of the selectorFieldByteOrder attribute of the Multiplexed Pdu. If Big Endian is specified, the start position indicates
            the bit position of the most significant bit in the IPdu. If Little Endian is specified, the start position indicates the bit position of the least significant bit in the IPdu. In AUTOSAR the bit counting is always set to "sawtooth" and the bit order is set to "Decreasing".

            In a complete System Description this attribute is mandatory. If a MultiplexedPdu is received by a Pdu Gateway and is not delivered to the IPduM but routed directly to a bus interface then the content of the MulitplexedPdu doesn't need to be described in the System Extract/Ecu Extract. To support this use case the multiplicity is set to 0..1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.selectorFieldStartPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATIC-PARTS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="staticPart.MultiplexedIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="STATIC-PART" type="AR:STATIC-PART"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-MODE" type="AR:TRIGGER-MODE">
            <xsd:annotation>
               <xsd:documentation>IPduM can be configured to send a transmission request for the new multiplexed IPdu to the PDU-Router because of the trigger conditions/ modes that are described in the TriggerMode enumeration.

            In a complete System Description this attribute is mandatory. If a MultiplexedPdu is received by a Pdu Gateway and is not delivered to the IPduM but routed directly to a bus interface then the content of the MulitplexedPdu doesn't need to be described in the System Extract/Ecu Extract. To support this use case the multiplicity is set to 0..1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.triggerMode";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNUSED-BIT-PATTERN" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>AUTOSAR COM and AUTOSAR IPDUM are filling not used areas of an IPdu with this bit-pattern. This attribute is mandatory to avoid undefined behavior. This byte-pattern will be repeated throughout the IPdu. 

            In a complete System Description this attribute is mandatory. If a MultiplexedPdu is received by a Pdu Gateway and is not delivered to the IPduM but routed directly to a bus interface then the content of the MulitplexedPdu doesn't need to be described in the System Extract/Ecu Extract. To support this use case the multiplicity is set to 0..1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.unusedBitPattern";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::MultiplexedIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="MULTIPLEXED-I-PDU">
      <xsd:annotation>
         <xsd:documentation>A MultiplexedPdu (i.e. NOT a COM I-PDU) contains a DynamicPart, an optional StaticPart and a selectorField. In case of multiplexing this IPdu is routed between the Pdu Multiplexer and the Interface Layer. 

      A multiplexer is used to define variable parts within an IPdu that may carry different signals. The receivers of such a IPdu can determine which signalPdus are transmitted by evaluating the selector field, which carries a unique selector code for each sub-part.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="MultiplexedIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDU"/>
         <xsd:group ref="AR:I-PDU"/>
         <xsd:group ref="AR:MULTIPLEXED-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::MultiplexedPart -->
   <xsd:group name="MULTIPLEXED-PART">
      <xsd:annotation>
         <xsd:documentation>The StaticPart and the DynamicPart have common properties. Both can be separated in multiple segments within the multiplexed PDU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-POSITIONS">
            <xsd:annotation>
               <xsd:documentation>The StaticPart and the DynamicPart can be separated in multiple segments within the multiplexed PDU. Therefore the StaticPart and
            the DynamicPart can contain multiple SegmentPositions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="segmentPosition.MultiplexedPart";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SEGMENT-POSITION" type="AR:SEGMENT-POSITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class CoreCommunication::NPdu -->
   <xsd:group name="N-PDU">
      <xsd:annotation>
         <xsd:documentation>This is a Pdu of the Transport Layer.
      The main purpose of the TP Layer is to segment and reassemble IPdus. 

      In case of a Pdu Gateway when the source and the target network are of the same kind (e.g. Can-to-Can routing) it is possible to optimize the routing. The incoming NPdu can be directly forwarded to the PduR and then be sent on the outbound bus without any (resource consuming) TP module involvement. To support this use case the NPdu is located under the IPdu. But in the AUTOSAR Layered Architecture the NPdu is not a specialization of an IPdu.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="NPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class CoreCommunication::NPdu -->
   <xsd:complexType abstract="false" mixed="false" name="N-PDU">
      <xsd:annotation>
         <xsd:documentation>This is a Pdu of the Transport Layer.
      The main purpose of the TP Layer is to segment and reassemble IPdus. 

      In case of a Pdu Gateway when the source and the target network are of the same kind (e.g. Can-to-Can routing) it is possible to optimize the routing. The incoming NPdu can be directly forwarded to the PduR and then be sent on the outbound bus without any (resource consuming) TP module involvement. To support this use case the NPdu is located under the IPdu. But in the AUTOSAR Layered Architecture the NPdu is not a specialization of an IPdu.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="NPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDU"/>
         <xsd:group ref="AR:I-PDU"/>
         <xsd:group ref="AR:N-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="N-PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="N-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class NetworkManagement::NmCluster -->
   <xsd:group name="NM-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>Set of NM nodes coordinated with use of the NM algorithm.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CLUSTER-REF">
            <xsd:annotation>
               <xsd:documentation>Asscociation to a CommunicationCluster in the topology description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCluster.communicationCluster";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CLUSTER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CHANNEL-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Channel identification number of the corresponding channel. Must be unique over all NmClusters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCluster.nmChannelId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CHANNEL-SLEEP-MASTER" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This parameter shall be set to indicate if the sleep of this network can be absolutely decided by the local node only and that no other nodes can oppose that decision.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCluster.nmChannelSleepMaster";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NODES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="nmNode.NmCluster";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-NM-NODE" type="AR:CAN-NM-NODE"/>
                  <xsd:element name="FLEXRAY-NM-NODE" type="AR:FLEXRAY-NM-NODE"/>
                  <xsd:element name="UDP-NM-NODE" type="AR:UDP-NM-NODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-SYNCHRONIZING-NETWORK" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If this parameter is true, then this network is a synchronizing network for the NM coordination cluster which it belongs to. The network is expected to call Nm_SynchronizationPoint() at regular intervals.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCluster.nmSynchronizingNetwork";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class NetworkManagement::NmClusterCoupling -->
   <xsd:group name="NM-CLUSTER-COUPLING">
      <xsd:annotation>
         <xsd:documentation>Attributes that are valid for each of the referenced (coupled) clusters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmClusterCoupling"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class NetworkManagement::NmConfig -->
   <xsd:group name="NM-CONFIG">
      <xsd:annotation>
         <xsd:documentation>Contains the all configuration elements for AUTOSAR Nm.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="NmConfigs";mmt.qualifiedName="NmConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CLUSTERS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="nmCluster.NmConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-NM-CLUSTER" type="AR:CAN-NM-CLUSTER"/>
                  <xsd:element name="FLEXRAY-NM-CLUSTER" type="AR:FLEXRAY-NM-CLUSTER"/>
                  <xsd:element name="UDP-NM-CLUSTER" type="AR:UDP-NM-CLUSTER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CLUSTER-COUPLINGS">
            <xsd:annotation>
               <xsd:documentation>Collection of NmClusterCouplings

            atpVariation: Derived, because NmCluster can vary.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="nmClusterCoupling.NmConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-NM-CLUSTER-COUPLING" type="AR:CAN-NM-CLUSTER-COUPLING"/>
                  <xsd:element name="FLEXRAY-NM-CLUSTER-COUPLING" type="AR:FLEXRAY-NM-CLUSTER-COUPLING"/>
                  <xsd:element name="UDP-NM-CLUSTER-COUPLING" type="AR:UDP-NM-CLUSTER-COUPLING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IF-ECUS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="nmIfEcu.NmConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="NM-ECU" type="AR:NM-ECU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::NmConfig -->
   <xsd:complexType abstract="false" mixed="false" name="NM-CONFIG">
      <xsd:annotation>
         <xsd:documentation>Contains the all configuration elements for AUTOSAR Nm.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="NmConfigs";mmt.qualifiedName="NmConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:NM-CONFIG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::NmCoordinator -->
   <xsd:group name="NM-COORDINATOR">
      <xsd:annotation>
         <xsd:documentation>A NM coordinator is an ECU, which is connected to at least two busses, and where the requirement exists that shutdown of NM of at least two of these busses (also referred to as coordinated busses) has to be performed synchronously.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmCoordinator"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEX" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Identification of the NMCoordinator.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCoordinator.index";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-ACTIVE-COORDINATOR" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute indicates whether a NM Coordinator is an active gateway (true) or a passive gateway (false).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCoordinator.nmActiveCoordinator";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-GLOBAL-COORDINATOR-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum shutdown time (in seconds) of a connected and coordinated NM-Cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCoordinator.nmGlobalCoordinatorTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NODE-REFS">
            <xsd:annotation>
               <xsd:documentation>reference to busses (via NmNodes) that are coordinated by the NmCoordinator.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCoordinator.nmNode";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="NM-NODE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:NM-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-SHUTDOWN-DELAY-TIMER" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time in seconds which the NM Coordination algorithm shall delay the release of the referenced cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmCoordinator.nmShutdownDelayTimer";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::NmCoordinator -->
   <xsd:complexType abstract="false" mixed="false" name="NM-COORDINATOR">
      <xsd:annotation>
         <xsd:documentation>A NM coordinator is an ECU, which is connected to at least two busses, and where the requirement exists that shutdown of NM of at least two of these busses (also referred to as coordinated busses) has to be performed synchronously.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmCoordinator"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:NM-COORDINATOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::NmEcu -->
   <xsd:group name="NM-ECU">
      <xsd:annotation>
         <xsd:documentation>ECU on which NM is running.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BUS-SPECIFIC-NM-ECU">
            <xsd:annotation>
               <xsd:documentation>Busspecific NmEcu attributes</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="busSpecificNmEcu.NmEcu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CAN-NM-ECU" type="AR:CAN-NM-ECU"/>
                  <xsd:element name="FLEXRAY-NM-ECU" type="AR:FLEXRAY-NM-ECU"/>
                  <xsd:element name="UDP-NM-ECU" type="AR:UDP-NM-ECU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Asscociation to an ECUInstance in the topology description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-BUS-SYNCHRONIZATION-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables bus synchronization support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmBusSynchronizationEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-COM-CONTROL-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables the Communication Control support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmComControlEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-COORDINATOR" type="AR:NM-COORDINATOR">
            <xsd:annotation>
               <xsd:documentation>Nm ECU may coordinate different clusters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="nmCoordinator.NmEcu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CYCLETIME-MAIN-FUNCTION" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>The period between successive calls to the Main Function of the NM Interface in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmCycletimeMainFunction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MULTIPLE-CHANNELS-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables channel multiplicity support.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="NmEcu.nmMultipleChannelsEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NODE-DETECTION-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables the Request Repeat Message Request support. Only valid if nmNodeIdEnabled is set to true.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmNodeDetectionEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NODE-ID-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables the source node identifier.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmNodeIdEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-PASSIVE-MODE-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute is deprecated and shall not be used. It is only kept in the model for backward compatibility reasons and will be removed in the future. The passive mode is configurable per channel with the attribute nmPassiveModeEnabled in NmNode.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="NmEcu.nmPassiveModeEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-PDU-RX-INDICATION-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Switch for enabling the PDU Rx Indication.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmPduRxIndicationEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REMOTE-SLEEP-IND-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Switch for enabling remote sleep indication support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmRemoteSleepIndEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MSG-IND-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Switch for enabling the Repeat Message Bit Indication.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmRepeatMsgIndEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-STATE-CHANGE-IND-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables the CAN Network Management state change notification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmStateChangeIndEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-USER-DATA-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Switch for enabling user data support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu.nmUserDataEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::NmEcu -->
   <xsd:complexType abstract="false" mixed="false" name="NM-ECU">
      <xsd:annotation>
         <xsd:documentation>ECU on which NM is running.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NM-ECU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="NM-ECU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NM-ECU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class NetworkManagement::NmNode -->
   <xsd:group name="NM-NODE">
      <xsd:annotation>
         <xsd:documentation>The linking of NmEcus to NmClusters is realized via the NmNodes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTROLLER-REF">
            <xsd:annotation>
               <xsd:documentation>Asscociation to an CommunicationController in the topology description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmNode.controller";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONTROLLER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IF-ECU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the NmEcu that contains this NmNode. (CommunicationController that is referenced by the NmNode shall be contained in the EcuInstance that is referenced by the NmEcu).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmNode.nmIfEcu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:NM-ECU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NODE-ID" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Node identifier of local NmNode. Must be unique in the NmCluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmNode.nmNodeId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-PASSIVE-MODE-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables support of the Passive Mode. The passive mode is configurable per channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmNode.nmPassiveModeEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RX-NM-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>receive NM Pdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmNode.rxNmPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RX-NM-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:NM-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TX-NM-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>transmit NM Pdu</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmNode.txNmPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TX-NM-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:NM-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="NM-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-NM-NODE"/>
         <xsd:enumeration value="FLEXRAY-NM-NODE"/>
         <xsd:enumeration value="NM-NODE"/>
         <xsd:enumeration value="UDP-NM-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::NmPdu -->
   <xsd:group name="NM-PDU">
      <xsd:annotation>
         <xsd:documentation>Network Management Pdu</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="NmPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-TO-I-PDU-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>This optional aggregation is used to describe NmUserData that is transmitted in the NmPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="iSignalToIPduMapping.NmPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-TO-I-PDU-MAPPING" type="AR:I-SIGNAL-TO-I-PDU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-DATA-INFORMATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines if the Pdu contains NM Data.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu.nmDataInformation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-VOTE-INFORMATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines if the Pdu contains NM Vote information.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu.nmVoteInformation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNUSED-BIT-PATTERN" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>AUTOSAR COM is filling not used areas of an Pdu with this bit-pattern. This attribute can only be used if the nmDataInformation attribute is set to true.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu.unusedBitPattern";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::NmPdu -->
   <xsd:complexType abstract="false" mixed="false" name="NM-PDU">
      <xsd:annotation>
         <xsd:documentation>Network Management Pdu</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="NmPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDU"/>
         <xsd:group ref="AR:NM-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="NM-PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NM-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Communication::NonqueuedReceiverComSpec -->
   <xsd:group name="NONQUEUED-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to non-queued receiving.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALIVE-TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Specify the amount of time (in seconds) after which the software component (via the RTE)  needs to be notified if the corresponding data item have not been received according to the specified timing description.

            If the aliveTimeout attribute is 0 no timeout monitoring shall be performed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedReceiverComSpec.aliveTimeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENABLE-UPDATE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute controls whether application code is entitled to check whether the value of the corresponding VariableDataPrototype has been updated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedReceiverComSpec.enableUpdate";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FILTER" type="AR:DATA-FILTER">
            <xsd:annotation>
               <xsd:documentation>The applicable filter algorithm for filtering the value of the corresponding dataElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="filter.NonqueuedReceiverComSpec";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-NEVER-RECEIVED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies whether for the corresponding VariableDataPrototype the "never received" flag is available. If yes, the RTE is supposed to assume that initially the VariableDataPrototype has not been received before.
            After the first reception of the corresponding VariableDataPrototype the flag is cleared.
            If the value of this attribute is set to TRUE the flag is required. If set to FALSE, the RTE shall not support the "never received" functionality for the corresponding VariableDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedReceiverComSpec.handleNeverReceived";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-TIMEOUT-TYPE" type="AR:HANDLE-TIMEOUT-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls the behavior with respect to the handling of timeouts.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedReceiverComSpec.handleTimeoutType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>Initial value to be used in case the sending component is not yet initialized. If the sender also specifies an initial value the receiver's value will be used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedReceiverComSpec.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::NonqueuedReceiverComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="NONQUEUED-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to non-queued receiving.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:R-PORT-COM-SPEC"/>
         <xsd:group ref="AR:RECEIVER-COM-SPEC"/>
         <xsd:group ref="AR:NONQUEUED-RECEIVER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::NonqueuedSenderComSpec -->
   <xsd:group name="NONQUEUED-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for non-queued sender/receiver communication (sender side)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>Initial value to be sent if sender component is not yet fully initialized, but receiver needs data already.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedSenderComSpec.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::NonqueuedSenderComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="NONQUEUED-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for non-queued sender/receiver communication (sender side)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NonqueuedSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:P-PORT-COM-SPEC"/>
         <xsd:group ref="AR:SENDER-COM-SPEC"/>
         <xsd:group ref="AR:NONQUEUED-SENDER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Note::Note -->
   <xsd:group name="NOTE">
      <xsd:annotation>
         <xsd:documentation>This represents a note in a documentation, which may be used to highlight specific issues such as hints or caution notes.

      N.B., Documentation notes can be nested recursively, even if this is not really intended. In case of nested notes e.g. the note icon of inner notes might be omitted while rendering the note.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Note"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LABEL" type="AR:MULTILANGUAGE-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This label can be used to superseed the default label specified by the noteType attribute. It is in particular useful for noteType="other".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Note.label";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:DOCUMENTATION-BLOCK"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Note::Note -->
   <xsd:attributeGroup name="NOTE">
      <xsd:annotation>
         <xsd:documentation>This represents a note in a documentation, which may be used to highlight specific issues such as hints or caution notes.

      N.B., Documentation notes can be nested recursively, even if this is not really intended. In case of nested notes e.g. the note icon of inner notes might be omitted while rendering the note.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Note"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="NOTE-TYPE" type="AR:NOTE-TYPE-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Type of the Note. Default is "HINT"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Note.noteType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Note::Note -->
   <xsd:complexType abstract="false" mixed="false" name="NOTE">
      <xsd:annotation>
         <xsd:documentation>This represents a note in a documentation, which may be used to highlight specific issues such as hints or caution notes.

      N.B., Documentation notes can be nested recursively, even if this is not really intended. In case of nested notes e.g. the note icon of inner notes might be omitted while rendering the note.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Note"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:NOTE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:NOTE"/>
   </xsd:complexType>
   <!-- element group for class Constants::NumericalValueSpecification -->
   <xsd:group name="NUMERICAL-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>A numerical  ValueSpecification which is intended to be assigned to a Primitive data element.
      Note that the numerical value is a variant, it can be computed by a formula.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NumericalValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This is the value itself.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="NumericalValueSpecification.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::NumericalValueSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="NUMERICAL-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>A numerical  ValueSpecification which is intended to be assigned to a Primitive data element.
      Note that the numerical value is a variant, it can be computed by a formula.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NumericalValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-SPECIFICATION"/>
         <xsd:group ref="AR:NUMERICAL-VALUE-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::NumericalValueVariationPoint -->
   <xsd:group name="NUMERICAL-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for Numerical attributes.

      Note that this class might be used in the extended meta-model only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NumericalValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class VariantHandling::NumericalValueVariationPoint -->
   <xsd:complexType abstract="false" mixed="true" name="NUMERICAL-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for Numerical attributes.

      Note that this class might be used in the extended meta-model only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NumericalValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-DEPENDENT-FORMULA"/>
         <xsd:group ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
         <xsd:group ref="AR:ABSTRACT-NUMERICAL-VARIATION-POINT"/>
         <xsd:group ref="AR:NUMERICAL-VALUE-VARIATION-POINT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
   </xsd:complexType>
   <!-- element group for class NvBlockComponent::NvBlockDataMapping -->
   <xsd:group name="NV-BLOCK-DATA-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping between the VariableDataPrototypes in the NvBlockComponents ports and the VariableDataPrototypes of the RAM Block.

      The data types of the referenced VariableDataPrototypes in the ports and the referenced sub-element (inside a CompositeDataType) of the VariableDataPrototype representing the RAM Block shall be compatible.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockDataMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NV-RAM-BLOCK-ELEMENT" type="AR:AUTOSAR-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a VariableDataPrototype of a Ram Block.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="nvRamBlockElement.NvBlockDataMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="READ-NV-DATA" type="AR:AUTOSAR-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a VariableDataPrototype of a pPort of the NvBlockComponent providing read access to the NvRam Mirror.
            If there is no port providing read access (write-only) the reference can be omitted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="readNvData.NvBlockDataMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITTEN-NV-DATA" type="AR:AUTOSAR-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a VariableDataPrototype of a rPort of the NvBlockComponent providing write access to the NvRam Mirror.
            If there is no port providing write access (read-only) the reference can be omitted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="writtenNvData.NvBlockDataMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NvBlockComponent::NvBlockDataMapping -->
   <xsd:complexType abstract="false" mixed="false" name="NV-BLOCK-DATA-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping between the VariableDataPrototypes in the NvBlockComponents ports and the VariableDataPrototypes of the RAM Block.

      The data types of the referenced VariableDataPrototypes in the ports and the referenced sub-element (inside a CompositeDataType) of the VariableDataPrototype representing the RAM Block shall be compatible.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockDataMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:NV-BLOCK-DATA-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class NvBlockComponent::NvBlockDescriptor -->
   <xsd:group name="NV-BLOCK-DESCRIPTOR">
      <xsd:annotation>
         <xsd:documentation>Specifies the properties of exactly on NvBlock.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockDescriptor"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLIENT-SERVER-PORTS">
            <xsd:annotation>
               <xsd:documentation>The RoleBasedPortAssignement defines which client server port of the NvBlockSwComponentType serves for which kind of service or notification. In case of notifications one common callback function is provided by the RTE for each individual kind of notification defined by the "role".

            The aggregation of RoleBasedPortAssignment is subject to variability with the purpose to support the conditional existence of ports.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="clientServerPort.NvBlockDescriptor";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-PORT-ASSIGNMENT" type="AR:ROLE-BASED-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSTANT-VALUE-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the ConstanSpecificationMapping to be applied for the particular NvBlock</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockDescriptor.constantValueMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONSTANT-VALUE-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CONSTANT-SPECIFICATION-MAPPING-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-TYPE-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the DataTypeMapping to be applied for the particular NvBlock</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockDescriptor.dataTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-TYPE-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:DATA-TYPE-MAPPING-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INSTANTIATION-DATA-DEF-PROPSS">
            <xsd:annotation>
               <xsd:documentation>The purpose of InstantiationDataDefProps are the refinement of some data def properties of individual instantiations within the context of a NvBlockSwComponentType.


            The aggregation of InstantiationDataDefProps is subject to variability with the purpose to support the conditional existence of ports, component internal memory objects and those attributes. 
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="instantiationDataDefProps.NvBlockDescriptor";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INSTANTIATION-DATA-DEF-PROPS" type="AR:INSTANTIATION-DATA-DEF-PROPS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NV-BLOCK-DATA-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Defines the mapping between the VariableDataPrototypes in the NvBlockComponents ports and the VariableDataPrototypes of the RAM Block.

            The aggregation of NvBlockDataMapping is subject to variability with the purpose to support the conditional existence of nv data ports. 
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="nvBlockDataMapping.NvBlockDescriptor";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="NV-BLOCK-DATA-MAPPING" type="AR:NV-BLOCK-DATA-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NV-BLOCK-NEEDS" type="AR:NV-BLOCK-NEEDS">
            <xsd:annotation>
               <xsd:documentation>Specifies the abstract needs on the configuration of the NvRam Manager for the single NvRam Block described by this NvBlockDescriptor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="nvBlockNeeds.NvBlockDescriptor";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RAM-BLOCK" type="AR:VARIABLE-DATA-PROTOTYPE">
            <xsd:annotation>
               <xsd:documentation>Defines the RAM Block of the NvBlock provided by NvBlockSwComponentType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ramBlock.NvBlockDescriptor";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROM-BLOCK" type="AR:PARAMETER-DATA-PROTOTYPE">
            <xsd:annotation>
               <xsd:documentation>Defines the ROM Block of the NvBlock provided by NvBlockSwComponentType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="romBlock.NvBlockDescriptor";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NvBlockComponent::NvBlockDescriptor -->
   <xsd:complexType abstract="false" mixed="false" name="NV-BLOCK-DESCRIPTOR">
      <xsd:annotation>
         <xsd:documentation>Specifies the properties of exactly on NvBlock.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockDescriptor"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NV-BLOCK-DESCRIPTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::NvBlockNeeds -->
   <xsd:group name="NV-BLOCK-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of a single Nv block.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALC-RAM-BLOCK-CRC" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines if CRC (re)calculation for the permanent RAM block is required.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.calcRamBlockCrc";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHECK-STATIC-BLOCK-ID" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines if the Static Block Id check shall be enabled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.checkStaticBlockId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="N-DATA-SETS" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of data sets to be provided by the NVRAM manager for this block.
            This is the total number of ROM blocks and NV Blocks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.nDataSets";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="N-ROM-BLOCKS" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of ROM blocks to be provided by the NVRAM manager for this block.
            Please not that these multiple ROM Blocks are given in a contiguous area.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.nRomBlocks";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="READONLY" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>True: data of this block are write protected for normal operation (but protection can be disabled)
            false: no restriction</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.readonly";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RELIABILITY" type="AR:NV-BLOCK-NEEDS-RELIABILITY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Reliability against data loss on the non-volatile medium.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.reliability";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESISTANT-TO-CHANGED-SW" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines whether an Nv block shall be treated resistant to configuration changes (true) or not (false). For details how to handle initialization in the latter case, refer to the NVRAM specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.resistantToChangedSw";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESTORE-AT-START" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines whether the associated RAM mirror block shall be implicitly restored during startup by the basic SW or not. Only relevant if a RAM mirror block is associated with this port (for Software Components the latter is modeled via SwcServiceDependency).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.restoreAtStart";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STORE-AT-SHUTDOWN" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines whether or not the associated RAM mirror block shall be implicitly stored during shutdown by the basic SW. 

            This is only relevant if a RAM mirror block is associated with this port (for software-components the latter is modeled by means of a SwcServiceDependency).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.storeAtShutdown";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITE-ONLY-ONCE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines write protection after first write:
            true: This block is prevented from being changed/erased or being replaced with the default ROM data after first initialization by the SWC.
            false: No such restriction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.writeOnlyOnce";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITE-VERIFICATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Defines if Write Verification shall be enabled for this Nv Block.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.writeVerification";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITING-FREQUENCY" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Provides the amount of updates to this block from the application point of view. It has to be provided in "number of write access per year".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.writingFrequency";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITING-PRIORITY" type="AR:NV-BLOCK-NEEDS-WRITING-PRIORITY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Requires the priority of writing this block in case of concurrent requests to write other blocks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.writingPriority";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::NvBlockNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="NV-BLOCK-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of a single Nv block.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:NV-BLOCK-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Components::NvBlockSwComponentType -->
   <xsd:group name="NV-BLOCK-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The NvBlockSwComponentType defines non volatile data which data can be shared between SwComponentPrototypes. The non volatile data of the NvBlockSwComponentType are accessible via provided and required ports.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="NvBlockSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NV-BLOCK-DESCRIPTORS">
            <xsd:annotation>
               <xsd:documentation>Specification of the properties of exactly on NvBlock.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="NvBlockSwComponentType.nvBlockDescriptor";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="NV-BLOCK-DESCRIPTOR" type="AR:NV-BLOCK-DESCRIPTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::NvBlockSwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="NV-BLOCK-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The NvBlockSwComponentType defines non volatile data which data can be shared between SwComponentPrototypes. The non volatile data of the NvBlockSwComponentType are accessible via provided and required ports.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="NvBlockSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:NV-BLOCK-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::NvDataInterface -->
   <xsd:group name="NV-DATA-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A non volatile data interface declares a number of VariableDataPrototypes to be exchanged between non volatile block components and atomic software components.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="NvDataInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NV-DATAS">
            <xsd:annotation>
               <xsd:documentation>The VariableDataPrototype of this nv data interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="nvData.interface";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-DATA-PROTOTYPE" type="AR:VARIABLE-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::NvDataInterface -->
   <xsd:complexType abstract="false" mixed="false" name="NV-DATA-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A non volatile data interface declares a number of VariableDataPrototypes to be exchanged between non volatile block components and atomic software components.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="NvDataInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:DATA-INTERFACE"/>
         <xsd:group ref="AR:NV-DATA-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::NvDataPortAnnotation -->
   <xsd:group name="NV-DATA-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port regarding a certain VariableDataPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvDataPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>The instance of nv data annotated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvDataPortAnnotation.variable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::NvDataPortAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="NV-DATA-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port regarding a certain VariableDataPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvDataPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:NV-DATA-PORT-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::NvProvideComSpec -->
   <xsd:group name="NV-PROVIDE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of RPortPrototypes with respect to Nv data communication on the provided side.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvProvideComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RAM-BLOCK-INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>This represents the initial value of the RAM block that corresponds to the referenced variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvProvideComSpec.ramBlockInitValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROM-BLOCK-INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>This represents the initial value of the ROM block that corresponds to the referenced variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvProvideComSpec.romBlockInitValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the variable for which the ComSpec is specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvProvideComSpec.variable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::NvProvideComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="NV-PROVIDE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of RPortPrototypes with respect to Nv data communication on the provided side.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvProvideComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:P-PORT-COM-SPEC"/>
         <xsd:group ref="AR:NV-PROVIDE-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::NvRequireComSpec -->
   <xsd:group name="NV-REQUIRE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of RPortPrototypes with respect to Nv data communication on the required side.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvRequireComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>The initial value owned by the NvComSpec</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvRequireComSpec.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>The VariableDataPrototype the ComSpec applies for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvRequireComSpec.variable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::NvRequireComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="NV-REQUIRE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of RPortPrototypes with respect to Nv data communication on the required side.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvRequireComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:R-PORT-COM-SPEC"/>
         <xsd:group ref="AR:NV-REQUIRE-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdControlServiceNeeds -->
   <xsd:group name="OBD-CONTROL-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Service 08 (request control of on-board system) in relation to a particular test-Identifier (TID) supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdControlServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEST-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Test Identifier (TID) according to ISO 15031-5.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdControlServiceNeeds.testId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdControlServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-CONTROL-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Service 08 (request control of on-board system) in relation to a particular test-Identifier (TID) supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdControlServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:OBD-CONTROL-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdInfoServiceNeeds -->
   <xsd:group name="OBD-INFO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Services in relation to a given InfoType (OBD Service 09) which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdInfoServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute is applicable only if the ServiceNeed is aggregated within BswModuleDependency.

            This attribute represents the length of data (in bytes) provided for this InfoType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdInfoServiceNeeds.dataLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INFO-TYPE" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>The InfoType according to ISO 15031-5</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdInfoServiceNeeds.infoType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdInfoServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-INFO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Services in relation to a given InfoType (OBD Service 09) which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdInfoServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:OBD-INFO-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdMonitorServiceNeeds -->
   <xsd:group name="OBD-MONITOR-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Services in relation to a particular on-board monitoring test supported by this component or module. (OBD Service 06).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ON-BOARD-MONITOR-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>On-board monitor ID according to ISO 15031-5.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds.onBoardMonitorId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEST-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Test Identifier (TID) according to ISO 15031-5.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds.testId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-AND-SCALING-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Unit and scaling ID according to ISO 15031-5.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds.unitAndScalingId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdMonitorServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-MONITOR-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Services in relation to a particular on-board monitoring test supported by this component or module. (OBD Service 06).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:OBD-MONITOR-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdPidServiceNeeds -->
   <xsd:group name="OBD-PID-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Services in relation to a particular PID (parameter identifier) which is supported by this component or module.

      In case of using a client/server communicated value, the related value shall be communicated via the port referenced by asssignedPort. The details of this communication (e.g. appropriate naming conventions) are specified in the relate software specifications (SWS).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute is applicable only if the ServiceNeed is aggregated within BswModuleDependency.

            This attribute represents the length of data (in bytes) provided for this particular PID signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds.dataLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Standardized parameter identifier (PID) according to the OBD standard specified in attribute "standard".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds.parameterId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STANDARD" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Annotates the standard according to which the PID is given, e.g. "ISO15031-5" or "SAE J1979 Rev May 2007".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds.standard";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdPidServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-PID-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Services in relation to a particular PID (parameter identifier) which is supported by this component or module.

      In case of using a client/server communicated value, the related value shall be communicated via the port referenced by asssignedPort. The details of this communication (e.g. appropriate naming conventions) are specified in the relate software specifications (SWS).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:OBD-PID-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdRatioServiceNeeds -->
   <xsd:group name="OBD-RATIO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Services in relation to a particular "ratio monitoring" which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTION-TYPE" type="AR:OBD-RATIO-CONNECTION-KIND-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines how the DEM is connected to the component or module to perform the IUMPR service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.connectionType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IUMPR-GROUP" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>Defines the IUMPR Group of the SAE standard. Note that possible values are not predefined by an enumeration meta-type in order to make the meta-model independent of the details of the SAE standard. Possible values are currently (AUTOSAR R3.1):
            CAT1 CAT2 OXS1 OXS2 EGR SAIR EVAP SECOXS1 SECOXS2 NMHCCAT NOXCAT NOXADSORB PMFILTER EGSENSOR BOOSTPRS NOGROUP NONE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.iumprGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RATE-BASED-MONITORED-EVENT-REF">
            <xsd:annotation>
               <xsd:documentation>The rate based monitored Diagnostic Event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.rateBasedMonitoredEvent";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DIAGNOSTIC-EVENT-NEEDS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-FID-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the primary Function Inhibition Identifier used for the rate based monitor. This is an optional attribute.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.usedFid";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FUNCTION-INHIBITION-NEEDS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-SECONDARY-FID-REFS">
            <xsd:annotation>
               <xsd:documentation>This represents the secondary Function Inhibition Identifier used for the rate based monitor. This is an optional attribute. The "primary" and all "secondary" FID inhibitions are combined by "OR".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.usedSecondaryFid";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="USED-SECONDARY-FID-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FUNCTION-INHIBITION-NEEDS--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdRatioServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-RATIO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a component or module on the configuration of OBD Services in relation to a particular "ratio monitoring" which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:group ref="AR:OBD-RATIO-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class OffsetConstraint::OffsetTimingConstraint -->
   <xsd:group name="OFFSET-TIMING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>Bounds the time offset between the occurrence of two timing events, without requiring a direct functional dependency between the source and the target.

      If the target event occurs, it is expected to occur earliest with the minimum, and latest with the maximum offset relatively after the occurrence of the source event. Note: not every source event occurrence must be followed by a target event occurrence.

      In contrast to LatencyTimingConstraint, there must not necessarily be a causal dependency between the source and target event.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OffsetTimingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The timing event that the target event is to be synchronized with.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OffsetTimingConstraint.source";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REF">
            <xsd:annotation>
               <xsd:documentation>The timing event which is expected to occur timely after the source event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OffsetTimingConstraint.target";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The mimum offset the target event occurs relatively after the occurrence of the source event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OffsetTimingConstraint.minimum";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum offset the target event occurs relatively after the occurrence of the source event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OffsetTimingConstraint.maximum";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class OffsetConstraint::OffsetTimingConstraint -->
   <xsd:complexType abstract="false" mixed="false" name="OFFSET-TIMING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>Bounds the time offset between the occurrence of two timing events, without requiring a direct functional dependency between the source and the target.

      If the target event occurs, it is expected to occur earliest with the minimum, and latest with the maximum offset relatively after the occurrence of the source event. Note: not every source event occurrence must be followed by a target event occurrence.

      In contrast to LatencyTimingConstraint, there must not necessarily be a causal dependency between the source and target event.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OffsetTimingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:OFFSET-TIMING-CONSTRAINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::OperationArgumentInComponentInstanceRef -->
   <xsd:group name="OPERATION-ARGUMENT-IN-COMPONENT-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef.base";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef.contextComponent";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef.contextPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-OPERATION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef.contextOperation";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROOT-ARGUMENT-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef.rootArgumentDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ARGUMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef.contextDataPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef.targetDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::OperationArgumentInComponentInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="OPERATION-ARGUMENT-IN-COMPONENT-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationArgumentInComponentInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:OPERATION-ARGUMENT-IN-COMPONENT-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::OperationInAtomicSwcInstanceRef -->
   <xsd:group name="OPERATION-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <!-- Association <<atpDerived>>contextPort skipped -->
         <!-- Association <<atpDerived>>targetOperation skipped -->
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class InstanceRefs::OperationInSystemInstanceRef -->
   <xsd:group name="OPERATION-IN-SYSTEM-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInSystemInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationInSystemInstanceRef.contextComposition";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ROOT-SW-COMPOSITION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationInSystemInstanceRef.contextComponent";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationInSystemInstanceRef.contextPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-OPERATION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationInSystemInstanceRef.targetOperation";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::OperationInSystemInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="OPERATION-IN-SYSTEM-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInSystemInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:OPERATION-IN-SYSTEM-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::OperationInvokedEvent -->
   <xsd:group name="OPERATION-INVOKED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The OperationInvokedEvent references the ClientServerOperation invoked by the client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInvokedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-IREF" type="AR:P-OPERATION-IN-ATOMIC-SWC-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The operation to be executed as the consequence of the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.event";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::OperationInvokedEvent -->
   <xsd:complexType abstract="false" mixed="false" name="OPERATION-INVOKED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The OperationInvokedEvent references the ClientServerOperation invoked by the client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInvokedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:OPERATION-INVOKED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::PModeGroupInAtomicSwcInstanceRef -->
   <xsd:group name="P-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PModeGroupInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-P-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PModeGroupInAtomicSwcInstanceRef.contextPPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PModeGroupInAtomicSwcInstanceRef.targetModeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::PModeGroupInAtomicSwcInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="P-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PModeGroupInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF"/>
         <xsd:group ref="AR:P-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::POperationInAtomicSwcInstanceRef -->
   <xsd:group name="P-OPERATION-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="POperationInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-P-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="POperationInAtomicSwcInstanceRef.contextPPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-PROVIDED-OPERATION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="POperationInAtomicSwcInstanceRef.targetProvidedOperation";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::POperationInAtomicSwcInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="P-OPERATION-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="POperationInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:OPERATION-IN-ATOMIC-SWC-INSTANCE-REF"/>
         <xsd:group ref="AR:P-OPERATION-IN-ATOMIC-SWC-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::PPortComSpec -->
   <xsd:group name="P-PORT-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for PPortPrototypes. This class will contain attributes that are valid for all kinds of provide ports, independent of client-server or sender-receiver communication patterns.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PPortComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class InstanceRefs::PPortInCompositionInstanceRef -->
   <xsd:group name="P-PORT-IN-COMPOSITION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PPortInCompositionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PPortInCompositionInstanceRef.contextComponent";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-P-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PPortInCompositionInstanceRef.targetPPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::PPortInCompositionInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="P-PORT-IN-COMPOSITION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PPortInCompositionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:PORT-IN-COMPOSITION-TYPE-INSTANCE-REF"/>
         <xsd:group ref="AR:P-PORT-IN-COMPOSITION-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::PPortPrototype -->
   <xsd:group name="P-PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Component port providing a certain port interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PPortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-COM-SPECS">
            <xsd:annotation>
               <xsd:documentation>Provided communication attributes per interface element (data element or operation).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="providedComSpec.PPortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-SWITCH-SENDER-COM-SPEC" type="AR:MODE-SWITCH-SENDER-COM-SPEC"/>
                  <xsd:element name="NONQUEUED-SENDER-COM-SPEC" type="AR:NONQUEUED-SENDER-COM-SPEC"/>
                  <xsd:element name="NV-PROVIDE-COM-SPEC" type="AR:NV-PROVIDE-COM-SPEC"/>
                  <xsd:element name="PARAMETER-PROVIDE-COM-SPEC" type="AR:PARAMETER-PROVIDE-COM-SPEC"/>
                  <xsd:element name="QUEUED-SENDER-COM-SPEC" type="AR:QUEUED-SENDER-COM-SPEC"/>
                  <xsd:element name="SERVER-COM-SPEC" type="AR:SERVER-COM-SPEC"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-INTERFACE-TREF">
            <xsd:annotation>
               <xsd:documentation>The interface that this port provides.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pPort.providedInterface";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-INTERFACE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::PPortPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="P-PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Component port providing a certain port interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PPortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:PORT-PROTOTYPE"/>
         <xsd:group ref="AR:P-PORT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="P-PORT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InstanceRefs::PTriggerInAtomicSwcTypeInstanceRef -->
   <xsd:group name="P-TRIGGER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PTriggerInAtomicSwcTypeInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-P-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PTriggerInAtomicSwcTypeInstanceRef.contextPPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-TRIGGER-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PTriggerInAtomicSwcTypeInstanceRef.targetTrigger";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::PTriggerInAtomicSwcTypeInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="P-TRIGGER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PTriggerInAtomicSwcTypeInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:TRIGGER-IN-ATOMIC-SWC-INSTANCE-REF"/>
         <xsd:group ref="AR:P-TRIGGER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::PVariableInAtomicSwcInstanceRef -->
   <xsd:group name="P-VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PVariableInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-P-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PVariableInAtomicSwcInstanceRef.contextPPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PVariableInAtomicSwcInstanceRef.targetDataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::PVariableInAtomicSwcInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="P-VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PVariableInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF"/>
         <xsd:group ref="AR:P-VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ARPackage::PackageableElement -->
   <xsd:group name="PACKAGEABLE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies the ability to be a member of an AUTOSAR package.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PackageableElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class PaginationAndView::Paginateable -->
   <xsd:group name="PAGINATEABLE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to control the pagination policy when creating documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Paginateable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class PaginationAndView::Paginateable -->
   <xsd:attributeGroup name="PAGINATEABLE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to control the pagination policy when creating documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Paginateable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="BREAK" type="AR:CHAPTER-ENUM-BREAK--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attributes allows to specify a forced page break.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Paginateable.break";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="KEEP-WITH-PREVIOUS" type="AR:KEEP-WITH-PREVIOUS-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute denotes the pagination policy. In particular it defines if the containing text block shall be kept together with the previous block.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Paginateable.keepWithPrevious";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- element group for class DataElements::ParameterAccess -->
   <xsd:group name="PARAMETER-ACCESS">
      <xsd:annotation>
         <xsd:documentation>The presence of a ParameterAccess implies that a RunnableEntity needs access to a ParameterDataPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCESSED-PARAMETER" type="AR:AUTOSAR-PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>Refernce to the accessed calibration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterAccess.accessedParameter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This allows denote instance and access specific properties, mainly input values and common axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterAccess.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::ParameterAccess -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-ACCESS">
      <xsd:annotation>
         <xsd:documentation>The presence of a ParameterAccess implies that a RunnableEntity needs access to a ParameterDataPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAMETER-ACCESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataPrototypes::ParameterDataPrototype -->
   <xsd:group name="PARAMETER-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A parameter element used for parameter interface and internal behavior, supporting signal like parameter and characteristic value communication patterns and parameter and characteristic value definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>Specifies initial value(s) of the ParameterDataPrototype</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterDataPrototype.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataPrototypes::ParameterDataPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A parameter element used for parameter interface and internal behavior, supporting signal like parameter and characteristic value communication patterns and parameter and characteristic value definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:group ref="AR:PARAMETER-DATA-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PARAMETER-DATA-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PARAMETER-DATA-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InstanceRefsUsage::ParameterInAtomicSWCTypeInstanceRef -->
   <xsd:group name="PARAMETER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>This class implements an instance reference which can be applied for variables as well as for parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterInAtomicSWCTypeInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the port providing the variable or the entry point to the variable structure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterInAtomicSWCTypeInstanceRef.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROOT-PARAMETER-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the entry point for references into a CompositeDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterInAtomicSWCTypeInstanceRef.rootParameterDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This ist the context in a compositeDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterInAtomicSWCTypeInstanceRef.contextDataPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the target of the instance ref</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterInAtomicSWCTypeInstanceRef.targetDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefsUsage::ParameterInAtomicSWCTypeInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:documentation>This class implements an instance reference which can be applied for variables as well as for parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterInAtomicSWCTypeInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:PARAMETER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ParameterInterface -->
   <xsd:group name="PARAMETER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A parameter interface declares a number of parameter and characteristic values to be exchanged between parameter components and software components.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="ParameterInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETERS">
            <xsd:annotation>
               <xsd:documentation>The ParameterDataPrototype of this ParameterInterface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterInterface.parameter";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAMETER-DATA-PROTOTYPE" type="AR:PARAMETER-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ParameterInterface -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A parameter interface declares a number of parameter and characteristic values to be exchanged between parameter components and software components.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="ParameterInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:DATA-INTERFACE"/>
         <xsd:group ref="AR:PARAMETER-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::ParameterPortAnnotation -->
   <xsd:group name="PARAMETER-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port used for calibration regarding a certain ParameterDataPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>The instance of annotated ParameterDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterPortAnnotation.parameter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PARAMETER-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::ParameterPortAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port used for calibration regarding a certain ParameterDataPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:PARAMETER-PORT-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::ParameterProvideComSpec -->
   <xsd:group name="PARAMETER-PROVIDE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>"Communication" specification that applies to parameters on the provided side of a connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterProvideComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>The initial value applicable for the corresponding ParameterDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterProvideComSpec.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>The ParameterDataPrototype to which the ParameterComSpec applies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterProvideComSpec.parameter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PARAMETER-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ParameterProvideComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-PROVIDE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>"Communication" specification that applies to parameters on the provided side of a connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterProvideComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:P-PORT-COM-SPEC"/>
         <xsd:group ref="AR:PARAMETER-PROVIDE-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::ParameterRequireComSpec -->
   <xsd:group name="PARAMETER-REQUIRE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>"Communication" specification that applies to parameters on the required side of a connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterRequireComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>The initial value applicable for the corresponding ParameterDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterRequireComSpec.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>The ParameterDataPrototype to which the ParameterRequireComSpec applies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterRequireComSpec.parameter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PARAMETER-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ParameterRequireComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-REQUIRE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>"Communication" specification that applies to parameters on the required side of a connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterRequireComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:R-PORT-COM-SPEC"/>
         <xsd:group ref="AR:PARAMETER-REQUIRE-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::ParameterSwComponentType -->
   <xsd:group name="PARAMETER-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ParameterSwComponentType defines parameters and characteristic values accessible via provided Ports. The provided values are the same for all connected SwComponentPrototypes</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ParameterSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSTANT-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the ConstanSpecificationMapping to be applied for the particular ParameterSwComponentType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterSwComponentType.constantMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONSTANT-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CONSTANT-SPECIFICATION-MAPPING-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-TYPE-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the DataTypeMapping to be applied for the particular ParameterSwComponentType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterSwComponentType.dataTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-TYPE-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:DATA-TYPE-MAPPING-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INSTANTIATION-DATA-DEF-PROPSS">
            <xsd:annotation>
               <xsd:documentation>The purpose of this is that within the context of a given SwComponentType some  data def properties of individual instantiations can be modified. 

            The aggregation of InstantiationDataDefProps is subject to variability with the  purpose to support the conditional existence of PortPrototypes
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ParameterSwComponentType.instantiationDataDefProps";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INSTANTIATION-DATA-DEF-PROPS" type="AR:INSTANTIATION-DATA-DEF-PROPS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::ParameterSwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ParameterSwComponentType defines parameters and characteristic values accessible via provided Ports. The provided values are the same for all connected SwComponentPrototypes</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ParameterSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:PARAMETER-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::Pdu -->
   <xsd:group name="PDU">
      <xsd:annotation>
         <xsd:documentation>Collection of all Pdus that can be routed through a bus interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Pdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Pdu length in bytes. In case of dynamic length IPdus (containing a dynamical length signal), this value indicates the maximum data length. It should be noted that in former AUTOSAR releases (Rel 2.1, Rel 3.0, Rel 3.1, Rel 4.0 Rev. 1) this parameter was defined in bits. 

            The Pdu length of zero bytes is allowed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Pdu.length";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="I-PDU"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="NM-PDU"/>
         <xsd:enumeration value="PDU"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-PDU"/>
         <xsd:enumeration value="XCP-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::PduMappingDefaultValue -->
   <xsd:group name="PDU-MAPPING-DEFAULT-VALUE">
      <xsd:annotation>
         <xsd:documentation>Default Value which will be distributed if no I-Pdu has been received since last sending.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduMappingDefaultValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>The default value consists of a number of elements. Each default value element is represented by the element and the position in an array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="defaultValueElement.PduMappingDefaultValue";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DEFAULT-VALUE-ELEMENT" type="AR:DEFAULT-VALUE-ELEMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::PduMappingDefaultValue -->
   <xsd:complexType abstract="false" mixed="false" name="PDU-MAPPING-DEFAULT-VALUE">
      <xsd:annotation>
         <xsd:documentation>Default Value which will be distributed if no I-Pdu has been received since last sending.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduMappingDefaultValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PDU-MAPPING-DEFAULT-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::PduToFrameMapping -->
   <xsd:group name="PDU-TO-FRAME-MAPPING">
      <xsd:annotation>
         <xsd:documentation>A PduToFrameMapping defines the composition of Pdus in each frame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PACKING-BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the order of the bytes of the Pdu and the packing into the Frame. The byte ordering "Little Endian" (MostSignificantByteLast) and "Big Endian" (MostSignificantByteFirst) can be selected.

            A mix between Little Endian and Big Endian within a Frame is not allowed (all PduToFrameMappings within a Frame must have the same packingByteOrder).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping.packingByteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a I-Pdu, N-Pdu or NmPdu that is transmitted in the Frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping.pdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="START-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This parameter is necessary to describe the byteposition of a Pdu within a Frame. 

            Note that the absolute position of the Pdu in the Frame is determined by the definition of the packingByteOrder attribute. If Big Endian is specified, the start position indicates the bit position of the most significant bit in the Frame. If Little Endian is specified, the start position indicates the bit position of the least significant bit in the Frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping.startPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPDATE-INDICATION-BIT-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Indication to the receivers that the corresponding Pdu was updated by the sender. 
            This attribute describes the position of the update bit in the frame that aggregates this PDUToFrameMapping. Length is always one bit.

            Note that the exact bit position of the updateIndicationBitPosition is linked to the value of the attribute packingByteOrder because the method of finding the bit position is different for the values mostSignificantByteFirst and mostSignificantByteLast. This means that if the value of packingByteOrder is changed while the value of updateIndicationBitPosition remains unchanged the exact bit position of updateIndicationBitPosition within the enclosing Frame still undergoes a change.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping.updateIndicationBitPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::PduToFrameMapping -->
   <xsd:complexType abstract="false" mixed="false" name="PDU-TO-FRAME-MAPPING">
      <xsd:annotation>
         <xsd:documentation>A PduToFrameMapping defines the composition of Pdus in each frame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PDU-TO-FRAME-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::PduTriggering -->
   <xsd:group name="PDU-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The PduTriggering describes on which channel the IPdu is transmitted.
      The Pdu routing by the PduR is only allowed for "IPdus" and not for NmPdus and XcpPdus.

      Depending on its relation to entities such channels and clusters it can be unambiguously deduced whether a fan-out is handled by the Pdu router or the Bus Interface. If the fan-out is specified between different clusters it shall be handled by the Pdu Router. If the fan-out is specified between different channels of the same cluster it shall be handled by the Bus Interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>References to the IPduPort on every ECU of the system which sends and/or
            receives the I-PDU.

            References for both the sender and the receiver side shall be included when the system is completely defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduTriggering.iPduPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-PDU-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the Pdu for which the PduTriggering is defined. One I-Pdu can be triggered on different channels (PduR fan-out). The Pdu routing by the PduR is only allowed for "IPdus" and not for NmPdus and XcpPdus. Nevertheless is the reference to the Pdu element necessary since the PduTriggering element is also used to specify the sending and receiving connections to EcuPorts.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduTriggering.iPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-TRIGGERINGS">
            <xsd:annotation>
               <xsd:documentation>This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="PduTriggering.iSignalTriggering";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-TRIGGERING-REF-CONDITIONAL" type="AR:I-SIGNAL-TRIGGERING-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::PduTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="PDU-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The PduTriggering describes on which channel the IPdu is transmitted.
      The Pdu routing by the PduR is only allowed for "IPdus" and not for NmPdus and XcpPdus.

      Depending on its relation to entities such channels and clusters it can be unambiguously deduced whether a fan-out is handled by the Pdu router or the Bus Interface. If the fan-out is specified between different clusters it shall be handled by the Pdu Router. If the fan-out is specified between different channels of the same cluster it shall be handled by the Bus Interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PDU-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PDU-TRIGGERING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PDU-TRIGGERING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::PduTriggeringRefConditional -->
   <xsd:group name="PDU-TRIGGERING-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PDU-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::PduTriggeringRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="PDU-TRIGGERING-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PDU-TRIGGERING-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::PdurIPduGroup -->
   <xsd:group name="PDUR-I-PDU-GROUP">
      <xsd:annotation>
         <xsd:documentation>The AUTOSAR PduR will enable and disable the sending of configurable groups of IPdus during runtime according to the AUTOSAR PduR specification.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PdurIPduGroups";mmt.qualifiedName="PdurIPduGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-MODE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the use-case for this PduRIPduGroup. For example, in a diagnostic mode all IPdus - which are not involved in diagnostic - are disabled. The use cases are not limited to a fixed enumeration and can be specified as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PdurIPduGroup.communicationMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDUS">
            <xsd:annotation>
               <xsd:documentation>This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="PdurIPduGroup.iPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PDU-TRIGGERING-REF-CONDITIONAL" type="AR:PDU-TRIGGERING-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::PdurIPduGroup -->
   <xsd:complexType abstract="false" mixed="false" name="PDUR-I-PDU-GROUP">
      <xsd:annotation>
         <xsd:documentation>The AUTOSAR PduR will enable and disable the sending of configurable groups of IPdus during runtime according to the AUTOSAR PduR specification.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PdurIPduGroups";mmt.qualifiedName="PdurIPduGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDUR-I-PDU-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PDUR-I-PDU-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PDUR-I-PDU-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PerInstanceMemory::PerInstanceMemory -->
   <xsd:group name="PER-INSTANCE-MEMORY">
      <xsd:annotation>
         <xsd:documentation>Defines a 'C' typed memory-block that needs to be available for each instance of the SW-component.  This is typically only useful if supportsMultipleInstantiation is TRUE of if the component defines NVRAM access via permanent blocks.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies initial value(s) of the PerInstanceMemory</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This represents the ability to to allocate RAM at specific memory sections, for example, to support the RAM block recovery strategy by mapping to uninitialized RAM.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>The name of the "C"-type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-DEFINITION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>A definition of the type with the syntax of a 'C' typedef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory.typeDefinition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PerInstanceMemory::PerInstanceMemory -->
   <xsd:complexType abstract="false" mixed="false" name="PER-INSTANCE-MEMORY">
      <xsd:annotation>
         <xsd:documentation>Defines a 'C' typed memory-block that needs to be available for each instance of the SW-component.  This is typically only useful if supportsMultipleInstantiation is TRUE of if the component defines NVRAM access via permanent blocks.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:PER-INSTANCE-MEMORY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PER-INSTANCE-MEMORY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PER-INSTANCE-MEMORY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SwcImplementation::PerInstanceMemorySize -->
   <xsd:group name="PER-INSTANCE-MEMORY-SIZE">
      <xsd:annotation>
         <xsd:documentation>Resources needed by the allocation of PerInstanceMemory for each SWC instance. Note that these resources are not covered by an ObjectFileSection, because they are supposed to be allocated by the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALIGNMENT" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Required alignment (1,2,4,...) of the referenced PerInstanceMemory</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize.alignment";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-MEMORY-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the referenced PerInstanceMemory.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize.perInstanceMemory";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PER-INSTANCE-MEMORY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIZE" type="AR:POSITIVE-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Size (in bytes) of the reference perInstanceMemory.
            The aggregation of PerInstanceMemorySize is subject to variability with the purpose to support variability in the software components implementations. Different algorithms in the implementation might require a different PerInstanceMemorySize.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="PerInstanceMemorySize.size";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcImplementation::PerInstanceMemorySize -->
   <xsd:complexType abstract="false" mixed="false" name="PER-INSTANCE-MEMORY-SIZE">
      <xsd:annotation>
         <xsd:documentation>Resources needed by the allocation of PerInstanceMemory for each SWC instance. Note that these resources are not covered by an ObjectFileSection, because they are supposed to be allocated by the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PER-INSTANCE-MEMORY-SIZE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EventTriggeringConstraint::PeriodicEventTriggering -->
   <xsd:group name="PERIODIC-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The PeriodicEventTriggering describes the behavior of an event with a strict periodic occurrence pattern, given by the period attribute.

      Additionally, it is possible to soften the strictness of the periodic occurrence behavior by specifying a jitter, so that there can be a deviation from the period up to the size of the jitter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PeriodicEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-INTER-ARRIVAL-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The minimum time distance between two consecutive occurrences of the associated event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PeriodicEventTriggering.minimumInterArrivalTime";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="JITTER" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum jitter of the periodic event occurrence.

            Jitter=max |nthPeriod - standardPeriod|</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PeriodicEventTriggering.jitter";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PERIOD" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The period of the event occurrence.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PeriodicEventTriggering.period";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EventTriggeringConstraint::PeriodicEventTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="PERIODIC-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The PeriodicEventTriggering describes the behavior of an event with a strict periodic occurrence pattern, given by the period attribute.

      Additionally, it is possible to soften the strictness of the periodic occurrence behavior by specifying a jitter, so that there can be a deviation from the period up to the size of the jitter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PeriodicEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:EVENT-TRIGGERING-CONSTRAINT"/>
         <xsd:group ref="AR:PERIODIC-EVENT-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::PermissibleSignalPath -->
   <xsd:group name="PERMISSIBLE-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The PermissibleSignalPath describes the way a data element shall take in the topology. The path is described by ordered references to PhysicalChannels. 

      If more than one PermissibleSignalPath is defined for the same
      signal/operation attributes, any of them can be chosen. Such a signal path can be a constraint for the communication matrix . This path describes that one data element should take path A (e.g. 1. CAN channel, 2. LIN channel) 
      and not path B (1. CAN channel, FlexRay channel A). 

      This has an effect on the frame generation and the frame path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PermissibleSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:documentation>The arguments of an operation that can take the predefined way in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.PermissibleSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNEL-REFS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcSignal can be transmitted on one of these physical channels.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PermissibleSignalPath.physicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PHYSICAL-CHANNEL-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNALS">
            <xsd:annotation>
               <xsd:documentation>The data element which can take the predefined way in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signal.PermissibleSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::PermissibleSignalPath -->
   <xsd:complexType abstract="false" mixed="false" name="PERMISSIBLE-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The PermissibleSignalPath describes the way a data element shall take in the topology. The path is described by ordered references to PhysicalChannels. 

      If more than one PermissibleSignalPath is defined for the same
      signal/operation attributes, any of them can be chosen. Such a signal path can be a constraint for the communication matrix . This path describes that one data element should take path A (e.g. 1. CAN channel, 2. LIN channel) 
      and not path B (1. CAN channel, FlexRay channel A). 

      This has an effect on the frame generation and the frame path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PermissibleSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SIGNAL-PATH-CONSTRAINT"/>
         <xsd:group ref="AR:PERMISSIBLE-SIGNAL-PATH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GlobalConstraints::PhysConstrs -->
   <xsd:group name="PHYS-CONSTRS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express physical constraints. Therefore it has (in opposite to InternalConstrs) a reference to a Unit.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCALE-CONSTRS">
            <xsd:annotation>
               <xsd:documentation>This is one particular scale in which contributes to the data constraints.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.scaleConstr";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SCALE-CONSTR" type="AR:SCALE-CONSTR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-GRADIENT" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This element specifies the maximum slope that may be used in curves and maps.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.maxGradient";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-DIFF" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>Maximum difference that is permitted between two consecutive values if the constraint is applied to an axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.maxDiff";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MONOTONY" type="AR:MONOTONY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This specifies the monotony constraints on the data object. Note that this applies only to curves and maps.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.monotony";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>This is the unit to which the physical contraints relate to. In particular it is the physical unit of the specified limits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.unit";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::PhysConstrs -->
   <xsd:complexType abstract="false" mixed="false" name="PHYS-CONSTRS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express physical constraints. Therefore it has (in opposite to InternalConstrs) a reference to a Unit.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PHYS-CONSTRS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::PhysicalChannel -->
   <xsd:group name="PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A physical channel is the transmission medium that is used to send and receive information between two communicating ECUs. Each CommunicationCluster has at least one physical channel. Bus systems like CAN and LIN only have exactly one PhysicalChannel. A FlexRay cluster may have more than one PhysicalChannels that may be used in parallel for redundant communication.

      An ECU is part of a cluster if it contains at least one controller that is connected to at least one channel of the cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMM-CONNECTORS">
            <xsd:annotation>
               <xsd:documentation>This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="PhysicalChannel.commConnector";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMMUNICATION-CONNECTOR-REF-CONDITIONAL" type="AR:COMMUNICATION-CONNECTOR-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-TRIGGERINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="frameTriggering.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-FRAME-TRIGGERING" type="AR:CAN-FRAME-TRIGGERING"/>
                  <xsd:element name="ETHERNET-FRAME-TRIGGERING" type="AR:ETHERNET-FRAME-TRIGGERING"/>
                  <xsd:element name="FLEXRAY-FRAME-TRIGGERING" type="AR:FLEXRAY-FRAME-TRIGGERING"/>
                  <xsd:element name="LIN-FRAME-TRIGGERING" type="AR:LIN-FRAME-TRIGGERING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-TRIGGERINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="iSignalTriggering.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-TRIGGERING" type="AR:I-SIGNAL-TRIGGERING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-TRIGGERINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="pduTriggering.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PDU-TRIGGERING" type="AR:PDU-TRIGGERING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="PHYSICAL-CHANNEL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ABSTRACT-CAN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="CAN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="ETHERNET-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="FLEXRAY-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="LIN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="TTCAN-PHYSICAL-CHANNEL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Units::PhysicalDimension -->
   <xsd:group name="PHYSICAL-DIMENSION">
      <xsd:annotation>
         <xsd:documentation>This class represents a physical dimension.
      If the physical dimension of two units is identical, then a conversion between them is possible. The conversion between units is related to the definition of the physical dimension.

      Note that the equivalence of the exponents does not per se define the convertibility. For example Energy and Torque share the same exponents (Nm).

      Please note further the the value of an exponent does not necessarily have to be an integer number. It is also possible that the value yields a rational number, e.g. to compute the square root of a given physical quantity. In this case the exponent value would be a rational number where the numerator value is 1 and the denominator value is 2.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PhysicalDimensions";mmt.qualifiedName="PhysicalDimension"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LENGTH-EXP" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "length".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.lengthExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASS-EXP" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "mass".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.massExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-EXP" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "time".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.timeExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CURRENT-EXP" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This attribute represents the exponent of the physical dimension "electric current".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.currentExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEMPERATURE-EXP" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "temperature".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.temperatureExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MOLAR-AMOUNT-EXP" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "quantity of substance".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.molarAmountExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LUMINOUS-INTENSITY-EXP" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "luminous intensity".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.luminousIntensityExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Units::PhysicalDimension -->
   <xsd:complexType abstract="false" mixed="false" name="PHYSICAL-DIMENSION">
      <xsd:annotation>
         <xsd:documentation>This class represents a physical dimension.
      If the physical dimension of two units is identical, then a conversion between them is possible. The conversion between units is related to the definition of the physical dimension.

      Note that the equivalence of the exponents does not per se define the convertibility. For example Energy and Torque share the same exponents (Nm).

      Please note further the the value of an exponent does not necessarily have to be an integer number. It is also possible that the value yields a rational number, e.g. to compute the square root of a given physical quantity. In this case the exponent value would be a rational number where the numerator value is 1 and the denominator value is 2.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PhysicalDimensions";mmt.qualifiedName="PhysicalDimension"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:PHYSICAL-DIMENSION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PHYSICAL-DIMENSION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PHYSICAL-DIMENSION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PncMapping::PncMapping -->
   <xsd:group name="PNC-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Describes a mapping between one or several Virtual Function Clusters onto Partial Network Clusters. A Virtual Function Cluster is realized by a PortGroup. A Partial Network Cluster is realized by one or more IPduGroups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>IPduGroup participating in a Partial Network Cluster. This reference is optional in case an ecu extract has only indirect pnc access, i.e. ecu is not directly conntected to a network which supports partial network.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping.pncGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PNC-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-SIGNAL-I-PDU-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-IDENTIFIER" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Identifer of the Partial Network Cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping.pncIdentifier";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VFC-IREFS">
            <xsd:annotation>
               <xsd:documentation>Virtual Function Cluster to be mapped onto a Partial Network Cluster. This reference is optional in case that the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy systems.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="vfc.PncMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VFC-IREF" type="AR:PORT-GROUP-IN-SYSTEM-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-FRAME-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to collection of FrameTriggerings that are used for the wakeup of this PNC (Application Frames or Nm Frames can be used). This reference is optional in case an ecu extract has only indirect pnc access, i.e. ecu is not directly conntected to a network which supports partial network.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping.wakeupFrame";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="WAKEUP-FRAME-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PncMapping::PncMapping -->
   <xsd:complexType abstract="false" mixed="false" name="PNC-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Describes a mapping between one or several Virtual Function Clusters onto Partial Network Clusters. A Virtual Function Cluster is realized by a PortGroup. A Partial Network Cluster is realized by one or more IPduGroups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PNC-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortAPIOptions::PortAPIOption -->
   <xsd:group name="PORT-API-OPTION">
      <xsd:annotation>
         <xsd:documentation>Options how to generate the signatures of calls for an AtomicSwComponentType in order to communicate over a PortPrototype (for calls into a RunnableEntity as well as for calls from a RunnableEntity to the PortPrototype).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENABLE-TAKE-ADDRESS" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If set to true, the software-component is able to use the API reference for deriving a pointer to an object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption.enableTakeAddress";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDIRECT-API" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If set to true this attribute specifies an "indirect API" to be generated for the associated port which means that the SWC is able to access the actions on a port via a pointer to an object representing a port. This allows e.g. iterating over ports in a loop. This option has no effect for PPortPrototypes of client/server interfaces.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption.indirectAPI";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-ARG-VALUES">
            <xsd:annotation>
               <xsd:documentation>An argument value defined by this port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="portArgValue.PortAPIOption";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PORT-DEFINED-ARGUMENT-VALUE" type="AR:PORT-DEFINED-ARGUMENT-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-REF">
            <xsd:annotation>
               <xsd:documentation>The option is valid for generated functions related to communication over this port</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption.port";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortAPIOptions::PortAPIOption -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-API-OPTION">
      <xsd:annotation>
         <xsd:documentation>Options how to generate the signatures of calls for an AtomicSwComponentType in order to communicate over a PortPrototype (for calls into a RunnableEntity as well as for calls from a RunnableEntity to the PortPrototype).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PORT-API-OPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortAPIOptions::PortDefinedArgumentValue -->
   <xsd:group name="PORT-DEFINED-ARGUMENT-VALUE">
      <xsd:annotation>
         <xsd:documentation>A PortDefinedArgumentValue is passed to a RunnableEntity dealing with the ClientServerOperations provided by a given PortPrototype. Note that this is restricted to PPortPrototypes of a ClientServerInterface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortDefinedArgumentValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE">
            <xsd:annotation>
               <xsd:documentation>Specifies the actual value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortDefinedArgumentValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-TYPE-TREF">
            <xsd:annotation>
               <xsd:documentation>The implementation type of this argument value. It should not be composite type or a pointer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortDefinedArgumentValue.valueType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortAPIOptions::PortDefinedArgumentValue -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-DEFINED-ARGUMENT-VALUE">
      <xsd:annotation>
         <xsd:documentation>A PortDefinedArgumentValue is passed to a RunnableEntity dealing with the ClientServerOperations provided by a given PortPrototype. Note that this is restricted to PPortPrototypes of a ClientServerInterface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortDefinedArgumentValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PORT-DEFINED-ARGUMENT-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::PortGroup -->
   <xsd:group name="PORT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Group of ports which share a common functionality, e.g. need specific network resources. This information shall be available on the VFB level in order to delegate it properly via compositions. When propagated into the ECU extract, this information is used as input for the configuration of Services like the Communication Manager. A PortGroup is defined locally in a component (which can be a composition) and refers to the "outer" ports belonging to the group as well as to the "inner" groups which propagate  this group into the components which are part of a composition. A PortGroup within an atomic SWC cannot be linked to inner groups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INNER-GROUP-IREFS">
            <xsd:annotation>
               <xsd:documentation>Links a PortGroup in a composition to another PortGroup, that is defined in a component which is part of this CompositionSwComponentType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup.innerGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INNER-GROUP-IREF" type="AR:INNER-PORT-GROUP-IN-COMPOSITION-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OUTER-PORTS">
            <xsd:annotation>
               <xsd:documentation>Outer port of this component which belongs to the group. A port can belong to several groups or to no group at all.
            This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="PortGroup.outerPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PORT-PROTOTYPE-REF-CONDITIONAL" type="AR:PORT-PROTOTYPE-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::PortGroup -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Group of ports which share a common functionality, e.g. need specific network resources. This information shall be available on the VFB level in order to delegate it properly via compositions. When propagated into the ECU extract, this information is used as input for the configuration of Services like the Communication Manager. A PortGroup is defined locally in a component (which can be a composition) and refers to the "outer" ports belonging to the group as well as to the "inner" groups which propagate  this group into the components which are part of a composition. A PortGroup within an atomic SWC cannot be linked to inner groups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:PORT-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PORT-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PORT-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InstanceRefs::PortGroupInSystemInstanceRef -->
   <xsd:group name="PORT-GROUP-IN-SYSTEM-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortGroupInSystemInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortGroupInSystemInstanceRef.contextComposition";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ROOT-SW-COMPOSITION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortGroupInSystemInstanceRef.contextComponent";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REF">
            <xsd:annotation>
               <xsd:documentation>Link to a PortGroup that is defined in a component which is part of this CompositionSwComponentType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortGroupInSystemInstanceRef.target";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::PortGroupInSystemInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-GROUP-IN-SYSTEM-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortGroupInSystemInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:PORT-GROUP-IN-SYSTEM-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::PortInCompositionTypeInstanceRef -->
   <xsd:group name="PORT-IN-COMPOSITION-TYPE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortInCompositionTypeInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <!-- Association <<atpDerived>>abstractContextComponent skipped -->
         <!-- Association <<atpDerived>>targetPort skipped -->
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class PortInterface::PortInterface -->
   <xsd:group name="PORT-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>Abstract base class for an interface that is either provided or required by a port of a  software component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-SERVICE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This flag is set if the PortInterface is to be used for communication between an
             
            * ApplicationSwComponentType or 
            * ServiceProxySwComponentType or 
            * SensorActuatorSwComponentType or
            * ComplexDeviceDriverSwComponentType or
            * EcuAbstractionSwComponentType 
            and a ServiceSwComponentType (namely an AUTOSAR Service) located on the same ECU. Otherwise the flag is not set.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortInterface.isService";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-KIND" type="AR:SERVICE-PROVIDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute provides further details about the nature of the applied service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortInterface.serviceKind";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="PORT-INTERFACE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="MODE-SWITCH-INTERFACE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="PORT-INTERFACE"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="TRIGGER-INTERFACE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortInterfaceBlueprint::PortInterfaceBlueprintMapping -->
   <xsd:group name="PORT-INTERFACE-BLUEPRINT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to map two PortInterfaces of which one acts as the blueprint for the other.</xsd:documentation>
         <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="PortInterfaceBlueprintMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-INTERFACE-BLUEPRINT-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the interface blueprint. Note that this interface needs to live in a package of category BLUEPRINT.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortInterfaceBlueprintMapping.portInterfaceBlueprint";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-INTERFACE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DERIVED-PORT-INTERFACE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the derived interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortInterfaceBlueprintMapping.derivedPortInterface";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-INTERFACE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterfaceBlueprint::PortInterfaceBlueprintMapping -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-INTERFACE-BLUEPRINT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to map two PortInterfaces of which one acts as the blueprint for the other.</xsd:documentation>
         <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="PortInterfaceBlueprintMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT-MAPPING"/>
         <xsd:group ref="AR:PORT-INTERFACE-BLUEPRINT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::PortInterfaceMapping -->
   <xsd:group name="PORT-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Specifies one PortInterfaceMapping to support the connection of Ports typed by two different PortInterfaces with PortInterface elements having unequal names and/or unequal semantic (resolution or range).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <xsd:simpleType name="PORT-INTERFACE-MAPPING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE-MAPPING"/>
         <xsd:enumeration value="MODE-INTERFACE-MAPPING"/>
         <xsd:enumeration value="PORT-INTERFACE-MAPPING"/>
         <xsd:enumeration value="TRIGGER-INTERFACE-MAPPING"/>
         <xsd:enumeration value="VARIABLE-AND-PARAMETER-INTERFACE-MAPPING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortInterface::PortInterfaceMappingSet -->
   <xsd:group name="PORT-INTERFACE-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>Specifies a set of (one or more) PortInterfaceMappings.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaceMappingSets";mmt.qualifiedName="PortInterfaceMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-INTERFACE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Specifies one PortInterfaceMapping to support the connection of Ports typed by two different PortInterfaces with PortInterface elements having unequal names and/or unequal semantic (resolution or range).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="portInterfaceMapping.PortInterfaceMappingSet";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-INTERFACE-MAPPING" type="AR:CLIENT-SERVER-INTERFACE-MAPPING"/>
                  <xsd:element name="MODE-INTERFACE-MAPPING" type="AR:MODE-INTERFACE-MAPPING"/>
                  <xsd:element name="TRIGGER-INTERFACE-MAPPING" type="AR:TRIGGER-INTERFACE-MAPPING"/>
                  <xsd:element name="VARIABLE-AND-PARAMETER-INTERFACE-MAPPING" type="AR:VARIABLE-AND-PARAMETER-INTERFACE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::PortInterfaceMappingSet -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-INTERFACE-MAPPING-SET">
      <xsd:annotation>
         <xsd:documentation>Specifies a set of (one or more) PortInterfaceMappings.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaceMappingSets";mmt.qualifiedName="PortInterfaceMappingSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:PORT-INTERFACE-MAPPING-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Components::PortPrototype -->
   <xsd:group name="PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Base class for the ports of an AUTOSAR software component.

      The aggregation of PortPrototypes is subject to variability with the purpose to support the conditional existence of ports.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLIENT-SERVER-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Annotation of this PortPrototype with respect to client/server communication.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototype.clientServerAnnotation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ANNOTATION" type="AR:CLIENT-SERVER-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELEGATED-PORT-ANNOTATION" type="AR:DELEGATED-PORT-ANNOTATION">
            <xsd:annotation>
               <xsd:documentation>Annotations on this delegated port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="delegatedPortAnnotation.PortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IO-HW-ABSTRACTION-SERVER-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Annotations on this IO Hardware Abstraction port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ioHwAbstractionServerAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="IO-HW-ABSTRACTION-SERVER-ANNOTATION" type="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-PORT-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Annotations on this mode port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modePortAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-PORT-ANNOTATION" type="AR:MODE-PORT-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NV-DATA-PORT-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Annotations on this non voilatile data port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="nvDataPortAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="NV-DATA-PORT-ANNOTATION" type="AR:NV-DATA-PORT-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-PORT-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Annotations on this parameter port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="parameterPortAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAMETER-PORT-ANNOTATION" type="AR:PARAMETER-PORT-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SENDER-RECEIVER-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Collection of annotations of this ports sender/receiver communication.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="senderReceiverAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-ANNOTATION" type="AR:RECEIVER-ANNOTATION"/>
                  <xsd:element name="SENDER-ANNOTATION" type="AR:SENDER-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-PORT-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Annotations on this trigger port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="triggerPortAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRIGGER-PORT-ANNOTATION" type="AR:TRIGGER-PORT-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="PORT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
         <xsd:enumeration value="PORT-PROTOTYPE"/>
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortProtoypeBlueprint::PortPrototypeBlueprint -->
   <xsd:group name="PORT-PROTOTYPE-BLUEPRINT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a blueprint of a PortPrototype by referring to a particular PortInterface. This blueprint can then be used as a guidance to create particular PortPrototypes which are defined according to this blueprint. By this it is possible to standardize application interfaces without the need to also standardize software-components with PortPrototypes typed by the standardized PortInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortPrototypeBlueprints";mmt.qualifiedName="PortPrototypeBlueprint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUES">
            <xsd:annotation>
               <xsd:documentation>This specifies the init values for the dataElements in the particular PortPrototypeBlueprint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototypeBlueprint.initValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PORT-PROTOTYPE-BLUEPRINT-INIT-VALUE" type="AR:PORT-PROTOTYPE-BLUEPRINT-INIT-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERFACE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the interface for which the blueprint is defined. It may be a blueprint itself  or a standardized PortInterface</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototypeBlueprint.interface";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-INTERFACE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortProtoypeBlueprint::PortPrototypeBlueprint -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-PROTOTYPE-BLUEPRINT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a blueprint of a PortPrototype by referring to a particular PortInterface. This blueprint can then be used as a guidance to create particular PortPrototypes which are defined according to this blueprint. By this it is possible to standardize application interfaces without the need to also standardize software-components with PortPrototypes typed by the standardized PortInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortPrototypeBlueprints";mmt.qualifiedName="PortPrototypeBlueprint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:PORT-PROTOTYPE-BLUEPRINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PORT-PROTOTYPE-BLUEPRINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PORT-PROTOTYPE-BLUEPRINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortProtoypeBlueprint::PortPrototypeBlueprintInitValue -->
   <xsd:group name="PORT-PROTOTYPE-BLUEPRINT-INIT-VALUE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express init values in PortPrototypeBlueprints. These init values act as a kind of blueprint from which for example proper ComSpecs can be derived.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototypeBlueprintInitValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the data prototype for which the init value applies</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototypeBlueprintInitValue.dataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:AUTOSAR-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE">
            <xsd:annotation>
               <xsd:documentation>This is the init value for the particular data prototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototypeBlueprintInitValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortProtoypeBlueprint::PortPrototypeBlueprintInitValue -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-PROTOTYPE-BLUEPRINT-INIT-VALUE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express init values in PortPrototypeBlueprints. These init values act as a kind of blueprint from which for example proper ComSpecs can be derived.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototypeBlueprintInitValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PORT-PROTOTYPE-BLUEPRINT-INIT-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortProtoypeBlueprint::PortPrototypeBlueprintMapping -->
   <xsd:group name="PORT-PROTOTYPE-BLUEPRINT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to map a PortPrototypeBlueprint to a PortProtoype of which one acts as the blueprint for the other.</xsd:documentation>
         <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="PortPrototypeBlueprintMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-BLUEPRINT-REF">
            <xsd:annotation>
               <xsd:documentation>The PortPrototypeBlueprint in the context of the mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototypeBlueprintMapping.portPrototypeBlueprint";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE-BLUEPRINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DERIVED-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>The PortPrototype in the context of the mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototypeBlueprintMapping.derivedPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortProtoypeBlueprint::PortPrototypeBlueprintMapping -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-PROTOTYPE-BLUEPRINT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to map a PortPrototypeBlueprint to a PortProtoype of which one acts as the blueprint for the other.</xsd:documentation>
         <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="PortPrototypeBlueprintMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT-MAPPING"/>
         <xsd:group ref="AR:PORT-PROTOTYPE-BLUEPRINT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::PortPrototypeRefConditional -->
   <xsd:group name="PORT-PROTOTYPE-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::PortPrototypeRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-PROTOTYPE-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PORT-PROTOTYPE-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::PositiveIntegerValueVariationPoint -->
   <xsd:group name="POSITIVE-INTEGER-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for positive Integer attributes.

      Note that this class might be used in the extended meta-model only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PositiveIntegerValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class VariantHandling::PositiveIntegerValueVariationPoint -->
   <xsd:complexType abstract="false" mixed="true" name="POSITIVE-INTEGER-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for positive Integer attributes.

      Note that this class might be used in the extended meta-model only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PositiveIntegerValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-DEPENDENT-FORMULA"/>
         <xsd:group ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
         <xsd:group ref="AR:POSITIVE-INTEGER-VALUE-VARIATION-POINT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::PostBuildVariantCondition -->
   <xsd:group name="POST-BUILD-VARIANT-CONDITION">
      <xsd:annotation>
         <xsd:documentation>This class specifies the value which must be assigned to a particular variant criterion in order to bind the variation point. If multiple criterion/value pairs are specified, they all must must match to bind the variation point.

      In other words binding can be represented by

        (criterion1 == value1) &amp;&amp; (condtion2 == value2) ...</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCondition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MATCHING-CRITERION-REF">
            <xsd:annotation>
               <xsd:documentation>This is the criterion which needs to match the value in order to make the PostbuildVariantCondition to be true.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCondition.matchingCriterion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:POST-BUILD-VARIANT-CRITERION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This is the particular value of the post-build variant criterion.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="PostBuildVariantCondition.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::PostBuildVariantCondition -->
   <xsd:complexType abstract="false" mixed="false" name="POST-BUILD-VARIANT-CONDITION">
      <xsd:annotation>
         <xsd:documentation>This class specifies the value which must be assigned to a particular variant criterion in order to bind the variation point. If multiple criterion/value pairs are specified, they all must must match to bind the variation point.

      In other words binding can be represented by

        (criterion1 == value1) &amp;&amp; (condtion2 == value2) ...</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCondition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:POST-BUILD-VARIANT-CONDITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::PostBuildVariantCriterion -->
   <xsd:group name="POST-BUILD-VARIANT-CRITERION">
      <xsd:annotation>
         <xsd:documentation>This class specifies one particular PostBuildVariantSelector.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PostBuildVariantCriterions";mmt.qualifiedName="PostBuildVariantCriterion"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-METHOD-REF">
            <xsd:annotation>
               <xsd:documentation>The compuMethod specifies the possible values for the variant criterion serving as an enumerator.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCriterion.compuMethod";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPU-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::PostBuildVariantCriterion -->
   <xsd:complexType abstract="false" mixed="false" name="POST-BUILD-VARIANT-CRITERION">
      <xsd:annotation>
         <xsd:documentation>This class specifies one particular PostBuildVariantSelector.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PostBuildVariantCriterions";mmt.qualifiedName="PostBuildVariantCriterion"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:POST-BUILD-VARIANT-CRITERION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="POST-BUILD-VARIANT-CRITERION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="POST-BUILD-VARIANT-CRITERION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class VariantHandling::PostBuildVariantCriterionValue -->
   <xsd:group name="POST-BUILD-VARIANT-CRITERION-VALUE">
      <xsd:annotation>
         <xsd:documentation>This class specifies a the value which must be assigned to a particular variant criterion in order to bind the variation point. If multiple criterion/value pairs are specified, they all must must match to bind the variation point.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCriterionValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIANT-CRITERION-REF">
            <xsd:annotation>
               <xsd:documentation>This association selects the variant criterion whose value is specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCriterionValue.variantCriterion";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:POST-BUILD-VARIANT-CRITERION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This is the particular value of the post-build variant criterion.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="PostBuildVariantCriterionValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>This provides the ability to add information why the value is set like it is.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCriterionValue.annotation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ANNOTATION" type="AR:ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::PostBuildVariantCriterionValue -->
   <xsd:complexType abstract="false" mixed="false" name="POST-BUILD-VARIANT-CRITERION-VALUE">
      <xsd:annotation>
         <xsd:documentation>This class specifies a the value which must be assigned to a particular variant criterion in order to bind the variation point. If multiple criterion/value pairs are specified, they all must must match to bind the variation point.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCriterionValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:POST-BUILD-VARIANT-CRITERION-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::PostBuildVariantCriterionValueSet -->
   <xsd:group name="POST-BUILD-VARIANT-CRITERION-VALUE-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote one set of postBuildVariantCriterionValues.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PostBuildVariantCriterionValueSets";mmt.qualifiedName="PostBuildVariantCriterionValueSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="POST-BUILD-VARIANT-CRITERION-VALUES">
            <xsd:annotation>
               <xsd:documentation>This is is one particular postbuild variant criterion/value pair being part of the PostBuildVariantSet.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PostBuildVariantCriterionValueSet.postBuildVariantCriterionValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="POST-BUILD-VARIANT-CRITERION-VALUE" type="AR:POST-BUILD-VARIANT-CRITERION-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::PostBuildVariantCriterionValueSet -->
   <xsd:complexType abstract="false" mixed="false" name="POST-BUILD-VARIANT-CRITERION-VALUE-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote one set of postBuildVariantCriterionValues.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PostBuildVariantCriterionValueSets";mmt.qualifiedName="PostBuildVariantCriterionValueSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:POST-BUILD-VARIANT-CRITERION-VALUE-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="POST-BUILD-VARIANT-CRITERION-VALUE-SET--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="POST-BUILD-VARIANT-CRITERION-VALUE-SET"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Chapters::PredefinedChapter -->
   <xsd:group name="PREDEFINED-CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This represents a predefined chapter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PredefinedChapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:CHAPTER-MODEL"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Chapters::PredefinedChapter -->
   <xsd:complexType abstract="false" mixed="false" name="PREDEFINED-CHAPTER">
      <xsd:annotation>
         <xsd:documentation>This represents a predefined chapter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PredefinedChapter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PREDEFINED-CHAPTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::PredefinedVariant -->
   <xsd:group name="PREDEFINED-VARIANT">
      <xsd:annotation>
         <xsd:documentation>This specifies one predefined variant. It is characterized by the union of all system constant values and post-build variant criterion values aggregated within all referenced system constant value sets and post build variant criterion value sets plus the value sets of the included variants.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PredefinedVariants";mmt.qualifiedName="PredefinedVariant"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INCLUDED-VARIANT-REFS">
            <xsd:annotation>
               <xsd:documentation>The associated variants are considered part of this PredefinedVariant. This means the settings of the included variants are included in the settings of the referencing PredefinedVariant. Nevertheless the included variants might be included in several predefined variants.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PredefinedVariant.includedVariant";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INCLUDED-VARIANT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PREDEFINED-VARIANT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POST-BUILD-VARIANT-CRITERION-VALUE-SET-REFS">
            <xsd:annotation>
               <xsd:documentation>This is the postBuildVariantCriterionValueSet contributing to the predefinded variant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PredefinedVariant.postBuildVariantCriterionValueSet";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="POST-BUILD-VARIANT-CRITERION-VALUE-SET-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:POST-BUILD-VARIANT-CRITERION-VALUE-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SYSTEMCONSTANT-VALUE-SET-REFS">
            <xsd:annotation>
               <xsd:documentation>This ist the set of Systemconstant Values contributing to the predefined variant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PredefinedVariant.swSystemconstantValueSet";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-SYSTEMCONSTANT-VALUE-SET-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SW-SYSTEMCONSTANT-VALUE-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::PredefinedVariant -->
   <xsd:complexType abstract="false" mixed="false" name="PREDEFINED-VARIANT">
      <xsd:annotation>
         <xsd:documentation>This specifies one predefined variant. It is characterized by the union of all system constant values and post-build variant criterion values aggregated within all referenced system constant value sets and post build variant criterion value sets plus the value sets of the included variants.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PredefinedVariants";mmt.qualifiedName="PredefinedVariant"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:PREDEFINED-VARIANT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PREDEFINED-VARIANT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PREDEFINED-VARIANT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class GerneralParameters::PrmChar -->
   <xsd:group name="PRM-CHAR">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to express the characteristics of one particular parameter. It can be exressed as numerical or as text parameter (provided as subclasses of PrmCharContents)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmChar"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COND" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents the particular conditions under which the parameter characteristic is valid.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmChar.cond";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:PRM-CHAR-NUMERICAL-CONTENTS"/>
            <xsd:group ref="AR:PRM-CHAR-TEXTUAL-CONTENTS"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="REMARK" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents further remarks about the particular parameter characteristics.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmChar.remark";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="160"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GerneralParameters::PrmChar -->
   <xsd:complexType abstract="false" mixed="false" name="PRM-CHAR">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to express the characteristics of one particular parameter. It can be exressed as numerical or as text parameter (provided as subclasses of PrmCharContents)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmChar"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PRM-CHAR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GerneralParameters::PrmCharAbsTol -->
   <xsd:group name="PRM-CHAR-ABS-TOL">
      <xsd:annotation>
         <xsd:documentation>The parameter is specified as ablolute value with a tolerance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharAbsTol"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ABS" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This represnts the absolute value of the parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharAbsTol.abs";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOL" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This represnts the tolerance of the parameter in the same units as the paramter: E.g. Tmperature= 50 +- 0.5 grad.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharAbsTol.tol";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GerneralParameters::PrmCharAbsTol -->
   <xsd:complexType abstract="false" mixed="false" name="PRM-CHAR-ABS-TOL">
      <xsd:annotation>
         <xsd:documentation>The parameter is specified as ablolute value with a tolerance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharAbsTol"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PRM-CHAR-NUMERICAL-VALUE"/>
         <xsd:group ref="AR:PRM-CHAR-ABS-TOL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GerneralParameters::PrmCharContents -->
   <xsd:group name="PRM-CHAR-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This is the contents of the parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class GerneralParameters::PrmCharMinTypMax -->
   <xsd:group name="PRM-CHAR-MIN-TYP-MAX">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the characteristics of a parameter as minimal, typical maximum value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharMinTypMax"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This represnts the minimum value of the parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharMinTypMax.min";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYP" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This represnts the typical value of the parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharMinTypMax.typ";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="110"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>This represnts the maximum value of the parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharMinTypMax.max";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="120"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GerneralParameters::PrmCharMinTypMax -->
   <xsd:complexType abstract="false" mixed="false" name="PRM-CHAR-MIN-TYP-MAX">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the characteristics of a parameter as minimal, typical maximum value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharMinTypMax"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PRM-CHAR-NUMERICAL-VALUE"/>
         <xsd:group ref="AR:PRM-CHAR-MIN-TYP-MAX"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GerneralParameters::PrmCharNumericalContents -->
   <xsd:group name="PRM-CHAR-NUMERICAL-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the fact that it is a numerical parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharNumericalContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:PRM-CHAR-ABS-TOL"/>
            <xsd:group ref="AR:PRM-CHAR-MIN-TYP-MAX"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="PRM-UNIT" type="AR:SINGLE-LANGUAGE-UNIT-NAMES">
            <xsd:annotation>
               <xsd:documentation>This is the measurement unit. Note that due to the fact that Prm is also available outside of MSRSW / AUTOSAR, this is not a formal reference  to a unit.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharNumericalContents.prmUnit";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="130"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GerneralParameters::PrmCharNumericalContents -->
   <xsd:complexType abstract="false" mixed="false" name="PRM-CHAR-NUMERICAL-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the fact that it is a numerical parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharNumericalContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PRM-CHAR-CONTENTS"/>
         <xsd:group ref="AR:PRM-CHAR-NUMERICAL-CONTENTS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GerneralParameters::PrmCharNumericalValue -->
   <xsd:group name="PRM-CHAR-NUMERICAL-VALUE">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents a numercial parameter characteristics.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharNumericalValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class GerneralParameters::PrmCharTextualContents -->
   <xsd:group name="PRM-CHAR-TEXTUAL-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the fact that it is a textual parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharTextualContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEXT" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This is the value of a textual parameter</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharTextualContents.text";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GerneralParameters::PrmCharTextualContents -->
   <xsd:complexType abstract="false" mixed="false" name="PRM-CHAR-TEXTUAL-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the fact that it is a textual parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrmCharTextualContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:PRM-CHAR-CONTENTS"/>
         <xsd:group ref="AR:PRM-CHAR-TEXTUAL-CONTENTS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GerneralParameters::Prms -->
   <xsd:group name="PRMS">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to specify a parameter table. It can be used e.g. to specify parameter tables in a data sheet.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Prms"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LABEL" type="AR:MULTILANGUAGE-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This represents the caption of the parameter table.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Prms.label";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="PRM" type="AR:GENERAL-PARAMETER">
            <xsd:annotation>
               <xsd:documentation>This represents one particular parameter in the the table.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Prms.prm";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GerneralParameters::Prms -->
   <xsd:complexType abstract="false" mixed="false" name="PRMS">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the ability to specify a parameter table. It can be used e.g. to specify parameter tables in a data sheet.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Prms"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:PRMS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class Communication::QueuedReceiverComSpec -->
   <xsd:group name="QUEUED-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to queued receiving.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="QueuedReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="QUEUE-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Length of queue for received events.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="QueuedReceiverComSpec.queueLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::QueuedReceiverComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="QUEUED-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to queued receiving.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="QueuedReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:R-PORT-COM-SPEC"/>
         <xsd:group ref="AR:RECEIVER-COM-SPEC"/>
         <xsd:group ref="AR:QUEUED-RECEIVER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::QueuedSenderComSpec -->
   <xsd:group name="QUEUED-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to distribution of  events (PPortPrototype, SenderReceiverInterface and dataElement carries an "event").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="QueuedSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class Communication::QueuedSenderComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="QUEUED-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to distribution of  events (PPortPrototype, SenderReceiverInterface and dataElement carries an "event").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="QueuedSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:P-PORT-COM-SPEC"/>
         <xsd:group ref="AR:SENDER-COM-SPEC"/>
         <xsd:group ref="AR:QUEUED-SENDER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::RModeGroupInAtomicSWCInstanceRef -->
   <xsd:group name="R-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RModeGroupInAtomicSWCInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-R-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RModeGroupInAtomicSWCInstanceRef.contextRPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RModeGroupInAtomicSWCInstanceRef.targetModeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::RModeGroupInAtomicSWCInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="R-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RModeGroupInAtomicSWCInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF"/>
         <xsd:group ref="AR:R-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::RModeInAtomicSwcInstanceRef -->
   <xsd:group name="R-MODE-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RModeInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RModeInAtomicSwcInstanceRef.contextPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-MODE-DECLARATION-GROUP-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RModeInAtomicSwcInstanceRef.contextModeDeclarationGroupPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RModeInAtomicSwcInstanceRef.targetModeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::RModeInAtomicSwcInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="R-MODE-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RModeInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:R-MODE-IN-ATOMIC-SWC-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::ROperationInAtomicSwcInstanceRef -->
   <xsd:group name="R-OPERATION-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ROperationInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-R-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ROperationInAtomicSwcInstanceRef.contextRPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REQUIRED-OPERATION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ROperationInAtomicSwcInstanceRef.targetRequiredOperation";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::ROperationInAtomicSwcInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="R-OPERATION-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ROperationInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:OPERATION-IN-ATOMIC-SWC-INSTANCE-REF"/>
         <xsd:group ref="AR:R-OPERATION-IN-ATOMIC-SWC-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::RPortComSpec -->
   <xsd:group name="R-PORT-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes of an RPortPrototypes. This class will contain attributes that are valid for all kinds of require-ports, independent of client-server or sender-receiver communication patterns.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RPortComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class InstanceRefs::RPortInCompositionInstanceRef -->
   <xsd:group name="R-PORT-IN-COMPOSITION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RPortInCompositionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RPortInCompositionInstanceRef.contextComponent";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-R-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RPortInCompositionInstanceRef.targetRPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::RPortInCompositionInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="R-PORT-IN-COMPOSITION-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RPortInCompositionInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:PORT-IN-COMPOSITION-TYPE-INSTANCE-REF"/>
         <xsd:group ref="AR:R-PORT-IN-COMPOSITION-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::RPortPrototype -->
   <xsd:group name="R-PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Component port requiring a certain port interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RPortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-COM-SPECS">
            <xsd:annotation>
               <xsd:documentation>Required communication attributes, one for each interface element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="requiredComSpec.RPortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-COM-SPEC" type="AR:CLIENT-COM-SPEC"/>
                  <xsd:element name="MODE-SWITCH-RECEIVER-COM-SPEC" type="AR:MODE-SWITCH-RECEIVER-COM-SPEC"/>
                  <xsd:element name="NONQUEUED-RECEIVER-COM-SPEC" type="AR:NONQUEUED-RECEIVER-COM-SPEC"/>
                  <xsd:element name="NV-REQUIRE-COM-SPEC" type="AR:NV-REQUIRE-COM-SPEC"/>
                  <xsd:element name="PARAMETER-REQUIRE-COM-SPEC" type="AR:PARAMETER-REQUIRE-COM-SPEC"/>
                  <xsd:element name="QUEUED-RECEIVER-COM-SPEC" type="AR:QUEUED-RECEIVER-COM-SPEC"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-INTERFACE-TREF">
            <xsd:annotation>
               <xsd:documentation>The interface that this port requires, i.e. the port depends on another port providing the specified interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="rPort.requiredInterface";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-INTERFACE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::RPortPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="R-PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Component port requiring a certain port interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RPortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:PORT-PROTOTYPE"/>
         <xsd:group ref="AR:R-PORT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="R-PORT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RTEEvents::RTEEvent -->
   <xsd:group name="RTE-EVENT">
      <xsd:annotation>
         <xsd:documentation>Abstract base class for all RTE-related events</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RTEEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISABLED-MODE-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the Modes that disable the Event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="disabledMode.RTEEvent";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DISABLED-MODE-IREF" type="AR:R-MODE-IN-ATOMIC-SWC-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="START-ON-EVENT-REF">
            <xsd:annotation>
               <xsd:documentation>RunnableEntity starts when the corresponding RTEEvent occurs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RTEEvent.startOnEvent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RUNNABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="RTE-EVENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
         <xsd:enumeration value="BACKGROUND-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVE-ERROR-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVED-EVENT"/>
         <xsd:enumeration value="DATA-SEND-COMPLETED-EVENT"/>
         <xsd:enumeration value="DATA-WRITE-COMPLETED-EVENT"/>
         <xsd:enumeration value="EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="INTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="OPERATION-INVOKED-EVENT"/>
         <xsd:enumeration value="RTE-EVENT"/>
         <xsd:enumeration value="SWC-MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="TIMING-EVENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InstanceRefs::RTriggerInAtomicSwcInstanceRef -->
   <xsd:group name="R-TRIGGER-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RTriggerInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-R-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RTriggerInAtomicSwcInstanceRef.contextRPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-TRIGGER-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RTriggerInAtomicSwcInstanceRef.targetTrigger";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::RTriggerInAtomicSwcInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="R-TRIGGER-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RTriggerInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:TRIGGER-IN-ATOMIC-SWC-INSTANCE-REF"/>
         <xsd:group ref="AR:R-TRIGGER-IN-ATOMIC-SWC-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::RVariableInAtomicSwcInstanceRef -->
   <xsd:group name="R-VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RVariableInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-R-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RVariableInAtomicSwcInstanceRef.contextRPort";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RVariableInAtomicSwcInstanceRef.targetDataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::RVariableInAtomicSwcInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="R-VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RVariableInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF"/>
         <xsd:group ref="AR:R-VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::ReceiverAnnotation -->
   <xsd:group name="RECEIVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of a receiver port, specifying properties of data elements that don't affect communication or generation of the RTE. The given attributes are requirements on the required data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-AGE" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum allowed age of the signal since it was originally read by a sensor. This is a requirement specified on the receiver side.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverAnnotation.signalAge";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::ReceiverAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="RECEIVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of a receiver port, specifying properties of data elements that don't affect communication or generation of the RTE. The given attributes are requirements on the required data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:SENDER-RECEIVER-ANNOTATION"/>
         <xsd:group ref="AR:RECEIVER-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::ReceiverComSpec -->
   <xsd:group name="RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Receiver-specific communication attributes (RPortPrototype typed by SenderReceiverInterface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Data element these attributes belong to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERNAL-REPLACEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>This reference is used to reference the AutosarDataPrototype to be taken for sourcing an external replacement in the out-of-range handling.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec.externalReplacement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:AUTOSAR-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-OUT-OF-RANGE" type="AR:HANDLE-OUT-OF-RANGE-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls how values that are out of the specified range are handled according to the values of HandleOutOfRangeEnum.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec.handleOutOfRange";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-OUT-OF-RANGE-STATUS" type="AR:HANDLE-OUT-OF-RANGE-STATUS-ENUM">
            <xsd:annotation>
               <xsd:documentation>Control the way how return values are created in case of an out-of-range situation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec.handleOutOfRangeStatus";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-DELTA-COUNTER-INIT" type="AR:POSITIVE-INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Initial maximum allowed gap between two counter values of two consecutively received valid Data, i.e. how many subsequent lost data is accepted. For example, if the receiver gets Data with counter 1 and MaxDeltaCounterInit is 1, then at the next reception the receiver can accept Counters with values 2 and 3, but not 4.

            Note that if the receiver does not receive new Data at a consecutive read, then the receiver increments the tolerance by 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ReceiverComSpec.maxDeltaCounterInit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NETWORK-REPRESENTATION" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>A networkRepresentation is used to define how the dataElement is mapped to a communication bus. The usage of SwDataDefProps for this purpose is restricted to the attributes compuMethod and baseType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec.networkRepresentation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USES-END-TO-END-PROTECTION" type="AR:BOOLEAN-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This indicates whether the corresponding dataElement shall be transmitted using end-to-end protection.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ReceiverComSpec.usesEndToEndProtection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Constants::RecordValueSpecification -->
   <xsd:group name="RECORD-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specifies the values for a record.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIELDS">
            <xsd:annotation>
               <xsd:documentation>The value for a single record field. This could also be mapped explicitly to a record element of the data type using the shortName of the ValueSpecification. But this would introduce a relationship to the data type that is too strong. As of now, it is only important that the structure of the data type matches the structure of the ValueSpecification indepenently of the shortNames.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RecordValueSpecification.field";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::RecordValueSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="RECORD-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specifies the values for a record.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-SPECIFICATION"/>
         <xsd:group ref="AR:RECORD-VALUE-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <xsd:complexType name="REF">
      <xsd:annotation>
         <xsd:documentation>This primitive denotes a name based reference. For detailed syntax see the xsd.pattern.

      * first slash (relative or absolute reference) [optional]
      * Identifier  [required]
      * a sequence of slashes and Identifiers [optional]

      This primitive is used by the meta-model tools to create the references.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Ref";xml.xsd.customType="REF";xml.xsd.pattern="/?[a-zA-Z][a-zA-Z0-9_]{0,127}(/[a-zA-Z][a-zA-Z0-9_]{0,127})*";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,primitive</xsd:appinfo>
         <xsd:appinfo source="constraint_2552">Index attribute is only valid for arrays The index attribute in references is valid only if the reference target is an ArrayElement and/or has an attribute maxNumberOfElements.</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:REF--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:REF"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- attribute group for class REF -->
   <xsd:attributeGroup name="REF">
      <xsd:annotation/>
      <xsd:attribute name="BASE" type="AR:IDENTIFIER--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute reflects the base to be used for this reference.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Ref.base";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="INDEX" type="AR:POSITIVE-INTEGER--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute supports the use case to point on specific elements in an array. This is in particular required if arrays are used to implement particular data objects.

         The attribute shall b</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Ref.index";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <xsd:simpleType name="REF--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="/?[a-zA-Z][a-zA-Z0-9_]{0,127}(/[a-zA-Z][a-zA-Z0-9_]{0,127})*"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ARPackage::ReferenceBase -->
   <xsd:group name="REFERENCE-BASE">
      <xsd:annotation>
         <xsd:documentation>This meta-class establishes a basis for relative references. Reference bases are identified by the shortLabel which must be unique in the current package.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceBase"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This is the name of the reference base. By this name, particular references can denote the applicable base.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceBase.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-DEFAULT" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute denotes if the current ReferenceBase is the default. Note that there can only be one default reference base within a package.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceBase.isDefault";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-GLOBAL" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This indicates that the target of the applicable reference can be resolved via the non-qualified shortName. This requires that the shortName of the target is unique within the package referenced in the reference base.

            The default is false.

            Note that the reference base also maintains a list of elements which may be referenced using a "global Reference".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceBase.isGlobal";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="25"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-IS-THIS-PACKAGE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This indicates that this base is established by the current package. In this case  the association "package" can be derived as the qualified shortName of the enclosing package. 

            If  the value of baseIsThisPackage is set to true then one of the following must be true:

            * target of the association "package" must be the enclosing package.
            * association "package" is omitted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceBase.baseIsThisPackage";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="28"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="GLOBAL-ELEMENTS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="GLOBAL-ELEMENT" type="AR:REFERRABLE--SUBTYPES-ENUM">
                     <xsd:annotation>
                        <xsd:documentation>This attribute represents a meta-class for which the global referencing is supported via this reference base.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceBase.globalElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="29"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PACKAGE-REF">
            <xsd:annotation>
               <xsd:documentation>This association specifies the basis of all relative references with the base equals shortLabel.

            This association must exist unless the value of baseIsThisPackage is set to true.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceBase.package";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:AR-PACKAGE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ARPackage::ReferenceBase -->
   <xsd:complexType abstract="false" mixed="false" name="REFERENCE-BASE">
      <xsd:annotation>
         <xsd:documentation>This meta-class establishes a basis for relative references. Reference bases are identified by the shortLabel which must be unique in the current package.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceBase"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERENCE-BASE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::ReferenceValueSpecification -->
   <xsd:group name="REFERENCE-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specifies a reference to a data prototype to be used as an initial value for a pointer in the software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFERENCE-VALUE-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced data prototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceValueSpecification.referenceValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ReferenceValueSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="REFERENCE-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specifies a reference to a data prototype to be used as an initial value for a pointer in the software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-SPECIFICATION"/>
         <xsd:group ref="AR:REFERENCE-VALUE-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Identifiable::Referrable -->
   <xsd:group name="REFERRABLE">
      <xsd:annotation>
         <xsd:documentation>Instances of this class can be referred to by their identifier (while adhering to namespace borders).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Referrable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="1" name="SHORT-NAME" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This specifies an identifying shortName for the object. It needs to be unique within its context and is intended for humans but even more for technical reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Referrable.shortName";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.enforceMinMultiplicity="true";xml.sequenceOffset="-100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="REFERRABLE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AR-ELEMENT"/>
         <xsd:enumeration value="AR-PACKAGE"/>
         <xsd:enumeration value="ABSTRACT-CAN-CLUSTER"/>
         <xsd:enumeration value="ABSTRACT-CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="ABSTRACT-CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="ABSTRACT-CAN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="AGE-CONSTRAINT"/>
         <xsd:enumeration value="ALIAS-NAME-SET"/>
         <xsd:enumeration value="ANALYZED-EXECUTION-TIME"/>
         <xsd:enumeration value="APPLICATION-ARRAY-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-ARRAY-ELEMENT"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="APPLICATION-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-ERROR"/>
         <xsd:enumeration value="APPLICATION-PRIMITIVE-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-DATA-TYPE"/>
         <xsd:enumeration value="APPLICATION-RECORD-ELEMENT"/>
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ARBITRARY-EVENT-TRIGGERING"/>
         <xsd:enumeration value="ARGUMENT-DATA-PROTOTYPE"/>
         <xsd:enumeration value="ASSEMBLY-SW-CONNECTOR"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-POINT"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RESULT-POINT"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATP-BLUEPRINT"/>
         <xsd:enumeration value="ATP-BLUEPRINTABLE"/>
         <xsd:enumeration value="ATP-CLASSIFIER"/>
         <xsd:enumeration value="ATP-FEATURE"/>
         <xsd:enumeration value="ATP-PROTOTYPE"/>
         <xsd:enumeration value="ATP-STRUCTURE-ELEMENT"/>
         <xsd:enumeration value="ATP-TYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:enumeration value="AUTOSAR-DATA-TYPE"/>
         <xsd:enumeration value="AUTOSAR-OPERATION-ARGUMENT-INSTANCE"/>
         <xsd:enumeration value="AUTOSAR-VARIABLE-INSTANCE"/>
         <xsd:enumeration value="BACKGROUND-EVENT"/>
         <xsd:enumeration value="BASE-TYPE"/>
         <xsd:enumeration value="BLUEPRINT-MAPPING-SET"/>
         <xsd:enumeration value="BSW-BACKGROUND-EVENT"/>
         <xsd:enumeration value="BSW-CALLED-ENTITY"/>
         <xsd:enumeration value="BSW-DEBUG-INFO"/>
         <xsd:enumeration value="BSW-EVENT"/>
         <xsd:enumeration value="BSW-EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="BSW-IMPLEMENTATION"/>
         <xsd:enumeration value="BSW-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="BSW-INTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="BSW-INTERNAL-TRIGGERING-POINT"/>
         <xsd:enumeration value="BSW-INTERRUPT-ENTITY"/>
         <xsd:enumeration value="BSW-MGR-NEEDS"/>
         <xsd:enumeration value="BSW-MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="BSW-MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="BSW-MODULE-DEPENDENCY"/>
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
         <xsd:enumeration value="BSW-MODULE-ENTITY"/>
         <xsd:enumeration value="BSW-MODULE-ENTRY"/>
         <xsd:enumeration value="BSW-MODULE-TIMING"/>
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
         <xsd:enumeration value="BSW-SCHEDULER-NAME-PREFIX"/>
         <xsd:enumeration value="BSW-TIMING-EVENT"/>
         <xsd:enumeration value="BURST-PATTERN-EVENT-TRIGGERING"/>
         <xsd:enumeration value="CALIBRATION-PARAMETER-VALUE-SET"/>
         <xsd:enumeration value="CAN-CLUSTER"/>
         <xsd:enumeration value="CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="CAN-FRAME"/>
         <xsd:enumeration value="CAN-FRAME-TRIGGERING"/>
         <xsd:enumeration value="CAN-NM-CLUSTER"/>
         <xsd:enumeration value="CAN-NM-NODE"/>
         <xsd:enumeration value="CAN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="CAN-TP-ADDRESS"/>
         <xsd:enumeration value="CAN-TP-CHANNEL"/>
         <xsd:enumeration value="CAN-TP-CONFIG"/>
         <xsd:enumeration value="CAN-TP-NODE"/>
         <xsd:enumeration value="CAPTION"/>
         <xsd:enumeration value="CHAPTER"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE-MAPPING"/>
         <xsd:enumeration value="CLIENT-SERVER-OPERATION"/>
         <xsd:enumeration value="CODE"/>
         <xsd:enumeration value="COLLECTABLE-ELEMENT"/>
         <xsd:enumeration value="COLLECTION"/>
         <xsd:enumeration value="COM-MGR-USER-NEEDS"/>
         <xsd:enumeration value="COMM-CONNECTOR-PORT"/>
         <xsd:enumeration value="COMMUNICATION-CLUSTER"/>
         <xsd:enumeration value="COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="COMPILER"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPU-METHOD"/>
         <xsd:enumeration value="CONCRETE-PATTERN-EVENT-TRIGGERING"/>
         <xsd:enumeration value="CONSTANT-SPECIFICATION"/>
         <xsd:enumeration value="CONSTANT-SPECIFICATION-MAPPING-SET"/>
         <xsd:enumeration value="CRYPTO-SERVICE-NEEDS"/>
         <xsd:enumeration value="DATA-CONSTR"/>
         <xsd:enumeration value="DATA-INTERFACE"/>
         <xsd:enumeration value="DATA-PROTOTYPE"/>
         <xsd:enumeration value="DATA-RECEIVE-ERROR-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVED-EVENT"/>
         <xsd:enumeration value="DATA-SEND-COMPLETED-EVENT"/>
         <xsd:enumeration value="DATA-TYPE-MAPPING-SET"/>
         <xsd:enumeration value="DATA-WRITE-COMPLETED-EVENT"/>
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="DEF-ITEM"/>
         <xsd:enumeration value="DELEGATION-SW-CONNECTOR"/>
         <xsd:enumeration value="DEPENDENCY-ON-ARTIFACT"/>
         <xsd:enumeration value="DIAG-EVENT-DEBOUNCE-ALGORITHM"/>
         <xsd:enumeration value="DIAG-EVENT-DEBOUNCE-COUNTER-BASED"/>
         <xsd:enumeration value="DIAG-EVENT-DEBOUNCE-MONITOR-INTERNAL"/>
         <xsd:enumeration value="DIAG-EVENT-DEBOUNCE-TIME-BASED"/>
         <xsd:enumeration value="DIAGNOSTIC-CAPABILITY-ELEMENT"/>
         <xsd:enumeration value="DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-EVENT-MANAGER-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-EVENT-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-IO-CONTROL-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-ROUTINE-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-VALUE-NEEDS"/>
         <xsd:enumeration value="DLT-USER-NEEDS"/>
         <xsd:enumeration value="DOCUMENTATION"/>
         <xsd:enumeration value="DOCUMENTATION-CONTEXT"/>
         <xsd:enumeration value="ECU-MAPPING"/>
         <xsd:enumeration value="EOC-EXECUTABLE-ENTITY-REF"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECU-INSTANCE"/>
         <xsd:enumeration value="ECU-PARTITION"/>
         <xsd:enumeration value="ECU-STATE-MGR-USER-NEEDS"/>
         <xsd:enumeration value="ECU-TIMING"/>
         <xsd:enumeration value="ECUC-ABSTRACT-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-ABSTRACT-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-ADD-INFO-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-CHOICE-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-CHOICE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-COMMON-ATTRIBUTES"/>
         <xsd:enumeration value="ECUC-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-CONTAINER-VALUE"/>
         <xsd:enumeration value="ECUC-DEFINITION-COLLECTION"/>
         <xsd:enumeration value="ECUC-DEFINITION-ELEMENT"/>
         <xsd:enumeration value="ECUC-ENUMERATION-LITERAL-DEF"/>
         <xsd:enumeration value="ECUC-ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-FOREIGN-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-FUNCTION-NAME-DEF"/>
         <xsd:enumeration value="ECUC-INSTANCE-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-LINKER-SYMBOL-DEF"/>
         <xsd:enumeration value="ECUC-MODULE-CONFIGURATION-VALUES"/>
         <xsd:enumeration value="ECUC-MODULE-DEF"/>
         <xsd:enumeration value="ECUC-MULTILINE-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-PARAM-CONF-CONTAINER-DEF"/>
         <xsd:enumeration value="ECUC-PARAMETER-DEF"/>
         <xsd:enumeration value="ECUC-QUERY"/>
         <xsd:enumeration value="ECUC-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ECUC-SYMBOLIC-NAME-REFERENCE-DEF"/>
         <xsd:enumeration value="ECUC-VALUE-COLLECTION"/>
         <xsd:enumeration value="END-TO-END-PROTECTION"/>
         <xsd:enumeration value="END-TO-END-PROTECTION-SET"/>
         <xsd:enumeration value="ETHERNET-CLUSTER"/>
         <xsd:enumeration value="ETHERNET-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="ETHERNET-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="ETHERNET-FRAME"/>
         <xsd:enumeration value="ETHERNET-FRAME-TRIGGERING"/>
         <xsd:enumeration value="ETHERNET-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="EVALUATED-VARIANT-SET"/>
         <xsd:enumeration value="EVENT-TRIGGERING-CONSTRAINT"/>
         <xsd:enumeration value="EXCLUSIVE-AREA"/>
         <xsd:enumeration value="EXECUTABLE-ENTITY"/>
         <xsd:enumeration value="EXECUTION-ORDER-CONSTRAINT"/>
         <xsd:enumeration value="EXECUTION-TIME"/>
         <xsd:enumeration value="EXECUTION-TIME-CONSTRAINT"/>
         <xsd:enumeration value="EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="FIBEX-ELEMENT"/>
         <xsd:enumeration value="FLAT-INSTANCE-DESCRIPTOR"/>
         <xsd:enumeration value="FLAT-MAP"/>
         <xsd:enumeration value="FLEXRAY-AR-TP-CONFIG"/>
         <xsd:enumeration value="FLEXRAY-AR-TP-NODE"/>
         <xsd:enumeration value="FLEXRAY-CLUSTER"/>
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="FLEXRAY-FRAME"/>
         <xsd:enumeration value="FLEXRAY-FRAME-TRIGGERING"/>
         <xsd:enumeration value="FLEXRAY-NM-CLUSTER"/>
         <xsd:enumeration value="FLEXRAY-NM-NODE"/>
         <xsd:enumeration value="FLEXRAY-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="FLEXRAY-TP-CONFIG"/>
         <xsd:enumeration value="FLEXRAY-TP-CONNECTION-CONTROL"/>
         <xsd:enumeration value="FLEXRAY-TP-NODE"/>
         <xsd:enumeration value="FLEXRAY-TP-PDU-POOL"/>
         <xsd:enumeration value="FRAME"/>
         <xsd:enumeration value="FRAME-PORT"/>
         <xsd:enumeration value="FRAME-TRIGGERING"/>
         <xsd:enumeration value="FUNCTION-INHIBITION-NEEDS"/>
         <xsd:enumeration value="GATEWAY"/>
         <xsd:enumeration value="GENERAL-PARAMETER"/>
         <xsd:enumeration value="HEAP-USAGE"/>
         <xsd:enumeration value="HW-ATTRIBUTE-DEF"/>
         <xsd:enumeration value="HW-ATTRIBUTE-LITERAL-DEF"/>
         <xsd:enumeration value="HW-CATEGORY"/>
         <xsd:enumeration value="HW-DESCRIPTION-ENTITY"/>
         <xsd:enumeration value="HW-ELEMENT"/>
         <xsd:enumeration value="HW-PIN"/>
         <xsd:enumeration value="HW-PIN-GROUP"/>
         <xsd:enumeration value="HW-TYPE"/>
         <xsd:enumeration value="I-PDU"/>
         <xsd:enumeration value="I-PDU-PORT"/>
         <xsd:enumeration value="I-SIGNAL"/>
         <xsd:enumeration value="I-SIGNAL-GROUP"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU"/>
         <xsd:enumeration value="I-SIGNAL-I-PDU-GROUP"/>
         <xsd:enumeration value="I-SIGNAL-PORT"/>
         <xsd:enumeration value="I-SIGNAL-TO-I-PDU-MAPPING"/>
         <xsd:enumeration value="I-SIGNAL-TRIGGERING"/>
         <xsd:enumeration value="IDENTIFIABLE"/>
         <xsd:enumeration value="IMPLEMENTATION"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE"/>
         <xsd:enumeration value="IMPLEMENTATION-DATA-TYPE-ELEMENT"/>
         <xsd:enumeration value="IMPLEMENTATION-PROPS"/>
         <xsd:enumeration value="INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="INTERNAL-TRIGGER-OCCURRED-EVENT"/>
         <xsd:enumeration value="INTERNAL-TRIGGERING-POINT"/>
         <xsd:enumeration value="INTERPOLATION-ROUTINE-MAPPING-SET"/>
         <xsd:enumeration value="J-1939-TP-CONFIG"/>
         <xsd:enumeration value="J-1939-TP-NODE"/>
         <xsd:enumeration value="KEYWORD"/>
         <xsd:enumeration value="KEYWORD-SET"/>
         <xsd:enumeration value="LATENCY-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="LIN-CLUSTER"/>
         <xsd:enumeration value="LIN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="LIN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="LIN-EVENT-TRIGGERED-FRAME"/>
         <xsd:enumeration value="LIN-FRAME"/>
         <xsd:enumeration value="LIN-FRAME-TRIGGERING"/>
         <xsd:enumeration value="LIN-MASTER"/>
         <xsd:enumeration value="LIN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="LIN-SCHEDULE-TABLE"/>
         <xsd:enumeration value="LIN-SLAVE"/>
         <xsd:enumeration value="LIN-SPORADIC-FRAME"/>
         <xsd:enumeration value="LIN-TP-CONFIG"/>
         <xsd:enumeration value="LIN-TP-NODE"/>
         <xsd:enumeration value="LIN-UNCONDITIONAL-FRAME"/>
         <xsd:enumeration value="LINKER"/>
         <xsd:enumeration value="LOGIC-ADDRESS"/>
         <xsd:enumeration value="MC-DATA-INSTANCE"/>
         <xsd:enumeration value="MEASURED-EXECUTION-TIME"/>
         <xsd:enumeration value="MEASURED-HEAP-USAGE"/>
         <xsd:enumeration value="MEASURED-STACK-USAGE"/>
         <xsd:enumeration value="MEMORY-SECTION"/>
         <xsd:enumeration value="MODE-DECLARATION"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP-PROTOTYPE"/>
         <xsd:enumeration value="MODE-INTERFACE-MAPPING"/>
         <xsd:enumeration value="MODE-SWITCH-INTERFACE"/>
         <xsd:enumeration value="MODE-SWITCH-POINT"/>
         <xsd:enumeration value="MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="MULTILANGUAGE-REFERRABLE"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="NM-CLUSTER"/>
         <xsd:enumeration value="NM-CONFIG"/>
         <xsd:enumeration value="NM-ECU"/>
         <xsd:enumeration value="NM-NODE"/>
         <xsd:enumeration value="NM-PDU"/>
         <xsd:enumeration value="NV-BLOCK-DESCRIPTOR"/>
         <xsd:enumeration value="NV-BLOCK-NEEDS"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-DATA-INTERFACE"/>
         <xsd:enumeration value="OBD-CONTROL-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-INFO-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-MONITOR-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-PID-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-RATIO-SERVICE-NEEDS"/>
         <xsd:enumeration value="OFFSET-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="OPERATION-INVOKED-EVENT"/>
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
         <xsd:enumeration value="PACKAGEABLE-ELEMENT"/>
         <xsd:enumeration value="PARAMETER-ACCESS"/>
         <xsd:enumeration value="PARAMETER-DATA-PROTOTYPE"/>
         <xsd:enumeration value="PARAMETER-INTERFACE"/>
         <xsd:enumeration value="PARAMETER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="PDU"/>
         <xsd:enumeration value="PDU-TO-FRAME-MAPPING"/>
         <xsd:enumeration value="PDU-TRIGGERING"/>
         <xsd:enumeration value="PDUR-I-PDU-GROUP"/>
         <xsd:enumeration value="PER-INSTANCE-MEMORY"/>
         <xsd:enumeration value="PERIODIC-EVENT-TRIGGERING"/>
         <xsd:enumeration value="PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="PHYSICAL-DIMENSION"/>
         <xsd:enumeration value="PORT-GROUP"/>
         <xsd:enumeration value="PORT-INTERFACE"/>
         <xsd:enumeration value="PORT-INTERFACE-MAPPING"/>
         <xsd:enumeration value="PORT-INTERFACE-MAPPING-SET"/>
         <xsd:enumeration value="PORT-PROTOTYPE"/>
         <xsd:enumeration value="PORT-PROTOTYPE-BLUEPRINT"/>
         <xsd:enumeration value="POST-BUILD-VARIANT-CRITERION"/>
         <xsd:enumeration value="POST-BUILD-VARIANT-CRITERION-VALUE-SET"/>
         <xsd:enumeration value="PREDEFINED-VARIANT"/>
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
         <xsd:enumeration value="RTE-EVENT"/>
         <xsd:enumeration value="REFERRABLE"/>
         <xsd:enumeration value="RESOURCE-CONSUMPTION"/>
         <xsd:enumeration value="ROOT-SW-COMPOSITION-PROTOTYPE"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-HEAP-USAGE"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-STACK-USAGE"/>
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
         <xsd:enumeration value="SDG-CAPTION"/>
         <xsd:enumeration value="SECTION-NAME-PREFIX"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVER-CALL-POINT"/>
         <xsd:enumeration value="SERVICE-NEEDS"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SIMULATED-EXECUTION-TIME"/>
         <xsd:enumeration value="SINGLE-LANGUAGE-REFERRABLE"/>
         <xsd:enumeration value="SOCKET-ADDRESS"/>
         <xsd:enumeration value="SPORADIC-EVENT-TRIGGERING"/>
         <xsd:enumeration value="STACK-USAGE"/>
         <xsd:enumeration value="STD"/>
         <xsd:enumeration value="STRUCTURED-REQ"/>
         <xsd:enumeration value="SUPERVISED-ENTITY-NEEDS"/>
         <xsd:enumeration value="SW-ADDR-METHOD"/>
         <xsd:enumeration value="SW-AXIS-TYPE"/>
         <xsd:enumeration value="SW-BASE-TYPE"/>
         <xsd:enumeration value="SW-COMPONENT-PROTOTYPE"/>
         <xsd:enumeration value="SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-CONNECTOR"/>
         <xsd:enumeration value="SW-GENERIC-AXIS-PARAM-TYPE"/>
         <xsd:enumeration value="SW-RECORD-LAYOUT"/>
         <xsd:enumeration value="SW-SERVICE-ARG"/>
         <xsd:enumeration value="SW-SYSTEMCONST"/>
         <xsd:enumeration value="SW-SYSTEMCONSTANT-VALUE-SET"/>
         <xsd:enumeration value="SWC-BSW-MAPPING"/>
         <xsd:enumeration value="SWC-IMPLEMENTATION"/>
         <xsd:enumeration value="SWC-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="SWC-MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="SWC-SERVICE-DEPENDENCY"/>
         <xsd:enumeration value="SWC-TIMING"/>
         <xsd:enumeration value="SWC-TO-ECU-MAPPING"/>
         <xsd:enumeration value="SWC-TO-IMPL-MAPPING"/>
         <xsd:enumeration value="SYMBOL-PROPS"/>
         <xsd:enumeration value="SYNC-TIME-BASE-MGR-USER-NEEDS"/>
         <xsd:enumeration value="SYNCHRONIZATION-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="SYNCHRONOUS-SERVER-CALL-POINT"/>
         <xsd:enumeration value="SYSTEM"/>
         <xsd:enumeration value="SYSTEM-MAPPING"/>
         <xsd:enumeration value="SYSTEM-SIGNAL"/>
         <xsd:enumeration value="SYSTEM-SIGNAL-GROUP"/>
         <xsd:enumeration value="SYSTEM-TIMING"/>
         <xsd:enumeration value="TD-EVENT-BSW"/>
         <xsd:enumeration value="TD-EVENT-BSW-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="TD-EVENT-BSW-MODE-DECLARATION"/>
         <xsd:enumeration value="TD-EVENT-BSW-MODULE"/>
         <xsd:enumeration value="TD-EVENT-COM"/>
         <xsd:enumeration value="TD-EVENT-COMPLEX"/>
         <xsd:enumeration value="TD-EVENT-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-FR-CLUSTER-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-FRAME"/>
         <xsd:enumeration value="TD-EVENT-I-PDU"/>
         <xsd:enumeration value="TD-EVENT-I-SIGNAL"/>
         <xsd:enumeration value="TD-EVENT-MODE-DECLARATION"/>
         <xsd:enumeration value="TD-EVENT-OPERATION"/>
         <xsd:enumeration value="TD-EVENT-SWC-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="TD-EVENT-TT-CAN-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-VARIABLE-DATA-PROTOTYPE"/>
         <xsd:enumeration value="TD-EVENT-VFB"/>
         <xsd:enumeration value="TIMING-CONSTRAINT"/>
         <xsd:enumeration value="TIMING-DESCRIPTION"/>
         <xsd:enumeration value="TIMING-DESCRIPTION-EVENT"/>
         <xsd:enumeration value="TIMING-DESCRIPTION-EVENT-CHAIN"/>
         <xsd:enumeration value="TIMING-EVENT"/>
         <xsd:enumeration value="TIMING-EXTENSION"/>
         <xsd:enumeration value="TOPIC-1"/>
         <xsd:enumeration value="TP-ADDRESS"/>
         <xsd:enumeration value="TP-CONFIG"/>
         <xsd:enumeration value="TRACE-REFERRABLE"/>
         <xsd:enumeration value="TRACEABLE"/>
         <xsd:enumeration value="TRACEABLE-TEXT"/>
         <xsd:enumeration value="TRIGGER"/>
         <xsd:enumeration value="TRIGGER-INTERFACE"/>
         <xsd:enumeration value="TRIGGER-INTERFACE-MAPPING"/>
         <xsd:enumeration value="TTCAN-CLUSTER"/>
         <xsd:enumeration value="TTCAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="TTCAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="TTCAN-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="UDP-NM-CLUSTER"/>
         <xsd:enumeration value="UDP-NM-NODE"/>
         <xsd:enumeration value="UNIT"/>
         <xsd:enumeration value="UNIT-GROUP"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-PDU"/>
         <xsd:enumeration value="VARIABLE-ACCESS"/>
         <xsd:enumeration value="VARIABLE-AND-PARAMETER-INTERFACE-MAPPING"/>
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE"/>
         <xsd:enumeration value="VARIATION-POINT-PROXY"/>
         <xsd:enumeration value="VFB-TIMING"/>
         <xsd:enumeration value="WAIT-POINT"/>
         <xsd:enumeration value="WORST-CASE-HEAP-USAGE"/>
         <xsd:enumeration value="WORST-CASE-STACK-USAGE"/>
         <xsd:enumeration value="XCP-PDU"/>
         <xsd:enumeration value="XDOC"/>
         <xsd:enumeration value="XFILE"/>
         <xsd:enumeration value="XREF-TARGET"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Timing::RelativeTolerance -->
   <xsd:group name="RELATIVE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RelativeTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RELATIVE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Maximum allowable deviation in percent</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RelativeTolerance.relative";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::RelativeTolerance -->
   <xsd:complexType abstract="false" mixed="false" name="RELATIVE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RelativeTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TIME-RANGE-TYPE-TOLERANCE"/>
         <xsd:group ref="AR:RELATIVE-TOLERANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ResourceConsumption::ResourceConsumption -->
   <xsd:group name="RESOURCE-CONSUMPTION">
      <xsd:annotation>
         <xsd:documentation>Description of consumed resources by one implementation of a software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ResourceConsumption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTION-TIMES">
            <xsd:annotation>
               <xsd:documentation>Collection of the execution time descriptions for this implementation.
            The aggregation of executionTime is subject to variability with the purpose to support the conditional existence of runnable entities.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="executionTime.ResourceConsumption";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ANALYZED-EXECUTION-TIME" type="AR:ANALYZED-EXECUTION-TIME"/>
                  <xsd:element name="MEASURED-EXECUTION-TIME" type="AR:MEASURED-EXECUTION-TIME"/>
                  <xsd:element name="ROUGH-ESTIMATE-OF-EXECUTION-TIME" type="AR:ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
                  <xsd:element name="SIMULATED-EXECUTION-TIME" type="AR:SIMULATED-EXECUTION-TIME"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HEAP-USAGES">
            <xsd:annotation>
               <xsd:documentation>Collection of the heap memory allocated by this implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="heapUsage.ResourceConsumption";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEASURED-HEAP-USAGE" type="AR:MEASURED-HEAP-USAGE"/>
                  <xsd:element name="ROUGH-ESTIMATE-HEAP-USAGE" type="AR:ROUGH-ESTIMATE-HEAP-USAGE"/>
                  <xsd:element name="WORST-CASE-HEAP-USAGE" type="AR:WORST-CASE-HEAP-USAGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-SECTIONS">
            <xsd:annotation>
               <xsd:documentation>An abstract memory section required by this Implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ResourceConsumption.memorySection";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEMORY-SECTION" type="AR:MEMORY-SECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECTION-NAME-PREFIXS">
            <xsd:annotation>
               <xsd:documentation>A prefix to be used for the memory section symbol in the code. 
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ResourceConsumption.sectionNamePrefix";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SECTION-NAME-PREFIX" type="AR:SECTION-NAME-PREFIX"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STACK-USAGES">
            <xsd:annotation>
               <xsd:documentation>Collection of the stack memory usage for each runnable entity of this implementation.
            The aggregation of StackUsage is subject to variability with the purpose to support the conditional existence of runnable entities.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="stackUsage.ResourceConsumption";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEASURED-STACK-USAGE" type="AR:MEASURED-STACK-USAGE"/>
                  <xsd:element name="ROUGH-ESTIMATE-STACK-USAGE" type="AR:ROUGH-ESTIMATE-STACK-USAGE"/>
                  <xsd:element name="WORST-CASE-STACK-USAGE" type="AR:WORST-CASE-STACK-USAGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ResourceConsumption::ResourceConsumption -->
   <xsd:complexType abstract="false" mixed="false" name="RESOURCE-CONSUMPTION">
      <xsd:annotation>
         <xsd:documentation>Description of consumed resources by one implementation of a software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ResourceConsumption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RESOURCE-CONSUMPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::RoleBasedBswModuleEntryAssignment -->
   <xsd:group name="ROLE-BASED-BSW-MODULE-ENTRY-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular BswModuleEntry (usually a configurable callback). 

      With this assignment, the role of the callback is mapped to a specific ServiceNeeds element, so that a tool is able to create appropriate configuration values for the module that implements the AUTOSAR Service.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedBswModuleEntryAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-ENTRY-REF">
            <xsd:annotation>
               <xsd:documentation>The assigned entry. It should be a providedEntry or expectedCallback of the module or cluster that requires the ServiceNeeds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedBswModuleEntryAssignment.assignedEntry";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROLE" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This is the role of the assigned BswModuleEntry in the given context. The attribute is required (for example) because different kind of callbacks may be associated with the same ServiceNeeds (e.g. end-notification vs. error-notification).

            The value must be the role name of a configurable function call (usually a callback) as standardized in the Software Specification of the related AUTOSAR Service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedBswModuleEntryAssignment.role";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::RoleBasedBswModuleEntryAssignment -->
   <xsd:complexType abstract="false" mixed="false" name="ROLE-BASED-BSW-MODULE-ENTRY-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular BswModuleEntry (usually a configurable callback). 

      With this assignment, the role of the callback is mapped to a specific ServiceNeeds element, so that a tool is able to create appropriate configuration values for the module that implements the AUTOSAR Service.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedBswModuleEntryAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ROLE-BASED-BSW-MODULE-ENTRY-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::RoleBasedDataAssignment -->
   <xsd:group name="ROLE-BASED-DATA-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular data object in the SwcInternalBehavior of a software component (or in the BswModuleBehavior of a module or cluster) in the context of an AUTOSAR Service.

      With this assignment, the role of the data can be mapped to a specific ServiceNeeds element, so that a tool is able to create the correct access.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedDataAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROLE" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This is the role of the assigned data in the given context, for example for an Nv block it is used to distinguish between an mirror block and a ROM default block. Possible values need to be specified on M1 level.

            This also is intended to support the so called "Signal based Approach" of the DCM. In this use case the name of the involved data element is required. This name shall be taken from the DataElement referenced by the property usedDataElement.

            The following values are standardized:
            * '''ramMirror''' indicates data to be used as a mirror for an Nv block.
            * '''defaultData''' indicates constant data to be used as default in the context of this ServiceNeeds, e.g. for an Nv block.
            * '''signalBasedDiagnostics''' indicates the RoleBasedDataAssignment shall be used for signal based diagnostics.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedDataAssignment.role";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-DATA-ELEMENT" type="AR:AUTOSAR-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>The VariableDataPrototype used in this role, e.g. 

            * RAM mirror for an Nv block which must belong to the same SwcInternalBehavior or BswInternalBehavior.

            * In the role signalBasedDiagnostics it has to refer to a VariableDataPrototype in a SenderReceiverInterface or a NvDataInterface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedDataAssignment.usedDataElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-PARAMETER-ELEMENT" type="AR:AUTOSAR-PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>The ParameterDataPrototype used in this role, e.g. 

            * ROM default for an Nv block. It must belong to the same SwcInternalBehavior or BswInternalbehavior.

            * In the role signalBasedDiagnostics it has to refer to a ParameterDataPrototype in a ParameterInterface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedDataAssignment.usedParameterElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-PIM-REF">
            <xsd:annotation>
               <xsd:documentation>The (untyped) PerInstanceMemory used in this role (e.g. as a RAM mirror for an Nv block).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedDataAssignment.usedPim";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PER-INSTANCE-MEMORY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::RoleBasedDataAssignment -->
   <xsd:complexType abstract="false" mixed="false" name="ROLE-BASED-DATA-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular data object in the SwcInternalBehavior of a software component (or in the BswModuleBehavior of a module or cluster) in the context of an AUTOSAR Service.

      With this assignment, the role of the data can be mapped to a specific ServiceNeeds element, so that a tool is able to create the correct access.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedDataAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ROLE-BASED-DATA-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::RoleBasedPortAssignment -->
   <xsd:group name="ROLE-BASED-PORT-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular service port (RPortPrototype or PPortPrototype) of an AtomicSwComponentType. With this assignment, the role of the service port can be mapped to a specific ServiceNeeds element, so that a tool is able to create the correct connector.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedPortAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Service port used in the assigned role. This port must either belong to the same AtomicSoftwareComponent as the SwcInternalBehavior which owns the ServiceDependency or to the same NvBlockComponentType as the NvBlockDescriptor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedPortAssignment.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROLE" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This is the role of the assigned Port in the given context.

            The value must be a name of a PortInterface as standardized in the Software Specification of the related AUTOSAR Service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedPortAssignment.role";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::RoleBasedPortAssignment -->
   <xsd:complexType abstract="false" mixed="false" name="ROLE-BASED-PORT-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular service port (RPortPrototype or PPortPrototype) of an AtomicSwComponentType. With this assignment, the role of the service port can be mapped to a specific ServiceNeeds element, so that a tool is able to create the correct connector.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedPortAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ROLE-BASED-PORT-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SystemTemplate::RootSwCompositionPrototype -->
   <xsd:group name="ROOT-SW-COMPOSITION-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>The RootSwCompositionPrototype represents the top-level-compostion of software components within a given System. According to the use case of the System, this may for example be the a more or less complete VFB description, the software of a System Extract or the software of a flat ECU Extract with only atomic SWCs. 

      Therefore the RootSwComposition will only occasionally contain all atomic software components that are used in a complete VFB System. The OEM is primarily interested in the required functionality and the interfaces defining the integration of the Software Component into the System. The internal structure of such a component contains often substantial intellectual property of a supplier. Therefore a top-level software composition will often contain empty compositions which represent subsystems. 

      The contained SwComponentPrototypes are fully specified by their SwComponentTypes (including PortPrototypes, PortInterfaces, VariableDataPrototypes, SwcInternalBehavior etc.), and their ports are interconnected using SwConnectorPrototypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RootSwCompositionPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALIBRATION-PARAMETER-VALUE-SET-REFS">
            <xsd:annotation>
               <xsd:documentation>Used CalibrationParameterValueSet for instance specific initialization of calibration parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RootSwCompositionPrototype.calibrationParameterValueSet";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CALIBRATION-PARAMETER-VALUE-SET-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CALIBRATION-PARAMETER-VALUE-SET--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLAT-MAP-REF">
            <xsd:annotation>
               <xsd:documentation>The FlatMap used in the scope of this RootSwCompositionPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RootSwCompositionPrototype.flatMap";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLAT-MAP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-TREF">
            <xsd:annotation>
               <xsd:documentation>We assume that there is exactly one top-level composition that includes all  Component instances  of the system</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RootSwCompositionPrototype.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPOSITION-SW-COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SystemTemplate::RootSwCompositionPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="ROOT-SW-COMPOSITION-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>The RootSwCompositionPrototype represents the top-level-compostion of software components within a given System. According to the use case of the System, this may for example be the a more or less complete VFB description, the software of a System Extract or the software of a flat ECU Extract with only atomic SWCs. 

      Therefore the RootSwComposition will only occasionally contain all atomic software components that are used in a complete VFB System. The OEM is primarily interested in the required functionality and the interfaces defining the integration of the Software Component into the System. The internal structure of such a component contains often substantial intellectual property of a supplier. Therefore a top-level software composition will often contain empty compositions which represent subsystems. 

      The contained SwComponentPrototypes are fully specified by their SwComponentTypes (including PortPrototypes, PortInterfaces, VariableDataPrototypes, SwcInternalBehavior etc.), and their ports are interconnected using SwConnectorPrototypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RootSwCompositionPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:ROOT-SW-COMPOSITION-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ROOT-SW-COMPOSITION-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ROOT-SW-COMPOSITION-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class HeapUsage::RoughEstimateHeapUsage -->
   <xsd:group name="ROUGH-ESTIMATE-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Rough estimation of the heap usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Rough estimate of the heap usage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateHeapUsage.memoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HeapUsage::RoughEstimateHeapUsage -->
   <xsd:complexType abstract="false" mixed="false" name="ROUGH-ESTIMATE-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Rough estimation of the heap usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HEAP-USAGE"/>
         <xsd:group ref="AR:ROUGH-ESTIMATE-HEAP-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::RoughEstimateOfExecutionTime -->
   <xsd:group name="ROUGH-ESTIMATE-OF-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Provides a description of a rough estimate on the ExecutionTime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateOfExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADDITIONAL-INFORMATION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Provides description on the rough estimate of the ExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateOfExecutionTime.additionalInformation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ESTIMATED-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The estimated execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateOfExecutionTime.estimatedExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::RoughEstimateOfExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="ROUGH-ESTIMATE-OF-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Provides a description of a rough estimate on the ExecutionTime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateOfExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
         <xsd:group ref="AR:ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class StackUsage::RoughEstimateStackUsage -->
   <xsd:group name="ROUGH-ESTIMATE-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Rough estimation of the stack usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Rough estimate of the stack usage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateStackUsage.memoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class StackUsage::RoughEstimateStackUsage -->
   <xsd:complexType abstract="false" mixed="false" name="ROUGH-ESTIMATE-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Rough estimation of the stack usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:STACK-USAGE"/>
         <xsd:group ref="AR:ROUGH-ESTIMATE-STACK-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class OasisExchangeTable::Row -->
   <xsd:group name="ROW">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express one row in a table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Row"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="ENTRY" type="AR:ENTRY">
            <xsd:annotation>
               <xsd:documentation>This represents one particular table cell. It is an entry in the table.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Row.entry";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class OasisExchangeTable::Row -->
   <xsd:attributeGroup name="ROW">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express one row in a table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Row"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ROWSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if by default a line should be displayed below the row.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Row.rowsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="VALIGN" type="AR:VALIGN-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates how the cells in the rows shall be aligned. Default is inherited from tbody, otherwise it is "TOP"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Row.valign";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class OasisExchangeTable::Row -->
   <xsd:complexType abstract="false" mixed="false" name="ROW">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express one row in a table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Row"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ROW"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ROW"/>
   </xsd:complexType>
   <!-- element group for class SwcInternalBehavior::RunnableEntity -->
   <xsd:group name="RUNNABLE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>A RunnableEntity represents the smallest code-fragment that is provided by an AtomicSwComponentType and are executed under control of the RTE. RunnableEntities are for instance set up to respond to data reception or operation invocation on a server.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENTS">
            <xsd:annotation>
               <xsd:documentation>This represents the formal definition of a an argument to a RunnableEntity.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.argument";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RUNNABLE-ENTITY-ARGUMENT" type="AR:RUNNABLE-ENTITY-ARGUMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASYNCHRONOUS-SERVER-CALL-RESULT-POINTS">
            <xsd:annotation>
               <xsd:documentation>The server call result point admits a runnable to fetch the result of an asynchronous server call.

            The aggregation of AsynchronousServerCallResultPoint is subject to variability with the purpose to support the conditional existence of client server PortPrototypes and the variant existence of server call result points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="asynchronousServerCallResultPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASYNCHRONOUS-SERVER-CALL-RESULT-POINT" type="AR:ASYNCHRONOUS-SERVER-CALL-RESULT-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-BE-INVOKED-CONCURRENTLY" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If the value of this attribute is set to TRUE the enclosing RunnableEntity can be invoked concurrently (even for one instance of the corresponding AtomicSwComponentType). This implies that it is the responsibility of the implementation of the RunnableEntity to take care of this form of concurrency. Note that the default value of this attribute is FALSE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.canBeInvokedConcurrently";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-READ-ACCESSS">
            <xsd:annotation>
               <xsd:documentation>RunnableEntity has implicit read access to dataElement of a sender-receiver PortPrototype or nv data of a nv data PortPrototype.

            The aggregation of dataReadAccess is subject to variability with the purpose to support the conditional existence of sender receiver ports or the variant existence of dataReadAccess in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RunnableEntity.dataReadAccess";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-ACCESS" type="AR:VARIABLE-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-RECEIVE-POINT-BY-ARGUMENTS">
            <xsd:annotation>
               <xsd:documentation>RunnableEntity has explicit read access to dataElement of a sender-receiver PortPrototype or nv data of a nv data PortPrototype.
            The result is passed back to the application by means of an argument in the function signature.

            The aggregation of dataReceivePointByArgument is subject to variability with the purpose to support the conditional existence of sender receiver PortPrototype or the variant existence of data receive points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RunnableEntity.dataReceivePointByArgument";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-ACCESS" type="AR:VARIABLE-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-RECEIVE-POINT-BY-VALUES">
            <xsd:annotation>
               <xsd:documentation>RunnableEntity has explicit read access to dataElement of a sender-receiver PortPrototyoe or nv data of a nv data PortPrototype.

            The result is passed back to the application by means of the return value.
            The aggregation of dataReceivePointByValue is subject to variability with the purpose to support the conditional existence of sender receiver ports or the variant existence of data receive points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RunnableEntity.dataReceivePointByValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-ACCESS" type="AR:VARIABLE-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-SEND-POINTS">
            <xsd:annotation>
               <xsd:documentation>RunnableEntity has explicit write access to dataElement of a sender-receiver PortPrototype or nv data of a nv data PortPrototype.

            The aggregation of dataSendPoint is subject to variability with the purpose to support the conditional existence of sender receiver PortPrototype or the variant existence of data send points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RunnableEntity.dataSendPoint";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-ACCESS" type="AR:VARIABLE-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-WRITE-ACCESSS">
            <xsd:annotation>
               <xsd:documentation>RunnableEntity has implicit write access to dataElement of a sender-receiver PortPrototype or nv data of a nv data PortPrototype.

            The aggregation of dataWriteAccess is subject to variability with the purpose to support the conditional existence of sender receiver ports or the variant existence of dataWriteAccess in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RunnableEntity.dataWriteAccess";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-ACCESS" type="AR:VARIABLE-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERNAL-TRIGGERING-POINTS">
            <xsd:annotation>
               <xsd:documentation>The aggregation of ExternalTriggeringPoint is subject to variability with the purpose to support the conditional existence of trigger ports or the variant existence of external triggering points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="externalTriggeringPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EXTERNAL-TRIGGERING-POINT" type="AR:EXTERNAL-TRIGGERING-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERNAL-TRIGGERING-POINTS">
            <xsd:annotation>
               <xsd:documentation>The aggregation of InternalTriggeringPoint is subject to variability with the purpose to support the variant existence of internal triggering points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="internalTriggeringPoint.RunnableEntity";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INTERNAL-TRIGGERING-POINT" type="AR:INTERNAL-TRIGGERING-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-ACCESS-POINTS">
            <xsd:annotation>
               <xsd:documentation>The runnable has a mode access point.
            The aggregation of ModeAccessPoint is subject to variability with the purpose to support the conditional existence of mode ports or the variant existence of mode access points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="modeAccessPoint.RunnableEntity";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-ACCESS-POINT" type="AR:MODE-ACCESS-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-SWITCH-POINTS">
            <xsd:annotation>
               <xsd:documentation>The runnable has a mode switch point.
            The aggregation of ModeSwitchPoint is subject to variability with the purpose to support the conditional existence of mode ports or the variant existence of mode switch points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="modeSwitchPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-SWITCH-POINT" type="AR:MODE-SWITCH-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-ACCESSS">
            <xsd:annotation>
               <xsd:documentation>The presence of a ParameterAccess implies that a RunnableEntity needs read only access to a ParameterDataPrototype which may either be local or within a PortPrototype.

            The aggregation of ParameterAccess is subject to variability with the purpose to support the conditional existence of parameter ports and component local parameters as well as the variant existence of ParameterAccess (points) in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RunnableEntity.parameterAccess";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAMETER-ACCESS" type="AR:PARAMETER-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="READ-LOCAL-VARIABLES">
            <xsd:annotation>
               <xsd:documentation>The presence of a readLocalVariable implies that a RunnableEntity needs read access to a VariableDataPrototype in the role of implicitInterRunnableVariable or explicitInterRunnableVariable.

            The aggregation of readLocalVariable is subject to variability with the purpose to support the conditional existence of implicitInterRunnableVariable and explicitInterRunnableVariable or the variant existence of readLocalVariable (points) in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RunnableEntity.readLocalVariable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-ACCESS" type="AR:VARIABLE-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVER-CALL-POINTS">
            <xsd:annotation>
               <xsd:documentation>The RunnableEntity has a ServerCallPoint.
            The aggregation of ServerCallPoint is subject to variability with the purpose to support the conditional existence of client server PortPrototypes or the variant existence of server call points in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="serverCallPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASYNCHRONOUS-SERVER-CALL-POINT" type="AR:ASYNCHRONOUS-SERVER-CALL-POINT"/>
                  <xsd:element name="SYNCHRONOUS-SERVER-CALL-POINT" type="AR:SYNCHRONOUS-SERVER-CALL-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL" type="AR:C-IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>The symbol describing this RunnableEntity's entry point. This is considered the API of the RunnableEntity and is required during the RTE contract phase.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.symbol";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAIT-POINTS">
            <xsd:annotation>
               <xsd:documentation>The WaitPoint associated with teh RunnableEntity.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="waitPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="WAIT-POINT" type="AR:WAIT-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITTEN-LOCAL-VARIABLES">
            <xsd:annotation>
               <xsd:documentation>The presence of a writtenLocalVariable implies that a RunnableEntity needs write access to a VariableDataPrototype in the role of implicitInterRunnableVariable or explicitInterRunnableVariable.

            The aggregation of writtenLocalVariable is subject to variability with the purpose to support the conditional existence of implicitInterRunnableVariable and explicitInterRunnableVariable or the variant existence of writtenLocalVariable (points) in the implementation.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="RunnableEntity.writtenLocalVariable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-ACCESS" type="AR:VARIABLE-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcInternalBehavior::RunnableEntity -->
   <xsd:complexType abstract="false" mixed="false" name="RUNNABLE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>A RunnableEntity represents the smallest code-fragment that is provided by an AtomicSwComponentType and are executed under control of the RTE. RunnableEntities are for instance set up to respond to data reception or operation invocation on a server.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:EXECUTABLE-ENTITY"/>
         <xsd:group ref="AR:RUNNABLE-ENTITY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="RUNNABLE-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RunnableEntity::RunnableEntityArgument -->
   <xsd:group name="RUNNABLE-ENTITY-ARGUMENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to provide specific information regarding the arguments to a RunnableEntity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntityArgument"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL" type="AR:C-IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This represents the symbol to be generated into the actual signature on the level of the C programming language.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntityArgument.symbol";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RunnableEntity::RunnableEntityArgument -->
   <xsd:complexType abstract="false" mixed="false" name="RUNNABLE-ENTITY-ARGUMENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to provide specific information regarding the arguments to a RunnableEntity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntityArgument"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:RUNNABLE-ENTITY-ARGUMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanCommunication::RxIdentifierRange -->
   <xsd:group name="RX-IDENTIFIER-RANGE">
      <xsd:annotation>
         <xsd:documentation>Optional definition of a CanId range to reduce the effort of specifying every possible FrameTriggering within the defined Id range during reception. All frames received within a range are mapped to the same Pdu that is passed to a upper layer module (e.g. Nm, CDD, PduR). 

      This range is redundant to the nmRangeConfig attributes of "CanNmNode". For backward compatibility reasons this redundancy shall be preserved and both shall be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RxIdentifierRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-CAN-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute can be used together with the upperCanId attribute to define a range of CanIds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RxIdentifierRange.lowerCanId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-CAN-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute can be used together with the lowerCanId attribute to define a range of CanIds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RxIdentifierRange.upperCanId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanCommunication::RxIdentifierRange -->
   <xsd:complexType abstract="false" mixed="false" name="RX-IDENTIFIER-RANGE">
      <xsd:annotation>
         <xsd:documentation>Optional definition of a CanId range to reduce the effort of specifying every possible FrameTriggering within the defined Id range during reception. All frames received within a range are mapped to the same Pdu that is passed to a upper layer module (e.g. Nm, CDD, PduR). 

      This range is redundant to the nmRangeConfig attributes of "CanNmNode". For backward compatibility reasons this redundancy shall be preserved and both shall be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RxIdentifierRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:RX-IDENTIFIER-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::SaveConfigurationEntry -->
   <xsd:group name="SAVE-CONFIGURATION-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This service is used to notify a slave node to store its configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SaveConfigurationEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class LinCommunication::SaveConfigurationEntry -->
   <xsd:complexType abstract="false" mixed="false" name="SAVE-CONFIGURATION-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This service is used to notify a slave node to store its configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SaveConfigurationEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:LIN-CONFIGURATION-ENTRY"/>
         <xsd:group ref="AR:SAVE-CONFIGURATION-ENTRY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GlobalConstraints::ScaleConstr -->
   <xsd:group name="SCALE-CONSTR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify constraints as a list of intervals (called scales).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This element specifies a short name for the scaleConstr. This can for example be used to create more specific messages of a constraint checker. The constraints cannot be associated in the meta-model, therefore shortLabel is somehow a substitute for shortName.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>&lt;desc&gt; represents a general but brief description of the object in question.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class GlobalConstraints::ScaleConstr -->
   <xsd:attributeGroup name="SCALE-CONSTR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify constraints as a list of intervals (called scales).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="VALIDITY" type="AR:SCALE-CONSTR-VALIDITY-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies if the values defined by the scales are considered to be valid. If the attribute is missing then the default value is "VALID".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.validity";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class GlobalConstraints::ScaleConstr -->
   <xsd:complexType abstract="false" mixed="false" name="SCALE-CONSTR">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify constraints as a list of intervals (called scales).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCALE-CONSTR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:SCALE-CONSTR"/>
   </xsd:complexType>
   <!-- element group for class GlobalConstraints::ScaleConstrs -->
   <xsd:group name="SCALE-CONSTRS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express embedded constraints. It can be used in physical as well as the internal domain. The units for the physical domain are derived from the unit of the container.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="SCALE-CONSTR" type="AR:SCALE-CONSTR">
            <xsd:annotation>
               <xsd:documentation>This is one particular scale in which contributes to the data constraints.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrs.scaleConstr";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::ScaleConstrs -->
   <xsd:complexType abstract="false" mixed="false" name="SCALE-CONSTRS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express embedded constraints. It can be used in physical as well as the internal domain. The units for the physical domain are derived from the unit of the container.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCALE-CONSTRS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::ScheduleTableEntry -->
   <xsd:group name="SCHEDULE-TABLE-ENTRY">
      <xsd:annotation>
         <xsd:documentation>Table entry in a LinScheduleTable. Specifies what will be done in the frame slot.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScheduleTableEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents introductory documentation about the schedule table entry.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScheduleTableEntry.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELAY" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Relative delay between this tableEntry and the start of the successor in the schedule table in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScheduleTableEntry.delay";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POSITION-IN-TABLE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Relative position in the schedule table. The first entry index in the schedule table is 0.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScheduleTableEntry.positionInTable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class SpecialData::Sd -->
   <xsd:group name="SD">
      <xsd:annotation>
         <xsd:documentation>This class represents a primitive element in a special data group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sd"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:VERBATIM-STRING--SIMPLE">
            <xsd:annotation>
               <xsd:documentation>This is the value of the special data.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Sd.value";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="false";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class SpecialData::Sd -->
   <xsd:attributeGroup name="SD">
      <xsd:annotation>
         <xsd:documentation>This class represents a primitive element in a special data group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sd"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="GID" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attributes specifies an identifier. Gid comes from the SGML/XML-Term "Generic Identifier" which is the element name in XML. The role of this attribute is the same as the name of an XML - element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Sd.gid";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class SpecialData::Sd -->
   <xsd:complexType name="SD">
      <xsd:annotation>
         <xsd:documentation>This class represents a primitive element in a special data group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sd"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:VERBATIM-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:SD"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- element group for class SpecialData::Sdg -->
   <xsd:group name="SDG">
      <xsd:annotation>
         <xsd:documentation>Sdg (SpecialDataGroup) is a generic model which can be used to keep arbitrary information which is not explicitly modeled in the meta-model. 

      Sdg can have various contents as defined by sdgContentsType. Special Data should only be used moderately since all elements should be defined in the meta-model. 

      Thereby SDG should be considered as a temporary solution when no explicit model is available. If an sdgCaption is available, it is possible to establish a reference to the sdg structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sdg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SDG-CAPTION" type="AR:SDG-CAPTION">
            <xsd:annotation>
               <xsd:documentation>this aggregation allows to assign the properties of Identifiable to the sdg. By this, a shortName etc. can be assigned to the Sdg.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Sdg.sdgCaption";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SDG-CAPTION-REF">
            <xsd:annotation>
               <xsd:documentation>This association allows to reuse an already exisiting caption.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Sdg.sdgCaptionRef";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.name="SDG-CAPTION-REF";xml.sequenceOffset="25"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SDG-CAPTION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:SDG-CONTENTS"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class SpecialData::Sdg -->
   <xsd:attributeGroup name="SDG">
      <xsd:annotation>
         <xsd:documentation>Sdg (SpecialDataGroup) is a generic model which can be used to keep arbitrary information which is not explicitly modeled in the meta-model. 

      Sdg can have various contents as defined by sdgContentsType. Special Data should only be used moderately since all elements should be defined in the meta-model. 

      Thereby SDG should be considered as a temporary solution when no explicit model is available. If an sdgCaption is available, it is possible to establish a reference to the sdg structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sdg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="GID" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attributes specifies an identifier. Gid comes from the SGML/XML-Term "Generic Identifier" which is the element name in XML. The role of this attribute is the same as the name of an XML - element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Sdg.gid";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class SpecialData::Sdg -->
   <xsd:complexType abstract="false" mixed="false" name="SDG">
      <xsd:annotation>
         <xsd:documentation>Sdg (SpecialDataGroup) is a generic model which can be used to keep arbitrary information which is not explicitly modeled in the meta-model. 

      Sdg can have various contents as defined by sdgContentsType. Special Data should only be used moderately since all elements should be defined in the meta-model. 

      Thereby SDG should be considered as a temporary solution when no explicit model is available. If an sdgCaption is available, it is possible to establish a reference to the sdg structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sdg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SDG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:SDG"/>
   </xsd:complexType>
   <!-- element group for class SpecialData::SdgCaption -->
   <xsd:group name="SDG-CAPTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the caption of a special data group. This allows to have some parts of special data as identifiable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SdgCaption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This represents a general but brief (one paragraph) description what the special data in question is about. It is only one paragraph! Desc is intended to be collected into overview tables. This property helps a human reader to identify the special data in question.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SdgCaption.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SpecialData::SdgCaption -->
   <xsd:complexType abstract="false" mixed="false" name="SDG-CAPTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the caption of a special data group. This allows to have some parts of special data as identifiable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SdgCaption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:SDG-CAPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <xsd:simpleType name="SDG-CAPTION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SDG-CAPTION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SpecialData::SdgContents -->
   <xsd:group name="SDG-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the possible contents of a special data group. It can be an arbitrary mix of references, of primitive special data and nested special data groups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="SDX-REF">
               <xsd:annotation>
                  <xsd:documentation>Reference to any identifiable element. This allows to use Sdg even to establish arbitrary relationships.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents.sdx";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:REFERRABLE--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="SD" type="AR:SD">
               <xsd:annotation>
                  <xsd:documentation>This is one particular special data element.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents.sd";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SDG" type="AR:SDG">
               <xsd:annotation>
                  <xsd:documentation>This aggregation allows to express nested special data groups. By this, any structure can be represented in SpeicalData.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents.sdg";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class SpecialData::SdgContents -->
   <xsd:complexType abstract="false" mixed="false" name="SDG-CONTENTS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the possible contents of a special data group. It can be an arbitrary mix of references, of primitive special data and nested special data groups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SDG-CONTENTS"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class MemorySectionUsage::SectionNamePrefix -->
   <xsd:group name="SECTION-NAME-PREFIX">
      <xsd:annotation>
         <xsd:documentation>A prefix to be used for generated code artifacts defining a memory section name in the source code of the using module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SectionNamePrefix"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MemorySectionUsage::SectionNamePrefix -->
   <xsd:complexType abstract="false" mixed="false" name="SECTION-NAME-PREFIX">
      <xsd:annotation>
         <xsd:documentation>A prefix to be used for generated code artifacts defining a memory section name in the source code of the using module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SectionNamePrefix"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:IMPLEMENTATION-PROPS"/>
         <xsd:group ref="AR:SECTION-NAME-PREFIX"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <xsd:simpleType name="SECTION-NAME-PREFIX--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SECTION-NAME-PREFIX"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::SegmentPosition -->
   <xsd:group name="SEGMENT-POSITION">
      <xsd:annotation>
         <xsd:documentation>The StaticPart and the DynamicPart can be
      separated in multiple segments within the multiplexed PDU. 

      The ISignalIPdus are copied bit by bit into the MultiplexedIPdu. If the space of the first segment is 5 bits large than the first 5 bits of the ISignalIPdu are copied into this first segment and so on.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the order of the bytes of the segment and the packing into the MultiplexedIPdu. The byte ordering "Little Endian" (MostSignificantByteLast) and "Big Endian" (MostSignificantByteFirst) can be selected.

            A mix between Little Endian and Big Endian within a MultiplexedIPdu (staticPart, dynamicPart, selectorField) is not allowed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition.segmentByteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Data Length of the segment in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition.segmentLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Segments bit position relatively to the beginning of a multiplexed IPdu.

            Note that the absolute position of the segment in the MultiplexedIPdu is determined by the definition of the segmentByteOrder attribute of the SegmentPosition. If Big Endian is specified, the start position indicates the bit position of the most significant bit in the IPdu. If Little Endian is specified, the start position indicates the bit position of the least significant bit in the IPdu. In AUTOSAR the bit counting is always set to "sawtooth" and the bit order is set to "Decreasing".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition.segmentPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SegmentPosition -->
   <xsd:complexType abstract="false" mixed="false" name="SEGMENT-POSITION">
      <xsd:annotation>
         <xsd:documentation>The StaticPart and the DynamicPart can be
      separated in multiple segments within the multiplexed PDU. 

      The ISignalIPdus are copied bit by bit into the MultiplexedIPdu. If the space of the first segment is 5 bits large than the first 5 bits of the ISignalIPdu are copied into this first segment and so on.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SEGMENT-POSITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::SenderAnnotation -->
   <xsd:group name="SENDER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of a sender port, specifying properties of data elements that don't affect communication or generation of the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::SenderAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of a sender port, specifying properties of data elements that don't affect communication or generation of the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:SENDER-RECEIVER-ANNOTATION"/>
         <xsd:group ref="AR:SENDER-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::SenderComSpec -->
   <xsd:group name="SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for a sender port (PPortPrototype typed by SenderReceiverInterface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Data element these quality of service attributes apply to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderComSpec.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-OUT-OF-RANGE" type="AR:HANDLE-OUT-OF-RANGE-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls how out-of-range values shall be dealt with.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderComSpec.handleOutOfRange";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NETWORK-REPRESENTATION" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>A networkRepresentation is used to define how the dataElement is mapped to a communication bus. The usage of SwDataDefProps for this purpose is restricted to the attributes compuMethod and baseType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderComSpec.networkRepresentation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-ACKNOWLEDGE" type="AR:TRANSMISSION-ACKNOWLEDGEMENT-REQUEST">
            <xsd:annotation>
               <xsd:documentation>Requested transmission acknowledgement for data element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionAcknowledge.SenderComSpec";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USES-END-TO-END-PROTECTION" type="AR:BOOLEAN-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This indicates whether the corresponding dataElement shall be transmitted using end-to-end protection.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SenderComSpec.usesEndToEndProtection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class DataMapping::SenderRecArrayElementMapping -->
   <xsd:group name="SENDER-REC-ARRAY-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The SenderRecArrayElement may be a primitive one or a composite one. If the element is primitive, it will be mapped to the SystemSignal (multiplicity 1). If the VariableDataPrototype that is referenced by SenderReceiverToSignalGroupMapping is typed by an ApplicationDataType the reference to the ApplicationArrayElement shall be used. If the VariableDataPrototype is typed by the ImplementationDataType the reference to the ImplementationArrayElement shall be used. 

      If the element is composite, there will be no mapping to the SystemSignal (multiplicity 0). In this case the ArrayElementMapping element will aggregate the TypeMapping element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive array element is mapped the indexed element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPLEX-TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>This aggregation will be used if the element is composite.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="complexTypeMapping.SenderRecArrayElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="SENDER-REC-ARRAY-TYPE-MAPPING" type="AR:SENDER-REC-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="SENDER-REC-RECORD-TYPE-MAPPING" type="AR:SENDER-REC-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEXED-ARRAY-ELEMENT" type="AR:INDEXED-ARRAY-ELEMENT">
            <xsd:annotation>
               <xsd:documentation>Reference to an indexed array element in the context of the dataElement or in the context of a composite element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="indexedArrayElement.SenderRecArrayElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the primitive ApplicationArrayElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayElementMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderRecArrayElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-REC-ARRAY-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The SenderRecArrayElement may be a primitive one or a composite one. If the element is primitive, it will be mapped to the SystemSignal (multiplicity 1). If the VariableDataPrototype that is referenced by SenderReceiverToSignalGroupMapping is typed by an ApplicationDataType the reference to the ApplicationArrayElement shall be used. If the VariableDataPrototype is typed by the ImplementationDataType the reference to the ImplementationArrayElement shall be used. 

      If the element is composite, there will be no mapping to the SystemSignal (multiplicity 0). In this case the ArrayElementMapping element will aggregate the TypeMapping element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive array element is mapped the indexed element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SENDER-REC-ARRAY-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderRecArrayTypeMapping -->
   <xsd:group name="SENDER-REC-ARRAY-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the ApplicationCompositeDataType is an Array, the "ArrayTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Each ApplicationArrayElement must be mapped on a SystemSignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="arrayElementMapping.SenderRecArrayTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SENDER-REC-ARRAY-ELEMENT-MAPPING" type="AR:SENDER-REC-ARRAY-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderRecArrayTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-REC-ARRAY-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the ApplicationCompositeDataType is an Array, the "ArrayTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SENDER-REC-COMPOSITE-TYPE-MAPPING"/>
         <xsd:group ref="AR:SENDER-REC-ARRAY-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderRecCompositeTypeMapping -->
   <xsd:group name="SENDER-REC-COMPOSITE-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Two mappings exist for the composite data types:
      "ArrayTypeMapping" and "RecordTypeMapping".
      In both, a primitive datatype will be mapped to a system signal. 

      But it is also possible to combine the arrays and the records, so that an "array" could be an element of a "record" and in the same manner a "record" could be an element of an "array". Nesting these data types is also possible.

      If an element of a composite data type is again a composite one, the "CompositeTypeMapping" element will be used one more time (aggregation between the ArrayElementMapping and CompositeTypeMapping or aggregation between the RecordElementMapping and CompositeTypeMapping).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecCompositeTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class DataMapping::SenderRecRecordElementMapping -->
   <xsd:group name="SENDER-REC-RECORD-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a primitive record element to a SystemSignal. If the VariableDataPrototype that is referenced by SenderReceiverToSignalGroupMapping is typed by an ApplicationDataType the reference applicationRecordElement shall be used. If the VariableDataPrototype is typed by the ImplementationDataType the reference implementationRecordElement shall be used. Either the implementationRecordElement or applicationRecordElement reference shall be used. 

      If the element is composite, there will be no mapping to the SystemSignal (multiplicity 0). In this case the RecordElementMapping element will aggregate the complexTypeMapping element. In that way also the composite datatypes can be mapped to SystemSignals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPLICATION-RECORD-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an ApplicationRecordElement in the context of the dataElement or in the context of a composite element. This reference shall only be used if the VariableDataPrototype that is referenced by the SenderReceiverToSignalGroupMapping.dataElement is typed by an ApplicationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping.applicationRecordElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-RECORD-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPLEX-TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>This aggregation will be used if the element is composite.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="complexTypeMapping.SenderRecRecordElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="SENDER-REC-ARRAY-TYPE-MAPPING" type="AR:SENDER-REC-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="SENDER-REC-RECORD-TYPE-MAPPING" type="AR:SENDER-REC-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-RECORD-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an ImplementationRecordElement in the context of the dataElement or in the context of a composite element. This reference shall only be used if VariableDataPrototype that is referenced by the SenderReceiverToSignalGroupMapping.dataElement is typed by an ImplementationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping.implementationRecordElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the primitive ApplicationRecordElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderRecRecordElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-REC-RECORD-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a primitive record element to a SystemSignal. If the VariableDataPrototype that is referenced by SenderReceiverToSignalGroupMapping is typed by an ApplicationDataType the reference applicationRecordElement shall be used. If the VariableDataPrototype is typed by the ImplementationDataType the reference implementationRecordElement shall be used. Either the implementationRecordElement or applicationRecordElement reference shall be used. 

      If the element is composite, there will be no mapping to the SystemSignal (multiplicity 0). In this case the RecordElementMapping element will aggregate the complexTypeMapping element. In that way also the composite datatypes can be mapped to SystemSignals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SENDER-REC-RECORD-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderRecRecordTypeMapping -->
   <xsd:group name="SENDER-REC-RECORD-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the ApplicationCompositeDataType is a Record, the "RecordTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECORD-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Each ApplicationRecordElement must be mapped on a SystemSignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="recordElementMapping.SenderRecRecordTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SENDER-REC-RECORD-ELEMENT-MAPPING" type="AR:SENDER-REC-RECORD-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderRecRecordTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-REC-RECORD-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the ApplicationCompositeDataType is a Record, the "RecordTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SENDER-REC-COMPOSITE-TYPE-MAPPING"/>
         <xsd:group ref="AR:SENDER-REC-RECORD-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::SenderReceiverAnnotation -->
   <xsd:group name="SENDER-RECEIVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of the data elements in a port that realizes a sender/receiver interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPUTED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Flag whether this data element was not measured directly but instead was calculated from possibly several other measured or calculated values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation.computed";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>The instance of VariableDataPrototype annotated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIMIT-KIND" type="AR:DATA-LIMIT-KIND-ENUM">
            <xsd:annotation>
               <xsd:documentation>This min or max has not to be mismatched with the min- and max for data-value in a compu-method. For example, this annotation
            shows when the result of the calculation performed in a RunnableEntity owned by one AtomicSwComponentType is transmitted to another AtomicSwComponentType whose RunnableEntity will use this value as a limit, e.g. the max.power which can be used by that software-component, or the current min. slip.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation.limitKind";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROCESSING-KIND" type="AR:PROCESSING-KIND-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls how data is processed according to the possible values of ProcessingKindEnum.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation.processingKind";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class PortInterface::SenderReceiverInterface -->
   <xsd:group name="SENDER-RECEIVER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A sender/receiver interface declares a number of data elements to be sent and received.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="SenderReceiverInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>The data elements of this SenderReceiverInterface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.interface";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-DATA-PROTOTYPE" type="AR:VARIABLE-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INVALIDATION-POLICYS">
            <xsd:annotation>
               <xsd:documentation>InvalidationPolicy for a particular dataElement</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverInterface.invalidationPolicy";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INVALIDATION-POLICY" type="AR:INVALIDATION-POLICY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::SenderReceiverInterface -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-RECEIVER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A sender/receiver interface declares a number of data elements to be sent and received.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="SenderReceiverInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:DATA-INTERFACE"/>
         <xsd:group ref="AR:SENDER-RECEIVER-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderReceiverToSignalGroupMapping -->
   <xsd:group name="SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a sender receiver communication data element with a composite datatype to a signal group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREF" type="AR:VARIABLE-DATA-PROTOTYPE-IN-SYSTEM-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a data element with a composite datatype which is mapped to a signal group.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.SenderReceiverToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the signal group, which contain all primitive datatypes of the composite type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping.signalGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>The CompositeTypeMapping maps the the ApplicationArrayElements and ApplicationRecordElements to Signals of the SignalGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="typeMapping.SenderReceiverToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="SENDER-REC-ARRAY-TYPE-MAPPING" type="AR:SENDER-REC-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="SENDER-REC-RECORD-TYPE-MAPPING" type="AR:SENDER-REC-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderReceiverToSignalGroupMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a sender receiver communication data element with a composite datatype to a signal group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DATA-MAPPING"/>
         <xsd:group ref="AR:SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderReceiverToSignalMapping -->
   <xsd:group name="SENDER-RECEIVER-TO-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a sender receiver communication data element with a primitive datatype to a signal. 
      If the data element has to be transmitted to several receivers there is still exactly one mapping defined.  In case of 1:n communication the VariableDataPrototype in the ProvidePort of the SwComponentPrototype is still mapped to only one SystemSignal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREF" type="AR:VARIABLE-DATA-PROTOTYPE-IN-SYSTEM-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the data element, which ought to be sent over the Communication bus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.SenderReceiverToSignalMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the data element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderReceiverToSignalMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-RECEIVER-TO-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a sender receiver communication data element with a primitive datatype to a signal. 
      If the data element has to be transmitted to several receivers there is still exactly one mapping defined.  In case of 1:n communication the VariableDataPrototype in the ProvidePort of the SwComponentPrototype is still mapped to only one SystemSignal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DATA-MAPPING"/>
         <xsd:group ref="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::SensorActuatorSwComponentType -->
   <xsd:group name="SENSOR-ACTUATOR-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The SensorActuatorSwComponentType introduces the possibility to link from the software representation of a sensor/actuator to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="SensorActuatorSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SENSOR-ACTUATOR-REF">
            <xsd:annotation>
               <xsd:documentation>Reference from the Sensor Actuator Software Component Type to the description of the actual hardware.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SensorActuatorSwComponentType.sensorActuator";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-DESCRIPTION-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::SensorActuatorSwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="SENSOR-ACTUATOR-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The SensorActuatorSwComponentType introduces the possibility to link from the software representation of a sensor/actuator to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="SensorActuatorSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::SeparateSignalPath -->
   <xsd:group name="SEPARATE-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The SeparateSignalPath describes that two SwcToSwcSignals and/or SwcToSwcOperationArguments must not take the same way (Signal Path) in the topology (e.g. Redundancy). 
      This means that the signals are not allowed to share 
      even a single physical channel in their path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SeparateSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcOperationArguments that must not take the same way (Signal Path) in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.SeparateSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNALS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcSignals that must not take the same way (Signal Path) in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signal.SeparateSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::SeparateSignalPath -->
   <xsd:complexType abstract="false" mixed="false" name="SEPARATE-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The SeparateSignalPath describes that two SwcToSwcSignals and/or SwcToSwcOperationArguments must not take the same way (Signal Path) in the topology (e.g. Redundancy). 
      This means that the signals are not allowed to share 
      even a single physical channel in their path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SeparateSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SIGNAL-PATH-CONSTRAINT"/>
         <xsd:group ref="AR:SEPARATE-SIGNAL-PATH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SequenceCounterMapping -->
   <xsd:group name="SEQUENCE-COUNTER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The purpose of sequence counters is to map a response to the correct request of a known client.

      The SequenceCounter is mapped to the requestGroup and to the responseGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SequenceCounterMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the SystemSignal with the SequenceCounter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SequenceCounterMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SequenceCounterMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SEQUENCE-COUNTER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The purpose of sequence counters is to map a response to the correct request of a known client.

      The SequenceCounter is mapped to the requestGroup and to the responseGroup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SequenceCounterMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SEQUENCE-COUNTER-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServerCall::ServerCallPoint -->
   <xsd:group name="SERVER-CALL-POINT">
      <xsd:annotation>
         <xsd:documentation>If a RunnableEntity owns a ServerCallPoint it is entitled to invoke a 
      particular ClientServerOperation of a specific RPortPrototype of the 
      corresponding AtomicSwComponentType</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerCallPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-IREF" type="AR:R-OPERATION-IN-ATOMIC-SWC-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The operation that is called by this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.ServerCallPoint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Time in seconds before the server call times out and returns with an error message. It depends on the call type (synchronous or asynchronous) how this is reported.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerCallPoint.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Communication::ServerComSpec -->
   <xsd:group name="SERVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for a server port (PPortPrototype and ClientServerInterface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-REF">
            <xsd:annotation>
               <xsd:documentation>Operation these communication attributes apply to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerComSpec.operation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="QUEUE-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Length of call queue on the mode user side. The queue is implemented by the RTE. The value must be greater or equal to 1. Setting the value of queueLength to 1 implies that incoming requests are rejected while another request that arrived earlier is being processed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerComSpec.queueLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ServerComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="SERVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for a server port (PPortPrototype and ClientServerInterface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:P-PORT-COM-SPEC"/>
         <xsd:group ref="AR:SERVER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ServiceDependency -->
   <xsd:group name="SERVICE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>Collects all dependencies of a software module or component on an  AUTOSAR Service related to a specific item (e.g. an Nv block, a diagnostic event etc.). It defines the quality of service (ServiceNeeds) of this item as well as (optionally) references to additional elements.

      This information is required for tools in order to generate the related basic software configuration and ServiceSwComponentTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class ServiceNeeds::ServiceNeeds -->
   <xsd:group name="SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>This expresses the abstract needs that a Software Component or Basic Software Module has on the configuration of an AUTOSAR Service to which it will be connected. "Abstract needs" means that the model abstracts from the Configuration Parameters of the underlying Basic Software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class Components::ServiceProxySwComponentType -->
   <xsd:group name="SERVICE-PROXY-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>This class provides the ability to express a software-component which provides access to an internal service for remote ECUs. It acts as a proxy for the service providing access to the service.

      An important use case is the request of vehicle mode switches: Such requests can be communicated via sender-receiver interfaces across ECU boundaries, but the mode manager being responsible to perform the mode switches is an AUTOSAR Service which is located in the Basic Software and is not visible in the VFB view. To handle this situation, a ServiceProxySwComponentType will act as proxy for the mode manager. It will have R-Ports to be connected with the mode requestors on VFB level and Service-Ports to be connected with the local mode manager at ECU integration time.

      Apart from the semantics, a ServiceProxySwComponentType has these specific properties:
      * A prototype of it can be mapped to more than one ECUs in the system description.
      * Exactly one additional instance of it will be created in the ECU-Extract per ECU to which the prototype has been mapped.
      * For remote communication, it can have only R-Ports with sender-receiver interfaces and 1:n semantics.
      * There shall be no connectors between two prototypes of any ServiceProxySwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ServiceProxySwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class Components::ServiceProxySwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="SERVICE-PROXY-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>This class provides the ability to express a software-component which provides access to an internal service for remote ECUs. It acts as a proxy for the service providing access to the service.

      An important use case is the request of vehicle mode switches: Such requests can be communicated via sender-receiver interfaces across ECU boundaries, but the mode manager being responsible to perform the mode switches is an AUTOSAR Service which is located in the Basic Software and is not visible in the VFB view. To handle this situation, a ServiceProxySwComponentType will act as proxy for the mode manager. It will have R-Ports to be connected with the mode requestors on VFB level and Service-Ports to be connected with the local mode manager at ECU integration time.

      Apart from the semantics, a ServiceProxySwComponentType has these specific properties:
      * A prototype of it can be mapped to more than one ECUs in the system description.
      * Exactly one additional instance of it will be created in the ECU-Extract per ECU to which the prototype has been mapped.
      * For remote communication, it can have only R-Ports with sender-receiver interfaces and 1:n semantics.
      * There shall be no connectors between two prototypes of any ServiceProxySwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ServiceProxySwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:SERVICE-PROXY-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Components::ServiceSwComponentType -->
   <xsd:group name="SERVICE-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>ServiceSwComponentType is used for configuring services for a given ECU. Instances of this class are only to be created in ECU Configuration phase for the specific purpose of the service configuration.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ServiceSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class Components::ServiceSwComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="SERVICE-SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>ServiceSwComponentType is used for configuring services for a given ECU. Instances of this class are only to be created in ECU Configuration phase for the specific purpose of the service configuration.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwComponentTypes";mmt.qualifiedName="ServiceSwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:group ref="AR:SERVICE-SW-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::SignalIPduCounter -->
   <xsd:group name="SIGNAL-I-PDU-COUNTER">
      <xsd:annotation>
         <xsd:documentation>A PduCounter is included in a predefined set of Pdus and used to ensure that a sequence of Pdus is maintained. The counter is incremented when a Pdu is transmitted. The receivers check if the received Pdu is the next one in sequence.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduCounter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-COUNTER-SIZE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Size of PduCounter expressed in bits. 
            Range: 1..8</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduCounter.pduCounterSize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-COUNTER-START-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Position of PduCounter expressed in bits. Note that PduCounter is not allowed to cross a byte border.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduCounter.pduCounterStartPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-COUNTER-THRESHOLD" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Threshold value of IPduCounter algorithm. See AUTOSAR COM Spec for more details.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduCounter.pduCounterThreshold";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SignalIPduCounter -->
   <xsd:complexType abstract="false" mixed="false" name="SIGNAL-I-PDU-COUNTER">
      <xsd:annotation>
         <xsd:documentation>A PduCounter is included in a predefined set of Pdus and used to ensure that a sequence of Pdus is maintained. The counter is incremented when a Pdu is transmitted. The receivers check if the received Pdu is the next one in sequence.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduCounter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SIGNAL-I-PDU-COUNTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::SignalIPduReplication -->
   <xsd:group name="SIGNAL-I-PDU-REPLICATION">
      <xsd:annotation>
         <xsd:documentation>PduReplication is a form of redundancy where the data content of one ISignalIPdu (source) is transmitted inside a set of replica ISignalIPdus. These ISignalIPdus (copies) have different Pdu IDs, identical PduCounters, identical data content and are transmitted with the same frequency.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduReplication"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-REPLICATION-VOTING" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of identical IPdus needed for successful voting (1-3).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduReplication.pduReplicationVoting";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REPLICA-PDUS-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to replica Pdus of this IPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduReplication.replicaPdus";pureMM.maxOccurs="2";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="REPLICA-PDUS-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SignalIPduReplication -->
   <xsd:complexType abstract="false" mixed="false" name="SIGNAL-I-PDU-REPLICATION">
      <xsd:annotation>
         <xsd:documentation>PduReplication is a form of redundancy where the data content of one ISignalIPdu (source) is transmitted inside a set of replica ISignalIPdus. These ISignalIPdus (copies) have different Pdu IDs, identical PduCounters, identical data content and are transmitted with the same frequency.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPduReplication"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SIGNAL-I-PDU-REPLICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::SignalPathConstraint -->
   <xsd:group name="SIGNAL-PATH-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>Additional guidelines for the System Generator, which specific way a signal between two Software Components should take in the network without defining in which frame and with which timing it is transmitted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalPathConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents introductory documentation about the signal path constraint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalPathConstraint.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ExecutionTime::SimulatedExecutionTime -->
   <xsd:group name="SIMULATED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Specifies the ExecutionTime which has been gathered using simulation means.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum simulated execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime.maximumExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The minimum simulated execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime.minimumExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NOMINAL-EXECUTION-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The nominal simulated execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime.nominalExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::SimulatedExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="SIMULATED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Specifies the ExecutionTime which has been gathered using simulation means.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
         <xsd:group ref="AR:SIMULATED-EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SingleLanguageData::SingleLanguageLongName -->
   <xsd:group name="SINGLE-LANGUAGE-LONG-NAME">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageLongName</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SingleLanguageLongName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class SingleLanguageData::SingleLanguageLongName -->
   <xsd:complexType abstract="false" mixed="true" name="SINGLE-LANGUAGE-LONG-NAME">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageLongName</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SingleLanguageLongName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MIXED-CONTENT-FOR-LONG-NAME"/>
         <xsd:group ref="AR:SINGLE-LANGUAGE-LONG-NAME"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Identifiable::SingleLanguageReferrable -->
   <xsd:group name="SINGLE-LANGUAGE-REFERRABLE">
      <xsd:annotation>
         <xsd:documentation>Instances of this class can be referred to by their identifier (while adhering to namespace borders). They also may have a longName but in one language only. 

      Specializations of this class only occur as inline elements in one particular language. Therefore they aggregate

      But they are not considered to contribute substantially to the overall structure of an AUTOSAR description. In particular it does not contain other Referrables.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SingleLanguageReferrable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LONG-NAME-1" type="AR:SINGLE-LANGUAGE-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This specifies the long name of the object. The role is longName1 for compatibilty to ASAM FSX</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SingleLanguageReferrable.longName1";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class SingleLanguageData::SingleLanguageUnitNames -->
   <xsd:group name="SINGLE-LANGUAGE-UNIT-NAMES">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to express a display name.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SingleLanguageUnitNames"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class SingleLanguageData::SingleLanguageUnitNames -->
   <xsd:complexType abstract="false" mixed="true" name="SINGLE-LANGUAGE-UNIT-NAMES">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to express a display name.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SingleLanguageUnitNames"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MIXED-CONTENT-FOR-UNIT-NAMES"/>
         <xsd:group ref="AR:SINGLE-LANGUAGE-UNIT-NAMES"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EthernetCommunication::SoAdConfig -->
   <xsd:group name="SO-AD-CONFIG">
      <xsd:annotation>
         <xsd:documentation>SoAd Configuration for one specific Physical Channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoAdConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>Collection of socket connections.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="connection.SoAdConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SOCKET-CONNECTION" type="AR:SOCKET-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOGIC-ADDRESSS">
            <xsd:annotation>
               <xsd:documentation>Collection of DoIp Addresses.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="logicAddress.SoAdConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LOGIC-ADDRESS" type="AR:LOGIC-ADDRESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOCKET-ADDRESSS">
            <xsd:annotation>
               <xsd:documentation>Collection of SoAdAddresses.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="socketAddress.SoAdConfig";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SOCKET-ADDRESS" type="AR:SOCKET-ADDRESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetCommunication::SoAdConfig -->
   <xsd:complexType abstract="false" mixed="false" name="SO-AD-CONFIG">
      <xsd:annotation>
         <xsd:documentation>SoAd Configuration for one specific Physical Channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoAdConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SO-AD-CONFIG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EthernetCommunication::SocketAddress -->
   <xsd:group name="SOCKET-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>SocketAddress contains the portAddress and the ipAddress.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SocketAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTOR-REF">
            <xsd:annotation>
               <xsd:documentation>Asscociation to a CommunicationConnector in the topology description. 
            In a System Description this reference is mandatory. In an ECU Extract this reference is optional (references to ECUs that are not part of the ECU Extract shall be avoided).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketAddress.connector";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ETHERNET-COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IP-ADDRESS" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Logical address that is assigned to the referenced device in a network utilizing the Internet Protocol for communication between its nodes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketAddress.ipAddress";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-ADDRESS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Remote or Local UDP or TCP port used for the  connection that refers this element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketAddress.portAddress";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetCommunication::SocketAddress -->
   <xsd:complexType abstract="false" mixed="false" name="SOCKET-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>SocketAddress contains the portAddress and the ipAddress.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SocketAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SOCKET-ADDRESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SOCKET-ADDRESS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SOCKET-ADDRESS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class EthernetCommunication::SocketConnection -->
   <xsd:group name="SOCKET-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>The SoAd serves as a (De)Multiplexer between different PDU sources and the TCP/IP stack.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AUTOSAR-CONNECTOR" type="AR:SO-AD-CONNECTOR-TYPE">
            <xsd:annotation>
               <xsd:documentation>Availability of protocol plug-ins. Entries in the Socket and PDU Routing Tables.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection.autosarConnector";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DO-IP-SOURCE-ADDRESS-REF">
            <xsd:annotation>
               <xsd:documentation>The logical DoIP address of the source entity. This optional reference shall only be used for DoIP (Diagnosis over IP).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection.doIpSourceAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LOGIC-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DO-IP-TARGET-ADDRESS-REF">
            <xsd:annotation>
               <xsd:documentation>The logical DoIP address of the target entity. This optional reference shall only be used for DoIP (Diagnosis over IP).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection.doIpTargetAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LOGIC-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOCAL-PORT-REF">
            <xsd:annotation>
               <xsd:documentation>Local Port for TCP/UDP connection (in case the local port is fixed).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection.localPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOCKET-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="N-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to data packets that are transmitted over Ethernet. Each data packet can contain multiple IPdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection.nPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDUS">
            <xsd:annotation>
               <xsd:documentation>PDUs handed over by the PDU Router (Transmission over the Ethernet) or PDUs handed over by SoAd (Reception over Ethernet). Multiple IPdus can be transmitted over one socket connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pdu.SocketConnection";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SOCKET-CONNECTION-IPDU-IDENTIFIER" type="AR:SOCKET-CONNECTION-IPDU-IDENTIFIER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REMOTE-PORT-REF">
            <xsd:annotation>
               <xsd:documentation>Remote Port for TCP/UDP connection. May be different for each Frame or use the same remote port. In second case headerId attribute needs to be considered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection.remotePort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOCKET-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOCKET-PROTOCOL" type="AR:SO-AD-PROTOCOL-TYPE">
            <xsd:annotation>
               <xsd:documentation>Specifies the transport protocol (UDP or TCP). Transport Protocols are responsible for encapsulating application data blocks into datagrams suitable for transfer to the network infrastructure for transmission to the destination host, or managing the reverse transaction by abstracting network datagrams and delivering them to an application.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection.socketProtocol";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetCommunication::SocketConnection -->
   <xsd:complexType abstract="false" mixed="false" name="SOCKET-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>The SoAd serves as a (De)Multiplexer between different PDU sources and the TCP/IP stack.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SOCKET-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EthernetCommunication::SocketConnectionIpduIdentifier -->
   <xsd:group name="SOCKET-CONNECTION-IPDU-IDENTIFIER">
      <xsd:annotation>
         <xsd:documentation>An Identifier is required in case of one port per ECU communication where multiple Pdus are transmitted over the same connection. If only one IPdu is transmitted over the connetion this attribute can be ignored.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnectionIpduIdentifier"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HEADER-ID" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>If multiple Pdus are transmitted over the same connection this headerId can be used to distinguish between the different Pdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnectionIpduIdentifier.headerId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an IPdu that is mapped to a socket connection. This reference can be used to derive the AUTOSAR Connector in SoAd configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnectionIpduIdentifier.pdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EthernetCommunication::SocketConnectionIpduIdentifier -->
   <xsd:complexType abstract="false" mixed="false" name="SOCKET-CONNECTION-IPDU-IDENTIFIER">
      <xsd:annotation>
         <xsd:documentation>An Identifier is required in case of one port per ECU communication where multiple Pdus are transmitted over the same connection. If only one IPdu is transmitted over the connetion this attribute can be ignored.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SocketConnectionIpduIdentifier"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SOCKET-CONNECTION-IPDU-IDENTIFIER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ResourceConsumption::SoftwareContext -->
   <xsd:group name="SOFTWARE-CONTEXT">
      <xsd:annotation>
         <xsd:documentation>Specifies the context of the software for this resource consumption.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareContext"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INPUT" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies the input vector which is used to provide the ExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareContext.input";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Specifies the state the software is in when the ExecutionTime is provided.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareContext.state";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ResourceConsumption::SoftwareContext -->
   <xsd:complexType abstract="false" mixed="false" name="SOFTWARE-CONTEXT">
      <xsd:annotation>
         <xsd:documentation>Specifies the context of the software for this resource consumption.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareContext"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SOFTWARE-CONTEXT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EventTriggeringConstraint::SporadicEventTriggering -->
   <xsd:group name="SPORADIC-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The SporadicEventTriggering describes the behavior of an event which occurs occasionally or singly.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SporadicEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-INTER-ARRIVAL-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The minimum time distance between two consecutive occurrences of the associated event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SporadicEventTriggering.minimumInterArrivalTime";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-INTER-ARRIVAL-TIME" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum time distance between two consecutive occurrences of the associated event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SporadicEventTriggering.maximumInterArrivalTime";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="JITTER" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum jitter of the sporadic event occurrence.

            Jitter=max |nthPeriod - standardPeriod|</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SporadicEventTriggering.jitter";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PERIOD" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The period of the event occurrence.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SporadicEventTriggering.period";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EventTriggeringConstraint::SporadicEventTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="SPORADIC-EVENT-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The SporadicEventTriggering describes the behavior of an event which occurs occasionally or singly.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SporadicEventTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:EVENT-TRIGGERING-CONSTRAINT"/>
         <xsd:group ref="AR:SPORADIC-EVENT-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class StackUsage::StackUsage -->
   <xsd:group name="STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Describes the stack memory usage of a software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTABLE-ENTITY-REF">
            <xsd:annotation>
               <xsd:documentation>The executable entity for which this stack usage is described.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StackUsage.executableEntity";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:EXECUTABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION">
            <xsd:annotation>
               <xsd:documentation>Contains information about the hardware context this stack usage is describing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hardwareConfiguration.StackUsage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Specifies for which hardware element (e.g. ECU) this stack usage is given.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StackUsage.hwElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT">
            <xsd:annotation>
               <xsd:documentation>Contains details about the software context this stack usage is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="softwareContext.StackUsage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class CoreCommunication::StaticPart -->
   <xsd:group name="STATIC-PART">
      <xsd:annotation>
         <xsd:documentation>Some parts/signals of the I-PDU may be the same regardless of the selector field. Such a part is called static part. The static part is optional.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StaticPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a Com IPdu which is routed to the IPduM module and is combined to a multiplexedPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StaticPart.iPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::StaticPart -->
   <xsd:complexType abstract="false" mixed="false" name="STATIC-PART">
      <xsd:annotation>
         <xsd:documentation>Some parts/signals of the I-PDU may be the same regardless of the selector field. Such a part is called static part. The static part is optional.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StaticPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MULTIPLEXED-PART"/>
         <xsd:group ref="AR:STATIC-PART"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::Std -->
   <xsd:group name="STD">
      <xsd:annotation>
         <xsd:documentation>This represents a reference to external standards.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Std"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUBTITLE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This represents the subtitle of the standard.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Std.subtitle";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This represents  version and state of a standard. Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Std.state";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATE" type="AR:DATE">
            <xsd:annotation>
               <xsd:documentation>This element specifies the release date of the external standard if applicable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Std.date";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="URL" type="AR:URL">
            <xsd:annotation>
               <xsd:documentation>This represents the URL of the standard.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Std.url";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POSITION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This represents the reference to the relevant positions of a standard. Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Std.position";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InlineTextElements::Std -->
   <xsd:complexType abstract="false" mixed="false" name="STD">
      <xsd:annotation>
         <xsd:documentation>This represents a reference to external standards.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Std"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:SINGLE-LANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:STD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RequirementsTracing::StructuredReq -->
   <xsd:group name="STRUCTURED-REQ">
      <xsd:annotation>
         <xsd:documentation>This represents a structured requirement. This is intended for a case where specific requirements for features are collected.

      Note that this can be rendered as a labeled list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATE" type="AR:DATE">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.date";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ISSUED-BY" type="AR:STRING">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.issuedBy";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="6"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute allows to denote the type of requirement to denote for example is it an "enhancement", "new feature" etc.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.type";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="7"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPORTANCE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This allows to represent the importance of the requirement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.importance";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="8"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESCRIPTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>Ths represents the general description of the requirement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.description";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RATIONALE" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents the rationale of the requirement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.rationale";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEPENDENCIES" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents an informal specifiaction of dependencies. Note that upstream tracing should be formalized in the property trace provided by the superclass Traceable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.dependencies";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USE-CASE" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This describes the relevant use cases. Note that formal references to use cases should be done in the trace relation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.useCase";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="35"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFLICTS" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents an informal specification of conflicts.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.conflicts";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTING-MATERIAL" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents an informal specifiaction of the supporting material.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.supportingMaterial";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REMARK" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents an informal remark. Note that this is not modeled as annotation, since these remark is still essential part of the requirement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq.remark";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RequirementsTracing::StructuredReq -->
   <xsd:complexType abstract="false" mixed="false" name="STRUCTURED-REQ">
      <xsd:annotation>
         <xsd:documentation>This represents a structured requirement. This is intended for a case where specific requirements for features are collected.

      Note that this can be rendered as a labeled list.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StructuredReq"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:TRACE-REFERRABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:STRUCTURED-REQ"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::SubElementMapping -->
   <xsd:group name="SUB-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class allows for the definition of mappings of elements of a composite data type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SubElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIRST-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>This represents the first element referenced in the scope of the mapping.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SubElementMapping.firstElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-COMPOSITE-DATA-TYPE-SUB-ELEMENT-REF" type="AR:APPLICATION-COMPOSITE-DATA-TYPE-SUB-ELEMENT-REF"/>
                  <xsd:element name="IMPLEMENTATION-DATA-TYPE-SUB-ELEMENT-REF" type="AR:IMPLEMENTATION-DATA-TYPE-SUB-ELEMENT-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECOND-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>This represents the second element referenced in the scope of the mapping.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SubElementMapping.secondElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-COMPOSITE-DATA-TYPE-SUB-ELEMENT-REF" type="AR:APPLICATION-COMPOSITE-DATA-TYPE-SUB-ELEMENT-REF"/>
                  <xsd:element name="IMPLEMENTATION-DATA-TYPE-SUB-ELEMENT-REF" type="AR:IMPLEMENTATION-DATA-TYPE-SUB-ELEMENT-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEXT-TABLE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>This allows for the text-table translation of individual elements of a composite data type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SubElementMapping.textTableMapping";pureMM.maxOccurs="2";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="TEXT-TABLE-MAPPING" type="AR:TEXT-TABLE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::SubElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SUB-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>This meta-class allows for the definition of mappings of elements of a composite data type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SubElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SUB-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::SubElementRef -->
   <xsd:group name="SUB-ELEMENT-REF">
      <xsd:annotation>
         <xsd:documentation>This meta-class provides the ability to reference elements of composite data type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SubElementRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ServiceNeeds::SupervisedEntityNeeds -->
   <xsd:group name="SUPERVISED-ENTITY-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Watchdog Manager for one specific Supervised Entity (SE).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVATE-AT-START" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>True/false: supervision activation status of SE shall be enabled/disabled at start.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.activateAtStart";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENABLE-DEACTIVATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>True: software-component shall be allowed to deactivate supervision of this SE
            false: not</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.enableDeactivation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXPECTED-ALIVE-CYCLE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Expected cycle time of alive trigger of this SE (in seconds).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.expectedAliveCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-ALIVE-CYCLE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Maximum cycle time of alive trigger of this SE (in seconds).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.maxAliveCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-ALIVE-CYCLE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Minimum cycle time of alive trigger of this SE (in seconds).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.minAliveCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOLERATED-FAILED-CYCLES" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of consecutive failed alive cycles for this SE which shall be tolerated until the supervision status of the SE is set to EXPIRED (see WdgM documentation for details). Note that this has to be recalculated w.r.t. the WdgMs own cycle time for ECU configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.toleratedFailedCycles";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::SupervisedEntityNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SUPERVISED-ENTITY-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Watchdog Manager for one specific Supervised Entity (SE).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:SUPERVISED-ENTITY-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class AuxillaryObjects::SwAddrMethod -->
   <xsd:group name="SW-ADDR-METHOD">
      <xsd:annotation>
         <xsd:documentation>Used to assign a common addressing method, e.g. common memory section, to data or code objects. These objects could actually live in different modules or components.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwAddrMethods";mmt.qualifiedName="SwAddrMethod"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-ALLOCATION-KEYWORD-POLICY" type="AR:MEMORY-ALLOCATION-KEYWORD-POLICY-TYPE">
            <xsd:annotation>
               <xsd:documentation>Enumeration to specify the name pattern of the Memory Allocation Keyword.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAddrMethod.memoryAllocationKeywordPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPTIONS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="OPTION" type="AR:IDENTIFIER">
                     <xsd:annotation>
                        <xsd:documentation>This attribute introduces the ability to specify further intended properties of the MemorySection in with the related objects shall be placed. 

                     These properties are handled as to be selected. The intended options are mentioned in the list. 

                     In the Memory Mapping configuration, this option list is used to determine an appropriate MemMapAddressingModeSet.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="SwAddrMethod.option";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECTION-INITIALIZATION-POLICY" type="AR:SECTION-INITIALIZATION-POLICY-TYPE">
            <xsd:annotation>
               <xsd:documentation>Specifies the expected initialization of the variables (inclusive those which are implementing VariableDataPrototypes). Therefore this is an implementation constraint for initialization code of BSW modules (especially RTE) as well as the start-up code which initializes the memory segment to which the AutosarDataPrototypes referring to the SwAddrMethod's are later on mapped.

            If the attribute is not defined it has the identical semantic as the attribute value "INIT"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAddrMethod.sectionInitializationPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECTION-TYPE" type="AR:MEMORY-SECTION-TYPE">
            <xsd:annotation>
               <xsd:documentation>Defines the type of memory sections which can be associated with this addresssing method.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAddrMethod.sectionType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AuxillaryObjects::SwAddrMethod -->
   <xsd:complexType abstract="false" mixed="false" name="SW-ADDR-METHOD">
      <xsd:annotation>
         <xsd:documentation>Used to assign a common addressing method, e.g. common memory section, to data or code objects. These objects could actually live in different modules or components.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwAddrMethods";mmt.qualifiedName="SwAddrMethod"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:SW-ADDR-METHOD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-ADDR-METHOD--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-ADDR-METHOD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CalibrationValue::SwAxisCont -->
   <xsd:group name="SW-AXIS-CONT">
      <xsd:annotation>
         <xsd:documentation>This represents the values for the axis of a compound primitive (curve, map).

      For standard and fix axis,  SwAxisCont contains the values of the axis directly. 

      The axis values of SwAxisCont with the CATEGORY CURVE_AXIS, COM_AXIS, RES_AXIS are for display only. For editing and processing, only the values in the related GroupAxis are binding..</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisCont"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:CALPRM-AXIS-CATEGORY-ENUM">
            <xsd:annotation>
               <xsd:documentation>this category specifies the particular axis types: 

            * FIX_AXIS 
            * STD_AXIS 
            * COM_AXIS 
            * CURVE_AXIS  (swArraysize necessary) 
            * RES_AXIS  (swArraysize necessary)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisCont.category";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the physical unit of the provided values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisCont.unit";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-DISPLAY-NAME" type="AR:SINGLE-LANGUAGE-UNIT-NAMES">
            <xsd:annotation>
               <xsd:documentation>This represents the display name which is used for the physical unit of the axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisCont.unitDisplayName";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-INDEX" type="AR:AXIS-INDEX-TYPE">
            <xsd:annotation>
               <xsd:documentation>This property allows to explicitly assign the axis contents to a particular axis. It is specified by numbers where 1 corresponds to the x-axis.
            It is also possible to derive the axis association from the sequence of the parent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisCont.swAxisIndex";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ARRAYSIZE" type="AR:VALUE-LIST">
            <xsd:annotation>
               <xsd:documentation>For multidimensional compound primitivies (curve, map ...) it is necessary to know the dimensions.They are specified using swArraySize.

            * RES_AXIS
            * CURVE_AXIS</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisCont.swArraysize";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VALUES-PHYS" type="AR:SW-VALUES">
            <xsd:annotation>
               <xsd:documentation>swValuesPhys represents the values in the physical domain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisCont.swValuesPhys";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationValue::SwAxisCont -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-CONT">
      <xsd:annotation>
         <xsd:documentation>This represents the values for the axis of a compound primitive (curve, map).

      For standard and fix axis,  SwAxisCont contains the values of the axis directly. 

      The axis values of SwAxisCont with the CATEGORY CURVE_AXIS, COM_AXIS, RES_AXIS are for display only. For editing and processing, only the values in the related GroupAxis are binding..</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisCont"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-AXIS-CONT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwAxisGeneric -->
   <xsd:group name="SW-AXIS-GENERIC">
      <xsd:annotation>
         <xsd:documentation>This element defines a genric axis. In a generic axis the axispoints points are calculated in the ECU. 
      The ECU is equipped with a fixed calculation algorithm. Parameters for the algorithm can be stored in the data component of the ECU. Therefore these paramters are specified in the data declaration, not in the calibration data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGeneric"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Associated axis calculation strategy.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGeneric.swAxisType";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-AXIS-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-NUMBER-OF-AXIS-POINTS" type="AR:INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>The number of base points to be calculated for this axis. This element exists to enable the number of axis points to be stored explicitly, although it could also be described as swGenericAxisParam.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwAxisGeneric.swNumberOfAxisPoints";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-PARAMS">
            <xsd:annotation>
               <xsd:documentation>Specific parameter of a generic axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGeneric.swGenericAxisParam";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-GENERIC-AXIS-PARAM" type="AR:SW-GENERIC-AXIS-PARAM"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwAxisGeneric -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-GENERIC">
      <xsd:annotation>
         <xsd:documentation>This element defines a genric axis. In a generic axis the axispoints points are calculated in the ECU. 
      The ECU is equipped with a fixed calculation algorithm. Parameters for the algorithm can be stored in the data component of the ECU. Therefore these paramters are specified in the data declaration, not in the calibration data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGeneric"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-AXIS-GENERIC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwAxisGrouped -->
   <xsd:group name="SW-AXIS-GROUPED">
      <xsd:annotation>
         <xsd:documentation>An SwAxisGrouped is an axis which is shared between multiple calibration parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGrouped"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHARED-AXIS-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the datatype of the calibration parameter providing the shared axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGrouped.sharedAxisType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-PRIMITIVE-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-INDEX" type="AR:AXIS-INDEX-TYPE">
            <xsd:annotation>
               <xsd:documentation>Describes which axis of the referenced calibration parameter provides the values for the group axis.
            The index satisfies the following convention:
            * 0 = value axis. in this case, the interpolation result of the referenced parameter is used as a base point index. This means that the A2L keyword CURVE_AXIS_REF can be supported.
            * The index should only be specified if the parameter under swCalprm contains more than one axis. It is standard practise for the axis index of parameters with more than one axis, to be set to 1, if data has not been assigned to swAxisIndex.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGrouped.swAxisIndex";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:SW-CALPRM-REF-PROXY"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwAxisGrouped -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-GROUPED">
      <xsd:annotation>
         <xsd:documentation>An SwAxisGrouped is an axis which is shared between multiple calibration parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGrouped"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-CALPRM-AXIS-TYPE-PROPS"/>
         <xsd:group ref="AR:SW-AXIS-GROUPED"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwAxisIndividual -->
   <xsd:group name="SW-AXIS-INDIVIDUAL">
      <xsd:annotation>
         <xsd:documentation>This element describes an axis integrated into a parameter (field etc.). The integration makes this individual to each parameter. The so-called grouped axis represents the counterpart to this. It is conceived as an independent parameter (see class SwAxisGrouped).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INPUT-VARIABLE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the datatype of the input value for the axis. This allows to define e.g. a type of curve, where the input value is finalized at the access point.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.inputVariableType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-PRIMITIVE-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VARIABLE-REFS">
            <xsd:annotation>
               <xsd:documentation>Refers to input variables of the axis. It is possible to specify more than one variable. Here the following is valid:

            * The variable with the highest priority must be given first. It is used in the generation of the code and is also displayed first in the application system.

            * All variables referenced must be of the same physical nature. This is usually detected in that the conversion formulae affected refer back to the same SI-units.
            In AUTOSAR this ensured by the constraint, that the referenced input variables must use a type compatible to "inputVariableType".

            * This multiple referencing allows a base point distribution for more than one input variable to be used. One example of this are the temperature curves which can depend both on the induction air temperature and the engine temperature.

            These variables can be displayed simultaneously by MCD systems (adjustment systems), enabling operating points to be shown in the curves.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.swVariableRef";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="false";xml.roleWrapperElement="true";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:group ref="AR:SW-VARIABLE-REF-PROXY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-METHOD-REF">
            <xsd:annotation>
               <xsd:documentation>This is the compuMethod which is expected for the axis. It is used in early stages if the particular input-value is not yet available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.compuMethod";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPU-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the physical unit of the input value of the axis. It is provided to support the case that the particular input variable is not yet known.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.unit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MAX-AXIS-POINTS" type="AR:INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Maximum number of base points contained in the axis of a map or curve.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwAxisIndividual.swMaxAxisPoints";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MIN-AXIS-POINTS" type="AR:INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Minimum number of base points contained in the axis of a map or curve.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwAxisIndividual.swMinAxisPoints";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-CONSTR-REF">
            <xsd:annotation>
               <xsd:documentation>Refers to constraints, e.g. for plausibility checks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.dataConstr";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-CONSTR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-GENERIC" type="AR:SW-AXIS-GENERIC">
            <xsd:annotation>
               <xsd:documentation>this specifies the properties of a generic axis if applicable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.swAxisGeneric";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwAxisIndividual -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-INDIVIDUAL">
      <xsd:annotation>
         <xsd:documentation>This element describes an axis integrated into a parameter (field etc.). The integration makes this individual to each parameter. The so-called grouped axis represents the counterpart to this. It is conceived as an independent parameter (see class SwAxisGrouped).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-CALPRM-AXIS-TYPE-PROPS"/>
         <xsd:group ref="AR:SW-AXIS-INDIVIDUAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwAxisType -->
   <xsd:group name="SW-AXIS-TYPE">
      <xsd:annotation>
         <xsd:documentation>Stands for a specific axis calculation strategy. No formal specification is given, due to the fact that it is possible to use arbitrary algorithms for calculating axis-points. Instead, the algorithm is described verbally but the parameters are specified formally with respect to their names and constraints. As a result, SwAxisType mainly reserves appropriate keywords.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwAxisTypes";mmt.qualifiedName="SwAxisType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-DESC" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>Associated axis description in textual form .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisType.swGenericAxisDesc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-PARAM-TYPES">
            <xsd:annotation>
               <xsd:documentation>Parameters for this calcultaion algorithm.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisType.swGenericAxisParamType";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-GENERIC-AXIS-PARAM-TYPE" type="AR:SW-GENERIC-AXIS-PARAM-TYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwAxisType -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-TYPE">
      <xsd:annotation>
         <xsd:documentation>Stands for a specific axis calculation strategy. No formal specification is given, due to the fact that it is possible to use arbitrary algorithms for calculating axis-points. Instead, the algorithm is described verbally but the parameters are specified formally with respect to their names and constraints. As a result, SwAxisType mainly reserves appropriate keywords.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwAxisTypes";mmt.qualifiedName="SwAxisType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:SW-AXIS-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-AXIS-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-AXIS-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BaseTypes::SwBaseType -->
   <xsd:group name="SW-BASE-TYPE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a base type used within ECU software.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BaseTypes";mmt.qualifiedName="SwBaseType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class BaseTypes::SwBaseType -->
   <xsd:complexType abstract="false" mixed="false" name="SW-BASE-TYPE">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a base type used within ECU software.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="BaseTypes";mmt.qualifiedName="SwBaseType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:BASE-TYPE"/>
         <xsd:group ref="AR:SW-BASE-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-BASE-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-BASE-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataDefProperties::SwBitRepresentation -->
   <xsd:group name="SW-BIT-REPRESENTATION">
      <xsd:annotation>
         <xsd:documentation>Description of the structure of a bit variable: Comprises of the bitPosition in a memory object (e.g. swHostVariable, which stands parallel to swBitRepresentation) and the numberOfBits . In this way, interrelated memory areas can be described. Non-related memory areas are not supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwBitRepresentation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BIT-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>If the "bit data object" is hosted witin another data object (e.g. if the memory can be accessed via byte as well as bit adress), this attribute specifies the position of the data object. The count starts at zero (0).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwBitRepresentation.bitPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-BITS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Number of bits allocated by a "bit data object" within its host data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwBitRepresentation.numberOfBits";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwBitRepresentation -->
   <xsd:complexType abstract="false" mixed="false" name="SW-BIT-REPRESENTATION">
      <xsd:annotation>
         <xsd:documentation>Description of the structure of a bit variable: Comprises of the bitPosition in a memory object (e.g. swHostVariable, which stands parallel to swBitRepresentation) and the numberOfBits . In this way, interrelated memory areas can be described. Non-related memory areas are not supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwBitRepresentation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-BIT-REPRESENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameter::SwCalprmAxis -->
   <xsd:group name="SW-CALPRM-AXIS">
      <xsd:annotation>
         <xsd:documentation>This element specifies an individual input parameter axis (abscissa).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-INDEX" type="AR:AXIS-INDEX-TYPE">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies which axis is specified by the containing SwCalprmAxis.

            For example in a curve this is usually "1". In a map this is "1" or "2".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.swAxisIndex";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:CALPRM-AXIS-CATEGORY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This property specifies the category of a particular axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.category";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:element name="SW-AXIS-GROUPED" type="AR:SW-AXIS-GROUPED"/>
            <xsd:element name="SW-AXIS-INDIVIDUAL" type="AR:SW-AXIS-INDIVIDUAL"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALIBRATION-ACCESS" type="AR:SW-CALIBRATION-ACCESS-ENUM">
            <xsd:annotation>
               <xsd:documentation>Describes the applicability of parameters and variables.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.swCalibrationAccess";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISPLAY-FORMAT" type="AR:DISPLAY-FORMAT-STRING">
            <xsd:annotation>
               <xsd:documentation>This property specifies how the axis values shall be displayed e.g. in documents or in measurement and calibration tools.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.displayFormat";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>The SwBaseType to be used for the axis. Note that this is not applicable for ApplicationDataTypes. The value shall be ignored.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="SwCalprmAxis.baseType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="110"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-BASE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationParameter::SwCalprmAxis -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-AXIS">
      <xsd:annotation>
         <xsd:documentation>This element specifies an individual input parameter axis (abscissa).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-CALPRM-AXIS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameter::SwCalprmAxisSet -->
   <xsd:group name="SW-CALPRM-AXIS-SET">
      <xsd:annotation>
         <xsd:documentation>This element specifies the input parameter axes (abscissas) of parameters (and variables, if these are used adaptively).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="SW-CALPRM-AXIS" type="AR:SW-CALPRM-AXIS">
            <xsd:annotation>
               <xsd:documentation>One axis belonging to this SwCalprmAxisSet</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisSet.swCalprmAxis";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationParameter::SwCalprmAxisSet -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-AXIS-SET">
      <xsd:annotation>
         <xsd:documentation>This element specifies the input parameter axes (abscissas) of parameters (and variables, if these are used adaptively).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-CALPRM-AXIS-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameter::SwCalprmAxisTypeProps -->
   <xsd:group name="SW-CALPRM-AXIS-TYPE-PROPS">
      <xsd:annotation>
         <xsd:documentation>Base class for the type of the calibration axis. This provides the particular model of the specialization. If the specialization would be the directly from SwCalPrmAxis, the sequence of common properties and the specializes ones would be different.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisTypeProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class DatadictionaryProxies::SwCalprmRefProxy -->
   <xsd:group name="SW-CALPRM-REF-PROXY">
      <xsd:annotation>
         <xsd:documentation>Wrapper class for different kinds of references to a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmRefProxy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-PARAMETER" type="AR:AUTOSAR-PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>This represents a Parameter within Autosar. Note that the Datatype of the referenced ParameterDataPrototype must be an ApplicationDataType of category VALUE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmRefProxy.arParameter";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MC-DATA-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>This reference is used in the McSupport file to express the final instance of group axis etc. It is not allowed to use this outside
            of an McDataInstance.

            The referenced mcDataInstance must be origninated from a ParameterDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmRefProxy.mcDataInstance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MC-DATA-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DatadictionaryProxies::SwCalprmRefProxy -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-REF-PROXY">
      <xsd:annotation>
         <xsd:documentation>Wrapper class for different kinds of references to a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmRefProxy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-CALPRM-REF-PROXY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameter::SwCalprmValueAxisLabels -->
   <xsd:group name="SW-CALPRM-VALUE-AXIS-LABELS">
      <xsd:annotation>
         <xsd:documentation>This element is used to record textual descriptions of axis values and is contained in ASAP1.4, for reasons of backward compatibility.

      In new systems, the application should be implemented via conversion formulae.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmValueAxisLabels"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class CalibrationParameter::SwCalprmValueAxisLabels -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-VALUE-AXIS-LABELS">
      <xsd:annotation>
         <xsd:documentation>This element is used to record textual descriptions of axis values and is contained in ASAP1.4, for reasons of backward compatibility.

      In new systems, the application should be implemented via conversion formulae.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmValueAxisLabels"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-CALPRM-VALUE-AXIS-LABELS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SoftwareComponentDocumentation::SwComponentDocumentation -->
   <xsd:group name="SW-COMPONENT-DOCUMENTATION">
      <xsd:annotation>
         <xsd:documentation>This class specifies the ability to write dedicated documentation to a component type according to ASAM FSX.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-FEATURE-DEF" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This element contains the definition of the physical functionality of this software component. This definition is more or less formal and is intended to be delivered from modeling tools.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation.swFeatureDef";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.roleElement="true";xml.sequenceOffset="20";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-FEATURE-DESC" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This element contains the textual description of the software functionality of this software component. Expert should write this description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation.swFeatureDesc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.roleElement="true";xml.sequenceOffset="30";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-TEST-DESC" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This element contains suggestions and hints for the test of the software functionality of this software component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation.swTestDesc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.roleElement="true";xml.sequenceOffset="50";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALIBRATION-NOTES" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This element contains calibration instructions and hints for a calibration engineer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation.swCalibrationNotes";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.roleElement="true";xml.sequenceOffset="60";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MAINTENANCE-NOTES" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This element contains information regarding the software maintenance of the component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation.swMaintenanceNotes";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.roleElement="true";xml.sequenceOffset="70";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DIAGNOSTICS-NOTES" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This element contains general information about diagnostics issues within the component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation.swDiagnosticsNotes";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.roleElement="true";xml.sequenceOffset="75";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CARB-DOC" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>This element records the documentation requested by CARB.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation.swCarbDoc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.roleElement="true";xml.sequenceOffset="80";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CHAPTER" type="AR:CHAPTER">
            <xsd:annotation>
               <xsd:documentation>These chapters provide additional information about the software component that do not fit in the other chapters.

            Note that this is subject to variation because Chapter aggregations in the role chapter are variant within the documentation in general.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="SwComponentDocumentation.chapter";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="100";xml.typeElement="true"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SoftwareComponentDocumentation::SwComponentDocumentation -->
   <xsd:complexType abstract="false" mixed="false" name="SW-COMPONENT-DOCUMENTATION">
      <xsd:annotation>
         <xsd:documentation>This class specifies the ability to write dedicated documentation to a component type according to ASAM FSX.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentDocumentation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-COMPONENT-DOCUMENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Composition::SwComponentPrototype -->
   <xsd:group name="SW-COMPONENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Role of a software component within a composition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-TREF">
            <xsd:annotation>
               <xsd:documentation>Type of the instance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentPrototype.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::SwComponentPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="SW-COMPONENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Role of a software component within a composition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:SW-COMPONENT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-COMPONENT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Components::SwComponentType -->
   <xsd:group name="SW-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>Base class for AUTOSAR software components.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-COMPONENT-DOCUMENTATIONS">
            <xsd:annotation>
               <xsd:documentation>This adds a documentation to the SwComponentType.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="swComponentDocumentation, variationPoint.shortLabel";mmt.qualifiedName="SwComponentType.swComponentDocumentation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="-10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-COMPONENT-DOCUMENTATION" type="AR:SW-COMPONENT-DOCUMENTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORTS">
            <xsd:annotation>
               <xsd:documentation>The ports through which this component can communicate.
            The aggregation of PortPrototype is subject to variability with the purpose to support the conditional existence of PortPrototypes.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="port.component";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="P-PORT-PROTOTYPE" type="AR:P-PORT-PROTOTYPE"/>
                  <xsd:element name="R-PORT-PROTOTYPE" type="AR:R-PORT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-GROUPS">
            <xsd:annotation>
               <xsd:documentation>A port group being part of this component.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwComponentType.portGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PORT-GROUP" type="AR:PORT-GROUP"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="SW-COMPONENT-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ATOMIC-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECU-ABSTRACTION-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="NV-BLOCK-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="PARAMETER-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-PROXY-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-SW-COMPONENT-TYPE"/>
         <xsd:enumeration value="SW-COMPONENT-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Composition::SwConnector -->
   <xsd:group name="SW-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>The base class for connectors between ports. Connectors have to be identifiable to allow references from the system constraint template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPING-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a PortInterfaceMapping specifying the mapping of unequal named PortInterface elements of the two different PortInterfaces typing the two PortPrototypes which are referenced by the ConnectorPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwConnector.mapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-INTERFACE-MAPPING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class DataDefProperties::SwDataDefProps -->
   <xsd:group name="SW-DATA-DEF-PROPS">
      <xsd:annotation>
         <xsd:documentation>This class is a collection of properties relevant for data objects under various aspects. One could consider this class as a "pattern of inheritance by aggregation". The properties can be applied to all objects of all classes in which SwDataDefProps is agrregated.

      Note that not all of the attributes or associated elements are useful all of the time. Hence, the process definition (e.g. expressed with an OCL or a Document Control Instance MSR-DCI) has the task of implementing limitations.

      SwDataDefProps covers various aspects:

      * Structure of the data element for calibration use cases: Is it a single value, a curve, or a map, but also the recordLayouts which specify, how such elements are mapped/converted to the DataTypes in the programming language (or in Autosar). This is mainly expressed by properties like swRecordLayout and swCalprmAxisSet 

      * Implementation aspects, mainly expressed by swImplPolicy, swVariableAccessImplPolicy, swAddrMethod, swPointerTagetProps, baseType, implementationDataType and additionalNativeTypeQualifier

      * Access policy for the MCD system, mainly expressed by swCalibrationAccess 

      * Semantics of the data element, mainly expressed by compuMethod and/or unit, dataConstr, invalidValue

      * Code generation policy provided by swRecordLayout</xsd:documentation>
         <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="SwDataDefProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-DATA-DEF-PROPS-CONDITIONAL" type="AR:SW-DATA-DEF-PROPS-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwDataDefProps -->
   <xsd:complexType abstract="false" mixed="false" name="SW-DATA-DEF-PROPS">
      <xsd:annotation>
         <xsd:documentation>This class is a collection of properties relevant for data objects under various aspects. One could consider this class as a "pattern of inheritance by aggregation". The properties can be applied to all objects of all classes in which SwDataDefProps is agrregated.

      Note that not all of the attributes or associated elements are useful all of the time. Hence, the process definition (e.g. expressed with an OCL or a Document Control Instance MSR-DCI) has the task of implementing limitations.

      SwDataDefProps covers various aspects:

      * Structure of the data element for calibration use cases: Is it a single value, a curve, or a map, but also the recordLayouts which specify, how such elements are mapped/converted to the DataTypes in the programming language (or in Autosar). This is mainly expressed by properties like swRecordLayout and swCalprmAxisSet 

      * Implementation aspects, mainly expressed by swImplPolicy, swVariableAccessImplPolicy, swAddrMethod, swPointerTagetProps, baseType, implementationDataType and additionalNativeTypeQualifier

      * Access policy for the MCD system, mainly expressed by swCalibrationAccess 

      * Semantics of the data element, mainly expressed by compuMethod and/or unit, dataConstr, invalidValue

      * Code generation policy provided by swRecordLayout</xsd:documentation>
         <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="SwDataDefProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-DATA-DEF-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwDataDefPropsConditional -->
   <xsd:group name="SW-DATA-DEF-PROPS-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwDataDefPropsConditional -->
   <xsd:complexType abstract="false" mixed="false" name="SW-DATA-DEF-PROPS-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-DATA-DEF-PROPS-CONTENT"/>
         <xsd:group ref="AR:SW-DATA-DEF-PROPS-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwDataDefPropsContent -->
   <xsd:group name="SW-DATA-DEF-PROPS-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>This aggregation allows to add annotations (yellow pads ...) related to the current data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.annotation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ANNOTATION" type="AR:ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ADDR-METHOD-REF">
            <xsd:annotation>
               <xsd:documentation>Addressing method related to this data object. Via an association to the same SwAddrmethod, it can be specified that several data prototypes shall be located in the same memory without already specifying the memory section itself.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swAddrMethod";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-ADDR-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ALIGNMENT" type="AR:ALIGNMENT-TYPE">
            <xsd:annotation>
               <xsd:documentation>The attribute describes the intended alignment of the DataPrototype. If the attribute is not defined the alignment is determined by the swBaseType size and the memoryAllocationKeywordPolicy of the referenced SwAddrMethod.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swAlignment";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="33"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Base type associated with this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.baseType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-BASE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-BIT-REPRESENTATION" type="AR:SW-BIT-REPRESENTATION">
            <xsd:annotation>
               <xsd:documentation>Description of the binary representaion in case of a bit variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swBitRepresentation";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALIBRATION-ACCESS" type="AR:SW-CALIBRATION-ACCESS-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies the read or write access by MCD tools for this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swCalibrationAccess";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VALUE-BLOCK-SIZE" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This represents the size of a Value Block</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwDataDefProps.swValueBlockSize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALPRM-AXIS-SET" type="AR:SW-CALPRM-AXIS-SET">
            <xsd:annotation>
               <xsd:documentation>This specifies the properties of the axes in case of a curve or map etc. This is mainly applicable to calibration parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swCalprmAxisSet";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-TEXT-PROPS" type="AR:SW-TEXT-PROPS">
            <xsd:annotation>
               <xsd:documentation>the specific properties if the data object is a text object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swTextProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="120"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-COMPARISON-VARIABLES">
            <xsd:annotation>
               <xsd:documentation>Variables used for comparison in an MCD process.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swComparisonVariable";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="170";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:group ref="AR:SW-VARIABLE-REF-PROXY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-METHOD-REF">
            <xsd:annotation>
               <xsd:documentation>Computation method associated with the semantics of this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.compuMethod";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="180"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPU-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-CONSTR-REF">
            <xsd:annotation>
               <xsd:documentation>Data constraint for this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.dataConstr";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="190"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-CONSTR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEPENDENCY" type="AR:SW-DATA-DEPENDENCY">
            <xsd:annotation>
               <xsd:documentation>Describes how the value of the data object has to be calculated from the value of another data object (by the MCD system).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swDataDependency";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="200"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISPLAY-FORMAT" type="AR:DISPLAY-FORMAT-STRING">
            <xsd:annotation>
               <xsd:documentation>This property describes how a number is to be rendered e.g. in documents or in a measurement and calibration system.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.displayFormat";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="210"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-DATA-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This association denotes the implementation type of a data declaration via its aggregated SwDataDefProps. It is used whenever a data declaration is not directly referring a base type. Especially

            * redefinition of an ImplementationDataType via a "typedef" to another ImplementationDatatype
            * the target type of a pointer (see SwPointerTargetProps), if it does not refer to a base type directly
            * the data type of an array or record element within an ImplementationDataType, if it does not refer to a base type directly
            * the data type of an SwServiceArg, if it does not refer to a base type directly</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.implementationDataType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="215"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IMPLEMENTATION-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-HOST-VARIABLE" type="AR:SW-VARIABLE-REF-PROXY">
            <xsd:annotation>
               <xsd:documentation>Contains a reference to a variable which serves as a host-variable for a bit variable. Only applicable to bit objects.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swHostVariable";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="220";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IMPL-POLICY" type="AR:SW-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Implementation policy for this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="230"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADDITIONAL-NATIVE-TYPE-QUALIFIER" type="AR:NATIVE-DECLARATION-STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute is used to declare native qualifiers of the prgramming language which can neither be deduced from the baseType (e.g. because the data object describes a pointer) nor from other more abstract attributes. Examples are qualifiers like "volatile" or "strict" of the C-language. All such declarations have to be put into one string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.additionalNativeTypeQualifier";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="235"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-INTENDED-RESOLUTION" type="AR:NUMERICAL-VALUE">
            <xsd:annotation>
               <xsd:documentation>The purpose of this element is to describe the requested quantization of data objects early on in the design process. The resolution ultimately occurs via the conversion formula present (compuMethod), which specifies the transition from the physical world to the standardized world (and vice-versa) (here, "the slope per bit" is present implicitly in the conversion formula). In the case of a development phase without a fixed conversion formula, a pre-specification can occur through  swIntendedResolution. If however, a conversion formula is present, this can be checked for plausibility against swIntendedResolution.

            The resolution is specified in the physical domain according to the property "unit".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swIntendedResolution";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="240"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-INTERPOLATION-METHOD" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This is a keyword identifying the mathematical method to be applied for interpolation. The keyword needs to be related to the interpolation routine which needs to be invoked.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swInterpolationMethod";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="250"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INVALID-VALUE">
            <xsd:annotation>
               <xsd:documentation>Optional value to express invalidity of the
            actual data element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.invalidValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="255"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MC-FUNCTION" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Specifies the name of a "Function" (in the sense of the MC system) to which this data object belongs. This corresponds to the Function in ASAM MCD 2MC /ASAP2 which defines the characteristic resp. which provides the measurement as output.

            The function name is only used for support of MC systems. It can be predefined on the level of software component design. If it  is not  predefined, it could be filled out with a reasonable name, e.g. the component  prototype name, from the ECU extract.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.mcFunction";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="257"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IS-VIRTUAL" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This element distinguishes virtual objects. Virtual objects do not appear in the memory, their derivation is much more dependent on other objects and hence they must have a swDataDependency .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swIsVirtual";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="260"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-POINTER-TARGET-PROPS" type="AR:SW-POINTER-TARGET-PROPS">
            <xsd:annotation>
               <xsd:documentation>Specifies that the containing data object is a pointer to another data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swPointerTargetProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="280"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-REF">
            <xsd:annotation>
               <xsd:documentation>Record layout for this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swRecordLayout";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="290"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-RECORD-LAYOUT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-REFRESH-TIMING" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>This element specifies the frequency in which the object involved shall be or is called or calculated.  This timing can be collected from the task in which write access processes to the variable run. But this cannot be done by the MCD system. 

            So this attribute can be used in an early phase to express the desired refresh timing and later on to specify the real refresh timing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swRefreshTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="300"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>Physical unit associated with the semantics of this data object. This attribute applies if no compuMethod is specified. If both units (this as well as via compuMethod) are specified the units must be the same.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.unit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="350"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-AXIS-DATA-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced ApplicationPrimitiveDataType represents the primitive data type of the value axis within a compound primitive (e.g. curve, map). It supersedes CompuMethod, Unit, and BaseType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.valueAxisDataType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="355"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-PRIMITIVE-DATA-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class DataDefProperties::SwDataDependency -->
   <xsd:group name="SW-DATA-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>This element describes the interdependencies of data objects, e.g. variables and parameters. 

      Use cases:
      * Calculate the value of a calibration parameter (by the MCD system) from the value(s) of other calibration parameters.
      * Virtual data - that means the data object is not directly in the ecu and this property describes how the "virtual variable" can be computed from the real ones (by the MCD system).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEPENDENCY-FORMULA" type="AR:COMPU-GENERIC-MATH">
            <xsd:annotation>
               <xsd:documentation>This element describes the formula with which the dependencies between the participating objects are defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependency.swDataDependencyFormula";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEPENDENCY-ARGS" type="AR:SW-DATA-DEPENDENCY-ARGS">
            <xsd:annotation>
               <xsd:documentation>Specifies the arguments used in the data dependency. Note that this is 0..1 since the aggregated class is a container (atpMixed).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependency.swDataDependencyArgs";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwDataDependency -->
   <xsd:complexType abstract="false" mixed="false" name="SW-DATA-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>This element describes the interdependencies of data objects, e.g. variables and parameters. 

      Use cases:
      * Calculate the value of a calibration parameter (by the MCD system) from the value(s) of other calibration parameters.
      * Virtual data - that means the data object is not directly in the ecu and this property describes how the "virtual variable" can be computed from the real ones (by the MCD system).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-DATA-DEPENDENCY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwDataDependencyArgs -->
   <xsd:group name="SW-DATA-DEPENDENCY-ARGS">
      <xsd:annotation>
         <xsd:documentation>This element specifies the elements used in a SwDataDependency.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependencyArgs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
               <xsd:group ref="AR:SW-CALPRM-REF-PROXY"/>
            </xsd:choice>
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
               <xsd:group ref="AR:SW-VARIABLE-REF-PROXY"/>
            </xsd:choice>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwDataDependencyArgs -->
   <xsd:complexType abstract="false" mixed="false" name="SW-DATA-DEPENDENCY-ARGS">
      <xsd:annotation>
         <xsd:documentation>This element specifies the elements used in a SwDataDependency.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependencyArgs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-DATA-DEPENDENCY-ARGS"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwGenericAxisParam -->
   <xsd:group name="SW-GENERIC-AXIS-PARAM">
      <xsd:annotation>
         <xsd:documentation>This element describes a specific parameter of a generic axis. The name of the parameter is defined through a reference to a parameter type defined on a corresponding axis type.

      The value of the parameter is given here in case that it is not changeable during calibration. Example is shift / Offset in a fixed axis.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParam"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-PARAM-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Parameter type defined on a corresponding axis type. References can only be made to axis parameters types which are defined within the referenced axis type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParam.swGenericAxisParamType";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-GENERIC-AXIS-PARAM-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VF" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This is the value of the genric axis parameter.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="CodeGenerationTime";mmt.qualifiedName="SwGenericAxisParam.vf";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwGenericAxisParam -->
   <xsd:complexType abstract="false" mixed="false" name="SW-GENERIC-AXIS-PARAM">
      <xsd:annotation>
         <xsd:documentation>This element describes a specific parameter of a generic axis. The name of the parameter is defined through a reference to a parameter type defined on a corresponding axis type.

      The value of the parameter is given here in case that it is not changeable during calibration. Example is shift / Offset in a fixed axis.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParam"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-GENERIC-AXIS-PARAM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwGenericAxisParamType -->
   <xsd:group name="SW-GENERIC-AXIS-PARAM-TYPE">
      <xsd:annotation>
         <xsd:documentation>This element describes a generic axis parameter type, namely:

      * Plausibility checks can be specified via dataConstr.

      * Textual description (desc), as a formal description is not of any use, due to the large variety of possibilities.

      * If this parameter contains structures, these can be simulated through the recursive use of swGenericAxisParamTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParamType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-CONSTR-REF">
            <xsd:annotation>
               <xsd:documentation>This refernce denoted data constraints applicable to the generic axis parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParamType.dataConstr";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-CONSTR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwGenericAxisParamType -->
   <xsd:complexType abstract="false" mixed="false" name="SW-GENERIC-AXIS-PARAM-TYPE">
      <xsd:annotation>
         <xsd:documentation>This element describes a generic axis parameter type, namely:

      * Plausibility checks can be specified via dataConstr.

      * Textual description (desc), as a formal description is not of any use, due to the large variety of possibilities.

      * If this parameter contains structures, these can be simulated through the recursive use of swGenericAxisParamTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParamType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-GENERIC-AXIS-PARAM-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-GENERIC-AXIS-PARAM-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-GENERIC-AXIS-PARAM-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataDefProperties::SwPointerTargetProps -->
   <xsd:group name="SW-POINTER-TARGET-PROPS">
      <xsd:annotation>
         <xsd:documentation>This element defines, that the data object (which is specified by the aggregating element) contains a reference to another data object or to a function in the CPU code. This corresponds to a pointer in the C-language.

      The attributes of this element describe the category and the detailed properties of the target which is either a data description or a function signature.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwPointerTargetProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-CATEGORY" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This specifies the category of the target:

            * In case of a data pointer, it must specify the category of the referenced data.

            * In case of a function pointer, it could be used to denote the category of the referenced BswModuleEntry. Since currently no categories for BswModuleEntry are defined, it will be empty.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwPointerTargetProps.targetCategory";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>The properties of the target data type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwPointerTargetProps.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FUNCTION-POINTER-SIGNATURE-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced BswModuleEntry serves as the signature of a function pointer definition. Primary use case: function pointer passed as argument to other function.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwPointerTargetProps.functionPointerSignature";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwPointerTargetProps -->
   <xsd:complexType abstract="false" mixed="false" name="SW-POINTER-TARGET-PROPS">
      <xsd:annotation>
         <xsd:documentation>This element defines, that the data object (which is specified by the aggregating element) contains a reference to another data object or to a function in the CPU code. This corresponds to a pointer in the C-language.

      The attributes of this element describe the category and the detailed properties of the target which is either a data description or a function signature.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwPointerTargetProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-POINTER-TARGET-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RecordLayout::SwRecordLayout -->
   <xsd:group name="SW-RECORD-LAYOUT">
      <xsd:annotation>
         <xsd:documentation>Defines how the data objects (variables, calibration parameters etc.) are to be stored in the ECU memory. As an example, this definition specifies the sequence of axis points in the ECU memory. Iterations through axis values are stored within the subelements swRecordLayoutGroup.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwRecordLayouts";mmt.qualifiedName="SwRecordLayout"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP" type="AR:SW-RECORD-LAYOUT-GROUP">
            <xsd:annotation>
               <xsd:documentation>This is the top level record layout group.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayout.swRecordLayoutGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RecordLayout::SwRecordLayout -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RECORD-LAYOUT">
      <xsd:annotation>
         <xsd:documentation>Defines how the data objects (variables, calibration parameters etc.) are to be stored in the ECU memory. As an example, this definition specifies the sequence of axis points in the ECU memory. Iterations through axis values are stored within the subelements swRecordLayoutGroup.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwRecordLayouts";mmt.qualifiedName="SwRecordLayout"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:SW-RECORD-LAYOUT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-RECORD-LAYOUT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-RECORD-LAYOUT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RecordLayout::SwRecordLayoutGroup -->
   <xsd:group name="SW-RECORD-LAYOUT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Specifies how a record layout is set up. Using SwRecordLayoutGroup it recursively models iterations through axis values. The subelement swRecordLayoutGroupContentType may reference other SwRecordLayouts, SwRecordLayoutVs and SwRecordLayoutGroups for the modeled record layout.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies a name which can be used e.g. when ECU code is generated from the record layout group.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="3"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:ASAM-RECORD-LAYOUT-SEMANTICS">
            <xsd:annotation>
               <xsd:documentation>This attribute denotes the semantics in particular in terms of the corresponding A2L-Keyword. This is to support the mapping of the more general record layouts in AUTOSAR/MSR to the specific A2l keywords. It is possible to express the specific semantics of A2l recordlayout keywords in swRecordlayoutGroup but not always vice versa. Therefore the mapping is provided in this optional attribute.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.category";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This property allows a brief description about the particular record layout group which can help to identify the entry. In depth documentation should go to introduction of the surrounding record layout.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-AXIS" type="AR:AXIS-INDEX-TYPE">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the iteration axis number for a SwRecordLayoutGroup. The current record layout group then refers exactly to the axis with this number. This means that the values are taken by iterating along the thus referenced axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupAxis";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-INDEX" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>This element attributes a symbolic name to the iterator of the superimposed record layout group. This can be referenced as a loop index in contained SwRecordLayoutV elements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupIndex";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-PARAM-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This association allows to specify record layout groups to iterate over generic axis parameters. For example, if the generic axis parameter is an array, the record layout group will iterate over this array. 

            Obviously, the axis referred to by swRecordLayoutGroupAxis must be a generic axis in which the referenced SwGenericAxisType is aggregated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swGenericAxisParamType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-GENERIC-AXIS-PARAM-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-FROM" type="AR:RECORD-LAYOUT-ITERATOR-POINT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the iterator index for the point in the axis from which a record layout group is commenced. Negative values are also possible, i.e. the value -4 counts from the fourth value from the end. If this property is missing, the iteration starts with '1'.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupFrom";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-TO" type="AR:RECORD-LAYOUT-ITERATOR-POINT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the end point for the iteration. Negative values are also possible, i.e. the value -4 counts up to the fourth value from the end. If this property is not there, the iteration ends at "-1" which is the last element.
            Note that depending on the arraySizeSemantics of SwTextProps the iteration ends at the value specified in swMaxTextSize.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupTo";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-STEP" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This property specifies the step width for the iterator index
            that is used for the current record layout group. Note that negative values are
            also possible, in case of the starting point is higher than the endpoint. If the
            property is missing, the step width is "1".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupStep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-COMPONENT" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>is used to denote the component to which the
            group in question applies. Thus, the record layout supports structured objects.This secures independence from the sequence of components, because they can be referred to via name.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutComponent";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:SW-RECORD-LAYOUT-GROUP-CONTENT"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RecordLayout::SwRecordLayoutGroup -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RECORD-LAYOUT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Specifies how a record layout is set up. Using SwRecordLayoutGroup it recursively models iterations through axis values. The subelement swRecordLayoutGroupContentType may reference other SwRecordLayouts, SwRecordLayoutVs and SwRecordLayoutGroups for the modeled record layout.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-RECORD-LAYOUT-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RecordLayout::SwRecordLayoutGroupContent -->
   <xsd:group name="SW-RECORD-LAYOUT-GROUP-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This is the contents of a RecordLaoyut which is inserted for every iteration. Note that since this is atpMixed, multiple properties can be inserted for each iteration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="SW-RECORD-LAYOUT-REF">
               <xsd:annotation>
                  <xsd:documentation>This association allows to support reusable "sub"-record layouts. In particluar, the contents of the referenced record layout must be used as if the the record layout group in the referenced record layout was aggregated in the current record layout group. 

               So semantically it would be equivalent to replace the particluar association with an aggregation of the  swRecordLayoutGroup of the referenced SwRecordLayout.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent.swRecordLayout";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="110"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:SW-RECORD-LAYOUT--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="SW-RECORD-LAYOUT-V" type="AR:SW-RECORD-LAYOUT-V">
               <xsd:annotation>
                  <xsd:documentation>Particular Value specification for this record layout group.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent.swRecordLayoutV";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="120"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="SW-RECORD-LAYOUT-GROUP" type="AR:SW-RECORD-LAYOUT-GROUP">
               <xsd:annotation>
                  <xsd:documentation>This aggregation provides support for nested iterations. For example if a map is to be handled, then we might have two nested SwRecordLayoutGroups, one for the x-axis and one for the y-axis. The inner iteration runs faster.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent.swRecordLayoutGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="130"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class RecordLayout::SwRecordLayoutGroupContent -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RECORD-LAYOUT-GROUP-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This is the contents of a RecordLaoyut which is inserted for every iteration. Note that since this is atpMixed, multiple properties can be inserted for each iteration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-RECORD-LAYOUT-GROUP-CONTENT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RecordLayout::SwRecordLayoutV -->
   <xsd:group name="SW-RECORD-LAYOUT-V">
      <xsd:annotation>
         <xsd:documentation>This element specifies which values are stored for the current SwRecordLayoutGroup. If no baseType is present, the SwBaseType referenced initially in the parent SwRecordLayoutGroup is valid. The specification of swRecordLayoutVAxis gives the axis of the values which shall be stored in accordance with the current record layout SwRecordLayoutGroup. In swRecordLayoutVProp one can specify the information which shall be stored.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies a name which can be used e.g. when ECU code is generated from the record layout value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="3"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:ASAM-RECORD-LAYOUT-SEMANTICS">
            <xsd:annotation>
               <xsd:documentation>This attribute denotes the semantics in particular in terms of the corresponding A2L-Keyword. This is to support the mapping of the more general record layouts in AUTOSAR/MSR to the specific A2l keywords. It is possible to express the specifc semantics of A2l recordlayout keywords in swRecordlayoutGroup but not always vice versa. Therefore the mapping is provided in this optional attribute.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.category";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>this property allows a brief description about the particular record layout value which can help to identify the entry. In depth documentation should go to introduction of the surrounding record layout.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This allows to refer to a base type in case a specific encoding is intended. If no base type is referred, the base type referenced initially in the corresponding DataPrototype is to be used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.baseType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-BASE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-V-AXIS" type="AR:AXIS-INDEX-TYPE">
            <xsd:annotation>
               <xsd:documentation>This attribute gives the index of the axis of which values that are
            stored in the record. swRecordVIndex refers to the symbolic names of the iterators
            for which the axis value shall be stored in the recrod. 

            In case of nested iterators (mainly for multidimensional objects) the iterator 
            names are specified as whitespace separated names. These symbolic names relate 
            to swRecordLayoutGroupIndex. The iterators are processed from left to right in such a manner
            that they symbolize the loop index from the outside to the inside. It is an error
            if more components are specified than axis are there in the related ApplicationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayoutVAxis";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-V-PROP" type="AR:NMTOKEN-STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute describes the kind of values to be stored. More details see below.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayoutVProp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-V-INDEX" type="AR:NMTOKENS-STRING">
            <xsd:annotation>
               <xsd:documentation>The symbolic value for iteration, or the symbolic values separated by white-spaces, refer to the symbolic values given in swRecordLayoutGroupIndex . The iterators are processed from left to right, in such a manner that they symbolize the loop index from the outside to the inside.

            It is an error  if the record layout is referenced by an entity which has less number of axis than index names referenced here.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayoutVIndex";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-PARAM-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This association supports the case that a value from a generic axis definition shall be stored. This value is denoted by a particular generic axis parameter type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swGenericAxisParamType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-GENERIC-AXIS-PARAM-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-V-FIX-VALUE" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the filler character for the current record
            layout, in the form of hex digits. It is also used to specify the fix value for e.g. FIXRIGHTDIFF.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayoutVFixValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RecordLayout::SwRecordLayoutV -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RECORD-LAYOUT-V">
      <xsd:annotation>
         <xsd:documentation>This element specifies which values are stored for the current SwRecordLayoutGroup. If no baseType is present, the SwBaseType referenced initially in the parent SwRecordLayoutGroup is valid. The specification of swRecordLayoutVAxis gives the axis of the values which shall be stored in accordance with the current record layout SwRecordLayoutGroup. In swRecordLayoutVProp one can specify the information which shall be stored.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-RECORD-LAYOUT-V"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceProcessTask::SwServiceArg -->
   <xsd:group name="SW-SERVICE-ARG">
      <xsd:annotation>
         <xsd:documentation>Specifies the properties of a data object exchanged during the call of an SwService, e.g. an argument or a return value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECTION" type="AR:ARGUMENT-DIRECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies the direction of the data transfer. The direction shall indicate the direction of the actual information that is being consumed by the caller and/or the callee, not the direction of formal arguments in C.

            The attribute is optional for backwards compatibility reasons.
            For example, if a pointer is used to pass a memory address for the expected result, the direction shall be "out".
            If a pointer is used to pass a memory address with content to be read by the callee, its direction shall be "in".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg.direction";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ARRAYSIZE" type="AR:VALUE-LIST">
            <xsd:annotation>
               <xsd:documentation>This turns the argument of the service to an array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg.swArraysize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>Data properties of this SwServiceArg.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceProcessTask::SwServiceArg -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SERVICE-ARG">
      <xsd:annotation>
         <xsd:documentation>Specifies the properties of a data object exchanged during the call of an SwService, e.g. an argument or a return value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-SERVICE-ARG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SystemConstant::SwSystemconst -->
   <xsd:group name="SW-SYSTEMCONST">
      <xsd:annotation>
         <xsd:documentation>This element defines a system constant which serves an input to 
      select a particular variation point. In particular a system constant serves
      as an operand of the binding function (swSyscond) in a Variation point.

      Note that the binding process can only happen  if a value was assigned to
      to the referenced system constants.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwSystemconsts";mmt.qualifiedName="SwSystemconst"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This denotes the data defintion properties of the system constant. In particular it is the limits and - in case the system constant is an enumeration - the compu method.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconst.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SystemConstant::SwSystemconst -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SYSTEMCONST">
      <xsd:annotation>
         <xsd:documentation>This element defines a system constant which serves an input to 
      select a particular variation point. In particular a system constant serves
      as an operand of the binding function (swSyscond) in a Variation point.

      Note that the binding process can only happen  if a value was assigned to
      to the referenced system constants.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwSystemconsts";mmt.qualifiedName="SwSystemconst"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:SW-SYSTEMCONST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-SYSTEMCONST--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-SYSTEMCONST"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class VariantHandling::SwSystemconstDependentFormula -->
   <xsd:group name="SW-SYSTEMCONST-DEPENDENT-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This class represents an expression depending on system constants.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconstDependentFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="SYSC-STRING-REF">
               <xsd:annotation>
                  <xsd:documentation>syscString indicates that the referenced systm constant shall be evaluated as a string according to Constr_1145 (in SWCT).</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconstDependentFormula.syscString";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:SW-SYSTEMCONST--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="SYSC-REF">
               <xsd:annotation>
                  <xsd:documentation>This refers to a system constant. The internal (coded) value of the system constant shall be used.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconstDependentFormula.sysc";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:SW-SYSTEMCONST--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- element group for class VariantHandling::SwSystemconstValue -->
   <xsd:group name="SW-SYSTEMCONST-VALUE">
      <xsd:annotation>
         <xsd:documentation>This meta-class assigns a particular value to a system constant.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconstValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SYSTEMCONST-REF">
            <xsd:annotation>
               <xsd:documentation>This is the system constant to which the value applies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconstValue.swSystemconst";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-SYSTEMCONST--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This is the particular value of a system constant. It is specified as Numerical. Further restrictions may apply by the definition of the system constant.

            The value attribute defines the internal value of the SwSystemconst as it is processed  in the Formula Language.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwSystemconstValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>This provides the ability to add information why the value is set like it is.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconstValue.annotation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ANNOTATION" type="AR:ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::SwSystemconstValue -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SYSTEMCONST-VALUE">
      <xsd:annotation>
         <xsd:documentation>This meta-class assigns a particular value to a system constant.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconstValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::SwSystemconstantValueSet -->
   <xsd:group name="SW-SYSTEMCONSTANT-VALUE-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a set of system constant values.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwSystemconstantValueSets";mmt.qualifiedName="SwSystemconstantValueSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SYSTEMCONSTANT-VALUES">
            <xsd:annotation>
               <xsd:documentation>This is one particular value of a system constant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwSystemconstantValueSet.swSystemconstantValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-SYSTEMCONST-VALUE" type="AR:SW-SYSTEMCONST-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::SwSystemconstantValueSet -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SYSTEMCONSTANT-VALUE-SET">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a set of system constant values.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwSystemconstantValueSets";mmt.qualifiedName="SwSystemconstantValueSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:SW-SYSTEMCONSTANT-VALUE-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-SYSTEMCONSTANT-VALUE-SET--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-SYSTEMCONSTANT-VALUE-SET"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataDefProperties::SwTextProps -->
   <xsd:group name="SW-TEXT-PROPS">
      <xsd:annotation>
         <xsd:documentation>This class expresses particular properties applicable to strings in variables or calibration parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-SIZE-SEMANTICS" type="AR:ARRAY-SIZE-SEMANTICS-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls the semantics of the arraysize for the array representing the string in an ImplementationDataType. It is there to support a safe conversion between ApplicationDatatype and ImplementationDatatype, even for variable length strings as required e.g. for Support of SAE J1939.

            In conjunction with swFillCharacter, it provides the following options:

            * FixedLengthString:  FixedSize - no fillcharacter
            * TerminatedStringFixedLengthCommunication: FixedSize - with fillcharacter
            * VariableLengthString: VariableSize - no fillcharacter
            * TerminatedStringVariableLengthCommunication: VariableSize with fillcharacter</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps.arraySizeSemantics";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MAX-TEXT-SIZE" type="AR:INTEGER-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Specifies the maximum text size in characters. Note the the size in bytes depends on the encoding in the corresponding baseType.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwTextProps.swMaxTextSize";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the base type of one character in the string. In particular this baseType denotes the intended encoding of the characters in the string  on level of ApplicationDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps.baseType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-BASE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-FILL-CHARACTER" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Filler character for text parameter to pad up to the maximum length swMaxTextSize.

            The value will be interpreted according to the encoding specified in the associated base type of the data object., e.g. 0x30 (hex) represents the ASCII character zero as filler character and 0 (dez) represents an end of string as filler character.

            The usage of the fill character depends on the arraySizeSemantics.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps.swFillCharacter";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwTextProps -->
   <xsd:complexType abstract="false" mixed="false" name="SW-TEXT-PROPS">
      <xsd:annotation>
         <xsd:documentation>This class expresses particular properties applicable to strings in variables or calibration parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-TEXT-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationValue::SwValueCont -->
   <xsd:group name="SW-VALUE-CONT">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the content of one particular SwInstance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwValueCont"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the physical unit of the provided values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwValueCont.unit";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-DISPLAY-NAME" type="AR:SINGLE-LANGUAGE-UNIT-NAMES">
            <xsd:annotation>
               <xsd:documentation>This specifies how the physical units of the current value set shall be displayed in documents or in user interfaces of tools.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwValueCont.unitDisplayName";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ARRAYSIZE" type="AR:VALUE-LIST">
            <xsd:annotation>
               <xsd:documentation>For multidimensional compound primitivies (curve, map ...) it is necessary to know the dimensions.They are specified using swArraySize. swArraysize is importand for VAL_BLK.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwValueCont.swArraysize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VALUES-PHYS" type="AR:SW-VALUES">
            <xsd:annotation>
               <xsd:documentation>swValuesPhys represents the values in the physical domain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwValueCont.swValuesPhys";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationValue::SwValueCont -->
   <xsd:complexType abstract="false" mixed="false" name="SW-VALUE-CONT">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents the content of one particular SwInstance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwValueCont"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-VALUE-CONT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationValue::SwValues -->
   <xsd:group name="SW-VALUES">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents a list of values. These values can either be the input values of a curve (abscissa values) or the associated values (ordinate values). In case of multdimensional structures, the values are ordered such that the lowest index runs the fastest. In particular for maps and cuboids etc. the resulting long value list can be subsectioned using ValueGroup. But the processing needs to be done as if vg is not there.

      Note that numerical values and textual values should not be mixed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwValues"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="VF" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
               <xsd:annotation>
                  <xsd:documentation>This allows to specify the value as Variationpoint. It is distinugished to non variant for sake of compatibility to ASAM CDF 2.0.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwValues.vf";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="VT" type="AR:VERBATIM-STRING">
               <xsd:annotation>
                  <xsd:documentation>This represents the values of textual data elements (Strings). Note that vt uses the | to separate the values for the different bitfield masks in case that the semantics of the related DataPrototype is described by means of a BITFIELD_TEXTTABLE in the associated CompuMethod.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwValues.vt";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="V" type="AR:NUMERICAL-VALUE">
               <xsd:annotation>
                  <xsd:documentation>This is a non variant Value. It is provided for sake of Compatibility to ASAM CDF.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwValues.v";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="VG" type="AR:VALUE-GROUP">
               <xsd:annotation>
                  <xsd:documentation>This allows to have intersections in the values in order to support specific rendeing (eg. using stylesheets). For tools it is important that V the values are always processed in the same (flattened) order and the tool is able to interpret it without respecting VG.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwValues.vg";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class CalibrationValue::SwValues -->
   <xsd:complexType abstract="false" mixed="false" name="SW-VALUES">
      <xsd:annotation>
         <xsd:documentation>This metaclass represents a list of values. These values can either be the input values of a curve (abscissa values) or the associated values (ordinate values). In case of multdimensional structures, the values are ordered such that the lowest index runs the fastest. In particular for maps and cuboids etc. the resulting long value list can be subsectioned using ValueGroup. But the processing needs to be done as if vg is not there.

      Note that numerical values and textual values should not be mixed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwValues"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-VALUES"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwVariableImpl -->
   <xsd:group name="SW-VARIABLE-IMPL">
      <xsd:annotation>
         <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class SwClass::SwVariableImpl -->
   <xsd:complexType abstract="false" mixed="false" name="SW-VARIABLE-IMPL">
      <xsd:annotation>
         <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-VARIABLE-IMPL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DatadictionaryProxies::SwVariableRefProxy -->
   <xsd:group name="SW-VARIABLE-REF-PROXY">
      <xsd:annotation>
         <xsd:documentation>Parent class for several kinds of references to a variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableRefProxy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AUTOSAR-VARIABLE" type="AR:AUTOSAR-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the reference to a Variable in an Autosar system. Note that the Target of the reference within AutosarrVariableRef must be of primitiveType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableRefProxy.autosarVariable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MC-DATA-INSTANCE-VAR-REF">
            <xsd:annotation>
               <xsd:documentation>This reference is used in the McSupport file to express the final instance of input values etc. It is not allowed to use this outside
            of an McDataInstance.

            The referenced mcDataInstance must be origninated from a VaraibleDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableRefProxy.mcDataInstanceVar";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MC-DATA-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DatadictionaryProxies::SwVariableRefProxy -->
   <xsd:complexType abstract="false" mixed="false" name="SW-VARIABLE-REF-PROXY">
      <xsd:annotation>
         <xsd:documentation>Parent class for several kinds of references to a variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableRefProxy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SW-VARIABLE-REF-PROXY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwcBswMapping::SwcBswMapping -->
   <xsd:group name="SWC-BSW-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Maps an SwcInternalBehavior to an BswInternalBehavior. This is required to coordinate the API generation and the scheduling for service components, ECU abstraction components and complex driver components by the RTE and the BSW scheduling mechanisms.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwcBswMappings";mmt.qualifiedName="SwcBswMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-BEHAVIOR-REF">
            <xsd:annotation>
               <xsd:documentation>The mapped BswInternalBehavior</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswMapping.bswBehavior";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-INTERNAL-BEHAVIOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUNNABLE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>A mapping between a pair of SWC and BSW runnables.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwcBswMapping.runnableMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-BSW-RUNNABLE-MAPPING" type="AR:SWC-BSW-RUNNABLE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SWC-BEHAVIOR-REF">
            <xsd:annotation>
               <xsd:documentation>The mapped SwcInternalBehavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswMapping.swcBehavior";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SWC-INTERNAL-BEHAVIOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYNCHRONIZED-MODE-GROUPS">
            <xsd:annotation>
               <xsd:documentation>A pair of SWC and BSW mode group prototypes to be synchronized by the scheduler.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwcBswMapping.synchronizedModeGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-BSW-SYNCHRONIZED-MODE-GROUP-PROTOTYPE" type="AR:SWC-BSW-SYNCHRONIZED-MODE-GROUP-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYNCHRONIZED-TRIGGERS">
            <xsd:annotation>
               <xsd:documentation>A pair of SWC and BSW Triggers to be synchronized by the scheduler.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwcBswMapping.synchronizedTrigger";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-BSW-SYNCHRONIZED-TRIGGER" type="AR:SWC-BSW-SYNCHRONIZED-TRIGGER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcBswMapping::SwcBswMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-BSW-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Maps an SwcInternalBehavior to an BswInternalBehavior. This is required to coordinate the API generation and the scheduling for service components, ECU abstraction components and complex driver components by the RTE and the BSW scheduling mechanisms.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwcBswMappings";mmt.qualifiedName="SwcBswMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:SWC-BSW-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SWC-BSW-MAPPING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SWC-BSW-MAPPING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SwcBswMapping::SwcBswRunnableMapping -->
   <xsd:group name="SWC-BSW-RUNNABLE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Maps a BswModuleEntity to a RunnableEntity if it is implemented as part of a BSW module (in the case of an AUTOSAR Service, a Complex Device Driver or an ECU Abstraction). The mapping can be used by a tool to find relevant information on the behavior, e.g. whether the bswEntity shall be running in interrupt context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswRunnableMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-ENTITY-REF">
            <xsd:annotation>
               <xsd:documentation>The mapped BswModuleEntity</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswRunnableMapping.bswEntity";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SWC-RUNNABLE-REF">
            <xsd:annotation>
               <xsd:documentation>The mapped SWC runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswRunnableMapping.swcRunnable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RUNNABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcBswMapping::SwcBswRunnableMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-BSW-RUNNABLE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Maps a BswModuleEntity to a RunnableEntity if it is implemented as part of a BSW module (in the case of an AUTOSAR Service, a Complex Device Driver or an ECU Abstraction). The mapping can be used by a tool to find relevant information on the behavior, e.g. whether the bswEntity shall be running in interrupt context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswRunnableMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SWC-BSW-RUNNABLE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwcBswMapping::SwcBswSynchronizedModeGroupPrototype -->
   <xsd:group name="SWC-BSW-SYNCHRONIZED-MODE-GROUP-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Synchronizes a mode group provided by a component via a port with a mode group provided by a BSW module or cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswSynchronizedModeGroupPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>The BSW mode group prototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswSynchronizedModeGroupPrototype.bswModeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SWC-MODE-GROUP-IREF" type="AR:P-MODE-GROUP-IN-ATOMIC-SWC-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The SWC mode group prototype provided by a particular port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="swcModeGroup.SwcBswSynchronizedModeGroupPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcBswMapping::SwcBswSynchronizedModeGroupPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-BSW-SYNCHRONIZED-MODE-GROUP-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Synchronizes a mode group provided by a component via a port with a mode group provided by a BSW module or cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswSynchronizedModeGroupPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SWC-BSW-SYNCHRONIZED-MODE-GROUP-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwcBswMapping::SwcBswSynchronizedTrigger -->
   <xsd:group name="SWC-BSW-SYNCHRONIZED-TRIGGER">
      <xsd:annotation>
         <xsd:documentation>Synchronizes a Trigger provided by a component via a port with a Trigger provided by a BSW module or cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswSynchronizedTrigger"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-TRIGGER-REF">
            <xsd:annotation>
               <xsd:documentation>The BSW Trigger.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswSynchronizedTrigger.bswTrigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SWC-TRIGGER-IREF" type="AR:P-TRIGGER-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The SWC Trigger provided by a particular port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="swcTrigger.SwcBswSynchronizedTrigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcBswMapping::SwcBswSynchronizedTrigger -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-BSW-SYNCHRONIZED-TRIGGER">
      <xsd:annotation>
         <xsd:documentation>Synchronizes a Trigger provided by a component via a port with a Trigger provided by a BSW module or cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcBswSynchronizedTrigger"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SWC-BSW-SYNCHRONIZED-TRIGGER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwcImplementation::SwcImplementation -->
   <xsd:group name="SWC-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a specialization of the general Implementation meta-class with respect to the usage in application software.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwcImplementations";mmt.qualifiedName="SwcImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BEHAVIOR-REF">
            <xsd:annotation>
               <xsd:documentation>The internal behavior implemented by this Implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcImplementation.behavior";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SWC-INTERNAL-BEHAVIOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-MEMORY-SIZES">
            <xsd:annotation>
               <xsd:documentation>Allows a definition of the size of the per-instance memory for this implementation.
            The aggregation of PerInstanceMemorySize  is subject to variability with the purpose to support variability in the software components implementations. Typically different algorithms in the implementation are requiring different number of memory objects, in this case PerInstanceMemory.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="perInstanceMemorySize.SwcImplementation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PER-INSTANCE-MEMORY-SIZE" type="AR:PER-INSTANCE-MEMORY-SIZE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-RTE-VENDOR" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>Identify a specific RTE vendor. This information is potentially important at the time of integrating (in particular: linking) the application code with the RTE. The semantics is that (if the association exists) the corresponding code has been created to fit to the vendor-mode RTE provided by this specific vendor. Attempting to integrate the code with another RTE generated in vendor mode is in general not possible.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcImplementation.requiredRTEVendor";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcImplementation::SwcImplementation -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a specialization of the general Implementation meta-class with respect to the usage in application software.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SwcImplementations";mmt.qualifiedName="SwcImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:IMPLEMENTATION"/>
         <xsd:group ref="AR:SWC-IMPLEMENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SWC-IMPLEMENTATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SWC-IMPLEMENTATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SwcInternalBehavior::SwcInternalBehavior -->
   <xsd:group name="SWC-INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>The SwcInternalBehavior of an AtomicSwComponentType describes the relevant aspects of the software-component with respect to the RTE, i.e. the RunnableEntities and the RTEEvents they respond to.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcInternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-TYPED-PER-INSTANCE-MEMORYS">
            <xsd:annotation>
               <xsd:documentation>Defines an AUTOSAR typed memory-block that needs to be available for each instance of the SW-component. This is typically only useful if supportsMultipleInstantiation is TRUE or if the component defines NVRAM access via permanent blocks.
            The aggregation of arTypedPerInstanceMemory is subject to variability with the purpose to support variability in the software components implementations. Typically different algorithms in the implementation are requiring different number of memory objects.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="arTypedPerInstanceMemory.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-DATA-PROTOTYPE" type="AR:VARIABLE-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENTS">
            <xsd:annotation>
               <xsd:documentation>This is a RTEEvent specified for the particular SwcInternalBehavior.

            The aggregation of RTEEvent is subject to variability with the purpose to support the conditional existence of RTE events. Note: the number of RTE events might vary due to the conditional existence of PortPrototypes using DataReceivedEvents or due to different scheduling needs of algorithms.

            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="event.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT" type="AR:ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
                  <xsd:element name="BACKGROUND-EVENT" type="AR:BACKGROUND-EVENT"/>
                  <xsd:element name="DATA-RECEIVE-ERROR-EVENT" type="AR:DATA-RECEIVE-ERROR-EVENT"/>
                  <xsd:element name="DATA-RECEIVED-EVENT" type="AR:DATA-RECEIVED-EVENT"/>
                  <xsd:element name="DATA-SEND-COMPLETED-EVENT" type="AR:DATA-SEND-COMPLETED-EVENT"/>
                  <xsd:element name="DATA-WRITE-COMPLETED-EVENT" type="AR:DATA-WRITE-COMPLETED-EVENT"/>
                  <xsd:element name="EXTERNAL-TRIGGER-OCCURRED-EVENT" type="AR:EXTERNAL-TRIGGER-OCCURRED-EVENT"/>
                  <xsd:element name="INTERNAL-TRIGGER-OCCURRED-EVENT" type="AR:INTERNAL-TRIGGER-OCCURRED-EVENT"/>
                  <xsd:element name="MODE-SWITCHED-ACK-EVENT" type="AR:MODE-SWITCHED-ACK-EVENT"/>
                  <xsd:element name="OPERATION-INVOKED-EVENT" type="AR:OPERATION-INVOKED-EVENT"/>
                  <xsd:element name="SWC-MODE-SWITCH-EVENT" type="AR:SWC-MODE-SWITCH-EVENT"/>
                  <xsd:element name="TIMING-EVENT" type="AR:TIMING-EVENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXPLICIT-INTER-RUNNABLE-VARIABLES">
            <xsd:annotation>
               <xsd:documentation>Implement state message semantics for establishing communication among runnables of the same component.
            The aggregation of explicitInterRunnableVariable is subject to variability with the purpose to support variability in the software components implementations. Typically different algorithms in the implementation are requiring different number of memory objects.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="explicitInterRunnableVariable.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-DATA-PROTOTYPE" type="AR:VARIABLE-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-TERMINATION-AND-RESTART" type="AR:HANDLE-TERMINATION-AND-RESTART-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute controls the behavior with respect to stopping and restarting. The corresponding AtomicSwComponentType may either not support stop and restart, or support only stop, or support both stop and restart.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcInternalBehavior.handleTerminationAndRestart";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLICIT-INTER-RUNNABLE-VARIABLES">
            <xsd:annotation>
               <xsd:documentation>Implement state message semantics for establishing communication among runnables of the same component.
            The aggregation of implicitInterRunnableVariable is subject to variability with the purpose to support variability in the software components implementations. Typically different algorithms in the implementation are requiring different number of memory objects.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="implicitInterRunnableVariable.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIABLE-DATA-PROTOTYPE" type="AR:VARIABLE-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INCLUDED-DATA-TYPE-SETS">
            <xsd:annotation>
               <xsd:documentation>The includedDataTypeSet is used by a software component for its implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="includedDataTypeSet.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INCLUDED-DATA-TYPE-SET" type="AR:INCLUDED-DATA-TYPE-SET"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INCLUDED-MODE-DECLARATION-GROUP-SETS">
            <xsd:annotation>
               <xsd:documentation>This aggregation represents the included ModeDeclarationGroups</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcInternalBehavior.includedModeDeclarationGroupSet";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INCLUDED-MODE-DECLARATION-GROUP-SET" type="AR:INCLUDED-MODE-DECLARATION-GROUP-SET"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INSTANTIATION-DATA-DEF-PROPSS">
            <xsd:annotation>
               <xsd:documentation>The purpose of this is that within the context  of a given SwComponentType some data def properties of individual instantiations can be  modified. 
            The aggregation of InstantiationDataDefProps is subject to variability with the purpose to support the conditional existence of PortPrototypes and component local memories like "perInstanceParameter" or "arTypedPerInstanceMemory".


            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwcInternalBehavior.instantiationDataDefProps";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INSTANTIATION-DATA-DEF-PROPS" type="AR:INSTANTIATION-DATA-DEF-PROPS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-MEMORYS">
            <xsd:annotation>
               <xsd:documentation>Defines a per-instance memory object needed by this software component.
            The aggregation of PerInstanceMemory is subject to variability with the purpose to support variability in the software components implementations. Typically different algorithms in the implementation are requiring different number of memory objects.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="perInstanceMemory.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PER-INSTANCE-MEMORY" type="AR:PER-INSTANCE-MEMORY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-PARAMETERS">
            <xsd:annotation>
               <xsd:documentation>Defines parameter(s) or characteristic value(s) that needs to be available for each instance of the software-component. This is typically only useful if supportsMultipleInstantiation is TRUE.
            The aggregation of perInstanceParameter is subject to variability with the purpose to support variability in the software components implementations. Typically different algorithms in the implementation are requiring different number of memory objects.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="perInstanceParameter.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAMETER-DATA-PROTOTYPE" type="AR:PARAMETER-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-API-OPTIONS">
            <xsd:annotation>
               <xsd:documentation>Options for generating the signature of port-related calls from a runnable to the RTE and vice versa.
            The aggregation of PortPrototypes is subject to variability with the purpose to support the conditional existence of ports. 
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="portAPIOption.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PORT-API-OPTION" type="AR:PORT-API-OPTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUNNABLES">
            <xsd:annotation>
               <xsd:documentation>This is a RunnableEntity specified for the particular SwcInternalBehavior.

            The aggregation of RunnableEntity is subject to variability with the purpose to support the conditional existence of RunnableEntities. Note: the number of RunnableEntities might vary due to the conditional existence of PortPrototypes using DataReceivedEvents or due to different scheduling needs of algorithms.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="runnable.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RUNNABLE-ENTITY" type="AR:RUNNABLE-ENTITY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-DEPENDENCYS">
            <xsd:annotation>
               <xsd:documentation>Defines the requirements on AUTOSAR Services for a particular item.

            The aggregation of SwcServiceDependency is subject to variability with the purpose to support the conditional existence of ports as well as the conditional existence of ServiceNeeds.

            The SwcServiceDependency owned by an SwcInternalBehavior can be located in a different physical file in order to support that SwcServiceDependency might be provided in later development 
            steps or even by different expert domain (e.g OBD expert for Obd related  Service Needs) tools. Therefore the aggregation is &lt;&lt;atpSplitable&gt;&gt;.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="SwcInternalBehavior.serviceDependency";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-SERVICE-DEPENDENCY" type="AR:SWC-SERVICE-DEPENDENCY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHARED-PARAMETERS">
            <xsd:annotation>
               <xsd:documentation>Defines parameter(s) or characteristic value(s) shared between SwComponentPrototypes of the same SwComponentType
            The aggregation of sharedParameter is subject to variability with the purpose to support variability in the software components implementations. Typically different algorithms in the implementation are requiring different number of memory objects.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="sharedParameter.SwcInternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAMETER-DATA-PROTOTYPE" type="AR:PARAMETER-DATA-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTS-MULTIPLE-INSTANTIATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Indicate whether the corresponding software-component can be multiply instantiated on one ECU. In this case the attribute will result in an appropriate component API on programming language level (with or without instance handle).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcInternalBehavior.supportsMultipleInstantiation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT-PROXYS">
            <xsd:annotation>
               <xsd:documentation>Proxy of a variation points in the C/C++ implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcInternalBehavior.variationPointProxy";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VARIATION-POINT-PROXY" type="AR:VARIATION-POINT-PROXY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcInternalBehavior::SwcInternalBehavior -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>The SwcInternalBehavior of an AtomicSwComponentType describes the relevant aspects of the software-component with respect to the RTE, i.e. the RunnableEntities and the RTEEvents they respond to.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcInternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:INTERNAL-BEHAVIOR"/>
         <xsd:group ref="AR:SWC-INTERNAL-BEHAVIOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SWC-INTERNAL-BEHAVIOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SWC-INTERNAL-BEHAVIOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RTEEvents::SwcModeSwitchEvent -->
   <xsd:group name="SWC-MODE-SWITCH-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised upon a received mode change.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcModeSwitchEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVATION" type="AR:MODE-ACTIVATION-KIND">
            <xsd:annotation>
               <xsd:documentation>Specifies if the event is activated on entering or exiting the referenced Mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcModeSwitchEvent.activation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to one or two Modes that initiate the Mode Switch Event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcModeSwitchEvent.mode";pureMM.maxOccurs="2";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="MODE-IREF" type="AR:R-MODE-IN-ATOMIC-SWC-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::SwcModeSwitchEvent -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-MODE-SWITCH-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised upon a received mode change.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcModeSwitchEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:SWC-MODE-SWITCH-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcServiceDependency -->
   <xsd:group name="SWC-SERVICE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>Specialization of ServiceDependency in the context of an SwcInternalBehavior. It allows to associate ports, port groups and (in special cases) data defined for an atomic software component  to a given ServiceNeeds element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcServiceDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-DATAS">
            <xsd:annotation>
               <xsd:documentation>Defines the role of an associated data object of the same component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcServiceDependency.assignedData";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-DATA-ASSIGNMENT" type="AR:ROLE-BASED-DATA-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-PORTS">
            <xsd:annotation>
               <xsd:documentation>Defines the role of an associated port of the same component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcServiceDependency.assignedPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-PORT-ASSIGNMENT" type="AR:ROLE-BASED-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REPRESENTED-PORT-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>This reference specifies an association between the ServiceNeeeds and a PortGroup, for example to request a communication mode which applies for communication via these ports. The referred PortGroup must be local to this atomic SWC, but via the links between the PortGroups, a tool can evaluate this information such that all the ports linked via this port group on the same ECU can be found.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcServiceDependency.representedPortGroup";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-NEEDS">
            <xsd:annotation>
               <xsd:documentation>The associated ServiceNeeds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcServiceDependency.serviceNeeds";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="BSW-MGR-NEEDS" type="AR:BSW-MGR-NEEDS"/>
                  <xsd:element name="COM-MGR-USER-NEEDS" type="AR:COM-MGR-USER-NEEDS"/>
                  <xsd:element name="CRYPTO-SERVICE-NEEDS" type="AR:CRYPTO-SERVICE-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS" type="AR:DIAGNOSTIC-COMMUNICATION-MANAGER-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-EVENT-MANAGER-NEEDS" type="AR:DIAGNOSTIC-EVENT-MANAGER-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-EVENT-NEEDS" type="AR:DIAGNOSTIC-EVENT-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-IO-CONTROL-NEEDS" type="AR:DIAGNOSTIC-IO-CONTROL-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-ROUTINE-NEEDS" type="AR:DIAGNOSTIC-ROUTINE-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-VALUE-NEEDS" type="AR:DIAGNOSTIC-VALUE-NEEDS"/>
                  <xsd:element name="DLT-USER-NEEDS" type="AR:DLT-USER-NEEDS"/>
                  <xsd:element name="ECU-STATE-MGR-USER-NEEDS" type="AR:ECU-STATE-MGR-USER-NEEDS"/>
                  <xsd:element name="FUNCTION-INHIBITION-NEEDS" type="AR:FUNCTION-INHIBITION-NEEDS"/>
                  <xsd:element name="NV-BLOCK-NEEDS" type="AR:NV-BLOCK-NEEDS"/>
                  <xsd:element name="OBD-CONTROL-SERVICE-NEEDS" type="AR:OBD-CONTROL-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-INFO-SERVICE-NEEDS" type="AR:OBD-INFO-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-MONITOR-SERVICE-NEEDS" type="AR:OBD-MONITOR-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-PID-SERVICE-NEEDS" type="AR:OBD-PID-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-RATIO-SERVICE-NEEDS" type="AR:OBD-RATIO-SERVICE-NEEDS"/>
                  <xsd:element name="SUPERVISED-ENTITY-NEEDS" type="AR:SUPERVISED-ENTITY-NEEDS"/>
                  <xsd:element name="SYNC-TIME-BASE-MGR-USER-NEEDS" type="AR:SYNC-TIME-BASE-MGR-USER-NEEDS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcServiceDependency -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-SERVICE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>Specialization of ServiceDependency in the context of an SwcInternalBehavior. It allows to associate ports, port groups and (in special cases) data defined for an atomic software component  to a given ServiceNeeds element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcServiceDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:SERVICE-DEPENDENCY"/>
         <xsd:group ref="AR:SWC-SERVICE-DEPENDENCY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Timing::SwcTiming -->
   <xsd:group name="SWC-TIMING">
      <xsd:annotation>
         <xsd:documentation>The SwcTiming is used to describe the timing of a software component. A software component can either be of type AtomicSwComponentType or CompositionSwComponentType. In the former case, the SwcTiming allows to describe timing description and constraints for the SwcInternalBehavior of the AtomicSwComponentType. In the latter case, timing descriptions and constraints can be defined for all AtomicSwComponentType's within the CompositionSwComponentType.

      Unlike the VfbTiming, TimingDescriptions aggregated by SwcTiming are restricted to event chains referring to events which are derived from the classes TDEventVfb and TDEventInternalBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="SwcTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BEHAVIOR-REF">
            <xsd:annotation>
               <xsd:documentation>This defines the scope of a SwcTiming. All corresponding timing descriptions and constraints must be defined within this scope.

            Note! The reason for the cardinality of 0..1 is to ensure backward compatibility.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcTiming.behavior";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SWC-INTERNAL-BEHAVIOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-REF">
            <xsd:annotation>
               <xsd:documentation>Deprecated. The use of this association is deprecated and one is encouraged to use the association between SwcTiming and SwcInternalBehavior.
            Please note, that the association between SwcTiming and SwComponentType is going to be removed in the future.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="SwcTiming.component";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::SwcTiming -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TIMING">
      <xsd:annotation>
         <xsd:documentation>The SwcTiming is used to describe the timing of a software component. A software component can either be of type AtomicSwComponentType or CompositionSwComponentType. In the former case, the SwcTiming allows to describe timing description and constraints for the SwcInternalBehavior of the AtomicSwComponentType. In the latter case, timing descriptions and constraints can be defined for all AtomicSwComponentType's within the CompositionSwComponentType.

      Unlike the VfbTiming, TimingDescriptions aggregated by SwcTiming are restricted to event chains referring to events which are derived from the classes TDEventVfb and TDEventInternalBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="SwcTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:TIMING-EXTENSION"/>
         <xsd:group ref="AR:SWC-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::SwcToEcuMapping -->
   <xsd:group name="SWC-TO-ECU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Map software components to a specific ECU Instance and optionally to a processing unit and to an EcuPartition. Per ECUInstance/ProcessingUnit/EcuPartition/SensorActuator only one SwcToEcuMapping shall be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>References to the software component instances that are mapped to the referenced ECUInstance. If the component prototype referenced is a composition, this indicates that all atomic software components within the composition are mapped to the ECU. 

            If there is aditionally a mapping of some SwComponentPrototype INSIDE the Composition to another ECU Instance the inner mapping overrides the outer mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.SwcToEcuMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPONENT-IREF" type="AR:COMPONENT-IN-SYSTEM-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTROLLED-HW-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Optional mapping of SwComponentPrototypes that are typed by SensorActuatorSwComponentType to a HwElement with category SensorActuator.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping.controlledHwElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>EcuInstance is a reference to an ECU Instance description</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARTITION-REF">
            <xsd:annotation>
               <xsd:documentation>An optional mapping of SWCs to Partitions. 
            With this mapping an OEM has the option to predefine an allocation in the System Design phase. The final and complete assignment is described in the OS Configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping.partition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-PARTITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROCESSING-UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>Optional mapping of software components to individual microcontroller cores residing in one ECU. A microcontroller core is described in the ECU Resource Template by the HwElement of HwCategory ProcessingUnit.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping.processingUnit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::SwcToEcuMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-ECU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Map software components to a specific ECU Instance and optionally to a processing unit and to an EcuPartition. Per ECUInstance/ProcessingUnit/EcuPartition/SensorActuator only one SwcToEcuMapping shall be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SWC-TO-ECU-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SWC-TO-ECU-MAPPING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SWC-TO-ECU-MAPPING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SWmapping::SwcToEcuMappingConstraint -->
   <xsd:group name="SWC-TO-ECU-MAPPING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>The System Constraint Description has to describe dedicated and exclusive mapping of SW-Cs to one or more ECUs. Dedicated mapping means that the SW-C can only be mapped to the ECUs it is dedicated to. Exclusive Mapping means that the SW-C cannot be mapped to the ECUs it is excluded from.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREF" type="AR:COMPONENT-IN-SYSTEM-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to SwComponentPrototypes for which the dedicated or exclusive mapping is defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.SwcToEcuMappingConstraint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REFS">
            <xsd:annotation>
               <xsd:documentation>If the dedicated mapping is described, the SwComponentPrototypes can only be mapped to these referenced ECUInstances. 

            If the exclusive mapping is described, the SwComponentPrototypes cannot be mapped to these referenced ECUInstances.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint.ecuInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECU-INSTANCE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SWC-TO-ECU-MAPPING-CONSTRAINT-TYPE" type="AR:SWC-TO-ECU-MAPPING-CONSTRAINT-TYPE">
            <xsd:annotation>
               <xsd:documentation>This attribute determines if dedicated or exclusive mapping is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint.swcToEcuMappingConstraintType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::SwcToEcuMappingConstraint -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-ECU-MAPPING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>The System Constraint Description has to describe dedicated and exclusive mapping of SW-Cs to one or more ECUs. Dedicated mapping means that the SW-C can only be mapped to the ECUs it is dedicated to. Exclusive Mapping means that the SW-C cannot be mapped to the ECUs it is excluded from.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:MAPPING-CONSTRAINT"/>
         <xsd:group ref="AR:SWC-TO-ECU-MAPPING-CONSTRAINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::SwcToImplMapping -->
   <xsd:group name="SWC-TO-IMPL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Map instances of an AtomicSwComponentType to a specific Implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToImplMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IMPLEMENTATION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a specific Implementation description.

            Implementation to be used by the specified SW component instance. This allows to achieve more precise estimates for the resource consumption that results from mapping the instance of an atomic SW component onto an ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToImplMapping.componentImplementation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SWC-IMPLEMENTATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the software component instances that are being mapped to the specified Implementation. The targeted SwComponentPrototype needs be of the AtomicSwComponentType being implemented by the referenced Implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.SwcToImplMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPONENT-IREF" type="AR:COMPONENT-IN-SYSTEM-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::SwcToImplMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-IMPL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Map instances of an AtomicSwComponentType to a specific Implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToImplMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SWC-TO-IMPL-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::SwcToSwcOperationArguments -->
   <xsd:group name="SWC-TO-SWC-OPERATION-ARGUMENTS">
      <xsd:annotation>
         <xsd:documentation>The SwcToSwcOperationArguments describes the information (client server operation arguments, plus the operation identification, if required) that are exchanged between two SW Components from exactly one client to one server, or from one server back to one client. The direction attribute defines which direction is described. If direction == IN, all arguments sent from the client to the server are described by the SwcToSwcOperationArguments, in direction == OUT, it's the arguments sent back from server to client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECTION" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS-DIRECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>Direction addressed by this SwcToSwcClientServerOperation element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments.direction";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the operation at the client and at the server side whose arguments are described by SwcToSwcOperationArguments. The two ports referenced must be connected by a connector in the software component description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.SwcToSwcOperationArguments";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="OPERATION-IREF" type="AR:OPERATION-IN-SYSTEM-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::SwcToSwcOperationArguments -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-SWC-OPERATION-ARGUMENTS">
      <xsd:annotation>
         <xsd:documentation>The SwcToSwcOperationArguments describes the information (client server operation arguments, plus the operation identification, if required) that are exchanged between two SW Components from exactly one client to one server, or from one server back to one client. The direction attribute defines which direction is described. If direction == IN, all arguments sent from the client to the server are described by the SwcToSwcOperationArguments, in direction == OUT, it's the arguments sent back from server to client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::SwcToSwcSignal -->
   <xsd:group name="SWC-TO-SWC-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>The SwcToSwcSignal describes the information (data element) that is exchanged between two SW Components. On the SWC Level it is possible that a SW Component sends one data element from one P-Port to two different SW Components (1:n Communication). The SwcToSwcSignal describes exactly the information which is exchanged between one P-Port of a SW Component and one R-Port of another SW Component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to a data element on the PPortPrototype and to the same data element on the RPortPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.SwcToSwcSignal";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="DATA-ELEMENT-IREF" type="AR:VARIABLE-DATA-PROTOTYPE-IN-SYSTEM-INSTANCE-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::SwcToSwcSignal -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-SWC-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>The SwcToSwcSignal describes the information (data element) that is exchanged between two SW Components. On the SWC Level it is possible that a SW Component sends one data element from one P-Port to two different SW Components (1:n Communication). The SwcToSwcSignal describes exactly the information which is exchanged between one P-Port of a SW Component and one R-Port of another SW Component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SWC-TO-SWC-SIGNAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::SymbolProps -->
   <xsd:group name="SYMBOL-PROPS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to attach with the symbol attribute a symbolic name that is conform to C language requirements to another meta-class, e.g. AtomicSwComponentType, that is a potential subject to a name clash on the level of RTE source code.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SymbolProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class Components::SymbolProps -->
   <xsd:complexType abstract="false" mixed="false" name="SYMBOL-PROPS">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to attach with the symbol attribute a symbolic name that is conform to C language requirements to another meta-class, e.g. AtomicSwComponentType, that is a potential subject to a name clash on the level of RTE source code.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SymbolProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:IMPLEMENTATION-PROPS"/>
         <xsd:group ref="AR:SYMBOL-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Synopsis::SynArgument -->
   <xsd:group name="SYN-ARGUMENT">
      <xsd:annotation>
         <xsd:documentation>This element describes one particular Argument within the current object synopsis. The name of the argument goes into itemLabel. The short description goes in to desc. The detailed description goes into addInfo5.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SynArgument"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class Synopsis::SynArgument -->
   <xsd:complexType abstract="false" mixed="false" name="SYN-ARGUMENT">
      <xsd:annotation>
         <xsd:documentation>This element describes one particular Argument within the current object synopsis. The name of the argument goes into itemLabel. The short description goes in to desc. The detailed description goes into addInfo5.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SynArgument"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SYN-ARGUMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::SyncTimeBaseMgrUserNeeds -->
   <xsd:group name="SYNC-TIME-BASE-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the needs on the configuration of the Synchronized Time-base Manager for one time-base. This class currently contains no attributes. An instance of this class is used to find out which ports of a software-component belong to this time-base in order to group the request and response ports of the same time-base. The actual time-base value is stored in the PortDefinedArgumentValue of the respective port specification.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SyncTimeBaseMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::SyncTimeBaseMgrUserNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SYNC-TIME-BASE-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the needs on the configuration of the Synchronized Time-base Manager for one time-base. This class currently contains no attributes. An instance of this class is used to find out which ports of a software-component belong to this time-base in order to group the request and response ports of the same time-base. The actual time-base value is stored in the PortDefinedArgumentValue of the respective port specification.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SyncTimeBaseMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-NEEDS"/>
         <xsd:group ref="AR:SYNC-TIME-BASE-MGR-USER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SynchronizationTimingConstraint::SynchronizationTimingConstraint -->
   <xsd:group name="SYNCHRONIZATION-TIMING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>This constraint is used to restrict the timing behavior of different, but correlated event chains, in regard to synchronization.

      Thereby, the following two scenarios are supported:

      1) [synchronizationConstraintType=responseSynchronization] An arbitrary number of correlated event chains with a common stimulus, but different responses, where the responses shall occur synchronously with respect to a predefined tolerance.

      2) [synchronizationConstraintType=stimulusSynchronization]  An arbitrary number of correlated event chains with a common response, but different stimuli, where the stimuli shall occur synchronously with respect to a predefined tolerance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SynchronizationTimingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCOPE-REFS">
            <xsd:annotation>
               <xsd:documentation>referenced event chains</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SynchronizationTimingConstraint.scope";pureMM.maxOccurs="-1";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SCOPE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT-CHAIN--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYNCHRONIZATION-CONSTRAINT-TYPE" type="AR:SYNCHRONIZATION-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this synchronization constraint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SynchronizationTimingConstraint.synchronizationConstraintType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOLERANCE" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>The maximum time interval, within which the synchronized events must occur.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SynchronizationTimingConstraint.tolerance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SynchronizationTimingConstraint::SynchronizationTimingConstraint -->
   <xsd:complexType abstract="false" mixed="false" name="SYNCHRONIZATION-TIMING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>This constraint is used to restrict the timing behavior of different, but correlated event chains, in regard to synchronization.

      Thereby, the following two scenarios are supported:

      1) [synchronizationConstraintType=responseSynchronization] An arbitrary number of correlated event chains with a common stimulus, but different responses, where the responses shall occur synchronously with respect to a predefined tolerance.

      2) [synchronizationConstraintType=stimulusSynchronization]  An arbitrary number of correlated event chains with a common response, but different stimuli, where the stimuli shall occur synchronously with respect to a predefined tolerance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SynchronizationTimingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TIMING-CONSTRAINT"/>
         <xsd:group ref="AR:SYNCHRONIZATION-TIMING-CONSTRAINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServerCall::SynchronousServerCallPoint -->
   <xsd:group name="SYNCHRONOUS-SERVER-CALL-POINT">
      <xsd:annotation>
         <xsd:documentation>This means that the RunnableEntity is supposed to perform a  blocking wait for a response from the server.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SynchronousServerCallPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class ServerCall::SynchronousServerCallPoint -->
   <xsd:complexType abstract="false" mixed="false" name="SYNCHRONOUS-SERVER-CALL-POINT">
      <xsd:annotation>
         <xsd:documentation>This means that the RunnableEntity is supposed to perform a  blocking wait for a response from the server.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SynchronousServerCallPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVER-CALL-POINT"/>
         <xsd:group ref="AR:SYNCHRONOUS-SERVER-CALL-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SystemTemplate::System -->
   <xsd:group name="SYSTEM">
      <xsd:annotation>
         <xsd:documentation>The top level element of the System Description.
      The System description defines five major elements: Topology, Software, Communication, Mapping and Mapping Constraints.

      The System element directly aggregates the elements describing the Software, Mapping and Mapping Constraints; it contains a reference to an ASAM FIBEX description specifying Communication and Topology.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Systems";mmt.qualifiedName="System"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-DOCUMENTATIONS">
            <xsd:annotation>
               <xsd:documentation>Possibility to provide additional documentation while defining the System. The System documentation can be composed of several chapters.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";atp.Splitkey="shortName, VariationPoint.shortLabel";mmt.qualifiedName="System.systemDocumentation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="-10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CHAPTER" type="AR:CHAPTER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-EXTRACT-VERSION" type="AR:REVISION-LABEL-STRING">
            <xsd:annotation>
               <xsd:documentation>Version number of the Ecu Extract.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.ecuExtractVersion";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIBEX-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>This property was modified due to atpVariation (DirectedAssociationPattern).</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="System.fibexElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FIBEX-ELEMENT-REF-CONDITIONAL" type="AR:FIBEX-ELEMENT-REF-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";atp.Splitkey="shortName, variationPoint.shortLabel";mmt.qualifiedName="mapping.System";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SYSTEM-MAPPING" type="AR:SYSTEM-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-VECTOR-LENGTH" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Length of the partial networking request release information vector.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.pncVectorLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-VECTOR-OFFSET" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Absolute offset (with respect to the Frame) of the partial networking request release information vector.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.pncVectorOffset";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROOT-SOFTWARE-COMPOSITIONS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="rootSoftwareComposition.System";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROOT-SW-COMPOSITION-PROTOTYPE" type="AR:ROOT-SW-COMPOSITION-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-VERSION" type="AR:REVISION-LABEL-STRING">
            <xsd:annotation>
               <xsd:documentation>Version number of the System Description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.systemVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SystemTemplate::System -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM">
      <xsd:annotation>
         <xsd:documentation>The top level element of the System Description.
      The System description defines five major elements: Topology, Software, Communication, Mapping and Mapping Constraints.

      The System element directly aggregates the elements describing the Software, Mapping and Mapping Constraints; it contains a reference to an ASAM FIBEX description specifying Communication and Topology.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Systems";mmt.qualifiedName="System"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:SYSTEM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SYSTEM--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SYSTEM"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SystemTemplate::SystemMapping -->
   <xsd:group name="SYSTEM-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The system mapping aggregates all mapping aspects (mapping of SW components to ECUs, mapping of data elements to signals, and mapping constraints).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SystemMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The data mappings defined.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="dataMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING" type="AR:CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING"/>
                  <xsd:element name="SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING" type="AR:SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING"/>
                  <xsd:element name="SENDER-RECEIVER-TO-SIGNAL-MAPPING" type="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-RESOURCE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="ecuResourceMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECU-MAPPING" type="AR:ECU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPING-CONSTRAINTS">
            <xsd:annotation>
               <xsd:documentation>Constraints that limit the mapping freedom for the mapping of SW components to ECUs.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="mappingConstraint.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPONENT-CLUSTERING" type="AR:COMPONENT-CLUSTERING"/>
                  <xsd:element name="COMPONENT-SEPARATION" type="AR:COMPONENT-SEPARATION"/>
                  <xsd:element name="SWC-TO-ECU-MAPPING-CONSTRAINT" type="AR:SWC-TO-ECU-MAPPING-CONSTRAINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="pncMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PNC-MAPPING" type="AR:PNC-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOURCE-ESTIMATIONS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="resourceEstimation.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECU-RESOURCE-ESTIMATION" type="AR:ECU-RESOURCE-ESTIMATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-PATH-CONSTRAINTS">
            <xsd:annotation>
               <xsd:documentation>Constraints that limit the mapping freedom for the mapping of data elements to signals.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="signalPathConstraint.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMMON-SIGNAL-PATH" type="AR:COMMON-SIGNAL-PATH"/>
                  <xsd:element name="FORBIDDEN-SIGNAL-PATH" type="AR:FORBIDDEN-SIGNAL-PATH"/>
                  <xsd:element name="PERMISSIBLE-SIGNAL-PATH" type="AR:PERMISSIBLE-SIGNAL-PATH"/>
                  <xsd:element name="SEPARATE-SIGNAL-PATH" type="AR:SEPARATE-SIGNAL-PATH"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IMPL-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="swImplMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-IMPL-MAPPING" type="AR:SWC-TO-IMPL-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="SystemDesignTime";mmt.qualifiedName="swMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-ECU-MAPPING" type="AR:SWC-TO-ECU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SystemTemplate::SystemMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The system mapping aggregates all mapping aspects (mapping of SW components to ECUs, mapping of data elements to signals, and mapping constraints).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SystemMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SYSTEM-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::SystemSignal -->
   <xsd:group name="SYSTEM-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>The system signal represents the communication system's view of data exchanged between SW components which reside on different ECUs. The system signals allow to represent this communication in a flattened structure, with exactly one system signal defined for each data element prototype sent and received by connected SW component instances.

      In case the System Description doesn't use a complete Software Component Description (VFB View) the data mapping of Variable Data Prototypes or Client Server Operations on SystemSignals needs not to be defined. This supports the inclusion of legacy signals.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SystemSignals";mmt.qualifiedName="SystemSignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DYNAMIC-LENGTH" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>The length of dynamic length signals is variable in run-time. Only a maximum length of such a signal is specified in the configuration (attribute length in ISignal element).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignal.dynamicLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SystemSignal -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>The system signal represents the communication system's view of data exchanged between SW components which reside on different ECUs. The system signals allow to represent this communication in a flattened structure, with exactly one system signal defined for each data element prototype sent and received by connected SW component instances.

      In case the System Description doesn't use a complete Software Component Description (VFB View) the data mapping of Variable Data Prototypes or Client Server Operations on SystemSignals needs not to be defined. This supports the inclusion of legacy signals.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SystemSignals";mmt.qualifiedName="SystemSignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:SYSTEM-SIGNAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SYSTEM-SIGNAL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SYSTEM-SIGNAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::SystemSignalGroup -->
   <xsd:group name="SYSTEM-SIGNAL-GROUP">
      <xsd:annotation>
         <xsd:documentation>A signal group refers to a set of signals that must always be kept together. A signal group is used to guarantee the atomic transfer of AUTOSAR composite data types.  

      The SystemSignalGroup defines a signal grouping on VFB level. On cluster level the Signal grouping is described by the ISignalGroup element.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SystemSignalGroups";mmt.qualifiedName="SystemSignalGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to a set of SystemSignals that must always be kept together.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignalGroup.systemSignal";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SYSTEM-SIGNAL-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SystemSignalGroup -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM-SIGNAL-GROUP">
      <xsd:annotation>
         <xsd:documentation>A signal group refers to a set of signals that must always be kept together. A signal group is used to guarantee the atomic transfer of AUTOSAR composite data types.  

      The SystemSignalGroup defines a signal grouping on VFB level. On cluster level the Signal grouping is described by the ISignalGroup element.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="SystemSignalGroups";mmt.qualifiedName="SystemSignalGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:SYSTEM-SIGNAL-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SYSTEM-SIGNAL-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Timing::SystemTiming -->
   <xsd:group name="SYSTEM-TIMING">
      <xsd:annotation>
         <xsd:documentation>A model element used to refine timing descriptions and constraints (from a VfbTiming) at System level, utilizing information about topology, software deployment, and signal mapping described in the System Template.

      TimingDescriptions aggregated by SystemTiming are restricted to events which are derived from the class TDEventVfb, TDEventSwcInternalBehavior and TDEventCom.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="SystemTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-REF">
            <xsd:annotation>
               <xsd:documentation>This defines the scope of a SystemTiming. All corresponding timing descriptions and constraints must be defined within this scope.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SystemTiming.system";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::SystemTiming -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM-TIMING">
      <xsd:annotation>
         <xsd:documentation>A model element used to refine timing descriptions and constraints (from a VfbTiming) at System level, utilizing information about topology, software deployment, and signal mapping described in the System Template.

      TimingDescriptions aggregated by SystemTiming are restricted to events which are derived from the class TDEventVfb, TDEventSwcInternalBehavior and TDEventCom.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="SystemTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:TIMING-EXTENSION"/>
         <xsd:group ref="AR:SYSTEM-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventBsw::TDEventBsw -->
   <xsd:group name="TD-EVENT-BSW">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to BSW modules.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBsw"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-DESCRIPTION-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBsw.bswModuleDescription";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-DESCRIPTION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class TDEventBswInternalBehavior::TDEventBswInternalBehavior -->
   <xsd:group name="TD-EVENT-BSW-INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the BswInternalBehavior of a BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswInternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-ENTITY-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswInternalBehavior.bswModuleEntity";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-BSW-INTERNAL-BEHAVIOR-TYPE" type="AR:TD-EVENT-BSW-INTERNAL-BEHAVIOR-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswInternalBehavior.tdEventBswInternalBehaviorType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventBswInternalBehavior::TDEventBswInternalBehavior -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-BSW-INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the BswInternalBehavior of a BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswInternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-BSW-INTERNAL-BEHAVIOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventBsw::TDEventBswModeDeclaration -->
   <xsd:group name="TD-EVENT-BSW-MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the mode communication on BSW level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENTRY-MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:documentation>Optional parameter which refines the scope of the TDEventBswModeDeclaration. If the parameter is set, the event occurs only if the mode declaration group prototype instance shall enter into the referenced ModeDeclaration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclaration.entryModeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXIT-MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:documentation>Optional parameter which refines the scope of the TDEventBswModeDeclaration. If the parameter is set, the event occurs only if the mode declaration group prototype instance shall exit from the referenced ModeDeclaration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclaration.exitModeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclaration.modeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-BSW-MODE-DECLARATION-TYPE" type="AR:TD-EVENT-BSW-MODE-DECLARATION-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclaration.tdEventBswModeDeclarationType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventBsw::TDEventBswModeDeclaration -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-BSW-MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the mode communication on BSW level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-BSW"/>
         <xsd:group ref="AR:TD-EVENT-BSW-MODE-DECLARATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventBsw::TDEventBswModule -->
   <xsd:group name="TD-EVENT-BSW-MODULE">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the interaction between BSW modules.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModule"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-ENTRY-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModule.bswModuleEntry";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-BSW-MODULE-TYPE" type="AR:TD-EVENT-BSW-MODULE-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModule.tdEventBswModuleType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventBsw::TDEventBswModule -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-BSW-MODULE">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the interaction between BSW modules.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModule"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-BSW"/>
         <xsd:group ref="AR:TD-EVENT-BSW-MODULE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventCom::TDEventCom -->
   <xsd:group name="TD-EVENT-COM">
      <xsd:annotation>
         <xsd:documentation>This is the abstract parent class to describe timing events related to communication including the physical layer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventCom"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The ECU context for a particular timing event. The link is optional, because the EcuInstance can not be defined for events of type TDEventCycleStart.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventCom.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class TDEventComplex::TDEventComplex -->
   <xsd:group name="TD-EVENT-COMPLEX">
      <xsd:annotation>
         <xsd:documentation>This is used to describe complex timing events.

      The context of a complex timing event either is described informally, e.g. using the documentation block, or is described formally by the associated TDEventOccurrenceExpression.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventComplex"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class TDEventComplex::TDEventComplex -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-COMPLEX">
      <xsd:annotation>
         <xsd:documentation>This is used to describe complex timing events.

      The context of a complex timing event either is described informally, e.g. using the documentation block, or is described formally by the associated TDEventOccurrenceExpression.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventComplex"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-COMPLEX"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventCom::TDEventCycleStart -->
   <xsd:group name="TD-EVENT-CYCLE-START">
      <xsd:annotation>
         <xsd:documentation>This is the abstract parent class to describe timing events related to a point in time where a communication cycle starts.

      Via the attribute "cycleRepetition", a filtered view to the cycle start can be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventCycleStart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-REPETITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The start of every &amp;lt;cycleRepetition&amp;gt; cycle is targeted by this event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventCycleStart.cycleRepetition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class TDEventCom::TDEventFrClusterCycleStart -->
   <xsd:group name="TD-EVENT-FR-CLUSTER-CYCLE-START">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the timing event related to a point in time where a communication cycle starts on a FlexRay cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrClusterCycleStart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FR-CLUSTER-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrClusterCycleStart.frCluster";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-CLUSTER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventCom::TDEventFrClusterCycleStart -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-FR-CLUSTER-CYCLE-START">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the timing event related to a point in time where a communication cycle starts on a FlexRay cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrClusterCycleStart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-COM"/>
         <xsd:group ref="AR:TD-EVENT-CYCLE-START"/>
         <xsd:group ref="AR:TD-EVENT-FR-CLUSTER-CYCLE-START"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventCom::TDEventFrame -->
   <xsd:group name="TD-EVENT-FRAME">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the exchange of frames between the communication controller and the bus specific (FlexRay / CAN / LIN) Interface BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrame.frame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FRAME--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNEL-REF">
            <xsd:annotation>
               <xsd:documentation>The PhysicalChannel on which the Frame is transmitted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrame.physicalChannel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-TYPE" type="AR:TD-EVENT-FRAME-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrame.tdEventType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventCom::TDEventFrame -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-FRAME">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the exchange of frames between the communication controller and the bus specific (FlexRay / CAN / LIN) Interface BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-COM"/>
         <xsd:group ref="AR:TD-EVENT-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventCom::TDEventIPdu -->
   <xsd:group name="TD-EVENT-I-PDU">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the exchange of I-PDUs between the bus specific (FlexRay / CAN / LIN) Interface BSW module and COM.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventIPdu.iPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNEL-REF">
            <xsd:annotation>
               <xsd:documentation>The PhysicalChannel on which the IPdu is transmitted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventIPdu.physicalChannel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-TYPE" type="AR:TD-EVENT-I-PDU-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventIPdu.tdEventType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventCom::TDEventIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-I-PDU">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the exchange of I-PDUs between the bus specific (FlexRay / CAN / LIN) Interface BSW module and COM.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-COM"/>
         <xsd:group ref="AR:TD-EVENT-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventCom::TDEventISignal -->
   <xsd:group name="TD-EVENT-I-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the exchange of I-Signals between COM and RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventISignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventISignal.iSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNEL-REF">
            <xsd:annotation>
               <xsd:documentation>The PhysicalChannel on which the ISignal is transmitted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventISignal.physicalChannel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-TYPE" type="AR:TD-EVENT-I-SIGNAL-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventISignal.tdEventType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventCom::TDEventISignal -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-I-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the exchange of I-Signals between COM and RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventISignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-COM"/>
         <xsd:group ref="AR:TD-EVENT-I-SIGNAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventVfb::TDEventModeDeclaration -->
   <xsd:group name="TD-EVENT-MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to mode switch communication at VFB level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENTRY-MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:documentation>Optional parameter which refines the scope of the TDEventModeDeclaration. If the parameter is set, the event occurs only if the mode declaration group prototype instance shall enter into the referenced ModeDeclaration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclaration.entryModeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXIT-MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:documentation>Optional parameter which refines the scope of the TDEventModeDeclaration. If the parameter is set, the event occurs only if the mode declaration group prototype instance shall exit from the referenced ModeDeclaration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclaration.exitModeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced mode declaration group prototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclaration.modeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-MODE-DECLARATION-TYPE" type="AR:TD-EVENT-MODE-DECLARATION-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclaration.tdEventModeDeclarationType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventVfb::TDEventModeDeclaration -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to mode switch communication at VFB level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-VFB"/>
         <xsd:group ref="AR:TD-EVENT-MODE-DECLARATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventOccurrenceExpression::TDEventOccurrenceExpression -->
   <xsd:group name="TD-EVENT-OCCURRENCE-EXPRESSION">
      <xsd:annotation>
         <xsd:documentation>This is used to specify a filter on the occurrences of TimingDescriptionEvents by means of a TDEventOccurrenceExpressionFormula.
      Filter criteria can be variable and argument values, i.e. the timing event only occurs for specific values, as well as the temporal characteristics of the occurrences of arbitrary timing events.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOccurrenceExpression"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENTS">
            <xsd:annotation>
               <xsd:documentation>An occurrence expression can reference an arbitrary number of OperationArgumentPrototypes in its expression. This association aggegrates instanceRefs to OperationArgumentPrototypes which can be referenced in the expression.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="argument.TDEventOccurrenceExpression";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AUTOSAR-OPERATION-ARGUMENT-INSTANCE" type="AR:AUTOSAR-OPERATION-ARGUMENT-INSTANCE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FORMULA" type="AR:TD-EVENT-OCCURRENCE-EXPRESSION-FORMULA">
            <xsd:annotation>
               <xsd:documentation>This is the expression formula which is used to describe the occurrence expression.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="formula.TDEventOccurrenceExpression";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIABLES">
            <xsd:annotation>
               <xsd:documentation>An occurrence expression can reference an arbitrary number of VariableDataPrototpyes in its expression. This association aggegrates instanceRefs to VariableDataPrototypes which can be referenced in the expression.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="variable.TDEventOccurrenceExpression";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AUTOSAR-VARIABLE-INSTANCE" type="AR:AUTOSAR-VARIABLE-INSTANCE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventOccurrenceExpression::TDEventOccurrenceExpression -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-OCCURRENCE-EXPRESSION">
      <xsd:annotation>
         <xsd:documentation>This is used to specify a filter on the occurrences of TimingDescriptionEvents by means of a TDEventOccurrenceExpressionFormula.
      Filter criteria can be variable and argument values, i.e. the timing event only occurs for specific values, as well as the temporal characteristics of the occurrences of arbitrary timing events.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOccurrenceExpression"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TD-EVENT-OCCURRENCE-EXPRESSION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TDEventOccurrenceExpression::TDEventOccurrenceExpressionFormula -->
   <xsd:group name="TD-EVENT-OCCURRENCE-EXPRESSION-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This is an extension of the FormulaExpression for the AUTOSAR Timing Extensions.
      A TDEventOccurrenceExpressionFormula provides the means to express the temporal characteristics of timing event occurrences in correlation with specific variable and argument values.
      The formal definition of the extended formula expression language is described in detail in the AUTOSAR Timing Extensions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOccurrenceExpressionFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="ARGUMENT-REF">
               <xsd:annotation>
                  <xsd:documentation>This is one particular argument value used in the expression formula.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOccurrenceExpressionFormula.argument";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:AUTOSAR-OPERATION-ARGUMENT-INSTANCE--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="EVENT-REF">
               <xsd:annotation>
                  <xsd:documentation>This is one particular timing description event used in the expression formula.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOccurrenceExpressionFormula.event";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="VARIABLE-REF">
               <xsd:annotation>
                  <xsd:documentation>This is one particular variable value used in the expression formula.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOccurrenceExpressionFormula.variable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:AUTOSAR-VARIABLE-INSTANCE--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class TDEventOccurrenceExpression::TDEventOccurrenceExpressionFormula -->
   <xsd:complexType abstract="false" mixed="true" name="TD-EVENT-OCCURRENCE-EXPRESSION-FORMULA">
      <xsd:annotation>
         <xsd:documentation>This is an extension of the FormulaExpression for the AUTOSAR Timing Extensions.
      A TDEventOccurrenceExpressionFormula provides the means to express the temporal characteristics of timing event occurrences in correlation with specific variable and argument values.
      The formal definition of the extended formula expression language is described in detail in the AUTOSAR Timing Extensions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOccurrenceExpressionFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:TD-EVENT-OCCURRENCE-EXPRESSION-FORMULA"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TDEventVfb::TDEventOperation -->
   <xsd:group name="TD-EVENT-OPERATION">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to client-server communication at VFB level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperation.operation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLIENT-SERVER-OPERATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-OPERATION-TYPE" type="AR:TD-EVENT-OPERATION-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperation.tdEventOperationType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventVfb::TDEventOperation -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-OPERATION">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to client-server communication at VFB level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-VFB"/>
         <xsd:group ref="AR:TD-EVENT-OPERATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventSwcInternalBehavior::TDEventSwcInternalBehavior -->
   <xsd:group name="TD-EVENT-SWC-INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the SwcInternalBehavior of an AtomicSwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREF" type="AR:COMPONENT-IN-COMPOSITION-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The context for the scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehavior.component";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUNNABLE-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehavior.runnable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RUNNABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-SWC-INTERNAL-BEHAVIOR-TYPE" type="AR:TD-EVENT-SWC-INTERNAL-BEHAVIOR-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehavior.tdEventSwcInternalBehaviorType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventSwcInternalBehavior::TDEventSwcInternalBehavior -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-SWC-INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to the SwcInternalBehavior of an AtomicSwComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-SWC-INTERNAL-BEHAVIOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventCom::TDEventTTCanCycleStart -->
   <xsd:group name="TD-EVENT-TT-CAN-CYCLE-START">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the timing event related to a point in time where a communication cycle starts on a TTCAN cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventTTCanCycleStart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TT-CAN-CLUSTER-REF">
            <xsd:annotation>
               <xsd:documentation>The scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventTTCanCycleStart.ttCanCluster";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TTCAN-CLUSTER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventCom::TDEventTTCanCycleStart -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-TT-CAN-CYCLE-START">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the timing event related to a point in time where a communication cycle starts on a TTCAN cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventTTCanCycleStart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-COM"/>
         <xsd:group ref="AR:TD-EVENT-CYCLE-START"/>
         <xsd:group ref="AR:TD-EVENT-TT-CAN-CYCLE-START"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TDEventVfb::TDEventVariableDataPrototype -->
   <xsd:group name="TD-EVENT-VARIABLE-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to sender-receiver communication at VFB level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVariableDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced VariableDataPrototype</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVariableDataPrototype.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TD-EVENT-VARIABLE-DATA-PROTOTYPE-TYPE" type="AR:TD-EVENT-VARIABLE-DATA-PROTOTYPE-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The specific type of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVariableDataPrototype.tdEventVariableDataPrototypeType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TDEventVfb::TDEventVariableDataPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="TD-EVENT-VARIABLE-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>This is used to describe timing events related to sender-receiver communication at VFB level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVariableDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT"/>
         <xsd:group ref="AR:TD-EVENT-VFB"/>
         <xsd:group ref="AR:TD-EVENT-VARIABLE-DATA-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="TD-EVENT-VARIABLE-DATA-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TDEventVfb::TDEventVfb -->
   <xsd:group name="TD-EVENT-VFB">
      <xsd:annotation>
         <xsd:documentation>This is the abstract parent class to describe timing events at VFB level.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVfb"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREF" type="AR:COMPONENT-IN-COMPOSITION-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>The context for the scope of this timing event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.TDEventVfb";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-EXTERNAL" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This attribute is used to refer to external events that are related to hardware I/O (e.g. physical sensors / actuators) already at VFB level.

            If set to TRUE this timing event refers to the point in time, where the  associated data is generated/processed by hardware I/O. 

            Furthermore, in this case the associated variable data prototype respectively operation must belong to a component of type SensorActuatorSwComponentType or ComplexDeviceDriverSwComponentType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVfb.isExternal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-REF">
            <xsd:annotation>
               <xsd:documentation>The port scope of the timing event</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVfb.port";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class OasisExchangeTable::Table -->
   <xsd:group name="TABLE">
      <xsd:annotation>
         <xsd:documentation>This class implements an exchange table according to OASIS Technical Resolution TR 9503:1995.

      http://www.oasis-open.org/specs/a503.htm</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Table"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TABLE-CAPTION" type="AR:CAPTION">
            <xsd:annotation>
               <xsd:documentation>This element specifies the table heading.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Table.tableCaption";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="TGROUP" type="AR:TGROUP">
            <xsd:annotation>
               <xsd:documentation>A table can be built of individual segments. Such a segment is called tgroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Table.tgroup";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class OasisExchangeTable::Table -->
   <xsd:attributeGroup name="TABLE">
      <xsd:annotation>
         <xsd:documentation>This class implements an exchange table according to OASIS Technical Resolution TR 9503:1995.

      http://www.oasis-open.org/specs/a503.htm</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Table"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="COLSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if by default a line should be drawn between the columns of this table.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Table.colsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="FLOAT" type="AR:FLOAT-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicate whether it is allowed to break the element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Table.float";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="FRAME" type="AR:FRAME-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Used to defined the frame line around a table.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Table.frame";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HELP-ENTRY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies an entry point in an online help system to be linked with the parent class. The syntax must be defined by the applied help system respectively help system generator.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Table.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ORIENT" type="AR:ORIENT-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicate whether a table should be represented as landscape or portrait. 
         - land : landscape
         - port : portrait</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Table.orient";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="PGWIDE" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Used to indicate wether the figure should take the complete page width (value = "pgwide") or not (value = "noPgwide").</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Table.pgwide";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ROWSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if by default  a line should be drawn at the bottom of table rows.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Table.rowsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="TABSTYLE" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates an external table style.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Table.tabstyle";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class OasisExchangeTable::Table -->
   <xsd:complexType abstract="false" mixed="false" name="TABLE">
      <xsd:annotation>
         <xsd:documentation>This class implements an exchange table according to OASIS Technical Resolution TR 9503:1995.

      http://www.oasis-open.org/specs/a503.htm</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Table"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:TABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:TABLE"/>
   </xsd:complexType>
   <!-- element group for class Fibex4Multiplatform::TargetIPduRef -->
   <xsd:group name="TARGET-I-PDU-REF">
      <xsd:annotation>
         <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TargetIPduRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="AR:PDU-MAPPING-DEFAULT-VALUE">
            <xsd:annotation>
               <xsd:documentation>If no I-Pdu has been received a default value will be distributed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="defaultValue.TargetIPduRef";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>IPdu Reference</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TargetIPduRef.targetIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PDU-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::TargetIPduRef -->
   <xsd:complexType abstract="false" mixed="false" name="TARGET-I-PDU-REF">
      <xsd:annotation>
         <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TargetIPduRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TARGET-I-PDU-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class OasisExchangeTable::Tbody -->
   <xsd:group name="TBODY">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a part within a table group. Such a part can be the table head, the table body or the table foot.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tbody"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="ROW" type="AR:ROW">
            <xsd:annotation>
               <xsd:documentation>This is a particular row in a table.
            The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="Tbody.row";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class OasisExchangeTable::Tbody -->
   <xsd:attributeGroup name="TBODY">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a part within a table group. Such a part can be the table head, the table body or the table foot.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tbody"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="VALIGN" type="AR:VALIGN-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates how the cells in the rows shall be aligned. Default is inherited from tbody, otherwise it is "TOP"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Tbody.valign";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class OasisExchangeTable::Tbody -->
   <xsd:complexType abstract="false" mixed="false" name="TBODY">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a part within a table group. Such a part can be the table head, the table body or the table foot.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tbody"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TBODY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:TBODY"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::TextTableMapping -->
   <xsd:group name="TEXT-TABLE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two DataPrototypes typed by AutosarDataTypes that refer to CompuMethods of category TEXTTABLE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TextTableMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="IDENTICAL-MAPPING" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>If identicalMapping is set == true the values of the two referenced DataPrototypes do not need any conversion of the values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TextTableMapping.identicalMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPING-DIRECTION" type="AR:MAPPING-DIRECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies the conversion direction for which the TextTableMapping is applicable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TextTableMapping.mappingDirection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-PAIRS">
            <xsd:annotation>
               <xsd:documentation>Defines a pair of values which are translated into each other.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="valuePair.TextTableMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TEXT-TABLE-VALUE-PAIR" type="AR:TEXT-TABLE-VALUE-PAIR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::TextTableMapping -->
   <xsd:complexType abstract="false" mixed="false" name="TEXT-TABLE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two DataPrototypes typed by AutosarDataTypes that refer to CompuMethods of category TEXTTABLE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TextTableMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TEXT-TABLE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::TextTableValuePair -->
   <xsd:group name="TEXT-TABLE-VALUE-PAIR">
      <xsd:annotation>
         <xsd:documentation>Defines a pair of text values which are translated into each other.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TextTableValuePair"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIRST-VALUE" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Value of first DataPrototype provided similar to a numerical ValueSpecification which is intended to be assigned to a Primitive data element.
            Note that the numerical value is a variant, it can be computed by a formula.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="TextTableValuePair.firstValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECOND-VALUE" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>Value of second DataPrototype provided similar to a numerical  ValueSpecification which is intended to be assigned to a Primitive data element.
            Note that the numerical value is a variant, it can be computed by a formula.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="TextTableValuePair.secondValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::TextTableValuePair -->
   <xsd:complexType abstract="false" mixed="false" name="TEXT-TABLE-VALUE-PAIR">
      <xsd:annotation>
         <xsd:documentation>Defines a pair of text values which are translated into each other.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TextTableValuePair"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TEXT-TABLE-VALUE-PAIR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::TextValueSpecification -->
   <xsd:group name="TEXT-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>A text (string)  ValueSpecification which is intended to be assigned to a Primitive data element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TextValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:VERBATIM-STRING">
            <xsd:annotation>
               <xsd:documentation>This is the value itself.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TextValueSpecification.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::TextValueSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="TEXT-VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>A text (string)  ValueSpecification which is intended to be assigned to a Primitive data element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TextValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-SPECIFICATION"/>
         <xsd:group ref="AR:TEXT-VALUE-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class OasisExchangeTable::Tgroup -->
   <xsd:group name="TGROUP">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a table section.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COLSPEC" type="AR:COLSPEC">
            <xsd:annotation>
               <xsd:documentation>This specifies one particular column specification in the table. There must be one entry for each column.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup.colspec";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="THEAD" type="AR:TBODY">
            <xsd:annotation>
               <xsd:documentation>This represents the heading of the table section. The heading is usually repeated at the beginning of each new page.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup.thead";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TFOOT" type="AR:TBODY">
            <xsd:annotation>
               <xsd:documentation>This represents the footer of the table segement. This segment is printed at the end of the table or before a page break.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup.tfoot";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TBODY" type="AR:TBODY">
            <xsd:annotation>
               <xsd:documentation>This is the main part of the table segment, called the table body.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup.tbody";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class OasisExchangeTable::Tgroup -->
   <xsd:attributeGroup name="TGROUP">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a table section.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ALIGN" type="AR:ALIGN-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Specifies how the cell entries shall be horizontally aligned within the specified TGROUP.
         Default is "LEFT"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup.align";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COLS" type="AR:INTEGER--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute represents the number of columns in the table.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup.cols";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="COLSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if by default a line shall be drawn between the columns of this table group.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup.colsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ROWSEP" type="AR:TABLE-SEPARATOR-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if by default a line shall be drawn at the bottom of the rows in this table group.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup.rowsep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class OasisExchangeTable::Tgroup -->
   <xsd:complexType abstract="false" mixed="false" name="TGROUP">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a table section.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tgroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TGROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:TGROUP"/>
   </xsd:complexType>
   <!-- element group for class Timing::TimeRangeType -->
   <xsd:group name="TIME-RANGE-TYPE">
      <xsd:annotation>
         <xsd:documentation>The timeRange can be specified with the value attribute. Optionally a tolerance can be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimeRangeType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOLERANCE">
            <xsd:annotation>
               <xsd:documentation>Optional specification of a tolerance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tolerance.TimeRangeType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="ABSOLUTE-TOLERANCE" type="AR:ABSOLUTE-TOLERANCE"/>
                  <xsd:element name="RELATIVE-TOLERANCE" type="AR:RELATIVE-TOLERANCE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Average value of a date (in seconds)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimeRangeType.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::TimeRangeType -->
   <xsd:complexType abstract="false" mixed="false" name="TIME-RANGE-TYPE">
      <xsd:annotation>
         <xsd:documentation>The timeRange can be specified with the value attribute. Optionally a tolerance can be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimeRangeType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TIME-RANGE-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::TimeRangeTypeTolerance -->
   <xsd:group name="TIME-RANGE-TYPE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimeRangeTypeTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- element group for class TimingConstraint::TimingConstraint -->
   <xsd:group name="TIMING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>The abstract parent class of different timing constraints supported by the Timing extension.

      A concrete timing constraint is used to bound the timing behavior of the model elements in its scope.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingConstraint";xml.sequenceOffset="20"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class TimingDescription::TimingDescription -->
   <xsd:group name="TIMING-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>The abstract parent class of the model elements that are used to define the scope of a timing constraint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingDescription";xml.sequenceOffset="10"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class TimingDescription::TimingDescriptionEvent -->
   <xsd:group name="TIMING-DESCRIPTION-EVENT">
      <xsd:annotation>
         <xsd:documentation>A timing event is the abstract representation of a specific system behavior -- that can be observed at runtime -- in the AUTOSAR specification. Timing events are used to define the scope for timing constraints. Depending on the specific scope, the view on the system, and the level of abstraction different types of events are defined.

      In order to avoid confusion with existing event descriptions in the AUTOSAR templates the timing specific event types use the prefix TD.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingDescriptionEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OCCURRENCE-EXPRESSION" type="AR:TD-EVENT-OCCURRENCE-EXPRESSION">
            <xsd:annotation>
               <xsd:documentation>The occurrence expression for this event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="occurrenceExpression.TimingDescriptionEvent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="TIMING-DESCRIPTION-EVENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="TD-EVENT-BSW"/>
         <xsd:enumeration value="TD-EVENT-BSW-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="TD-EVENT-BSW-MODE-DECLARATION"/>
         <xsd:enumeration value="TD-EVENT-BSW-MODULE"/>
         <xsd:enumeration value="TD-EVENT-COM"/>
         <xsd:enumeration value="TD-EVENT-COMPLEX"/>
         <xsd:enumeration value="TD-EVENT-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-FR-CLUSTER-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-FRAME"/>
         <xsd:enumeration value="TD-EVENT-I-PDU"/>
         <xsd:enumeration value="TD-EVENT-I-SIGNAL"/>
         <xsd:enumeration value="TD-EVENT-MODE-DECLARATION"/>
         <xsd:enumeration value="TD-EVENT-OPERATION"/>
         <xsd:enumeration value="TD-EVENT-SWC-INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="TD-EVENT-TT-CAN-CYCLE-START"/>
         <xsd:enumeration value="TD-EVENT-VARIABLE-DATA-PROTOTYPE"/>
         <xsd:enumeration value="TD-EVENT-VFB"/>
         <xsd:enumeration value="TIMING-DESCRIPTION-EVENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TimingDescription::TimingDescriptionEventChain -->
   <xsd:group name="TIMING-DESCRIPTION-EVENT-CHAIN">
      <xsd:annotation>
         <xsd:documentation>An event chain describes the causal order for a set of functionally dependent timing events. Each event chain has a well defined stimulus and response, which describe its start and end point. Furthermore, it can be hierarchically decomposed into an arbitrary number of sub-chains, so called ''event chain segments''.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingDescriptionEventChain"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="STIMULUS-REF">
            <xsd:annotation>
               <xsd:documentation>The stimulus event representing the point in time where the event chain is activated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimingDescriptionEventChain.stimulus";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESPONSE-REF">
            <xsd:annotation>
               <xsd:documentation>The response event representing the point in time where the event chain is terminated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimingDescriptionEventChain.response";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>A composed event chain consists of an arbitrary number of sub-chains.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimingDescriptionEventChain.segment";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SEGMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:TIMING-DESCRIPTION-EVENT-CHAIN--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TimingDescription::TimingDescriptionEventChain -->
   <xsd:complexType abstract="false" mixed="false" name="TIMING-DESCRIPTION-EVENT-CHAIN">
      <xsd:annotation>
         <xsd:documentation>An event chain describes the causal order for a set of functionally dependent timing events. Each event chain has a well defined stimulus and response, which describe its start and end point. Furthermore, it can be hierarchically decomposed into an arbitrary number of sub-chains, so called ''event chain segments''.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingDescriptionEventChain"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION"/>
         <xsd:group ref="AR:TIMING-DESCRIPTION-EVENT-CHAIN"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="TIMING-DESCRIPTION-EVENT-CHAIN--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="TIMING-DESCRIPTION-EVENT-CHAIN"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RTEEvents::TimingEvent -->
   <xsd:group name="TIMING-EVENT">
      <xsd:annotation>
         <xsd:documentation>TimingEvent references the RunnableEntity that need to be started in response to the TimingEvent</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PERIOD" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Period of timing event in seconds. The value of this attribute must be greater than zero.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimingEvent.period";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::TimingEvent -->
   <xsd:complexType abstract="false" mixed="false" name="TIMING-EVENT">
      <xsd:annotation>
         <xsd:documentation>TimingEvent references the RunnableEntity that need to be started in response to the TimingEvent</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:TIMING-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Timing::TimingExtension -->
   <xsd:group name="TIMING-EXTENSION">
      <xsd:annotation>
         <xsd:documentation>The abstract parent class of the different template specific timing extensions.

      Depending on the specific timing extension (VfbTiming, SwcTiming, SystemTiming, BswModuleTiming, EcuTiming) the timing descriptions and timing constraints, that can be used to specify the timing behavior, are restricted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingExtension"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMING-DESCRIPTIONS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="timingDescription.TimingExtension";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TD-EVENT-BSW-INTERNAL-BEHAVIOR" type="AR:TD-EVENT-BSW-INTERNAL-BEHAVIOR"/>
                  <xsd:element name="TD-EVENT-BSW-MODE-DECLARATION" type="AR:TD-EVENT-BSW-MODE-DECLARATION"/>
                  <xsd:element name="TD-EVENT-BSW-MODULE" type="AR:TD-EVENT-BSW-MODULE"/>
                  <xsd:element name="TD-EVENT-COMPLEX" type="AR:TD-EVENT-COMPLEX"/>
                  <xsd:element name="TD-EVENT-FR-CLUSTER-CYCLE-START" type="AR:TD-EVENT-FR-CLUSTER-CYCLE-START"/>
                  <xsd:element name="TD-EVENT-FRAME" type="AR:TD-EVENT-FRAME"/>
                  <xsd:element name="TD-EVENT-I-PDU" type="AR:TD-EVENT-I-PDU"/>
                  <xsd:element name="TD-EVENT-I-SIGNAL" type="AR:TD-EVENT-I-SIGNAL"/>
                  <xsd:element name="TD-EVENT-MODE-DECLARATION" type="AR:TD-EVENT-MODE-DECLARATION"/>
                  <xsd:element name="TD-EVENT-OPERATION" type="AR:TD-EVENT-OPERATION"/>
                  <xsd:element name="TD-EVENT-SWC-INTERNAL-BEHAVIOR" type="AR:TD-EVENT-SWC-INTERNAL-BEHAVIOR"/>
                  <xsd:element name="TD-EVENT-TT-CAN-CYCLE-START" type="AR:TD-EVENT-TT-CAN-CYCLE-START"/>
                  <xsd:element name="TD-EVENT-VARIABLE-DATA-PROTOTYPE" type="AR:TD-EVENT-VARIABLE-DATA-PROTOTYPE"/>
                  <xsd:element name="TIMING-DESCRIPTION-EVENT-CHAIN" type="AR:TIMING-DESCRIPTION-EVENT-CHAIN"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMING-GUARANTEES">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="timingGuarantee.TimingExtension";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AGE-CONSTRAINT" type="AR:AGE-CONSTRAINT"/>
                  <xsd:element name="ARBITRARY-EVENT-TRIGGERING" type="AR:ARBITRARY-EVENT-TRIGGERING"/>
                  <xsd:element name="BURST-PATTERN-EVENT-TRIGGERING" type="AR:BURST-PATTERN-EVENT-TRIGGERING"/>
                  <xsd:element name="CONCRETE-PATTERN-EVENT-TRIGGERING" type="AR:CONCRETE-PATTERN-EVENT-TRIGGERING"/>
                  <xsd:element name="EXECUTION-ORDER-CONSTRAINT" type="AR:EXECUTION-ORDER-CONSTRAINT"/>
                  <xsd:element name="EXECUTION-TIME-CONSTRAINT" type="AR:EXECUTION-TIME-CONSTRAINT"/>
                  <xsd:element name="LATENCY-TIMING-CONSTRAINT" type="AR:LATENCY-TIMING-CONSTRAINT"/>
                  <xsd:element name="OFFSET-TIMING-CONSTRAINT" type="AR:OFFSET-TIMING-CONSTRAINT"/>
                  <xsd:element name="PERIODIC-EVENT-TRIGGERING" type="AR:PERIODIC-EVENT-TRIGGERING"/>
                  <xsd:element name="SPORADIC-EVENT-TRIGGERING" type="AR:SPORADIC-EVENT-TRIGGERING"/>
                  <xsd:element name="SYNCHRONIZATION-TIMING-CONSTRAINT" type="AR:SYNCHRONIZATION-TIMING-CONSTRAINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMING-REQUIREMENTS">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was -1.</xsd:documentation>
               <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="timingRequirement.TimingExtension";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AGE-CONSTRAINT" type="AR:AGE-CONSTRAINT"/>
                  <xsd:element name="ARBITRARY-EVENT-TRIGGERING" type="AR:ARBITRARY-EVENT-TRIGGERING"/>
                  <xsd:element name="BURST-PATTERN-EVENT-TRIGGERING" type="AR:BURST-PATTERN-EVENT-TRIGGERING"/>
                  <xsd:element name="CONCRETE-PATTERN-EVENT-TRIGGERING" type="AR:CONCRETE-PATTERN-EVENT-TRIGGERING"/>
                  <xsd:element name="EXECUTION-ORDER-CONSTRAINT" type="AR:EXECUTION-ORDER-CONSTRAINT"/>
                  <xsd:element name="EXECUTION-TIME-CONSTRAINT" type="AR:EXECUTION-TIME-CONSTRAINT"/>
                  <xsd:element name="LATENCY-TIMING-CONSTRAINT" type="AR:LATENCY-TIMING-CONSTRAINT"/>
                  <xsd:element name="OFFSET-TIMING-CONSTRAINT" type="AR:OFFSET-TIMING-CONSTRAINT"/>
                  <xsd:element name="PERIODIC-EVENT-TRIGGERING" type="AR:PERIODIC-EVENT-TRIGGERING"/>
                  <xsd:element name="SPORADIC-EVENT-TRIGGERING" type="AR:SPORADIC-EVENT-TRIGGERING"/>
                  <xsd:element name="SYNCHRONIZATION-TIMING-CONSTRAINT" type="AR:SYNCHRONIZATION-TIMING-CONSTRAINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Chapters::Topic1 -->
   <xsd:group name="TOPIC-1">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a topic of a documentation. Topics are similar to chapters but they cannot be nested. 

      They also do not appear in the table of content. Topics can be used to produce intermediate headlines thus structuring a chapter internally.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Topic1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:TOPIC-CONTENT-OR-MSR-QUERY"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Chapters::Topic1 -->
   <xsd:attributeGroup name="TOPIC-1">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a topic of a documentation. Topics are similar to chapters but they cannot be nested. 

      They also do not appear in the table of content. Topics can be used to produce intermediate headlines thus structuring a chapter internally.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Topic1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="HELP-ENTRY" type="AR:STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This specifies an entry point in an online help system to be linked with the parent class. The syntax must be defined by the applied help system respectively help system generator.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Topic1.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Chapters::Topic1 -->
   <xsd:complexType abstract="false" mixed="false" name="TOPIC-1">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a topic of a documentation. Topics are similar to chapters but they cannot be nested. 

      They also do not appear in the table of content. Topics can be used to produce intermediate headlines thus structuring a chapter internally.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Topic1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:TOPIC-1"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
      <xsd:attributeGroup ref="AR:TOPIC-1"/>
   </xsd:complexType>
   <!-- element group for class Chapters::TopicContent -->
   <xsd:group name="TOPIC-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the content of a topic. It is mainly a documentation block, but can also be a table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TopicContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
               <xsd:group ref="AR:DOCUMENTATION-BLOCK"/>
            </xsd:choice>
            <xsd:element name="TABLE" type="AR:TABLE">
               <xsd:annotation>
                  <xsd:documentation>Ths represents a table within a topic.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="TopicContent.table";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class Chapters::TopicContent -->
   <xsd:complexType abstract="false" mixed="false" name="TOPIC-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the content of a topic. It is mainly a documentation block, but can also be a table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TopicContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TOPIC-CONTENT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Chapters::TopicContentOrMsrQuery -->
   <xsd:group name="TOPIC-CONTENT-OR-MSR-QUERY">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a topic or a topic content which is generated using queries.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TopicContentOrMsrQuery"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="MSR-QUERY-P-1" type="AR:MSR-QUERY-P-1">
               <xsd:annotation>
                  <xsd:documentation>This represents automatically contributed contents provided by an msrquery.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="TopicContentOrMsrQuery.msrQueryP1";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
               <xsd:group ref="AR:TOPIC-CONTENT"/>
            </xsd:choice>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class Chapters::TopicContentOrMsrQuery -->
   <xsd:complexType abstract="false" mixed="false" name="TOPIC-CONTENT-OR-MSR-QUERY">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents a topic or a topic content which is generated using queries.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TopicContentOrMsrQuery"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TOPIC-CONTENT-OR-MSR-QUERY"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Chapters::TopicOrMsrQuery -->
   <xsd:group name="TOPIC-OR-MSR-QUERY">
      <xsd:annotation>
         <xsd:documentation>This class provides the alternative of a Topic with an MsrQuery which delivers a topic.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TopicOrMsrQuery"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="TOPIC-1" type="AR:TOPIC-1">
               <xsd:annotation>
                  <xsd:documentation>This is used to create particcular topics within a chapter. A topic is similar to a subchapter, but cannot be nesxted and will not appear in the table of contents of the document.
               The upper multiplicity of this role has been increased to * due to resolving an atpVariation stereotype. The previous value was 1.</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PostBuild";mmt.qualifiedName="TopicOrMsrQuery.topic1";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="180"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="MSR-QUERY-TOPIC-1" type="AR:MSR-QUERY-TOPIC-1">
               <xsd:annotation>
                  <xsd:documentation>This represents automatically contributed topics provided by an msrquery.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="TopicOrMsrQuery.msrQueryTopic1";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="190"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class Chapters::TopicOrMsrQuery -->
   <xsd:complexType abstract="false" mixed="false" name="TOPIC-OR-MSR-QUERY">
      <xsd:annotation>
         <xsd:documentation>This class provides the alternative of a Topic with an MsrQuery which delivers a topic.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TopicOrMsrQuery"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TOPIC-OR-MSR-QUERY"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::TpAddress -->
   <xsd:group name="TP-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TpAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TpAddress.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::TpAddress -->
   <xsd:complexType abstract="false" mixed="false" name="TP-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TpAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TP-ADDRESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="TP-ADDRESS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="TP-ADDRESS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::TpConfig -->
   <xsd:group name="TP-CONFIG">
      <xsd:annotation>
         <xsd:documentation>Contains all configuration elements for AUTOSAR TP.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TpConfig"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CLUSTER-REF">
            <xsd:annotation>
               <xsd:documentation>A TpConfig is existing always in the context of exactly one CommunicationCluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TpConfig.communicationCluster";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CLUSTER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class RequirementsTracing::TraceReferrable -->
   <xsd:group name="TRACE-REFERRABLE">
      <xsd:annotation>
         <xsd:documentation>This meta class is intended to add the category to the subclasses of Traceable. 

      Even if the model seems to be a bit awkward, it ensures backwards compatibility of the schema.

      This approach allows to have sublclasses of Traceable which are either Identifiable or only Referrable while still maintaining the consistent sequence of shortName, longName, category.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TraceReferrable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:CATEGORY-STRING">
            <xsd:annotation>
               <xsd:documentation>This specifies the category of the trace such as "REQUIREMENT_ITEM", "SPECIFICATION_ITEM" ...</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TraceReferrable.category";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class RequirementsTracing::Traceable -->
   <xsd:group name="TRACEABLE">
      <xsd:annotation>
         <xsd:documentation>This meta class represents the ability to be subject to tracing within an AUTOSAR model.

      Note that it is expected that its subclasses inherit either from MultilanguageReferrable or from Identifiable. Nevertheless it also inherits from MultilanguageReferrable in order to provide a common reference target for all Traceables.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Traceable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRACE-REFS">
            <xsd:annotation>
               <xsd:documentation>This assocation represents the ability to trace to upstream requirements / constraints. This supports for example  the bottom up tracing 

            ProjectObjectives &lt;- MainRequirements &lt;- Features &lt;- RequirementSpecs &lt;- BSW/AI</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Traceable.trace";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRACE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:TRACEABLE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="TRACEABLE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AGE-CONSTRAINT"/>
         <xsd:enumeration value="ARBITRARY-EVENT-TRIGGERING"/>
         <xsd:enumeration value="BURST-PATTERN-EVENT-TRIGGERING"/>
         <xsd:enumeration value="CONCRETE-PATTERN-EVENT-TRIGGERING"/>
         <xsd:enumeration value="EVENT-TRIGGERING-CONSTRAINT"/>
         <xsd:enumeration value="EXECUTION-ORDER-CONSTRAINT"/>
         <xsd:enumeration value="EXECUTION-TIME-CONSTRAINT"/>
         <xsd:enumeration value="LATENCY-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="OFFSET-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="PERIODIC-EVENT-TRIGGERING"/>
         <xsd:enumeration value="SPORADIC-EVENT-TRIGGERING"/>
         <xsd:enumeration value="STRUCTURED-REQ"/>
         <xsd:enumeration value="SYNCHRONIZATION-TIMING-CONSTRAINT"/>
         <xsd:enumeration value="TIMING-CONSTRAINT"/>
         <xsd:enumeration value="TRACEABLE"/>
         <xsd:enumeration value="TRACEABLE-TEXT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RequirementsTracing::TraceableText -->
   <xsd:group name="TRACEABLE-TEXT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a traceable text item such as requirements etc.

      The following approach appliles:

      * '''shortName''' represents the tag for tracing
      * '''longName''' represents the head line
      * '''category''' represents the kind of the tagged text</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TraceableText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:DOCUMENTATION-BLOCK"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RequirementsTracing::TraceableText -->
   <xsd:complexType abstract="false" mixed="false" name="TRACEABLE-TEXT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to denote a traceable text item such as requirements etc.

      The following approach appliles:

      * '''shortName''' represents the tag for tracing
      * '''longName''' represents the head line
      * '''category''' represents the kind of the tagged text</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TraceableText"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
         <xsd:group ref="AR:PAGINATEABLE"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:TRACE-REFERRABLE"/>
         <xsd:group ref="AR:TRACEABLE"/>
         <xsd:group ref="AR:TRACEABLE-TEXT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:DOCUMENT-VIEW-SELECTABLE"/>
      <xsd:attributeGroup ref="AR:PAGINATEABLE"/>
   </xsd:complexType>
   <!-- element group for class Communication::TransmissionAcknowledgementRequest -->
   <xsd:group name="TRANSMISSION-ACKNOWLEDGEMENT-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests transmission acknowledgement that data has been sent successfully. Success/failure is reported via a SendPoint of a RunnableEntity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionAcknowledgementRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Number of seconds before an error is reported or in case of allowed redundancy, the value is sent again.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionAcknowledgementRequest.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::TransmissionAcknowledgementRequest -->
   <xsd:complexType abstract="false" mixed="false" name="TRANSMISSION-ACKNOWLEDGEMENT-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests transmission acknowledgement that data has been sent successfully. Success/failure is reported via a SendPoint of a RunnableEntity.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionAcknowledgementRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TRANSMISSION-ACKNOWLEDGEMENT-REQUEST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::TransmissionModeCondition -->
   <xsd:group name="TRANSMISSION-MODE-CONDITION">
      <xsd:annotation>
         <xsd:documentation>Possibility to attach a condition to each signal within an I-PDU.

      If at least one condition evaluates to true, TRANSMISSION MODE True shall be used for this I-Pdu. In all other cases, the TRANSMISSION MODE FALSE shall be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeCondition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-FILTER" type="AR:DATA-FILTER">
            <xsd:annotation>
               <xsd:documentation>Possibilities to define conditions</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataFilter.TransmissionModeCondition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-IN-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a signal to which a condition is attached.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeCondition.iSignalInIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-TO-I-PDU-MAPPING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::TransmissionModeCondition -->
   <xsd:complexType abstract="false" mixed="false" name="TRANSMISSION-MODE-CONDITION">
      <xsd:annotation>
         <xsd:documentation>Possibility to attach a condition to each signal within an I-PDU.

      If at least one condition evaluates to true, TRANSMISSION MODE True shall be used for this I-Pdu. In all other cases, the TRANSMISSION MODE FALSE shall be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeCondition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TRANSMISSION-MODE-CONDITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::TransmissionModeDeclaration -->
   <xsd:group name="TRANSMISSION-MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR COM provides the possibility to define two different TRANSMISSION MODES (True and False) for each I-PDU.

      As TransmissionMode selector the signal content can be evaluated via transmissionModeCondition (implemented directly in the COM module) or mode conditions can be defined with the modeDrivenTrueCondition or modeDrivenFalseCondition (evaluated by BswM and invoking Com_SwitchIpduTxMode COM API). If modeDrivenTrueCondition and modeDrivenFalseCondition are defined they shall never evaluate to true both at the same time. 

      The mixing of Transmission Mode Switch via API and signal value is not allowed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DRIVEN-FALSE-CONDITIONS">
            <xsd:annotation>
               <xsd:documentation>Defines the trigger for the Com_SwitchIpduTxMode Transmission Mode switch. Only if all defined modeDrivenFalseConditions evaluate to true (AND associated) the transmissionModeFalseTiming shall be activated.  modeDrivenTrueCondition and modeDrivenFalseCondition shall never evaluate to true both at the same time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeDrivenFalseCondition.TransmissionModeDeclaration";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DRIVEN-TRANSMISSION-MODE-CONDITION" type="AR:MODE-DRIVEN-TRANSMISSION-MODE-CONDITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DRIVEN-TRUE-CONDITIONS">
            <xsd:annotation>
               <xsd:documentation>Defines the trigger for the Com_SwitchIpduTxMode Transmission Mode switch. Only if all defined modeDrivenTrueConditions evaluate to true (AND associated) the transmissionModeTrueTiming shall be activated.  modeDrivenTrueCondition and modeDrivenFalseCondition shall never evaluate to true both at the same time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeDrivenTrueCondition.TransmissionModeDeclaration";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DRIVEN-TRANSMISSION-MODE-CONDITION" type="AR:MODE-DRIVEN-TRANSMISSION-MODE-CONDITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-MODE-CONDITIONS">
            <xsd:annotation>
               <xsd:documentation>The Transmission Mode Selector evaluates the conditions for a subset of signals and decides which transmission mode should be used. In case only one transmission mode is used there is no need for the "TransmissionModeCondition" and its sub-structure. In case the transmission mode shall be switched using the COM-API "Com_SwitchIpduTxMode" there is no need for the"TransmissionModeCondition" and its sub-structure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionModeCondition.TransmissionModeDeclaration";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRANSMISSION-MODE-CONDITION" type="AR:TRANSMISSION-MODE-CONDITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-MODE-FALSE-TIMING" type="AR:TRANSMISSION-MODE-TIMING">
            <xsd:annotation>
               <xsd:documentation>Timing Specification if the COM Transmission Mode is false.  
            The Transmission Mode Selector is defined to be false, if all Conditions evaluate to false.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionModeFalseTiming.TransmissionModeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-MODE-TRUE-TIMING" type="AR:TRANSMISSION-MODE-TIMING">
            <xsd:annotation>
               <xsd:documentation>Timing Specification if the COM Transmission Mode is true.  
            The Transmission Mode Selector is defined to be true, if at least one Condition evaluates to true.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionModeTrueTiming.TransmissionModeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::TransmissionModeDeclaration -->
   <xsd:complexType abstract="false" mixed="false" name="TRANSMISSION-MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR COM provides the possibility to define two different TRANSMISSION MODES (True and False) for each I-PDU.

      As TransmissionMode selector the signal content can be evaluated via transmissionModeCondition (implemented directly in the COM module) or mode conditions can be defined with the modeDrivenTrueCondition or modeDrivenFalseCondition (evaluated by BswM and invoking Com_SwitchIpduTxMode COM API). If modeDrivenTrueCondition and modeDrivenFalseCondition are defined they shall never evaluate to true both at the same time. 

      The mixing of Transmission Mode Switch via API and signal value is not allowed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TRANSMISSION-MODE-DECLARATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::TransmissionModeTiming -->
   <xsd:group name="TRANSMISSION-MODE-TIMING">
      <xsd:annotation>
         <xsd:documentation>If the COM Transmission Mode is false the timing is aggregated by the TransmissionModeTiming element in the role of transmissionModeFalseTiming. If the COM Transmission Mode is true the timing is aggregated by the TransmissionModeTiming element in the role of transmissionModeTrueTiming.  

      COM supports the following Transmission Modes: 
      Periodic (Cyclic Timing)
      Direct /n-times (EventControlledTiming)
      Mixed (Cyclic and EventControlledTiming are assigned)
      None (no timing is assigned)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLIC-TIMING" type="AR:CYCLIC-TIMING">
            <xsd:annotation>
               <xsd:documentation>Periodic Transmission Mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="cyclicTiming.TransmissionModeTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-CONTROLLED-TIMING" type="AR:EVENT-CONTROLLED-TIMING">
            <xsd:annotation>
               <xsd:documentation>Direct Transmission Mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="eventControlledTiming.TransmissionModeTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::TransmissionModeTiming -->
   <xsd:complexType abstract="false" mixed="false" name="TRANSMISSION-MODE-TIMING">
      <xsd:annotation>
         <xsd:documentation>If the COM Transmission Mode is false the timing is aggregated by the TransmissionModeTiming element in the role of transmissionModeFalseTiming. If the COM Transmission Mode is true the timing is aggregated by the TransmissionModeTiming element in the role of transmissionModeTrueTiming.  

      COM supports the following Transmission Modes: 
      Periodic (Cyclic Timing)
      Direct /n-times (EventControlledTiming)
      Mixed (Cyclic and EventControlledTiming are assigned)
      None (no timing is assigned)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TRANSMISSION-MODE-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TriggerDeclaration::Trigger -->
   <xsd:group name="TRIGGER">
      <xsd:annotation>
         <xsd:documentation>A trigger which is provided (i.e. released) or required (i.e. used to activate something) in the given context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Trigger"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IMPL-POLICY" type="AR:SW-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute, when set to value queued, allows for a queued processing of Triggers.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Trigger.swImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-PERIOD" type="AR:MULTIDIMENSIONAL-TIME">
            <xsd:annotation>
               <xsd:documentation>Optional definition of a period in case of a periodically (time or angle) driven external trigger.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Trigger.triggerPeriod";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TriggerDeclaration::Trigger -->
   <xsd:complexType abstract="false" mixed="false" name="TRIGGER">
      <xsd:annotation>
         <xsd:documentation>A trigger which is provided (i.e. released) or required (i.e. used to activate something) in the given context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Trigger"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-STRUCTURE-ELEMENT"/>
         <xsd:group ref="AR:TRIGGER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="TRIGGER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="TRIGGER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InstanceRefs::TriggerInAtomicSwcInstanceRef -->
   <xsd:group name="TRIGGER-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TriggerInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <!-- Association <<atpDerived>>contextPort skipped -->
         <!-- Association <<atpDerived>>target skipped -->
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class PortInterface::TriggerInterface -->
   <xsd:group name="TRIGGER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A trigger interface declares a number of triggers that can be sent by an trigger source.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="TriggerInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGERS">
            <xsd:annotation>
               <xsd:documentation>The Trigger of this trigger interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="trigger.TriggerInterface";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRIGGER" type="AR:TRIGGER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::TriggerInterface -->
   <xsd:complexType abstract="false" mixed="false" name="TRIGGER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A trigger interface declares a number of triggers that can be sent by an trigger source.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="PortInterfaces";mmt.qualifiedName="TriggerInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:ATP-BLUEPRINT"/>
         <xsd:group ref="AR:ATP-BLUEPRINTABLE"/>
         <xsd:group ref="AR:ATP-CLASSIFIER"/>
         <xsd:group ref="AR:ATP-TYPE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:TRIGGER-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::TriggerInterfaceMapping -->
   <xsd:group name="TRIGGER-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of unequal named Triggers in context of two different TriggerInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TriggerInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Mapping of two Trigger in two different TriggerInterface</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="triggerMapping.TriggerInterfaceMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRIGGER-MAPPING" type="AR:TRIGGER-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::TriggerInterfaceMapping -->
   <xsd:complexType abstract="false" mixed="false" name="TRIGGER-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of unequal named Triggers in context of two different TriggerInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TriggerInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-INTERFACE-MAPPING"/>
         <xsd:group ref="AR:TRIGGER-INTERFACE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TriggerDeclaration::TriggerMapping -->
   <xsd:group name="TRIGGER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two particular unequally named Triggers in the given context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIRST-TRIGGER-REF">
            <xsd:annotation>
               <xsd:documentation>A Trigger to be mapped.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMapping.firstTrigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECOND-TRIGGER-REF">
            <xsd:annotation>
               <xsd:documentation>A Trigger to be mapped.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMapping.secondTrigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TriggerDeclaration::TriggerMapping -->
   <xsd:complexType abstract="false" mixed="false" name="TRIGGER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of two particular unequally named Triggers in the given context.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TRIGGER-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::TriggerPortAnnotation -->
   <xsd:group name="TRIGGER-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port used for calibration regarding a certain Trigger.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TriggerPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-REF">
            <xsd:annotation>
               <xsd:documentation>The instance of annotated trigger.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TriggerPortAnnotation.trigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::TriggerPortAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="TRIGGER-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port used for calibration regarding a certain Trigger.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TriggerPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:TRIGGER-PORT-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TriggerDeclaration::TriggerRefConditional -->
   <xsd:group name="TRIGGER-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TRIGGER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TriggerDeclaration::TriggerRefConditional -->
   <xsd:complexType abstract="false" mixed="false" name="TRIGGER-REF-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TRIGGER-REF-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::Tt -->
   <xsd:group name="TT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express specific technical terms.  The kind of term is denoted in the attribute "type".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tt"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TERM" type="AR:STRING--SIMPLE">
            <xsd:annotation>
               <xsd:documentation>This is the term itself.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Tt.term";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="false";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class InlineTextElements::Tt -->
   <xsd:attributeGroup name="TT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express specific technical terms.  The kind of term is denoted in the attribute "type".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tt"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="TYPE" type="AR:NMTOKEN-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This attribute specifies the type of the technical term. Values are such as "VARIABLE" "CALPRM". It is no longer an enum in order to support process specific extensions.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Tt.type";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class InlineTextElements::Tt -->
   <xsd:complexType name="TT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express specific technical terms.  The kind of term is denoted in the attribute "type".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tt"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:TT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- element group for class TtcanCommunication::TtcanAbsolutelyScheduledTiming -->
   <xsd:group name="TTCAN-ABSOLUTELY-SCHEDULED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Each frame in TTCAN is identified by its slot id and communication cycle. A description is provided by the usage of AbsolutelyScheduledTiming. 

      A frame can be sent multiple times within one communication cycle. For describing this case multiple AbsolutelyScheduledTimings have to be used. The main use case would be that a frame is sent twice within one communication cycle.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanAbsolutelyScheduledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CYCLE">
            <xsd:annotation>
               <xsd:documentation>The communication cycle where the frame is sent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="communicationCycle.TtcanAbsolutelyScheduledTiming";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CYCLE-COUNTER" type="AR:CYCLE-COUNTER"/>
                  <xsd:element name="CYCLE-REPETITION" type="AR:CYCLE-REPETITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-MARK" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Where FlexRay counts the slots in the static segment, TTCAN requires explicit Tx and Rx time marks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanAbsolutelyScheduledTiming.timeMark";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER" type="AR:TTCAN-TRIGGER-TYPE">
            <xsd:annotation>
               <xsd:documentation>Trigger type for this time window.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanAbsolutelyScheduledTiming.trigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TtcanCommunication::TtcanAbsolutelyScheduledTiming -->
   <xsd:complexType abstract="false" mixed="false" name="TTCAN-ABSOLUTELY-SCHEDULED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Each frame in TTCAN is identified by its slot id and communication cycle. A description is provided by the usage of AbsolutelyScheduledTiming. 

      A frame can be sent multiple times within one communication cycle. For describing this case multiple AbsolutelyScheduledTimings have to be used. The main use case would be that a frame is sent twice within one communication cycle.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanAbsolutelyScheduledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:TTCAN-ABSOLUTELY-SCHEDULED-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TtcanTopology::TtcanCluster -->
   <xsd:group name="TTCAN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>TTCAN bus specific cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="TtcanCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TTCAN-CLUSTER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TTCAN-CLUSTER-CONDITIONAL" type="AR:TTCAN-CLUSTER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TtcanTopology::TtcanCluster -->
   <xsd:complexType abstract="false" mixed="false" name="TTCAN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>TTCAN bus specific cluster attributes.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="CommunicationClusters";mmt.qualifiedName="TtcanCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
         <xsd:group ref="AR:ABSTRACT-CAN-CLUSTER"/>
         <xsd:group ref="AR:TTCAN-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="TTCAN-CLUSTER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="TTCAN-CLUSTER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TtcanTopology::TtcanClusterConditional -->
   <xsd:group name="TTCAN-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TtcanTopology::TtcanClusterConditional -->
   <xsd:complexType abstract="false" mixed="false" name="TTCAN-CLUSTER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:ABSTRACT-CAN-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:TTCAN-CLUSTER-CONTENT"/>
         <xsd:group ref="AR:TTCAN-CLUSTER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TtcanTopology::TtcanClusterContent -->
   <xsd:group name="TTCAN-CLUSTER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASIC-CYCLE-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Length of a basic-cycle. Unit: NTUs</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCluster.basicCycleLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NTU" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Unit measuring all times and providing a constant of the whole network. For level 1, this is always the CAN bit time. Unit: seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCluster.ntu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-MODE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Possible operation modes

            True: Time-Triggered
            False: Event-Synchronised-Time-Triggered</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCluster.operationMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class TtcanTopology::TtcanCommunicationConnector -->
   <xsd:group name="TTCAN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>TTCAN bus specific communication connector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class TtcanTopology::TtcanCommunicationConnector -->
   <xsd:complexType abstract="false" mixed="false" name="TTCAN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>TTCAN bus specific communication connector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:ABSTRACT-CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:TTCAN-COMMUNICATION-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TtcanTopology::TtcanCommunicationController -->
   <xsd:group name="TTCAN-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>TTCAN bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TTCAN-COMMUNICATION-CONTROLLER-VARIANTS">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TTCAN-COMMUNICATION-CONTROLLER-CONDITIONAL" type="AR:TTCAN-COMMUNICATION-CONTROLLER-CONDITIONAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TtcanTopology::TtcanCommunicationController -->
   <xsd:complexType abstract="false" mixed="false" name="TTCAN-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>TTCAN bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:ABSTRACT-CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:TTCAN-COMMUNICATION-CONTROLLER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TtcanTopology::TtcanCommunicationControllerConditional -->
   <xsd:group name="TTCAN-COMMUNICATION-CONTROLLER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TtcanTopology::TtcanCommunicationControllerConditional -->
   <xsd:complexType abstract="false" mixed="false" name="TTCAN-COMMUNICATION-CONTROLLER-CONDITIONAL">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:ABSTRACT-CAN-COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:TTCAN-COMMUNICATION-CONTROLLER-CONTENT"/>
         <xsd:group ref="AR:TTCAN-COMMUNICATION-CONTROLLER-CONDITIONAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TtcanTopology::TtcanCommunicationControllerContent -->
   <xsd:group name="TTCAN-COMMUNICATION-CONTROLLER-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPL-WATCHDOG-LIMIT" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The Appl_Watchdog_Limit shall be an 8-bit value specifying the period for the application watchdog in Appl_Watchdog_Limit times 256 NTUs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController.applWatchdogLimit";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXPECTED-TX-TRIGGER" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The Expected_Tx_Trigger shall be an eight (8) bit value which limits the number of messages the FSE may try to transmit in one matrix cycle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController.expectedTxTrigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERNAL-CLOCK-SYNCHRONISATION" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>One bit shall be used to configure whether or not external clock synchronisation will be allowed during runtime (only Level 2).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController.externalClockSynchronisation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INITIAL-REF-OFFSET" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The Initial_Ref_Offset shall be an eight (8) bit value for the initialisation of Ref_Trigger_Offset.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController.initialRefOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASTER" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>One bit shall be used to distinguish between (potential) time masters and time slaves. This can be derived from the frame-triggering's triggers.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController.master";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-MASTER-PRIORITY" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The time master priority shall contain a three bit value for the priority of the current time master (the last three bits of the identifier of the reference message). This can be derived from the frame-triggering's triggers.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController.timeMasterPriority";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-TRIGGERED-CAN-LEVEL" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>One bit shall be used to distinguish between Level 1 and Level 2.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController.timeTriggeredCanLevel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TX-ENABLE-WINDOW-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>The length of the Tx_Enable window shall be a four (4) bit value specifying the length of the time period (1-16 nominal CAN bit times) in which a transmission may be started.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanCommunicationController.txEnableWindowLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class TtcanTopology::TtcanPhysicalChannel -->
   <xsd:group name="TTCAN-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>TTCAN bus specific physical channel attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class TtcanTopology::TtcanPhysicalChannel -->
   <xsd:complexType abstract="false" mixed="false" name="TTCAN-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>TTCAN bus specific physical channel attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PHYSICAL-CHANNEL"/>
         <xsd:group ref="AR:ABSTRACT-CAN-PHYSICAL-CHANNEL"/>
         <xsd:group ref="AR:TTCAN-PHYSICAL-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::UdpNmCluster -->
   <xsd:group name="UDP-NM-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>Udp specific NmCluster attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CBV-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Defines the position of the control bit vector within the NM PDU (Byte positon).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmCbvPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CHANNEL-ACTIVE" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>This switch determines if the respective UdpNm channel is active or not. Indicates whether a particular UdpNm channel shall be initialized (TRUE) or not (FALSE).
            If this parameter is set to FALSE the respective NM instance shall not be used during runtime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmChannelActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MESSAGE-TIMEOUT-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout of a NM message in seconds. It determines how long the NM shall wait with notification of transmission failure while communication errors occur on the bus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmMessageTimeoutTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MSG-CYCLE-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Period of a UdpNm message in seconds. It determines the periodic rate in the periodic transmission mode with bus load reduction and is the basis for transmit scheduling in the periodic transmission mode without bus load reduction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmMsgCycleTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NETWORK-TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Network Timeout for UdpNm PDUs in seconds.
            It denotes the time how long the CanNm shall stay in the Network Mode before transition into Prepare Bus-Sleep Mode shall take place.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmNetworkTimeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NID-POSITION" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Defines the byte position of the source node identifier within the NM PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmNidPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REMOTE-SLEEP-INDICATION-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout for Remote Sleep Indication in seconds. It defines the time how long it shall take to recognize that all other nodes are ready to sleep.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmRemoteSleepIndicationTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MESSAGE-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout for Repeat Message State in seconds. Defines the time how long the NM shall stay in the Repeat Message State.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmRepeatMessageTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-USER-DATA-LENGTH" type="AR:INTEGER">
            <xsd:annotation>
               <xsd:documentation>Defines the length of the user data contained in the NM Pdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmUserDataLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-WAIT-BUS-SLEEP-TIME" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Timeout for bus calm down phase in seconds. It denotes the time how long the CanNm shall stay in the Prepare Bus-Sleep Mode before transition into Bus-Sleep Mode shall take place.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster.nmWaitBusSleepTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::UdpNmCluster -->
   <xsd:complexType abstract="false" mixed="false" name="UDP-NM-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>Udp specific NmCluster attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NM-CLUSTER"/>
         <xsd:group ref="AR:UDP-NM-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="UDP-NM-CLUSTER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="UDP-NM-CLUSTER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class NetworkManagement::UdpNmClusterCoupling -->
   <xsd:group name="UDP-NM-CLUSTER-COUPLING">
      <xsd:annotation>
         <xsd:documentation>Udp attributes that are valid for each of the referenced (coupled) UdpNm clusters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmClusterCoupling"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUPLED-CLUSTER-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to coupled UdpNm Clusters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmClusterCoupling.coupledCluster";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COUPLED-CLUSTER-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:UDP-NM-CLUSTER--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-BUS-LOAD-REDUCTION-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables busload reduction support</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmClusterCoupling.nmBusLoadReductionEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IMMEDIATE-RESTART-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enables the asynchronous transmission of a CanNm PDU upon bus-communication request in Prepare-Bus-Sleep mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmClusterCoupling.nmImmediateRestartEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::UdpNmClusterCoupling -->
   <xsd:complexType abstract="false" mixed="false" name="UDP-NM-CLUSTER-COUPLING">
      <xsd:annotation>
         <xsd:documentation>Udp attributes that are valid for each of the referenced (coupled) UdpNm clusters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmClusterCoupling"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:NM-CLUSTER-COUPLING"/>
         <xsd:group ref="AR:UDP-NM-CLUSTER-COUPLING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::UdpNmEcu -->
   <xsd:group name="UDP-NM-ECU">
      <xsd:annotation>
         <xsd:documentation>Udp NM specific ECU attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MSG-INDICATION-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enable/disable the notification that a RepeatMessageRequest bit has been received.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmEcu.nmRepeatMsgIndicationEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-SYNCHRONIZATION-POINT-ENABLED" type="AR:BOOLEAN">
            <xsd:annotation>
               <xsd:documentation>Enable/disable the NM Coordination algorithm to being able to initiate the
            synchronization algorithm.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmEcu.nmSynchronizationPointEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::UdpNmEcu -->
   <xsd:complexType abstract="false" mixed="false" name="UDP-NM-ECU">
      <xsd:annotation>
         <xsd:documentation>Udp NM specific ECU attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:BUSSPECIFIC-NM-ECU"/>
         <xsd:group ref="AR:UDP-NM-ECU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class NetworkManagement::UdpNmNode -->
   <xsd:group name="UDP-NM-NODE">
      <xsd:annotation>
         <xsd:documentation>Udp specific NM Node attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MSG-CYCLE-OFFSET" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Node specific time offset in the periodic transmission node. It determines the start delay of the transmission. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmNode.nmMsgCycleOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class NetworkManagement::UdpNmNode -->
   <xsd:complexType abstract="false" mixed="false" name="UDP-NM-NODE">
      <xsd:annotation>
         <xsd:documentation>Udp specific NM Node attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UdpNmNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NM-NODE"/>
         <xsd:group ref="AR:UDP-NM-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::UnassignFrameId -->
   <xsd:group name="UNASSIGN-FRAME-ID">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an Unassign Frame Id master request where the protected identifier is assigned the value 0x40. This will disable reception/transmission of a previously dynamically assigned frame identifier.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnassignFrameId"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNASSIGNED-FRAME-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:documentation>The frame whose identifier is reset by this assignment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnassignFrameId.unassignedFrameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::UnassignFrameId -->
   <xsd:complexType abstract="false" mixed="false" name="UNASSIGN-FRAME-ID">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an Unassign Frame Id master request where the protected identifier is assigned the value 0x40. This will disable reception/transmission of a previously dynamically assigned frame identifier.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnassignFrameId"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:SCHEDULE-TABLE-ENTRY"/>
         <xsd:group ref="AR:LIN-CONFIGURATION-ENTRY"/>
         <xsd:group ref="AR:UNASSIGN-FRAME-ID"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Units::Unit -->
   <xsd:group name="UNIT">
      <xsd:annotation>
         <xsd:documentation>This is a physical measurement unit. All units that might be defined should stem from SI units. In order to convert one unit into another factor and offset are defined. For the calculation from SI-unit to the defined unit the factor (factorSiToUnit ) and the offset (offsetSiToUnit ) are applied:

      unit = siUnit * factorSiToUnit + offsetSiToUnit 

      For the calculation from a unit to SI-unit the reciprocal of the factor (factorSiToUnit ) and the negation of the offset (offsetSiToUnit ) are applied:

      siUnit = (unit - offsetSiToUnit) / factorSiToUnit</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Units";mmt.qualifiedName="Unit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISPLAY-NAME" type="AR:SINGLE-LANGUAGE-UNIT-NAMES">
            <xsd:annotation>
               <xsd:documentation>This specifies how the unit shall be displayed in documents or in user interfaces of tools.The displayName corresponds to the Unit.Display in an ASAM MCD-2MC file.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Unit.displayName";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FACTOR-SI-TO-UNIT" type="AR:FLOAT">
            <xsd:annotation>
               <xsd:documentation>This is the factor for the conversion from and to siUnits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Unit.factorSiToUnit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET-SI-TO-UNIT" type="AR:FLOAT">
            <xsd:annotation>
               <xsd:documentation>This is the offset for the conversion from and to siUnits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Unit.offsetSiToUnit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-DIMENSION-REF">
            <xsd:annotation>
               <xsd:documentation>This association represents the physical dimension to which the unit belongs to. Note that only values with units of the same physical dimensions might be converted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Unit.physicalDimension";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PHYSICAL-DIMENSION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Units::Unit -->
   <xsd:complexType abstract="false" mixed="false" name="UNIT">
      <xsd:annotation>
         <xsd:documentation>This is a physical measurement unit. All units that might be defined should stem from SI units. In order to convert one unit into another factor and offset are defined. For the calculation from SI-unit to the defined unit the factor (factorSiToUnit ) and the offset (offsetSiToUnit ) are applied:

      unit = siUnit * factorSiToUnit + offsetSiToUnit 

      For the calculation from a unit to SI-unit the reciprocal of the factor (factorSiToUnit ) and the negation of the offset (offsetSiToUnit ) are applied:

      siUnit = (unit - offsetSiToUnit) / factorSiToUnit</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Units";mmt.qualifiedName="Unit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:UNIT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="UNIT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="UNIT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Units::UnitGroup -->
   <xsd:group name="UNIT-GROUP">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a logical grouping of units.The category denotes the unit system that the referenced units are associated to. 

      In this way, e.g. country-specific unit systems (CATEGORY="COUNTRY") can be defined as well as specific unit systems for certain application domains. 

      In the same way a group of equivalent units, can be defined which are used in different countries, by setting CATEGORY="EQUIV_UNITS".  KmPerHour and MilesPerHour could such be combined to one group named "vehicle_speed". The unit MeterPerSec would not belong to this group because it is normally not used for vehicle speed. But all of the mentioned units could be combined to one group named "speed".

      Note that the UnitGroup does not ensure the physical compliance of the units. This is maintained by the physical dimension.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="UnitGroups";mmt.qualifiedName="UnitGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REFS">
            <xsd:annotation>
               <xsd:documentation>This represents one particular unit in the UnitGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnitGroup.unit";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="UNIT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Units::UnitGroup -->
   <xsd:complexType abstract="false" mixed="false" name="UNIT-GROUP">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to specify a logical grouping of units.The category denotes the unit system that the referenced units are associated to. 

      In this way, e.g. country-specific unit systems (CATEGORY="COUNTRY") can be defined as well as specific unit systems for certain application domains. 

      In the same way a group of equivalent units, can be defined which are used in different countries, by setting CATEGORY="EQUIV_UNITS".  KmPerHour and MilesPerHour could such be combined to one group named "vehicle_speed". The unit MeterPerSec would not belong to this group because it is normally not used for vehicle speed. But all of the mentioned units could be combined to one group named "speed".

      Note that the UnitGroup does not ensure the physical compliance of the units. This is maintained by the physical dimension.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="UnitGroups";mmt.qualifiedName="UnitGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:UNIT-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::UnlimitedIntegerValueVariationPoint -->
   <xsd:group name="UNLIMITED-INTEGER-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for unlimited Integer attributes.

      Note that this class might be used in the extended meta-model only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnlimitedIntegerValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class VariantHandling::UnlimitedIntegerValueVariationPoint -->
   <xsd:complexType abstract="false" mixed="true" name="UNLIMITED-INTEGER-VALUE-VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This class represents an attribute value variation point for unlimited Integer attributes.

      Note that this class might be used in the extended meta-model only.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnlimitedIntegerValueVariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:FORMULA-EXPRESSION"/>
         <xsd:group ref="AR:SW-SYSTEMCONST-DEPENDENT-FORMULA"/>
         <xsd:group ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
         <xsd:group ref="AR:UNLIMITED-INTEGER-VALUE-VARIATION-POINT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ATTRIBUTE-VALUE-VARIATION-POINT"/>
   </xsd:complexType>
   <!-- element group for class BlockElements::Url -->
   <xsd:group name="URL">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies an Uniform Resource Locator (URL).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Url"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="AR:URI-STRING--SIMPLE">
            <xsd:annotation>
               <xsd:documentation>This is the url itself</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Url.value";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="false";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class BlockElements::Url -->
   <xsd:attributeGroup name="URL">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies an Uniform Resource Locator (URL).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Url"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="MIME-TYPE" type="AR:MIME-TYPE-STRING--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>this denotes the mime type of the resource located by the url.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Url.mimeType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class BlockElements::Url -->
   <xsd:complexType name="URL">
      <xsd:annotation>
         <xsd:documentation>This meta-class specifies an Uniform Resource Locator (URL).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Url"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:URI-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:URL"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::UserDefinedIPdu -->
   <xsd:group name="USER-DEFINED-I-PDU">
      <xsd:annotation>
         <xsd:documentation>UserDefinedIPdu allows to describe PDU-based communication over Complex Communication Drivers. If a new BSW module is added above the PduR (e.g. a Diagnostic Service ) then this IPdu element shall be used to describe the communication.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="UserDefinedIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CDD-TYPE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the CDD that transmits or receives the UserDefinedPdu. If several CDDs are defined this attribute is used to distinguish between them.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UserDefinedIPdu.cddType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::UserDefinedIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="USER-DEFINED-I-PDU">
      <xsd:annotation>
         <xsd:documentation>UserDefinedIPdu allows to describe PDU-based communication over Complex Communication Drivers. If a new BSW module is added above the PduR (e.g. a Diagnostic Service ) then this IPdu element shall be used to describe the communication.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="UserDefinedIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDU"/>
         <xsd:group ref="AR:I-PDU"/>
         <xsd:group ref="AR:USER-DEFINED-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::UserDefinedPdu -->
   <xsd:group name="USER-DEFINED-PDU">
      <xsd:annotation>
         <xsd:documentation>UserDefinedPdu allows to describe PDU-based communication over Complex Communication Drivers. If a new BSW module is added above the BusIf (e.g. a new Nm module) then this Pdu element shall be used to describe the communication.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="UserDefinedPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CDD-TYPE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the CDD that transmits or receives the UserDefinedIPdu. If several CDDs are defined this attribute is used to distinguish between them.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UserDefinedPdu.cddType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::UserDefinedPdu -->
   <xsd:complexType abstract="false" mixed="false" name="USER-DEFINED-PDU">
      <xsd:annotation>
         <xsd:documentation>UserDefinedPdu allows to describe PDU-based communication over Complex Communication Drivers. If a new BSW module is added above the BusIf (e.g. a new Nm module) then this Pdu element shall be used to describe the communication.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="UserDefinedPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDU"/>
         <xsd:group ref="AR:USER-DEFINED-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CalibrationValue::ValueGroup -->
   <xsd:group name="VALUE-GROUP">
      <xsd:annotation>
         <xsd:documentation>This element enables valules  to be grouped. It can be used to perform row and column-orientated groupings, so that these can be rendered properly e.g. as a table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ValueGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LABEL" type="AR:MULTILANGUAGE-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This label allows to give the valueGroup a partiluclar name. It can be usel if the Values are rendered as a table.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ValueGroup.label";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:SW-VALUES"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationValue::ValueGroup -->
   <xsd:complexType abstract="false" mixed="false" name="VALUE-GROUP">
      <xsd:annotation>
         <xsd:documentation>This element enables valules  to be grouped. It can be used to perform row and column-orientated groupings, so that these can be rendered properly e.g. as a table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ValueGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::ValueList -->
   <xsd:group name="VALUE-LIST">
      <xsd:annotation>
         <xsd:documentation>This is a generic list of numerical values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ValueList"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="VF" type="AR:NUMERICAL-VALUE-VARIATION-POINT">
               <xsd:annotation>
                  <xsd:documentation>This is one entry in the list of numerical values</xsd:documentation>
                  <xsd:appinfo source="tags">Vh.latestBindingTime="PreCompileTime";mmt.qualifiedName="ValueList.vf";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element name="V" type="AR:NUMERICAL-VALUE">
               <xsd:annotation>
                  <xsd:documentation>This is a particular numerical value without variation.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="ValueList.v";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class DataDefProperties::ValueList -->
   <xsd:complexType abstract="false" mixed="false" name="VALUE-LIST">
      <xsd:annotation>
         <xsd:documentation>This is a generic list of numerical values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ValueList"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VALUE-LIST"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::ValueSpecification -->
   <xsd:group name="VALUE-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Base class for expressions leading to a value which can be used to initialize a data object.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ValueSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This can be used to identify particular value specifications for human readers, for example elements of a record type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ValueSpecification.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class DataElements::VariableAccess -->
   <xsd:group name="VARIABLE-ACCESS">
      <xsd:annotation>
         <xsd:documentation>The presence of a VariableAccess implies that a RunnableEntity needs access to a VariableDataPrototype. 

      The kind of access is specified by the role in which the class is used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCESSED-VARIABLE" type="AR:AUTOSAR-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>This denotes the accessed variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableAccess.accessedVariable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCOPE" type="AR:VARIABLE-ACCESS-SCOPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute allows for constraining the scope of the corresponding communication. For example, it possible to express whether the communication is intended to cross the boundary of an ECU or whether it is intended not to cross the boundary of a single partition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableAccess.scope";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::VariableAccess -->
   <xsd:complexType abstract="false" mixed="false" name="VARIABLE-ACCESS">
      <xsd:annotation>
         <xsd:documentation>The presence of a VariableAccess implies that a RunnableEntity needs access to a VariableDataPrototype. 

      The kind of access is specified by the role in which the class is used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:VARIABLE-ACCESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="VARIABLE-ACCESS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="VARIABLE-ACCESS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortInterface::VariableAndParameterInterfaceMapping -->
   <xsd:group name="VARIABLE-AND-PARAMETER-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of VariableDataPrototypes or ParameterDataPrototypes in context of two different SenderReceiverInterfaces, NvDataInterfaces or ParameterInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableAndParameterInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Defines the mapping of two particular VariableDataPrototypes or ParameterDataPrototypes with unequal names and/or unequal semantic (resolution or range) in context of two different SenderReceiverInterfaces, NvDataInterfaces or ParameterInterfaces</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataMapping.VariableAndParameterInterfaceMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-PROTOTYPE-MAPPING" type="AR:DATA-PROTOTYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::VariableAndParameterInterfaceMapping -->
   <xsd:complexType abstract="false" mixed="false" name="VARIABLE-AND-PARAMETER-INTERFACE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Defines the mapping of VariableDataPrototypes or ParameterDataPrototypes in context of two different SenderReceiverInterfaces, NvDataInterfaces or ParameterInterfaces.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableAndParameterInterfaceMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-INTERFACE-MAPPING"/>
         <xsd:group ref="AR:VARIABLE-AND-PARAMETER-INTERFACE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataPrototypes::VariableDataPrototype -->
   <xsd:group name="VARIABLE-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A VariableDataPrototype is used to contain values in an ECU application. This  means that most likely a VariableDataPrototype allocates "static" memory on the  ECU. In some cases optimization strategies might lead to a situation where the  memory allocation can be avoided.

      In particular, the value of a VariableDataPrototype is likely to change as the ECU on which it is used executes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE">
            <xsd:annotation>
               <xsd:documentation>Specifies initial value(s) of the VariableDataPrototype</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototype.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="APPLICATION-VALUE-SPECIFICATION" type="AR:APPLICATION-VALUE-SPECIFICATION"/>
                  <xsd:element name="ARRAY-VALUE-SPECIFICATION" type="AR:ARRAY-VALUE-SPECIFICATION"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="NUMERICAL-VALUE-SPECIFICATION" type="AR:NUMERICAL-VALUE-SPECIFICATION"/>
                  <xsd:element name="RECORD-VALUE-SPECIFICATION" type="AR:RECORD-VALUE-SPECIFICATION"/>
                  <xsd:element name="REFERENCE-VALUE-SPECIFICATION" type="AR:REFERENCE-VALUE-SPECIFICATION"/>
                  <xsd:element name="TEXT-VALUE-SPECIFICATION" type="AR:TEXT-VALUE-SPECIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VARIATION-POINT" type="AR:VARIATION-POINT">
            <xsd:annotation>
               <xsd:documentation>This element was generated/modified due to an atpVariation stereotype.</xsd:documentation>
               <xsd:appinfo source="tags">pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10000"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataPrototypes::VariableDataPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="VARIABLE-DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A VariableDataPrototype is used to contain values in an ECU application. This  means that most likely a VariableDataPrototype allocates "static" memory on the  ECU. In some cases optimization strategies might lead to a situation where the  memory allocation can be avoided.

      In particular, the value of a VariableDataPrototype is likely to change as the ECU on which it is used executes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ATP-FEATURE"/>
         <xsd:group ref="AR:ATP-PROTOTYPE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:AUTOSAR-DATA-PROTOTYPE"/>
         <xsd:group ref="AR:VARIABLE-DATA-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class InstanceRefs::VariableDataPrototypeInSystemInstanceRef -->
   <xsd:group name="VARIABLE-DATA-PROTOTYPE-IN-SYSTEM-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototypeInSystemInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototypeInSystemInstanceRef.contextComponent";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototypeInSystemInstanceRef.contextComposition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ROOT-SW-COMPOSITION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-PORT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototypeInSystemInstanceRef.contextPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototypeInSystemInstanceRef.targetDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::VariableDataPrototypeInSystemInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="VARIABLE-DATA-PROTOTYPE-IN-SYSTEM-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableDataPrototypeInSystemInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:VARIABLE-DATA-PROTOTYPE-IN-SYSTEM-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefsUsage::VariableInAtomicSWCTypeInstanceRef -->
   <xsd:group name="VARIABLE-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableInAtomicSWCTypeInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the port providing the paramter or the entry point to the parameter structure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInAtomicSWCTypeInstanceRef.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROOT-VARIABLE-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInAtomicSWCTypeInstanceRef.rootVariableDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This ist the context in a compositeDataType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInAtomicSWCTypeInstanceRef.contextDataPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the target of the instance ref. Note that it must be one of ApplicationCompositeElementDataPrototype of VariableDataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInAtomicSWCTypeInstanceRef.targetDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefsUsage::VariableInAtomicSWCTypeInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="VARIABLE-IN-ATOMIC-SWC-TYPE-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableInAtomicSWCTypeInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:VARIABLE-IN-ATOMIC-SWC-TYPE-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InstanceRefs::VariableInAtomicSwcInstanceRef -->
   <xsd:group name="VARIABLE-IN-ATOMIC-SWC-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableInAtomicSwcInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <!-- Association <<atpDerived>>contextPort skipped -->
         <!-- Association <<atpDerived>>abstractTargetDataElement skipped -->
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class InstanceRefs::VariableInComponentInstanceRef -->
   <xsd:group name="VARIABLE-IN-COMPONENT-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableInComponentInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <!-- Association <<atpDerived>>base skipped -->
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInComponentInstanceRef.contextComponent";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTEXT-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInComponentInstanceRef.contextPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROOT-VARIABLE-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInComponentInstanceRef.rootVariableDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VARIABLE-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInComponentInstanceRef.contextDataPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:APPLICATION-COMPOSITE-ELEMENT-DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-DATA-PROTOYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableInComponentInstanceRef.targetDataProtoype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InstanceRefs::VariableInComponentInstanceRef -->
   <xsd:complexType abstract="false" mixed="false" name="VARIABLE-IN-COMPONENT-INSTANCE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableInComponentInstanceRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:ATP-INSTANCE-REF"/>
         <xsd:group ref="AR:VARIABLE-IN-COMPONENT-INSTANCE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::VariationPoint -->
   <xsd:group name="VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a "structural variation point". The container of the variation point is part of the selected variant if swSyscond evaluates to true and each postBuildVariantCriterion is fulfilled.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This provides a name to the particular variation point to support the RTE generator. It is necessary for supporting splitable aggregations and if binding time is later than CodeGenerationTime, as well as some RTE conditions. It needs to be unique with in the enclosing Identifiables with the same ShortName.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariationPoint.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:MULTI-LANGUAGE-OVERVIEW-PARAGRAPH">
            <xsd:annotation>
               <xsd:documentation>This allows to describe shortly the purpose of the variation point.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariationPoint.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BLUEPRINT-CONDITION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents a description that documents how the variation point shall be resolved when deriving objects from the blueprint.

            Note that variationPoints are not allowed within a blueprintCondition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariationPoint.blueprintCondition";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="28"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SYSCOND" type="AR:CONDITION-BY-FORMULA">
            <xsd:annotation>
               <xsd:documentation>This condition acts as Binding Function for the VariationPoint.
            Note that the mulitplicity is 0..1 in order to support pure postBuild variants.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariationPoint.swSyscond";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POST-BUILD-VARIANT-CONDITIONS">
            <xsd:annotation>
               <xsd:documentation>This is the set of post build variant conditions which all  shall be fulfilled in order to (postbuild) bind the variation point.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariationPoint.postBuildVariantCondition";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="POST-BUILD-VARIANT-CONDITION" type="AR:POST-BUILD-VARIANT-CONDITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SDG" type="AR:SDG">
            <xsd:annotation>
               <xsd:documentation>An optional special data group is attached to every variation point. These data can be used by external software systems to attach application specific data. For example, a variant management system might add an identifier, an URL or a specific classifier.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariationPoint.sdg";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::VariationPoint -->
   <xsd:complexType abstract="false" mixed="false" name="VARIATION-POINT">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to express a "structural variation point". The container of the variation point is part of the selected variant if swSyscond evaluates to true and each postBuildVariantCriterion is fulfilled.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariationPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:VARIATION-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class VariantHandling::VariationPointProxy -->
   <xsd:group name="VARIATION-POINT-PROXY">
      <xsd:annotation>
         <xsd:documentation>The VariationPointProxy represents variation points of the C/C++ implementation. In case of bindingTime = compileTime the RTE provides defines which can be used for Pre Processor directives to implement compileTime variability.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariationPointProxy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONDITION-ACCESS" type="AR:CONDITION-BY-FORMULA">
            <xsd:annotation>
               <xsd:documentation>This condition acts as Binding Function for the VariationPoint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariationPointProxy.conditionAccess";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-ACCESS">
            <xsd:annotation>
               <xsd:documentation>This value acts as Binding Function for the VariationPoint.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariationPointProxy.valueAccess";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="BOOLEAN-VALUE-VARIATION-POINT" type="AR:BOOLEAN-VALUE-VARIATION-POINT"/>
                  <xsd:element name="FLOAT-VALUE-VARIATION-POINT" type="AR:FLOAT-VALUE-VARIATION-POINT"/>
                  <xsd:element name="INTEGER-VALUE-VARIATION-POINT" type="AR:INTEGER-VALUE-VARIATION-POINT"/>
                  <xsd:element name="LIMIT" type="AR:LIMIT"/>
                  <xsd:element name="NUMERICAL-VALUE-VARIATION-POINT" type="AR:NUMERICAL-VALUE-VARIATION-POINT"/>
                  <xsd:element name="POSITIVE-INTEGER-VALUE-VARIATION-POINT" type="AR:POSITIVE-INTEGER-VALUE-VARIATION-POINT"/>
                  <xsd:element name="UNLIMITED-INTEGER-VALUE-VARIATION-POINT" type="AR:UNLIMITED-INTEGER-VALUE-VARIATION-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class VariantHandling::VariationPointProxy -->
   <xsd:complexType abstract="false" mixed="false" name="VARIATION-POINT-PROXY">
      <xsd:annotation>
         <xsd:documentation>The VariationPointProxy represents variation points of the C/C++ implementation. In case of bindingTime = compileTime the RTE provides defines which can be used for Pre Processor directives to implement compileTime variability.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariationPointProxy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:VARIATION-POINT-PROXY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Timing::VfbTiming -->
   <xsd:group name="VFB-TIMING">
      <xsd:annotation>
         <xsd:documentation>A model element used to define timing descriptions and constraints at VFB level.

      TimingDescriptions aggregated by VfbTiming are restricted to event chains referring to events which are derived from the class TDEventVfb.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="VfbTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-REF">
            <xsd:annotation>
               <xsd:documentation>This defines the scope of a VfbTiming. All corresponding timing descriptions and constraints must be defined within this scope.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VfbTiming.component";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::VfbTiming -->
   <xsd:complexType abstract="false" mixed="false" name="VFB-TIMING">
      <xsd:annotation>
         <xsd:documentation>A model element used to define timing descriptions and constraints at VFB level.

      TimingDescriptions aggregated by VfbTiming are restricted to event chains referring to events which are derived from the class TDEventVfb.</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="TimingExtensions";mmt.qualifiedName="VfbTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:AR-ELEMENT"/>
         <xsd:group ref="AR:TIMING-EXTENSION"/>
         <xsd:group ref="AR:VFB-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::WaitPoint -->
   <xsd:group name="WAIT-POINT">
      <xsd:annotation>
         <xsd:documentation>This defines a wait-point for which the RunnableEntity can wait.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WaitPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="AR:TIME-VALUE">
            <xsd:annotation>
               <xsd:documentation>Time in seconds before the WaitPoint times out and the blocking wait call returns with an error indicating the timeout.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WaitPoint.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-REF">
            <xsd:annotation>
               <xsd:documentation>This is the RTEEvent this WaitPoint is waiting for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WaitPoint.trigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RTE-EVENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::WaitPoint -->
   <xsd:complexType abstract="false" mixed="false" name="WAIT-POINT">
      <xsd:annotation>
         <xsd:documentation>This defines a wait-point for which the RunnableEntity can wait.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WaitPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:WAIT-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LanguageDataModel::WhitespaceControlled -->
   <xsd:group name="WHITESPACE-CONTROLLED">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to control the white-space handling  e.g. in xml serialization. This is implemented by adding the attribute "space".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WhitespaceControlled"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- attribute group for class LanguageDataModel::WhitespaceControlled -->
   <xsd:attributeGroup name="WHITESPACE-CONTROLLED">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to control the white-space handling  e.g. in xml serialization. This is implemented by adding the attribute "space".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WhitespaceControlled"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute ref="xml:space" use="required">
         <xsd:annotation>
            <xsd:documentation>This attribute is used to signal an intention that in that element, white space should be preserved by applications. It is defined according to xml:space as declared by W3C.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="WhitespaceControlled.xmlSpace";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true";xml.attributeRef="true";xml.enforceMinMultiplicity="true";xml.name="space";xml.nsPrefix="xml"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- element group for class HeapUsage::WorstCaseHeapUsage -->
   <xsd:group name="WORST-CASE-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Provides a formal worst case heap usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Worst case heap consumption.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseHeapUsage.memoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HeapUsage::WorstCaseHeapUsage -->
   <xsd:complexType abstract="false" mixed="false" name="WORST-CASE-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Provides a formal worst case heap usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HEAP-USAGE"/>
         <xsd:group ref="AR:WORST-CASE-HEAP-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class StackUsage::WorstCaseStackUsage -->
   <xsd:group name="WORST-CASE-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Provides a formal worst case stack usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-CONSUMPTION" type="AR:POSITIVE-INTEGER">
            <xsd:annotation>
               <xsd:documentation>Worst case stack consumption.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseStackUsage.memoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class StackUsage::WorstCaseStackUsage -->
   <xsd:complexType abstract="false" mixed="false" name="WORST-CASE-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Provides a formal worst case stack usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:STACK-USAGE"/>
         <xsd:group ref="AR:WORST-CASE-STACK-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::XcpPdu -->
   <xsd:group name="XCP-PDU">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR XCP Pdu</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="XcpPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class CoreCommunication::XcpPdu -->
   <xsd:complexType abstract="false" mixed="false" name="XCP-PDU">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR XCP Pdu</xsd:documentation>
         <xsd:appinfo source="tags">atp.recommendedPackage="Pdus";mmt.qualifiedName="XcpPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:MULTILANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COLLECTABLE-ELEMENT"/>
         <xsd:group ref="AR:PACKAGEABLE-ELEMENT"/>
         <xsd:group ref="AR:FIBEX-ELEMENT"/>
         <xsd:group ref="AR:PDU"/>
         <xsd:group ref="AR:XCP-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::Xdoc -->
   <xsd:group name="XDOC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to refer to an external document which can be rendered as printed matter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This represents document number of an external document that is referenced. Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc.number";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATE" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This represents version and state of the external document. Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc.state";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATE" type="AR:DATE">
            <xsd:annotation>
               <xsd:documentation>This element specifies the release date of the external document if applicable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc.date";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PUBLISHER" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This represents the publisher of an external document that is being referenced. Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc.publisher";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="URL" type="AR:URL">
            <xsd:annotation>
               <xsd:documentation>This specifies the URL of the external document.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc.url";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POSITION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This represents the reference to the relevant positions of a standard. Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc.position";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InlineTextElements::Xdoc -->
   <xsd:complexType abstract="false" mixed="false" name="XDOC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to refer to an external document which can be rendered as printed matter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:SINGLE-LANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:XDOC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::Xfile -->
   <xsd:group name="XFILE">
      <xsd:annotation>
         <xsd:documentation>This represents to reference an external file within a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xfile"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="URL" type="AR:URL">
            <xsd:annotation>
               <xsd:documentation>This represents the URL of the external file.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xfile.url";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOOL" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This element describes the tool which was used to generate the corresponding Xfile . Kept as a string since no specific syntax can be provided to denote a tool.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xfile.tool";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOOL-VERSION" type="AR:STRING">
            <xsd:annotation>
               <xsd:documentation>This element describes the tool version which was used to generate the corresponding xfile. Kept as a string, since no specific syntax can be specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xfile.toolVersion";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InlineTextElements::Xfile -->
   <xsd:complexType abstract="false" mixed="false" name="XFILE">
      <xsd:annotation>
         <xsd:documentation>This represents to reference an external file within a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xfile"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:SINGLE-LANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:XFILE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::Xref -->
   <xsd:group name="XREF">
      <xsd:annotation>
         <xsd:documentation>This represents a cross-reference within documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xref"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LABEL-1" type="AR:SINGLE-LANGUAGE-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>This allows to specify a replacement text which shall be rendered if showContent is selected.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xref.label1";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFERRABLE-REF">
            <xsd:annotation>
               <xsd:documentation>This establishes the reference in Autosar style</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xref.referrable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:REFERRABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class InlineTextElements::Xref -->
   <xsd:attributeGroup name="XREF">
      <xsd:annotation>
         <xsd:documentation>This represents a cross-reference within documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xref"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="SHOW-CONTENT" type="AR:SHOW-CONTENT-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the content of the xref element shall be rendered. The default is "NO-SHOW-CONTENT".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showContent";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHOW-RESOURCE-ALIAS-NAME" type="AR:SHOW-RESOURCE-ALIAS-NAME-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>This indicates if the alias names of the referenced objects shall be rendered. This means this is some kind of backward searching: look whether there is an  alias for the referenced object, if yes, print it. 

         If there is more than one AliasNameSet, Xref might render all of those.

         If no alilas is found and showResourceShortName is set to NoShowShortName, then the shortName of the reference target shall be displayed. By this showResourceAliasName is similar to showResourceShortName but shows the aliasName instead of the shortName.

         Default is NO-SHOW-ALIAS-NAME.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showResourceAliasName";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHOW-RESOURCE-CATEGORY" type="AR:SHOW-RESOURCE-CATEGORY-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the category of the referenced resource shall be rendered. Default is "NO-SHOW-CATEGORY".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showResourceCategory";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHOW-RESOURCE-LONG-NAME" type="AR:SHOW-RESOURCE-LONG-NAME-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the longName of the referenced resource shall be rendered. Default is "SHOW-LONG-NAME".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showResourceLongName";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHOW-RESOURCE-NUMBER" type="AR:SHOW-RESOURCE-NUMBER-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the Number of the referenced resource shall be shown. Default is "SHOW--NUMBER"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showResourceNumber";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHOW-RESOURCE-PAGE" type="AR:SHOW-RESOURCE-PAGE-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the page number of the referenced resource shall be shown. Default is "SHOW-PAGE"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showResourcePage";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHOW-RESOURCE-SHORT-NAME" type="AR:SHOW-RESOURCE-SHORT-NAME-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the shortJName of the referenced resource shall be shown. Default is "SHOW-SHORT-NAME"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showResourceShortName";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHOW-RESOURCE-TYPE" type="AR:SHOW-RESOURCE-TYPE-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the type of the referenced Resource shall be shown. Default is "SHOW-TYPE"</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showResourceType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="SHOW-SEE" type="AR:SHOW-SEE-ENUM--SIMPLE">
         <xsd:annotation>
            <xsd:documentation>Indicates if the word "see " shall be shown before the reference. Default is "NO-SHOW-SEE". Note that this is there for compatibility reasons only.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Xref.showSee";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class InlineTextElements::Xref -->
   <xsd:complexType abstract="false" mixed="false" name="XREF">
      <xsd:annotation>
         <xsd:documentation>This represents a cross-reference within documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xref"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:XREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:XREF"/>
   </xsd:complexType>
   <!-- element group for class InlineTextElements::XrefTarget -->
   <xsd:group name="XREF-TARGET">
      <xsd:annotation>
         <xsd:documentation>This element specifies a reference target which can be scattered throughout the text.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="XrefTarget"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
   </xsd:group>
   <!-- complex type for class InlineTextElements::XrefTarget -->
   <xsd:complexType abstract="false" mixed="false" name="XREF-TARGET">
      <xsd:annotation>
         <xsd:documentation>This element specifies a reference target which can be scattered throughout the text.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="XrefTarget"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-OBJECT"/>
         <xsd:group ref="AR:REFERRABLE"/>
         <xsd:group ref="AR:SINGLE-LANGUAGE-REFERRABLE"/>
         <xsd:group ref="AR:XREF-TARGET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <xsd:complexType name="ADDRESS">
      <xsd:annotation>
         <xsd:documentation>This is used to specify an address within the CPU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Address";xml.xsd.customType="ADDRESS";xml.xsd.pattern="0x[0-9a-z]*";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ADDRESS--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ADDRESS--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="0x[0-9a-z]*"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ALIGN-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies horizontal alignment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AlignEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ALIGN-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ALIGN-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CENTER">
            <xsd:annotation>
               <xsd:documentation>The content of the table is horizontally centered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AlignEnum.center"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="JUSTIFY">
            <xsd:annotation>
               <xsd:documentation>This indicates that the content of table cell shall be justified (rendered as a block where white-space is expanded such that all lines are filled up).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AlignEnum.justify"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LEFT">
            <xsd:annotation>
               <xsd:documentation>This indicates that the content of a table cell is left justified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AlignEnum.left"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RIGHT">
            <xsd:annotation>
               <xsd:documentation>This indicates that the content of a table cell is left justified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AlignEnum.right"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ALIGNMENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>This primitive represents the alignment of objects within a memory section. The value is in number of bits or UNKNOWN (deprecated), 8 , 16, 32 UNSPECIFIED or BOOLEAN. Typical values for numbers are 8, 16, 32.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AlignmentType";xml.xsd.customType="ALIGNMENT-TYPE";xml.xsd.pattern="[1-9][0-9]*|0x[0-9a-f]*|0[0-7]*|0b[0-1]*|UNSPECIFIED|UNKNOWN|BOOLEAN";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ALIGNMENT-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ALIGNMENT-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[1-9][0-9]*|0x[0-9a-f]*|0[0-7]*|0b[0-1]*|UNSPECIFIED|UNKNOWN|BOOLEAN"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="AREA-ENUM-NOHREF">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the fact that the area has no reference.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AreaEnumNohref"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:AREA-ENUM-NOHREF--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="AREA-ENUM-NOHREF--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NOHREF">
            <xsd:annotation>
               <xsd:documentation>This indicates that the area has no active link.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AreaEnumNohref.nohref"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="AREA-ENUM-SHAPE">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the shape of the area.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AreaEnumShape"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:AREA-ENUM-SHAPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="AREA-ENUM-SHAPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CIRCLE">
            <xsd:annotation>
               <xsd:documentation>The shape is a circle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AreaEnumShape.circle"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DEFAULT">
            <xsd:annotation>
               <xsd:documentation>This specifies the fact that the area covers the rest of the figure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AreaEnumShape.default"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="POLY">
            <xsd:annotation>
               <xsd:documentation>The area is specified as polygon.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AreaEnumShape.poly"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RECT">
            <xsd:annotation>
               <xsd:documentation>The shape is specified as rectangle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AreaEnumShape.rect"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ARGUMENT-DIRECTION-ENUM">
      <xsd:annotation>
         <xsd:documentation>Use cases:

      * Arguments in ClientServerOperation can have different directions that need to be formally indicated because they have an impact on how the function signature looks like eventually.

      * Arguments in BswModuleEntry already determine a function signature, but the direction is used to specify the semantics, especially of pointer arguments.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentDirectionEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ARGUMENT-DIRECTION-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ARGUMENT-DIRECTION-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="IN">
            <xsd:annotation>
               <xsd:documentation>The argument value is passed to the callee.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentDirectionEnum.in"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INOUT">
            <xsd:annotation>
               <xsd:documentation>The argument value is passed to the callee but also passed back from the callee to the caller.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentDirectionEnum.inout"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OUT">
            <xsd:annotation>
               <xsd:documentation>The argument value is passed from the callee  to the caller.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentDirectionEnum.out"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ARRAY-SIZE-SEMANTICS-ENUM">
      <xsd:annotation>
         <xsd:documentation>This type controls how the information about the number of elements in an ApplicationArrayDataType is to be interpreted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArraySizeSemanticsEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ARRAY-SIZE-SEMANTICS-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ARRAY-SIZE-SEMANTICS-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FIXED-SIZE">
            <xsd:annotation>
               <xsd:documentation>This means that the ApplicationArrayDataType will always have a fixed number of elements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArraySizeSemanticsEnum.fixedSize"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VARIABLE-SIZE">
            <xsd:annotation>
               <xsd:documentation>This implies that the actual number of elements in the ApplicationArrayDataType might vary at run-time. The value of arraySize represents the maximum number of elements in the array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArraySizeSemanticsEnum.variableSize"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ASAM-RECORD-LAYOUT-SEMANTICS">
      <xsd:annotation>
         <xsd:documentation>This primitive is used to denote the semantics in particular in terms of the corresponding A2L-Keyword. This is to support the mapping of the more general record layouts in AUTOSAR/MSR to the specific A2L keywords. It is possible to express the specifc semantics of A2l recordlayout keywords in swRecordlayoutGroup but not always vice versa. Therefore the mapping is provided in this optional attribute.

      It is specified as NMTOKEN to reduce the direct dependency of ASAM an AUTOSAR standards.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsamRecordLayoutSemantics";xml.xsd.customType="ASAM-RECORD-LAYOUT-SEMANTICS";xml.xsd.type="NMTOKEN"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ASAM-RECORD-LAYOUT-SEMANTICS--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ASAM-RECORD-LAYOUT-SEMANTICS--SIMPLE">
      <xsd:restriction base="xsd:NMTOKEN"/>
   </xsd:simpleType>
   <xsd:complexType name="AXIS-INDEX-TYPE">
      <xsd:annotation>
         <xsd:documentation>This type specifies an axis in a curve/map data object. The index satisfies  the following convention:

      * 0 output "axis"
      * 1 input axis 1 (x input axis e.g. of a curve)
      * 2 input axis 2 (y input axis e.g. of a map)
      * 3 input axis 3 (z input axis e.g. of a cuboid)
      *  4.. 9 etc.

      The output "axis" provides access to the output value of the parameter. Note that this access is usually performed via an index according to the input axis.

      In addition to this, the Values STRING and ARRAY support specific iterations.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AxisIndexType";xml.xsd.customType="AXIS-INDEX-TYPE";xml.xsd.pattern="[0-9]+|STRING|ARRAY";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:AXIS-INDEX-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="AXIS-INDEX-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[0-9]+|STRING|ARRAY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="BASE-TYPE-ENCODING-STRING">
      <xsd:annotation>
         <xsd:documentation>This is the string denotion of a BaseType encoding. It may be refined by specific use-cases.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeEncodingString";xml.xsd.customType="BASE-TYPE-ENCODING-STRING";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:BASE-TYPE-ENCODING-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="BASE-TYPE-ENCODING-STRING--SIMPLE">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>
   <xsd:complexType name="BINDING-TIME-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the applicable binding times for the pre build variation points.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BindingTimeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:BINDING-TIME-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="BINDING-TIME-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CODE-GENERATION-TIME">
            <xsd:annotation>
               <xsd:documentation>* Coding by hand, based on requirements document.
         * Tool based code generation, e.g. from a model.
         * The model may contain variants.
         * Only code for the selected variant(s) is actually generated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BindingTimeEnum.CodeGenerationTime"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LINK-TIME">
            <xsd:annotation>
               <xsd:documentation>Configure what is included in object code, and what is omitted
         Based on which variant(s) are selected
         E.g. for modules that are delivered as object code (as opposed to those that are delivered as source code)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BindingTimeEnum.LinkTime"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PRE-COMPILE-TIME">
            <xsd:annotation>
               <xsd:documentation>This is typically the C-Preprocessor.
         Exclude parts of the code from the compilation process, e.g.,
         because they are not required for the selected variant,
         because they are incompatible with the selected variant,
         because they require resources that are not present in the selected variant.
         Object code is only generated for the selected variant(s).
         The code that is excluded at this stage code will not be available at later stages.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BindingTimeEnum.PreCompileTime"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SYSTEM-DESIGN-TIME">
            <xsd:annotation>
               <xsd:documentation>* Designing the VFB.
         * Software Component types (portinterfaces).
         * SWC Prototypes and the Connections between SWCprototypes.
         * Designing the Topology
         * ECUs and interconnecting Networks
         * Designing the Communication Matrix and Data Mapping</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BindingTimeEnum.SystemDesignTime"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="BOOLEAN">
      <xsd:annotation>
         <xsd:documentation>A Boolean value denotes a logical condition that is either 'true' or 'false'.
      It can be one of "0", "1", "true", "false"</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Boolean";xml.xsd.customType="BOOLEAN";xml.xsd.pattern="0|1|true|false";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:BOOLEAN--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="BOOLEAN--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="0|1|true|false"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="BSW-CALL-TYPE">
      <xsd:annotation>
         <xsd:documentation>Denotes the mechanism by which the entry into the Bsw module shall be called.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswCallType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:BSW-CALL-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="BSW-CALL-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CALLBACK">
            <xsd:annotation>
               <xsd:documentation>Callback (i.e. the caller specifies the signature)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswCallType.callback"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INTERRUPT">
            <xsd:annotation>
               <xsd:documentation>Interrupt routine</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswCallType.interrupt"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="REGULAR">
            <xsd:annotation>
               <xsd:documentation>Regular API call</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswCallType.regular"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SCHEDULED">
            <xsd:annotation>
               <xsd:documentation>Called by the scheduler</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswCallType.scheduled"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="BSW-EXECUTION-CONTEXT">
      <xsd:annotation>
         <xsd:documentation>Specifies the execution context required or guaranteed for the call associated with this service.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswExecutionContext"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:BSW-EXECUTION-CONTEXT--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="BSW-EXECUTION-CONTEXT--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HOOK">
            <xsd:annotation>
               <xsd:documentation>Context of an OS "hook" routine always</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswExecutionContext.hook"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INTERRUPT-CAT-1">
            <xsd:annotation>
               <xsd:documentation>CAT1 interrupt context always</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswExecutionContext.interruptCat1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INTERRUPT-CAT-2">
            <xsd:annotation>
               <xsd:documentation>CAT2 interrupt context always</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswExecutionContext.interruptCat2"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TASK">
            <xsd:annotation>
               <xsd:documentation>Task context always</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswExecutionContext.task"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="UNSPECIFIED">
            <xsd:annotation>
               <xsd:documentation>The execution context is not specified by the API</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswExecutionContext.unspecified"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="BSW-INTERRUPT-CATEGORY">
      <xsd:annotation>
         <xsd:documentation>Category of the interrupt service</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptCategory"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:BSW-INTERRUPT-CATEGORY--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="BSW-INTERRUPT-CATEGORY--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAT-1">
            <xsd:annotation>
               <xsd:documentation>Cat1 interrupt routines are not controlled by the OS and are only allowed to make a very limited selection of OS calls to enable and disable all interrupts. The BswInterruptEntity  is implemented by the interrupt service routine, which is directly called from the interrupt vector (not via the OS).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptCategory.cat1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CAT-2">
            <xsd:annotation>
               <xsd:documentation>Cat2 interrupt routines are controlled by the OS and they are allowed to make OS calls. The BswInterruptEntity  is implemented by the interrupt handler, which is called from the OS.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptCategory.cat2"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="BYTE-ORDER-ENUM">
      <xsd:annotation>
         <xsd:documentation>When more than one byte is stored in the memory the order of those bytes may differ depending on the architecture of the processing unit. If the least significant byte is stored at the lowest address, this architecture is called little endian and otherwise it is called big endian.

      ByteOrder is very important in case of communication between different PUs or ECUs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ByteOrderEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:BYTE-ORDER-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="BYTE-ORDER-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MOST-SIGNIFICANT-BYTE-FIRST">
            <xsd:annotation>
               <xsd:documentation>Most significant byte shall come at the lowest address (also known as BigEndian or as Motorola-Format)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ByteOrderEnum.mostSignificantByteFirst"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MOST-SIGNIFICANT-BYTE-LAST">
            <xsd:annotation>
               <xsd:documentation>Most significant byte shall come highest address (also known as LittleEndian or as Intel-Format)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ByteOrderEnum.mostSignificantByteLast"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OPAQUE">
            <xsd:annotation>
               <xsd:documentation>For opaque data endianness conversion has to be configured to Opaque. See AUTOSAR COM Specification for more details.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ByteOrderEnum.opaque"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="CALPRM-AXIS-CATEGORY-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enum specifies the possible values of the category property within  SwCalprmAxis.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAxisCategoryEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:CALPRM-AXIS-CATEGORY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="CALPRM-AXIS-CATEGORY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COM-AXIS">
            <xsd:annotation>
               <xsd:documentation>COM-AXIS is equal to an STD_AXIS, the difference is, that a COM-AXIS is an shared axis, that means this axis can be used multiple times by different curves or maps. This value is obsolete.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="CalprmAxisCategoryEnum.comAxis_O";xml.name="COM-AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="COM_AXIS">
            <xsd:annotation>
               <xsd:documentation>COM_AXIS is equal to an STD_AXIS, the difference is, that a COM_AXIS is an shared axis, that means this axis can be used multiple times by different curves or maps.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAxisCategoryEnum.comAxis";xml.name="COM_AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CURVE-AXIS">
            <xsd:annotation>
               <xsd:documentation>CURVE-AXIS uses a separate CURVE to rescale the axis. The referenced CURVE is used to lookup an axis index, and the index value is used by the controller to determine the operating point in the CURVE or MAP. This value is obsolete.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="CalprmAxisCategoryEnum.curveAxis_O";xml.name="CURVE-AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CURVE_AXIS">
            <xsd:annotation>
               <xsd:documentation>CURVE_AXIS uses a separate CURVE to rescale the axis. The referenced CURVE is used to lookup an axis index, and the index value is used by the controller to determine the operating point in the CURVE or MAP.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAxisCategoryEnum.curveAxis";xml.name="CURVE_AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FIX-AXIS">
            <xsd:annotation>
               <xsd:documentation>FIX-AXIS means that the input axis is not stored. The axis is calculated using parameters  and so on it is also not possible to modify the axis points. This value is obsolete.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="CalprmAxisCategoryEnum.fixAXIS_O";xml.name="FIX-AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FIX_AXIS">
            <xsd:annotation>
               <xsd:documentation>FIX_AXIS means that the input axis is not stored. The axis is calculated using parameters  and so on it is also not possible to modify the axis points.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAxisCategoryEnum.fixAXIS";xml.name="FIX_AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RES-AXIS">
            <xsd:annotation>
               <xsd:documentation>RES-AXIS is also an shared axis like COM_AXIS, the difference is that this kind of axis can be used for rescaling. This value is obsolete.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="CalprmAxisCategoryEnum.resAxis_O";xml.name="RES-AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RES_AXIS">
            <xsd:annotation>
               <xsd:documentation>RES_AXIS is also an shared axis like COM_AXIS, the difference is that this kind of axis can be used for rescaling.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAxisCategoryEnum.resAxis";xml.name="RES_AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STD-AXIS">
            <xsd:annotation>
               <xsd:documentation>STD-AXIS means that input and output axis definition are stored within this CURVE.
         There is no shared or calculated axis. This value is obsolete.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="CalprmAxisCategoryEnum.stdAxis_O";xml.name="STD-AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STD_AXIS">
            <xsd:annotation>
               <xsd:documentation>STD_AXIS means that input and output axis definition are stored within this CURVE.
         There is no shared or calculated axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAxisCategoryEnum.stdAxis";xml.name="STD_AXIS"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="CAN-ADDRESSING-MODE-TYPE">
      <xsd:annotation>
         <xsd:documentation>Indicates whether standard or extended CAN identifiers are used</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanAddressingModeType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:CAN-ADDRESSING-MODE-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="CAN-ADDRESSING-MODE-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EXTENDED">
            <xsd:annotation>
               <xsd:documentation>Extended 29-bit-identifiers are used (CAN 2.0B)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanAddressingModeType.extended"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STANDARD">
            <xsd:annotation>
               <xsd:documentation>Standard 11-bit-identifiers are used (CAN 2.0A)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanAddressingModeType.standard"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="CAN-TP-ADDRESSING-FORMAT-TYPE">
      <xsd:annotation>
         <xsd:documentation>Declares which communication addressing mode is supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpAddressingFormatType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:CAN-TP-ADDRESSING-FORMAT-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="CAN-TP-ADDRESSING-FORMAT-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EXTENDED">
            <xsd:annotation>
               <xsd:documentation>To use extended addressing format.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpAddressingFormatType.extended"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MIXED">
            <xsd:annotation>
               <xsd:documentation>To use mixed addressing format.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpAddressingFormatType.mixed"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STANDARD">
            <xsd:annotation>
               <xsd:documentation>To use normal addressing format.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpAddressingFormatType.standard"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="CAN-TP-CHANNEL-MODE-TYPE">
      <xsd:annotation>
         <xsd:documentation>The CAN Transport Layer supports half and full duplex channel modes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpChannelModeType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:CAN-TP-CHANNEL-MODE-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="CAN-TP-CHANNEL-MODE-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FULL-DUPLEX-MODE">
            <xsd:annotation>
               <xsd:documentation>full duplex channel mode</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpChannelModeType.fullDuplexMode"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="HALF-DUPLEX-MODE">
            <xsd:annotation>
               <xsd:documentation>half duplex channel mode</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpChannelModeType.halfDuplexMode"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="CATEGORY-STRING">
      <xsd:annotation>
         <xsd:documentation>This represents the pattern applicable to categories.

      It is basically the same as Identifier but has a different semantics. Therefore it is modeled as a primitive of its own.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CategoryString";xml.xsd.customType="CATEGORY-STRING";xml.xsd.pattern="[A-Z][A-Z_]*";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:CATEGORY-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="CATEGORY-STRING--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[A-Z][A-Z_]*"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="CHAPTER-ENUM-BREAK">
      <xsd:annotation>
         <xsd:documentation>This allows to specify the page break policy of a paginatable element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChapterEnumBreak"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:CHAPTER-ENUM-BREAK--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="CHAPTER-ENUM-BREAK--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BREAK">
            <xsd:annotation>
               <xsd:documentation>This indicates the a page break shall be applied before the current block.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ChapterEnumBreak.break"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-BREAK">
            <xsd:annotation>
               <xsd:documentation>This indicates that there is no need to force a page break before this block.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ChapterEnumBreak.noBreak"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="COMMUNICATION-DIRECTION-TYPE">
      <xsd:annotation>
         <xsd:documentation>Describes the communication direction.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationDirectionType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:COMMUNICATION-DIRECTION-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="COMMUNICATION-DIRECTION-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="IN">
            <xsd:annotation>
               <xsd:documentation>Reception (Input)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationDirectionType.in"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OUT">
            <xsd:annotation>
               <xsd:documentation>Transmission (Output)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationDirectionType.out"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="CSE-CODE-TYPE-STRING">
      <xsd:annotation>
         <xsd:documentation>This primitive represents an ASAM CSE (Codes for Scaling Units) code as defined in the ASAM-MCD-2MC-ASAP2 	specification.
       
      '''Time'''

          0:   1 sec
          1:  10 sec
          2: 100 sec
          
          3:   1 msec
          4:  10 msec
          5: 100 msec
          
          6:   1 sec
          7:  10 sec
          
          8:   1 min
          9:   1 hour
         10:   1 day

      '''Angle'''

        100:   Angular degrees
        101:   Revolutions (360 degrees)
        102:   Cycle (720 degrees)
               e.g. in case of IC engines

      '''Cylinder Segment'''

        103:   Cylinder segment
               Combustion e.g. in case of IC engines

      '''others'''

        998:   When frame available
               Time Source defined in the 
               ASAP 2 keyword, FRAME

        999:   Always if there is new value
               Calculation of a new upper range 
               limit after receiving a new partial value, 
               e.g. when calculating a complex trigger 
               condition

      1000:   Non deterministic
               Without fixed scaling</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CseCodeType";xml.xsd.customType="CSE-CODE-TYPE-STRING";xml.xsd.type="unsignedInt"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:CSE-CODE-TYPE-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="CSE-CODE-TYPE-STRING--SIMPLE">
      <xsd:restriction base="xsd:unsignedInt"/>
   </xsd:simpleType>
   <xsd:complexType name="CYCLE-REPETITION-TYPE">
      <xsd:annotation>
         <xsd:documentation>The number of communication cycles (after the first cycle) whenever the frame is sent again. The FlexRay communication controller allows only determined values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:CYCLE-REPETITION-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="CYCLE-REPETITION-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CYCLE-REPETITION-1">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="1"

         valid only for FlexRay Protocol 2.1 Rev A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-10">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="10"

         to support FlexRay 3.0</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-16">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="16"

         valid only for FlexRay Protocol 2.1 Rev A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition16"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-2">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="2"

         valid only for FlexRay Protocol 2.1 Rev A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition2"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-20">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="20"

         to support FlexRay 3.0</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-32">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="32"

         valid only for FlexRay Protocol 2.1 Rev A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition32"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-4">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="4"

         valid only for FlexRay Protocol 2.1 Rev A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition4"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-40">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="40"

         to support FlexRay 3.0</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-5">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="5"

         to support FlexRay 3.0</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-50">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="50"

         to support FlexRay 3.0</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-64">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="64"

         valid only for FlexRay Protocol 2.1 Rev A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition64"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CYCLE-REPETITION-8">
            <xsd:annotation>
               <xsd:documentation>Attribute cycleRepetition value="8"

         valid only for FlexRay Protocol 2.1 Rev A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetitionType.cycleRepetition8"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DATA-FILTER-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enum specifies the supported DataFilterTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DATA-FILTER-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DATA-FILTER-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ALWAYS">
            <xsd:annotation>
               <xsd:documentation>No filtering is performed so that the message always passes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum.always"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MASKED-NEW-DIFFERS-MASKED-OLD">
            <xsd:annotation>
               <xsd:documentation>Pass messages where the masked value has changed.

         (new_value&amp;mask) !=(old_value&amp;mask)
         new_value: current value of the message
         old_value: last value of the message (initialized with the initial value of the message, updated with new_value if the new message value is not filtered out)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum.maskedNewDiffersMaskedOld"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MASKED-NEW-DIFFERS-X">
            <xsd:annotation>
               <xsd:documentation>Pass messages whose masked value is not equal to a specific value x

         (new_value&amp;mask) != x
         new_value: current value of the message</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum.maskedNewDiffersX"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MASKED-NEW-EQUALS-X">
            <xsd:annotation>
               <xsd:documentation>Pass messages whose masked value is equal to a specific value x

         (new_value&amp;amp;mask) == x
         new_value: current value of the message</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum.maskedNewEqualsX"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NEVER">
            <xsd:annotation>
               <xsd:documentation>The filter removes all messages.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum.never"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NEW-IS-OUTSIDE">
            <xsd:annotation>
               <xsd:documentation>Pass a message if its value is outside a predefined boundary.

         (min &gt; new_value) OR (new_value &gt; max)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum.newIsOutside"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NEW-IS-WITHIN">
            <xsd:annotation>
               <xsd:documentation>Pass a message if its value is within a predefined boundary.

         min &lt;= new_value &lt;= max</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum.newIsWithin"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ONE-EVERY-N">
            <xsd:annotation>
               <xsd:documentation>Pass a message once every N message occurrences.
         Algorithm: occurrence % period == offset
         Start: occurrence = 0.
         Each time the message is received or transmitted, occurrence is incremented by 1 after filtering.
         Length of occurrence is 8 bit (minimum).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataFilterTypeEnum.oneEveryN"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DATA-LIMIT-KIND-ENUM">
      <xsd:annotation>
         <xsd:documentation>Indicates whether the data element carries a minimum or maximum value, thereby limiting the current range of another value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataLimitKindEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DATA-LIMIT-KIND-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DATA-LIMIT-KIND-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MAX">
            <xsd:annotation>
               <xsd:documentation>Limitation to maximum value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataLimitKindEnum.max"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MIN">
            <xsd:annotation>
               <xsd:documentation>Limitation to minimum value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataLimitKindEnum.min"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NONE">
            <xsd:annotation>
               <xsd:documentation>No limitation applicable</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataLimitKindEnum.none"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DATA-TYPE-POLICY-ENUM">
      <xsd:annotation>
         <xsd:documentation>This class lists the supported DataTypePolicies.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataTypePolicyEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DATA-TYPE-POLICY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DATA-TYPE-POLICY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LEGACY">
            <xsd:annotation>
               <xsd:documentation>In case the System Description doesn't use a complete Software Component Description (VFB View) this value can be chosen. This supports the inclusion of legacy signals. 

         The aggregation of SwDataDefProps can be used to configure the "ComSignalDataInvalidValue" and the Data Semantics.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataTypePolicyEnum.legacy"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NETWORK-REPRESENTATION-FROM-COM-SPEC">
            <xsd:annotation>
               <xsd:documentation>If this value is chosen the ISignal network representation must be compatible to the network representation of the comspec.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataTypePolicyEnum.networkRepresentationFromComSpec"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OVERRIDE">
            <xsd:annotation>
               <xsd:documentation>If this value is chosen the requirmenents specified in the PortInterface (portInterfaceDefinition) and in the  comspec (networkRepresentationFromComSpec) are not fullfilled by the aggregated SwDataDefProps.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataTypePolicyEnum.override"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PORT-INTERFACE-DEFINITION">
            <xsd:annotation>
               <xsd:documentation>If this value is chosen the ISignal network representation must be compatible to the default datatype specified in the PortInterface (portInterfaceDefinition).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataTypePolicyEnum.portInterfaceDefinition"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DATE">
      <xsd:annotation>
         <xsd:documentation>A datatype representing a timestamp. The smallest granularity is 1 second.

      This datatype represents a timestamp in the format yyyy-mm-dd followed by an optional time. The lead-in character for the time is "T" and the format is hh:mm:ss. In addition, a time zone designator must be specified. The time zone designator can either be "Z" (for UTC) or the time offset to UTC, i.e. (+|-)hh:mm.

      Examples:

      2009-07-23

      2009-07-23T14:38:00+01:00

      2009-07-23T13:38:00Z</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DateTime";xml.xsd.customType="DATE";xml.xsd.pattern="([0-9]{4}-[0-9]{2}-[0-9]{2})(T[0-9]{2}:[0-9]{2}:[0-9]{2}(Z|([+\-][0-9]{2}:[0-9]{2})))?";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DATE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DATE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="([0-9]{4}-[0-9]{2}-[0-9]{2})(T[0-9]{2}:[0-9]{2}:[0-9]{2}(Z|([+\-][0-9]{2}:[0-9]{2})))?"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DEPENDENCY-USAGE-ENUM">
      <xsd:annotation>
         <xsd:documentation>Enumeration describing the process steps a dependency is valid in.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DependencyUsageEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DEPENDENCY-USAGE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DEPENDENCY-USAGE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BUILD">
            <xsd:annotation>
               <xsd:documentation>The object referred by the dependency is required during the build process.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyUsageEnum.build"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CODEGENERATION">
            <xsd:annotation>
               <xsd:documentation>The object referred by the dependency is required during code generation</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyUsageEnum.codegeneration"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="COMPILE">
            <xsd:annotation>
               <xsd:documentation>The object referred by the dependency is required during compilation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyUsageEnum.compile"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EXECUTE">
            <xsd:annotation>
               <xsd:documentation>The object referred by the dependency is required at execution time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyUsageEnum.execute"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LINK">
            <xsd:annotation>
               <xsd:documentation>The object referred by the dependency is required during linking.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyUsageEnum.link"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DIAG-PDU-TYPE">
      <xsd:annotation>
         <xsd:documentation>Used to distinguish a diagnostic request from a response.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagPduType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DIAG-PDU-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DIAG-PDU-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DIAG-REQUEST">
            <xsd:annotation>
               <xsd:documentation>Diagnostic Request</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagPduType.diagRequest"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DIAG-RESPONSE">
            <xsd:annotation>
               <xsd:documentation>Diagnostic Response</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagPduType.diagResponse"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DIAG-REQUIREMENT-ID-STRING">
      <xsd:annotation>
         <xsd:documentation>This string denotes an Identifier for a requirement.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagRequirementIdString";xml.xsd.customType="DIAG-REQUIREMENT-ID-STRING";xml.xsd.pattern="[0-9a-zA-Z_\-]+";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DIAG-REQUIREMENT-ID-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DIAG-REQUIREMENT-ID-STRING--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[0-9a-zA-Z_\-]+"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DIAGNOSTIC-AUDIENCE-ENUM">
      <xsd:annotation>
         <xsd:documentation>The possible values of the intended audience for a diagnostic object.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticAudienceEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DIAGNOSTIC-AUDIENCE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DIAGNOSTIC-AUDIENCE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AFTER-SALES">
            <xsd:annotation>
               <xsd:documentation>The object is relevant for the OEM after-sales organization.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticAudienceEnum.afterSales"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AFTERMAKET">
            <xsd:annotation>
               <xsd:documentation>The object is for free aftermarket service organizations.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="DiagnosticAudienceEnum.aftermaket"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AFTERMARKET">
            <xsd:annotation>
               <xsd:documentation>The object is for free aftermarket service organizations.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticAudienceEnum.aftermarket"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DEVELOPMENT">
            <xsd:annotation>
               <xsd:documentation>The object is relevant for engineering only.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticAudienceEnum.development"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MANUFACTURING">
            <xsd:annotation>
               <xsd:documentation>The object is relevant for manufacturing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticAudienceEnum.manufacturing"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SUPPLIER">
            <xsd:annotation>
               <xsd:documentation>The object is relevant for the ECU-supplier aftermarket organization.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticAudienceEnum.supplier"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DIAGNOSTIC-ROUTINE-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the different types of diagnostic routines.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticRoutineTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DIAGNOSTIC-ROUTINE-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DIAGNOSTIC-ROUTINE-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ASYNCHRONOUS">
            <xsd:annotation>
               <xsd:documentation>This indicates that the diagnostic server is not blocked while the diagnostic routine is running.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticRoutineTypeEnum.asynchronous"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SYNCHRONOUS">
            <xsd:annotation>
               <xsd:documentation>This indicates that the diagnostic routine blocks the diagnostic server in the ECU while the routine is running.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticRoutineTypeEnum.synchronous"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DIAGNOSTIC-VALUE-ACCESS-ENUM">
      <xsd:annotation>
         <xsd:documentation>Defines the access of the configured diagnostic current values which will be used by the DEM or DCM module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticValueAccessEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DIAGNOSTIC-VALUE-ACCESS-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DIAGNOSTIC-VALUE-ACCESS-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="READ-ONLY">
            <xsd:annotation>
               <xsd:documentation>The access to the data element is limited to read-only. This is typically used to read-out diagnostic information (e.g. current values).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticValueAccessEnum.readOnly"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="READ-WRITE">
            <xsd:annotation>
               <xsd:documentation>The value of the diagnostic data element is classified as configurable (read and write access is possible).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticValueAccessEnum.readWrite"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DISPLAY-FORMAT-STRING">
      <xsd:annotation>
         <xsd:documentation>This is a display format specifier for the display of values  e.g. in documents or in measurement and calibration systems. 

      The display format specifier is a subset of the ANSI C printf specifiers with the following
      form:

        % [flags] [width] [.prec] type character 

      For more details refer to "ASAM-HarmonizedDataObjects-V1.1.pdf" chapter 13.3.2 DISPLAY OF DATA. 

      Due to the numerical nature of value settings, only the following type characters are allowed:

      * d:  Signed decimal integer 
      * i:  Signed decimal integer 
      * o:  Unsigned octal integer 
      * u:  Unsigned decimal integer 
      * x:  Unsigned hexadecimal integer, using "abcdef" 
      * X:  Unsigned hexadecimal integer, using "ABCDEF" 
      * e:  Signed value having the form [-]d.dddd e [sign]ddd where d is a single decimal digit, dddd is one or more decimal digits, ddd is exactly three decimal digits, and sign is + or - 
      * E:  Identical to the e format except that E rather than e introduces the exponent 
      * f:  Signed value having the form [-]dddd.dddd, where dddd is one or more decimal digits; the number of digits before the decimal point depends on the magnitude of the number, and the number of digits after the decimal point depends on the requested precision 
      * g:  Signed value printed in f or e format, whichever is more compact for the given value and precision; trailing zeros are truncated, and the decimal point appears only if one or more digits follow it 
      * G:  Identical to the g format, except that E, rather than e, introduces the exponent (where appropriate)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DisplayFormatString";xml.xsd.customType="DISPLAY-FORMAT-STRING";xml.xsd.pattern="%[ \-+#]?[0-9]*(\.[0-9])?[diouxXfeEgGcs]";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DISPLAY-FORMAT-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DISPLAY-FORMAT-STRING--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="%[ \-+#]?[0-9]*(\.[0-9])?[diouxXfeEgGcs]"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="DTC-KIND-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator defines the possible kinds of diagnostic monitors regarding the OBD relevance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DtcKindEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:DTC-KIND-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="DTC-KIND-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EMISSION-RELATED-DTC">
            <xsd:annotation>
               <xsd:documentation>This indicates that the monitor reports a OBD relevant malfunction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DtcKindEnum.emissionRelatedDtc"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NON-EMMISSION-RELATED-DTC">
            <xsd:annotation>
               <xsd:documentation>This indicates that the monitor reports a non OBD relevant malfunction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DtcKindEnum.nonEmmissionRelatedDtc"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="E-ENUM">
      <xsd:annotation>
         <xsd:documentation>This specifies the possible kinds of emphasis as proposal how to render it on paper or screen. Note that it would have been better to use plain, weak (italic), strong (bold), veryStrong (bolditalic) ... But users complained about this.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:E-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="E-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BOLD">
            <xsd:annotation>
               <xsd:documentation>The emphasis is preferably represented in boldface font.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EEnum.bold"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BOLDITALIC">
            <xsd:annotation>
               <xsd:documentation>The emphasis is preferably represented in boldface plus italic font.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EEnum.bolditalic"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ITALIC">
            <xsd:annotation>
               <xsd:documentation>The emphasis is preferably represented in italic font.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EEnum.italic"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PLAIN">
            <xsd:annotation>
               <xsd:documentation>The emphasis has no specific rendering. It is used if e.g. semantic information is applied to the emphasis text.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EEnum.plain"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="E-ENUM-FONT">
      <xsd:annotation>
         <xsd:documentation>This specifies the possible kind of fonts to be used for emphasis.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EEnumFont"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:E-ENUM-FONT--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="E-ENUM-FONT--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEFAULT">
            <xsd:annotation>
               <xsd:documentation>The emphasis uses the default font.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EEnumFont.default"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MONO">
            <xsd:annotation>
               <xsd:documentation>The emphasis uses a monospaced font.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EEnumFont.mono"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ECUC-AFFECTION-ENUM">
      <xsd:annotation>
         <xsd:documentation>Possible affections used by the EcucConfigurationClassAffection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucAffectionEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ECUC-AFFECTION-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ECUC-AFFECTION-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LT-AFFECTS-PB">
            <xsd:annotation>
               <xsd:documentation>A link time parameter affecting one or several post-build time parameter(s).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAffectionEnum.LTAffectsPB"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-AFFECT">
            <xsd:annotation>
               <xsd:documentation>no affect on any other parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAffectionEnum.NOAffect"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PC-AFFECTS-LT">
            <xsd:annotation>
               <xsd:documentation>A pre-compile time parameter affecting one or several link time parameter(s).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAffectionEnum.PCAffectsLT"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PC-AFFECTS-LT-AND-PB">
            <xsd:annotation>
               <xsd:documentation>A pre-compile time parameter affecting one or several link time and post-build time parameter(s)).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAffectionEnum.PCAffectsLTAndPB"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PC-AFFECTS-PB">
            <xsd:annotation>
               <xsd:documentation>A pre-compile time parameter affecting one or several post build time parameter(s).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucAffectionEnum.PCAffectsPB"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ECUC-CONFIGURATION-CLASS-ENUM">
      <xsd:annotation>
         <xsd:documentation>Possible configuration classes for the AUTOSAR configuration parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationClassEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ECUC-CONFIGURATION-CLASS-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ECUC-CONFIGURATION-CLASS-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LINK">
            <xsd:annotation>
               <xsd:documentation>Link Time: parts of configuration are delivered from another object code file</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationClassEnum.Link"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="POST-BUILD">
            <xsd:annotation>
               <xsd:documentation>PostBuildTime: the configuration parameter has to be stored at a known memory location.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationClassEnum.PostBuild"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PRE-COMPILE">
            <xsd:annotation>
               <xsd:documentation>PreCompile Time: after compilation a configuration parameter can not be changed any more.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationClassEnum.PreCompile"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PUBLISHED-INFORMATION">
            <xsd:annotation>
               <xsd:documentation>PublishedInformation is used to specify the fact that certain 
         information is fixed even before the pre-compile stage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationClassEnum.PublishedInformation"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ECUC-CONFIGURATION-VARIANT-ENUM">
      <xsd:annotation>
         <xsd:documentation>Specifies the possible Configuration Variants used for AUTOSAR BSW Modules.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationVariantEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ECUC-CONFIGURATION-VARIANT-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ECUC-CONFIGURATION-VARIANT-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PRECONFIGURED-CONFIGURATION">
            <xsd:annotation>
               <xsd:documentation>Preconfigured (i.e. fixed) configuration which cannot be changed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationVariantEnum.PreconfiguredConfiguration"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RECOMMENDED-CONFIGURATION">
            <xsd:annotation>
               <xsd:documentation>Recommended configuration for a module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationVariantEnum.RecommendedConfiguration"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VARIANT-LINK-TIME">
            <xsd:annotation>
               <xsd:documentation>Specifies that the BSW Module implementation may use PreCompileTime and LinkTime configuration parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationVariantEnum.VariantLinkTime"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VARIANT-POST-BUILD">
            <xsd:annotation>
               <xsd:documentation>Specifies that the BSW Module implementation may use PreCompileTime, LinkTime and PostBuild configuration parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationVariantEnum.VariantPostBuild"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VARIANT-POST-BUILD-LOADABLE">
            <xsd:annotation>
               <xsd:documentation>Specifies that the BSW Module implementation may use PreCompileTime, LinkTime and PostBuild loadable configuration parameters (supported in the VSMD).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationVariantEnum.VariantPostBuildLoadable"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VARIANT-POST-BUILD-SELECTABLE">
            <xsd:annotation>
               <xsd:documentation>Specifies that the BSW Module implementation may use PreCompileTime, LinkTime and PostBuild selectable configuration parameters (supported in the VSMD).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationVariantEnum.VariantPostBuildSelectable"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VARIANT-PRE-COMPILE">
            <xsd:annotation>
               <xsd:documentation>Specifies that the BSW Module implementation uses only PreCompileTime configuration parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcucConfigurationVariantEnum.VariantPreCompile"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="EXECUTION-TIME-TYPE-ENUM">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTimeTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:EXECUTION-TIME-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="EXECUTION-TIME-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="GROSS">
            <xsd:annotation>
               <xsd:documentation>Indicates that the given execution time is the time used to execute the ExecutableEntity without any interruption and and including external calls.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTimeTypeEnum.gross"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NET">
            <xsd:annotation>
               <xsd:documentation>Indicates that the given execution time is the time used to execute the ExecutableEntity without any interruption and without any external calls.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTimeTypeEnum.net"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="EXT-ID-CLASS-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is in fact an enumerator. The possible values are all legal XML names of identifiable objects even those of other XML files. 

      If the schemas of all questionable files are generated from a common meta-model, this is something like an IdentifiableSubtypesEnum. Maybe a future version of the Schema generator can generate such an enum.

      As of now it is specified as string.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExtIdClassEnum";xml.xsd.customType="EXT-ID-CLASS-ENUM";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:EXT-ID-CLASS-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="EXT-ID-CLASS-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>
   <xsd:complexType name="FILTER-DEBOUNCING-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumeration defines possible values for the filter debouncing strategy.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FilterDebouncingEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:FILTER-DEBOUNCING-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="FILTER-DEBOUNCING-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEBOUNCE-DATA">
            <xsd:annotation>
               <xsd:documentation>The signal is a
         mean value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FilterDebouncingEnum.debounceData"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RAW-DATA">
            <xsd:annotation>
               <xsd:documentation>Means that no modification of the
         signal has been applied. This is the default
         value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FilterDebouncingEnum.rawData"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="WAIT-TIME-DATE">
            <xsd:annotation>
               <xsd:documentation>The signal is delivered by a GET operation after a certain amount of time</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FilterDebouncingEnum.waitTimeDate"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="FLEXRAY-CHANNEL-NAME">
      <xsd:annotation>
         <xsd:documentation>Name of the channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayChannelName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:FLEXRAY-CHANNEL-NAME--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-CHANNEL-NAME--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CHANNEL-A">
            <xsd:annotation>
               <xsd:documentation>Channel A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayChannelName.channelA"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CHANNEL-B">
            <xsd:annotation>
               <xsd:documentation>Channel B</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayChannelName.channelB"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="FLEXRAY-NM-SCHEDULE-VARIANT">
      <xsd:annotation>
         <xsd:documentation>FrNm schedule variant according to FrNm SWS.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmScheduleVariant"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:FLEXRAY-NM-SCHEDULE-VARIANT--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-NM-SCHEDULE-VARIANT--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SCHEDULE-VARIANT-1">
            <xsd:annotation>
               <xsd:documentation>NM-Vote and NM Data transmitted within one PDU in static segment. The NM-Vote has to be realized as separate bit within the PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmScheduleVariant.scheduleVariant1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SCHEDULE-VARIANT-2">
            <xsd:annotation>
               <xsd:documentation>NM-Vote and NM-Data transmitted within one PDU in dynamic segment. The presence (or non-presence) of the PDU corresponds to the NM-Vote</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmScheduleVariant.scheduleVariant2"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SCHEDULE-VARIANT-3">
            <xsd:annotation>
               <xsd:documentation>NM-Vote and NM-Data are transmitted in the static segment in separate PDUs. This alternative is not recommended =&gt; Alternative 1 should be used instead.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmScheduleVariant.scheduleVariant3"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SCHEDULE-VARIANT-4">
            <xsd:annotation>
               <xsd:documentation>NM-Vote transmitted in static and NM-Data transmitted in dynamic segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmScheduleVariant.scheduleVariant4"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SCHEDULE-VARIANT-5">
            <xsd:annotation>
               <xsd:documentation>NM-Vote is transmitted in dynamic and NM-Data is transmitted in static segment. This alternative is not recommended =&gt; Variants 2 or 6 should be used instead.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmScheduleVariant.scheduleVariant5"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SCHEDULE-VARIANT-6">
            <xsd:annotation>
               <xsd:documentation>NM-Vote and NM-Data are transmitted in dynamic segment in separate PDUs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmScheduleVariant.scheduleVariant6"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SCHEDULE-VARIANT-7">
            <xsd:annotation>
               <xsd:documentation>NM-Vote and a copy of the CBV are transmitted in the static segment (using the FlexRay NM Vector support) and NM-Data is transmitted in the dynamic segment</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayNmScheduleVariant.scheduleVariant7"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="FLOAT">
      <xsd:annotation>
         <xsd:documentation>An instance of Float is an element from the set of real numbers. The value must comply with IEEE 754 and is limited to what can be expressed by a 64 bit binary representation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Float";xml.xsd.customType="FLOAT";xml.xsd.type="double"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:FLOAT--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="FLOAT--SIMPLE">
      <xsd:restriction base="xsd:double"/>
   </xsd:simpleType>
   <xsd:complexType name="FLOAT-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the policy how an objects floats on a page.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FloatEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:FLOAT-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="FLOAT-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLOAT">
            <xsd:annotation>
               <xsd:documentation>This indicates that a page formatter is allowed to float the table to optimize the pagination. This is for example supported by TeX.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FloatEnum.float"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-FLOAT">
            <xsd:annotation>
               <xsd:documentation>This indicates that a page formatter is not allowed to float the object to optimize the pagination.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FloatEnum.noFloat"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="FR-AR-TP-ACK-TYPE">
      <xsd:annotation>
         <xsd:documentation>Type of Acknowledgement.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrArTpAckType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:FR-AR-TP-ACK-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="FR-AR-TP-ACK-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ACK-WITH-RT">
            <xsd:annotation>
               <xsd:documentation>Acknowledgement with retry.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrArTpAckType.ackWithRt"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ACK-WITHOUT-RT">
            <xsd:annotation>
               <xsd:documentation>Acknowledgement without retry.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrArTpAckType.ackWithoutRt"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-ACK">
            <xsd:annotation>
               <xsd:documentation>No acknowledgement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrArTpAckType.noAck"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="FRAME-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the policy, where to place a frame border around the table.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrameEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:FRAME-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="FRAME-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ALL">
            <xsd:annotation>
               <xsd:documentation>Borders all around the table</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameEnum.all"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BOTTOM">
            <xsd:annotation>
               <xsd:documentation>Border at the bottom of the table</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameEnum.bottom"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NONE">
            <xsd:annotation>
               <xsd:documentation>No borders around the table</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameEnum.none"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SIDES">
            <xsd:annotation>
               <xsd:documentation>Borders at the sides of the table</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameEnum.sides"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TOP">
            <xsd:annotation>
               <xsd:documentation>Border at the top of the table</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameEnum.top"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TOPBOT">
            <xsd:annotation>
               <xsd:documentation>Borders at the top and bottom of  the table</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameEnum.topbot"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="GRAPHIC-FIT-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the policy how to place and scale the figure on the page.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:GRAPHIC-FIT-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="GRAPHIC-FIT-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AS-IS">
            <xsd:annotation>
               <xsd:documentation>This indicates that the image shall be incorporated as is without scaling, rotation etc.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.AsIs"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FIT-TO-PAGE">
            <xsd:annotation>
               <xsd:documentation>Fit to the page</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.FitToPage"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FIT-TO-TEXT">
            <xsd:annotation>
               <xsd:documentation>fit to the text containing the graphic.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.FitToText"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LIMIT-TO-PAGE">
            <xsd:annotation>
               <xsd:documentation>This indicates that the width of the graphic shall be limited to the '''page width'''. The image shall not be scaled down but cropped.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.LimitToPage"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LIMIT-TO-TEXT">
            <xsd:annotation>
               <xsd:documentation>This indicates that the width of the graphic shall be limited to the width of the current '''text flow'''. The image shall not be scaled down but cropped.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.LimitToText"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ROTATE-180">
            <xsd:annotation>
               <xsd:documentation>Rotate 180 degree</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.Rotate180"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ROTATE-180-LIMIT-TO-TEXT">
            <xsd:annotation>
               <xsd:documentation>Rotate 180 degree</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.Rotate180LimitToText"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ROTATE-90-CCW">
            <xsd:annotation>
               <xsd:documentation>Rotate 90 degree counter clockwise</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.Rotate90ccw"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ROTATE-90-CCW-FIT-TO-TEXT">
            <xsd:annotation>
               <xsd:documentation>Rotate by 90 degree counter clock wise and then fit to text</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.Rotate90CcwFitToText"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ROTATE-90-CCW-LIMIT-TO-TEXT">
            <xsd:annotation>
               <xsd:documentation>Rotate by 90 degree counter clock wise and then fit to text</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.Rotate90CcwLimitToText"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ROTATE-90-CW">
            <xsd:annotation>
               <xsd:documentation>Rotate 90 degree clockwise</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.Rotate90Cw"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ROTATE-90-CW-FIT-TO-TEXT">
            <xsd:annotation>
               <xsd:documentation>Rotate by 90 degree and then fit to text</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.Rotate90CwFitToText"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ROTATE-90-CW-LIMIT-TO-TEXT">
            <xsd:annotation>
               <xsd:documentation>Rotate by 90 degree and then fit to text</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicFitEnum.Rotate90CwLimitToText"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="GRAPHIC-NOTATION-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the various notations (finally file types) used to represent the figure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="GraphicNotationEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:GRAPHIC-NOTATION-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="GRAPHIC-NOTATION-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EPS">
            <xsd:annotation>
               <xsd:documentation>Encapsulated Postscript</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicNotationEnum.eps"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="GIF">
            <xsd:annotation>
               <xsd:documentation>Graphics Interchange Format</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicNotationEnum.gif"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="JPG">
            <xsd:annotation>
               <xsd:documentation>"Joint Photographic Experts Group"  format</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicNotationEnum.jpg"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SVG">
            <xsd:annotation>
               <xsd:documentation>scalable vector graphic</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GraphicNotationEnum.svg"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="HANDLE-INVALID-ENUM">
      <xsd:annotation>
         <xsd:documentation>Strategies of handling the reception of invalidValue.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HandleInvalidEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:HANDLE-INVALID-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="HANDLE-INVALID-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DONT-INVALIDATE">
            <xsd:annotation>
               <xsd:documentation>Invalidation is switched off.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleInvalidEnum.dontInvalidate"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KEEP">
            <xsd:annotation>
               <xsd:documentation>The application software is supposed to  handle signal invalidation on RTE API level either by DataReceiveErrorEvent or check of error code on read access.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleInvalidEnum.keep"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="REPLACE">
            <xsd:annotation>
               <xsd:documentation>Replace a received invalidValue. The replacement value is specified by the initValue.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleInvalidEnum.replace"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="HANDLE-OUT-OF-RANGE-ENUM">
      <xsd:annotation>
         <xsd:documentation>A value of this type is taken for controlling the range checking behavior of the AUTOSAR RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:HANDLE-OUT-OF-RANGE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="HANDLE-OUT-OF-RANGE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEFAULT">
            <xsd:annotation>
               <xsd:documentation>The RTE will use the initValue if the actual value is out of the specified bounds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeEnum.default"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EXTERNAL-REPLACEMENT">
            <xsd:annotation>
               <xsd:documentation>This indicates that the value replacement is sourced from the externalReplacement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeEnum.externalReplacement"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="IGNORE">
            <xsd:annotation>
               <xsd:documentation>The RTE will ignore any attempt to send or receive the corresponding dataElement if the value is out of the specified range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeEnum.ignore"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INVALID">
            <xsd:annotation>
               <xsd:documentation>The RTE will use the invalidValue if the value is out of the specified bounds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeEnum.invalid"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NONE">
            <xsd:annotation>
               <xsd:documentation>A range check is not required.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeEnum.none"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SATURATE">
            <xsd:annotation>
               <xsd:documentation>The RTE will saturate the value of the dataElement such that it is limited to the applicable upper bound if it is greater than the upper bound. Consequently, it is limited to the applicable lower bound if the value is less than the lower bound.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeEnum.saturate"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="HANDLE-OUT-OF-RANGE-STATUS-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumeration defines how the RTE handles values that are out of range.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeStatusEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:HANDLE-OUT-OF-RANGE-STATUS-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="HANDLE-OUT-OF-RANGE-STATUS-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INDICATE">
            <xsd:annotation>
               <xsd:documentation>The RTE sets the return status to RTE_E_OUT_OF_RANGE if the received value is out of range and the attribute handleOutOfRange is not set to "none" or "invalid".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeStatusEnum.indicate"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SILENT">
            <xsd:annotation>
               <xsd:documentation>The RTE sets the return status to RTE_E_OK</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleOutOfRangeStatusEnum.silent"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="HANDLE-TERMINATION-AND-RESTART-ENUM">
      <xsd:annotation>
         <xsd:documentation>Controls the behavior of an AtomicSwComponentType with respect to stop and restart.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HandleTerminationAndRestartEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:HANDLE-TERMINATION-AND-RESTART-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="HANDLE-TERMINATION-AND-RESTART-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-BE-TERMINATED">
            <xsd:annotation>
               <xsd:documentation>Supports termination.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleTerminationAndRestartEnum.canBeTerminated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CAN-BE-TERMINATED-AND-RESTARTED">
            <xsd:annotation>
               <xsd:documentation>Supports termination and restarting.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleTerminationAndRestartEnum.canBeTerminatedAndRestarted"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-SUPPORT">
            <xsd:annotation>
               <xsd:documentation>Stop and restart is not supported at all.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleTerminationAndRestartEnum.noSupport"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="HANDLE-TIMEOUT-ENUM">
      <xsd:annotation>
         <xsd:documentation>Strategies of handling a reception timeout violation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HandleTimeoutEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:HANDLE-TIMEOUT-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="HANDLE-TIMEOUT-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NONE">
            <xsd:annotation>
               <xsd:documentation>If set to none no replacement shall take place.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleTimeoutEnum.none"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="REPLACE">
            <xsd:annotation>
               <xsd:documentation>If set to replace, the replacement value used shall be the  ComInitValue.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HandleTimeoutEnum.replace"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="INTEGER">
      <xsd:annotation>
         <xsd:documentation>An instance of Integer is an element in the set of integer numbers ( ..., -2, -1, 0, 1, 2, ...).  

      The value can be expressed in decimal, octal, hexadecimal and binary representation. Negative numbers can only be expressed in decimal notation

      Range is from -2147483648 and 2147483647.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Integer";xml.xsd.customType="INTEGER";xml.xsd.pattern="[+\-]?[1-9][0-9]*|0x[0-9a-f]*|0[0-7]*|0b[0-1]*";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:INTEGER--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="INTEGER--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[+\-]?[1-9][0-9]*|0x[0-9a-f]*|0[0-7]*|0b[0-1]*"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="INTERVAL-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the type of an interval.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntervalTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:INTERVAL-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="INTERVAL-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLOSED">
            <xsd:annotation>
               <xsd:documentation>The area is limited by the value given. The value itself is included.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IntervalTypeEnum.closed"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INFINITE">
            <xsd:annotation>
               <xsd:documentation>The area is unlimited. (- or + depending on lower or higher Limit). Note that in this case the numerical value specified in the limit has no relevance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IntervalTypeEnum.infinite"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OPEN">
            <xsd:annotation>
               <xsd:documentation>The area is limited by the value given. The value itself is not included.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IntervalTypeEnum.open"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ITEM-LABEL-POS-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies, how the label of a labeled list shall be rendered.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ItemLabelPosEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ITEM-LABEL-POS-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ITEM-LABEL-POS-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NEWLINE">
            <xsd:annotation>
               <xsd:documentation>The label is renders in a new line.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ItemLabelPosEnum.newline"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NEWLINE-IF-NECESSARY">
            <xsd:annotation>
               <xsd:documentation>The label is rendered in a new line if it is longer than the indentation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ItemLabelPosEnum.newlineIfNecessary"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-NEWLINE">
            <xsd:annotation>
               <xsd:documentation>The label is rendered in one line with the item even if it is longer than the indentation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ItemLabelPosEnum.noNewline"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="KEEP-WITH-PREVIOUS-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies a page break policy by controlling blocks which shall be kept together.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="KeepWithPreviousEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:KEEP-WITH-PREVIOUS-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="KEEP-WITH-PREVIOUS-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="KEEP">
            <xsd:annotation>
               <xsd:documentation>This indicates that the block shall be kept together with the previous block.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="KeepWithPreviousEnum.keep"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-KEEP">
            <xsd:annotation>
               <xsd:documentation>This indicates that there is no need to keep the block with the previous one. This is the same as if the attribute itself is missing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="KeepWithPreviousEnum.noKeep"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="L-ENUM">
      <xsd:annotation>
         <xsd:documentation>This denotes the possible language designators according to the two letter code of ISO 693.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:L-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="L-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AA">
            <xsd:annotation>
               <xsd:documentation>Afar</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.aa"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AB">
            <xsd:annotation>
               <xsd:documentation>Abkhazian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ab"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AF">
            <xsd:annotation>
               <xsd:documentation>Afrikaans</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.af"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AM">
            <xsd:annotation>
               <xsd:documentation>Amharic</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.am"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AR">
            <xsd:annotation>
               <xsd:documentation>Arabic</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ar"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AS">
            <xsd:annotation>
               <xsd:documentation>Assamese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.as"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AY">
            <xsd:annotation>
               <xsd:documentation>Aymara</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ay"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="AZ">
            <xsd:annotation>
               <xsd:documentation>Azerbaijani</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.az"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BA">
            <xsd:annotation>
               <xsd:documentation>Bashkir</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ba"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BE">
            <xsd:annotation>
               <xsd:documentation>Byelorussian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.be"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BG">
            <xsd:annotation>
               <xsd:documentation>Bulgarian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.bg"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BH">
            <xsd:annotation>
               <xsd:documentation>Bihari</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.bh"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BI">
            <xsd:annotation>
               <xsd:documentation>Bislama</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.bi"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BN">
            <xsd:annotation>
               <xsd:documentation>Bengali</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.bn"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BO">
            <xsd:annotation>
               <xsd:documentation>Tibetian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.bo"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BR">
            <xsd:annotation>
               <xsd:documentation>Breton</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.br"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CA">
            <xsd:annotation>
               <xsd:documentation>Catalan</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ca"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CO">
            <xsd:annotation>
               <xsd:documentation>Corsican</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.co"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CS">
            <xsd:annotation>
               <xsd:documentation>Czech</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.cs"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CY">
            <xsd:annotation>
               <xsd:documentation>Welsh</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.cy"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DA">
            <xsd:annotation>
               <xsd:documentation>Danish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.da"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DE">
            <xsd:annotation>
               <xsd:documentation>German</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.de";xml.attribute="true"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DZ">
            <xsd:annotation>
               <xsd:documentation>Bhutani</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.dz"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EL">
            <xsd:annotation>
               <xsd:documentation>Greek</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.el"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EN">
            <xsd:annotation>
               <xsd:documentation>English</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.en";xml.attribute="true"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EO">
            <xsd:annotation>
               <xsd:documentation>Esperanto</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.eo"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ES">
            <xsd:annotation>
               <xsd:documentation>Spanish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.es"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ET">
            <xsd:annotation>
               <xsd:documentation>Estonian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.et"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EU">
            <xsd:annotation>
               <xsd:documentation>Basque</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.eu"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FA">
            <xsd:annotation>
               <xsd:documentation>Persian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.fa"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FI">
            <xsd:annotation>
               <xsd:documentation>Finnish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.fi"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FJ">
            <xsd:annotation>
               <xsd:documentation>Fiji</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.fj"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FO">
            <xsd:annotation>
               <xsd:documentation>Faeroese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.fo"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FOR-ALL">
            <xsd:annotation>
               <xsd:documentation>The content applies to all languages</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.forAll"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FR">
            <xsd:annotation>
               <xsd:documentation>French</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.fr";xml.attribute="true"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FY">
            <xsd:annotation>
               <xsd:documentation>Frisian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.fy"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="GA">
            <xsd:annotation>
               <xsd:documentation>Irish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ga"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="GD">
            <xsd:annotation>
               <xsd:documentation>Scots Gaelic</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.gd"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="GL">
            <xsd:annotation>
               <xsd:documentation>Galician</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.gl"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="GN">
            <xsd:annotation>
               <xsd:documentation>Guarani</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.gn"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="GU">
            <xsd:annotation>
               <xsd:documentation>Gjarati</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.gu"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="HA">
            <xsd:annotation>
               <xsd:documentation>Hausa</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ha"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="HI">
            <xsd:annotation>
               <xsd:documentation>Hindi</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.hi"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="HR">
            <xsd:annotation>
               <xsd:documentation>Croatian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.hr"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="HU">
            <xsd:annotation>
               <xsd:documentation>Hungarian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.hu"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="HY">
            <xsd:annotation>
               <xsd:documentation>Armenian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.hy"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="IA">
            <xsd:annotation>
               <xsd:documentation>Interlingua</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ia"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="IE">
            <xsd:annotation>
               <xsd:documentation>Interlingue</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ie"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="IK">
            <xsd:annotation>
               <xsd:documentation>Inupiak</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ik"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="IN">
            <xsd:annotation>
               <xsd:documentation>Indonesian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.in"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="IS">
            <xsd:annotation>
               <xsd:documentation>Icelandic</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.is"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="IT">
            <xsd:annotation>
               <xsd:documentation>Italian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.it";xml.attribute="true"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="IW">
            <xsd:annotation>
               <xsd:documentation>Hebrew</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.iw"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="JA">
            <xsd:annotation>
               <xsd:documentation>Japanese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ja"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="JI">
            <xsd:annotation>
               <xsd:documentation>Yiddish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ji"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="JW">
            <xsd:annotation>
               <xsd:documentation>Javanese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.jw"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KA">
            <xsd:annotation>
               <xsd:documentation>Georgian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ka"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KK">
            <xsd:annotation>
               <xsd:documentation>Kazakh</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.kk"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KL">
            <xsd:annotation>
               <xsd:documentation>Greenlandic</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.kl"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KM">
            <xsd:annotation>
               <xsd:documentation>Cambodian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.km"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KN">
            <xsd:annotation>
               <xsd:documentation>Kannada</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.kn"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KO">
            <xsd:annotation>
               <xsd:documentation>Korean</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ko"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KS">
            <xsd:annotation>
               <xsd:documentation>Kashmiri</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ks"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KU">
            <xsd:annotation>
               <xsd:documentation>Kurdish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ku"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="KY">
            <xsd:annotation>
               <xsd:documentation>Kirghiz</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ky"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LA">
            <xsd:annotation>
               <xsd:documentation>Latin</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.la"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LN">
            <xsd:annotation>
               <xsd:documentation>Lingala</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ln"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LO">
            <xsd:annotation>
               <xsd:documentation>Laothian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.lo"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LT">
            <xsd:annotation>
               <xsd:documentation>Lithuanian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.lt"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LV">
            <xsd:annotation>
               <xsd:documentation>Lavian, Lettish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.lv"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MG">
            <xsd:annotation>
               <xsd:documentation>Malagasy</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.mg"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MI">
            <xsd:annotation>
               <xsd:documentation>Maori</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.mi"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MK">
            <xsd:annotation>
               <xsd:documentation>Macedonian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.mk"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ML">
            <xsd:annotation>
               <xsd:documentation>Malayalam</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ml"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MN">
            <xsd:annotation>
               <xsd:documentation>Mongolian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.mn"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MO">
            <xsd:annotation>
               <xsd:documentation>Moldavian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.mo"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MR">
            <xsd:annotation>
               <xsd:documentation>Marathi</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.mr"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MS">
            <xsd:annotation>
               <xsd:documentation>Malay</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ms"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MT">
            <xsd:annotation>
               <xsd:documentation>Maltese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.mt"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MY">
            <xsd:annotation>
               <xsd:documentation>Burmese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.my"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NA">
            <xsd:annotation>
               <xsd:documentation>Nauru</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.na"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NE">
            <xsd:annotation>
               <xsd:documentation>Nepali</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ne"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NL">
            <xsd:annotation>
               <xsd:documentation>Dutch</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.nl"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO">
            <xsd:annotation>
               <xsd:documentation>Norwegian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.no"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OC">
            <xsd:annotation>
               <xsd:documentation>Occitan</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.oc"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OM">
            <xsd:annotation>
               <xsd:documentation>(Afan) Oromo</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.om"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OR">
            <xsd:annotation>
               <xsd:documentation>Oriya</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.or"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PA">
            <xsd:annotation>
               <xsd:documentation>Punjabi</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.pa"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PL">
            <xsd:annotation>
               <xsd:documentation>Polish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.pl"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PS">
            <xsd:annotation>
               <xsd:documentation>Pashto, Pushto</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ps"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PT">
            <xsd:annotation>
               <xsd:documentation>Portuguese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.pt"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="QU">
            <xsd:annotation>
               <xsd:documentation>Quechua</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.qu"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RM">
            <xsd:annotation>
               <xsd:documentation>Rhaeto-Romance</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.rm"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RN">
            <xsd:annotation>
               <xsd:documentation>Kirundi</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.rn"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RO">
            <xsd:annotation>
               <xsd:documentation>Romanian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ro"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RU">
            <xsd:annotation>
               <xsd:documentation>Russian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ru"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RW">
            <xsd:annotation>
               <xsd:documentation>Kinyarwanda</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.rw"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SA">
            <xsd:annotation>
               <xsd:documentation>Sanskrit</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sa"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SD">
            <xsd:annotation>
               <xsd:documentation>Sindhi</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sd"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SG">
            <xsd:annotation>
               <xsd:documentation>Sangro</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sg"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SH">
            <xsd:annotation>
               <xsd:documentation>Serbo-Croatian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sh"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SI">
            <xsd:annotation>
               <xsd:documentation>Singhalese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.si"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SK">
            <xsd:annotation>
               <xsd:documentation>Slovak</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sk"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SL">
            <xsd:annotation>
               <xsd:documentation>Slovenian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sl"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SM">
            <xsd:annotation>
               <xsd:documentation>Samoan</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sm"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SN">
            <xsd:annotation>
               <xsd:documentation>Shona</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sn"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SO">
            <xsd:annotation>
               <xsd:documentation>Somali</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.so"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SQ">
            <xsd:annotation>
               <xsd:documentation>Albanian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sq"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SR">
            <xsd:annotation>
               <xsd:documentation>Serbian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sr"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SS">
            <xsd:annotation>
               <xsd:documentation>Siswati</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ss"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ST">
            <xsd:annotation>
               <xsd:documentation>Sesotho</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.st"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SU">
            <xsd:annotation>
               <xsd:documentation>Sundanese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.su"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SV">
            <xsd:annotation>
               <xsd:documentation>Swedish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sv"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SW">
            <xsd:annotation>
               <xsd:documentation>Swahili</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.sw"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TA">
            <xsd:annotation>
               <xsd:documentation>Tamil</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ta"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TE">
            <xsd:annotation>
               <xsd:documentation>Tegulu</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.te"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TG">
            <xsd:annotation>
               <xsd:documentation>Tajik</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.tg"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TH">
            <xsd:annotation>
               <xsd:documentation>Thai</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.th"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TI">
            <xsd:annotation>
               <xsd:documentation>Tigrinya</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ti"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TK">
            <xsd:annotation>
               <xsd:documentation>Turkmen</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.tk"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TL">
            <xsd:annotation>
               <xsd:documentation>Tagalog</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.tl"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TN">
            <xsd:annotation>
               <xsd:documentation>Setswana</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.tn"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TO">
            <xsd:annotation>
               <xsd:documentation>Tonga</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.to"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TR">
            <xsd:annotation>
               <xsd:documentation>Turkish</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.tr"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TS">
            <xsd:annotation>
               <xsd:documentation>Tsonga</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ts"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TT">
            <xsd:annotation>
               <xsd:documentation>Tatar</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.tt"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TW">
            <xsd:annotation>
               <xsd:documentation>Twi</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.tw"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="UK">
            <xsd:annotation>
               <xsd:documentation>Ukrainian</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.uk"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="UR">
            <xsd:annotation>
               <xsd:documentation>Urdu</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.ur"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="UZ">
            <xsd:annotation>
               <xsd:documentation>Uzbek</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.uz"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VI">
            <xsd:annotation>
               <xsd:documentation>Vietnamese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.vi"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VO">
            <xsd:annotation>
               <xsd:documentation>Volapuk</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.vo"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="WO">
            <xsd:annotation>
               <xsd:documentation>Wolof</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.wo"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="XH">
            <xsd:annotation>
               <xsd:documentation>Xhosa</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.xh"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="YO">
            <xsd:annotation>
               <xsd:documentation>Yoruba</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.yo"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ZH">
            <xsd:annotation>
               <xsd:documentation>Chinese</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.zh"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ZU">
            <xsd:annotation>
               <xsd:documentation>Zulu</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LEnum.zu"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="LATENCY-CONSTRAINT-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the type of the latency timing constraint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LatencyConstraintTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:LATENCY-CONSTRAINT-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="LATENCY-CONSTRAINT-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AGE">
            <xsd:annotation>
               <xsd:documentation>In this case, the latency constraint is seen from the perspective of the response event of the associated event chain. Given a certain response event, the age interval of the latest stimulus is constrained.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LatencyConstraintTypeEnum.age"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="REACTION">
            <xsd:annotation>
               <xsd:documentation>In this case, the latency constraint is seen from the perspective of the stimulus event of the associated event chain. Given a certain stimulus event, the reaction interval of the first response is constrained.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LatencyConstraintTypeEnum.reaction"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="LIN-CHECKSUM-TYPE">
      <xsd:annotation>
         <xsd:documentation>Use of classic or enhanced checksum is managed by the master node and it is determined per frame identifier;</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinChecksumType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:LIN-CHECKSUM-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="LIN-CHECKSUM-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLASSIC">
            <xsd:annotation>
               <xsd:documentation>Classic in communication with LIN 1.3 slave nodes</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinChecksumType.classic"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ENHANCED">
            <xsd:annotation>
               <xsd:documentation>Enhanced in communication with LIN 2.0 slave nodes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinChecksumType.enhanced"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="LIST-ENUM">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the notation of the various types of lists.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ListEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:LIST-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="LIST-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NUMBER">
            <xsd:annotation>
               <xsd:documentation>This indicates that the list is an numerated list.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ListEnum.number"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="UNNUMBER">
            <xsd:annotation>
               <xsd:documentation>This indicates that it is an enumeration (bulleted list)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ListEnum.unnumber"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="MAPPING-DIRECTION-ENUM">
      <xsd:annotation>
         <xsd:documentation>Specifies the conversion direction for which the mapping is applicable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MappingDirectionEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MAPPING-DIRECTION-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MAPPING-DIRECTION-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BIDIRECTIONAL">
            <xsd:annotation>
               <xsd:documentation>The TextTableMapping is applicable in both directions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MappingDirectionEnum.bidirectional"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FIRST-TO-SECOND">
            <xsd:annotation>
               <xsd:documentation>The TextTableMapping is applicable in the direction from firstDataPrototype / firstOperationArgument referring into the PortInterface of the PPortPrototype to secondDataPrototype / secondOperationArgument referring into the PortInterface of the RPortPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MappingDirectionEnum.firstToSecond"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SECOND-TO-FIRST">
            <xsd:annotation>
               <xsd:documentation>The TextTableMapping is applicable in the direction from secondDataPrototype / secondOperationArgument referring into the PortInterface of the PPortPrototype to firstDataPrototype / firstOperationArgument referring into the PortInterface of the RPortPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MappingDirectionEnum.secondToFirst"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="MAX-COMM-MODE-ENUM">
      <xsd:annotation>
         <xsd:documentation>Maximum bus communication mode required by a user of the Communication Manager Service.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MaxCommModeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MAX-COMM-MODE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MAX-COMM-MODE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FULL">
            <xsd:annotation>
               <xsd:documentation>Full communication is requested.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaxCommModeEnum.full"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NONE">
            <xsd:annotation>
               <xsd:documentation>No communication is requested.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaxCommModeEnum.none"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SILENT">
            <xsd:annotation>
               <xsd:documentation>Silent communication is requested: Only listening but not "talking".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaxCommModeEnum.silent"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="MAXIMUM-MESSAGE-LENGTH-TYPE">
      <xsd:annotation>
         <xsd:documentation>Type of Acknowledgement.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MaximumMessageLengthType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MAXIMUM-MESSAGE-LENGTH-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MAXIMUM-MESSAGE-LENGTH-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-4-G">
            <xsd:annotation>
               <xsd:documentation>SF-E allowed (SF of arbitrary length depending on FrTpPduLength), up to (2**32)-1 byte message length (all FF-x allowed).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaximumMessageLengthType.I4g"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ISO">
            <xsd:annotation>
               <xsd:documentation>Up to (2**12)-1 Byte message length (No FF-Ex or SF-E or AF shall be used and recognized).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaximumMessageLengthType.iso"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ISO-6">
            <xsd:annotation>
               <xsd:documentation>As ISO, but the maximum payload length is limited to 6 byte (SF-I, FF-I, CF). This is necessary to route TP on CAN when using Extended Addressing or Mixed Addressing on CAN.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaximumMessageLengthType.iso6"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="MEMORY-ALLOCATION-KEYWORD-POLICY-TYPE">
      <xsd:annotation>
         <xsd:documentation>Enumeration to specify the name pattern of the Memory Allocation Keyword.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemoryAllocationKeywordPolicyType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MEMORY-ALLOCATION-KEYWORD-POLICY-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MEMORY-ALLOCATION-KEYWORD-POLICY-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ADDR-METHOD-SHORT-NAME">
            <xsd:annotation>
               <xsd:documentation>The MemorySection shortNames of referring MemorySections and therefore the belonging Memory Allocation Keywords in the code are build with the shortName of the SwAddrMethod. This is the default value if the attribute does not exist.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemoryAllocationKeywordPolicyType.AddrMethodShortName"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ADDR-METHOD-SHORT-NAME-AND-ALIGNMENT">
            <xsd:annotation>
               <xsd:documentation>The MemorySection shortNames of referring MemorySections and therefore the belonging Memory Allocation Keywords in the code are build with the shortName of the SwAddrMethod and the alignment attribute of the MemorySection. This requests a separation of objects in memory dependent from the alignment and is not applicable for SwAddrMethods referred by RunnableEntitys and BswSchedulableEntitys.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemoryAllocationKeywordPolicyType.AddrMethodShortNameAndAlignment"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="MEMORY-SECTION-TYPE">
      <xsd:annotation>
         <xsd:documentation>Enumeration to specify the essential nature of the data which can be allocated in a common memory class by the means of the AUTOSAR Memory Mapping.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MEMORY-SECTION-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MEMORY-SECTION-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CALIBRATION-OFFLINE">
            <xsd:annotation>
               <xsd:documentation>Program data which can only be used for offline calibration.

         '''Note''': This value is deprecated and shall be substituted by calPrm.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="MemorySectionType.calibrationOffline"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CALIBRATION-ONLINE">
            <xsd:annotation>
               <xsd:documentation>Program data which can be used for online calibration.

         '''Note''': This value is deprecated and shall be substituted by calPrm.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="MemorySectionType.calibrationOnline"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CALIBRATION-VARIABLES">
            <xsd:annotation>
               <xsd:documentation>Values which are available in the ECU but do not exist in the Hex-file. No upload is required to obtain access to the ECU data. The ECU will never be touched by the instrumentation tool with the exception of upload. These are calculated values which are not represented in the CPU memory (no address is associated).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionType.calibrationVariables"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CALPRM">
            <xsd:annotation>
               <xsd:documentation>To be used for calibratable constants of ECU-functions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionType.calprm"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CODE">
            <xsd:annotation>
               <xsd:documentation>To be used for mapping code to application block, boot block, external flash etc.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionType.code"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CONFIG-DATA">
            <xsd:annotation>
               <xsd:documentation>Constants with attributes that show that they reside in one segment for module configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionType.configData"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CONST">
            <xsd:annotation>
               <xsd:documentation>To be used for global or static constants.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionType.const"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EXCLUDE-FROM-FLASH">
            <xsd:annotation>
               <xsd:documentation>Values existing in the ECU but not dropped down in the binary file. No upload should be needed to obtain access to the ECU data. The ECU will never be touched by the instrumentation tool, with the exception of upload. These are memory areas which are not overwritten by downloading the executable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionType.excludeFromFlash"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="USER-DEFINED">
            <xsd:annotation>
               <xsd:documentation>No specific categorization of sectionType possible.

         '''Note''': This value is deprecated and shall be substituted by var, code, const, calprm, configData, excludeFromFlash and the appropriate values of the orthogonal attributes sectionInitializationPolicy, memoryAllocationKeywordPolicy and option.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="MemorySectionType.userDefined"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VAR">
            <xsd:annotation>
               <xsd:documentation>To be used for global or static variables. The expected initialization is specified with the attribute sectionInitializationPolicy.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionType.var"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VAR-FAST">
            <xsd:annotation>
               <xsd:documentation>To be used for all global or static variables that have at least one of the following properties: - accessed bit-wise - frequently used - high number of accesses in source code Some platforms allow the use of bit instructions for variables located in this specific RAM area as well as shorter addressing instructions. This saves code and runtime.

         '''Note''': This value is deprecated and shall be substituted by var and the appropriate values of the orthogonal attributes sectionInitializationPolicy, memoryAllocationKeywordPolicy and option.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="MemorySectionType.varFast"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VAR-NO-INIT">
            <xsd:annotation>
               <xsd:documentation>To be used for all global or static variables that are never initialized.

         '''Note''': This value is deprecated and shall be substituted by var and the appropriate values of the orthogonal attributes sectionInitializationPolicy, memoryAllocationKeywordPolicy and option.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="MemorySectionType.varNoInit"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VAR-POWER-ON-INIT">
            <xsd:annotation>
               <xsd:documentation>To be used for all global or static variables that are initialized only after power on reset.

         '''Note''': This value is deprecated and shall be substituted by var and the appropriate values of the orthogonal attributes sectionInitializationPolicy, memoryAllocationKeywordPolicy and option.</xsd:documentation>
               <xsd:appinfo source="tags">atp.Status="obsolete";mmt.qualifiedName="MemorySectionType.varPowerOnInit"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="MIME-TYPE-STRING">
      <xsd:annotation>
         <xsd:documentation>This primitive denotes the an Internet media type, originally called a MIME type after MIME and sometimes a Content-type after the name of a header in several protocols whose value is such a type, is a two-part identifier for file formats on the Internet.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MimeTypeString";xml.xsd.customType="MIME-TYPE-STRING";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MIME-TYPE-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MIME-TYPE-STRING--SIMPLE">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>
   <xsd:complexType name="MODE-ACTIVATION-KIND">
      <xsd:annotation>
         <xsd:documentation>Kind of mode switch condition used for activation of an event, as further described for each enumeration field.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeActivationKind"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MODE-ACTIVATION-KIND--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MODE-ACTIVATION-KIND--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ON-ENTRY">
            <xsd:annotation>
               <xsd:documentation>On entering the referred mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeActivationKind.onEntry"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ON-EXIT">
            <xsd:annotation>
               <xsd:documentation>On exiting the referred mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeActivationKind.onExit"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ON-TRANSITION">
            <xsd:annotation>
               <xsd:documentation>On transition of the 1st referred mode to the 2nd referred mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeActivationKind.onTransition"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="MODIFICATION-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator expresses if an object has been changed in its content or in its documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModificationTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MODIFICATION-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MODIFICATION-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONTENT-RELATED">
            <xsd:annotation>
               <xsd:documentation>The attribute contentRelated expresses, that a substantial change of the content was performed in the object. Usually this means e.g. that the derived artifacts need to be regenerated (e.g. code generation).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModificationTypeEnum.contentRelated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DOC-RELATED">
            <xsd:annotation>
               <xsd:documentation>The attribute docRelated expresses, that a change was applied to the documentation or other informal aspects of the object. Usually this means e.g. that not all derived artifacts need to be regenerated (e.g. code generation).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModificationTypeEnum.docRelated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="MONOTONY-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator denotes the values for specification of  monotony for e.g. curves.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MonotonyEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:MONOTONY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="MONOTONY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DECREASING">
            <xsd:annotation>
               <xsd:documentation>This indicates that the related curve needs to be monotony decreasing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MonotonyEnum.decreasing"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INCREASING">
            <xsd:annotation>
               <xsd:documentation>This indicates that the related curve needs to be monotony increasing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MonotonyEnum.increasing"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-MONOTONY">
            <xsd:annotation>
               <xsd:documentation>This indicates that the related curve needs not to be monotony.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MonotonyEnum.noMonotony"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STRICTLY-DECREASING">
            <xsd:annotation>
               <xsd:documentation>This indicates that the related curve needs to be strictly monotony decreasing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MonotonyEnum.strictlyDecreasing"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STRICTLY-INCREASING">
            <xsd:annotation>
               <xsd:documentation>This indicates that the related curve needs to be strictly monotony increasing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MonotonyEnum.strictlyIncreasing"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="NMTOKEN-STRING">
      <xsd:annotation>
         <xsd:documentation>This is an identifier as used in xml, e.g. xml-names. Basic difference to Identifier is the fact that it can contain "-".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NameToken";xml.xsd.customType="NMTOKEN-STRING";xml.xsd.type="NMTOKEN"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:NMTOKEN-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="NMTOKEN-STRING--SIMPLE">
      <xsd:restriction base="xsd:NMTOKEN"/>
   </xsd:simpleType>
   <xsd:complexType name="NMTOKENS-STRING">
      <xsd:annotation>
         <xsd:documentation>This is a white-space separated list of name tokens.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NameTokens";xml.xsd.customType="NMTOKENS-STRING";xml.xsd.type="NMTOKENS"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:NMTOKENS-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="NMTOKENS-STRING--SIMPLE">
      <xsd:restriction base="xsd:NMTOKENS"/>
   </xsd:simpleType>
   <xsd:complexType name="NATIVE-DECLARATION-STRING">
      <xsd:annotation>
         <xsd:documentation>This string contains a native data declaration of a data type in a programming language. It is basically a string, but white-space must be preserved.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NativeDeclarationString";xml.xsd.customType="NATIVE-DECLARATION-STRING";xml.xsd.type="string";xml.xsd.whiteSpace="preserve"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:NATIVE-DECLARATION-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="NATIVE-DECLARATION-STRING--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:whiteSpace value="preserve"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="NETWORK-TARGET-ADDRESS-TYPE">
      <xsd:annotation>
         <xsd:documentation>Network Target Address type (see ISO 15765-2).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NetworkTargetAddressType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:NETWORK-TARGET-ADDRESS-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="NETWORK-TARGET-ADDRESS-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FUNCTIONAL">
            <xsd:annotation>
               <xsd:documentation>Functional request type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NetworkTargetAddressType.functional"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PHYSICAL">
            <xsd:annotation>
               <xsd:documentation>Physical request type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NetworkTargetAddressType.physical"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="NOTE-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the type of the note. It can be used to render a note label or even a note icon.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NoteTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:NOTE-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="NOTE-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAUTION">
            <xsd:annotation>
               <xsd:documentation>This indicates that the note is an alert which shall be considered carefully.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NoteTypeEnum.caution"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EXAMPLE">
            <xsd:annotation>
               <xsd:documentation>This indicates that the note represents an example, e.g. a code example etc.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NoteTypeEnum.example"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EXERCISE">
            <xsd:annotation>
               <xsd:documentation>This indicates that the note represents an exercise for the reader.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NoteTypeEnum.exercise"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="HINT">
            <xsd:annotation>
               <xsd:documentation>This indicates that the note represents a hint which helps the user for better understanding.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NoteTypeEnum.hint"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INSTRUCTION">
            <xsd:annotation>
               <xsd:documentation>This indicates that the note represents an instruction, e.g. a step by step procedure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NoteTypeEnum.instruction"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OTHER">
            <xsd:annotation>
               <xsd:documentation>This indicates that the note is something else. The particular type of the note shall then be specified in the label of the note.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NoteTypeEnum.other"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TIP">
            <xsd:annotation>
               <xsd:documentation>This indicates that the note represents which is good to know. It is similar to a hint, but focuses more to good practice than to better understanding.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NoteTypeEnum.tip"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="NUMERICAL-VALUE">
      <xsd:annotation>
         <xsd:documentation>This primitive specifies a numerical value. It can be denoted in different formats such as Decimal, Octal, Hexadecimal, Float. See the xsd pattern for details.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Numerical";xml.xsd.customType="NUMERICAL-VALUE";xml.xsd.pattern="(0x[0-9a-f]*)|(0[1-7][0-7]*)|(0b[0-1]*)|([+\-]?[0-9]+(\.[0-9]*)?(E([+\-]?)[0-9]*)?)";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:NUMERICAL-VALUE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="NUMERICAL-VALUE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="(0x[0-9a-f]*)|(0[1-7][0-7]*)|(0b[0-1]*)|([+\-]?[0-9]+(\.[0-9]*)?(E([+\-]?)[0-9]*)?)"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="NV-BLOCK-NEEDS-RELIABILITY-ENUM">
      <xsd:annotation>
         <xsd:documentation>Reliability against data loss on the non-volatile medium.
      These requirements give only a relative indication, for example on the required degree of redundancy for storage. They do however not specify by which means (e.g. software or hardware) the reliability is actually achieved.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeedsReliabilityEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:NV-BLOCK-NEEDS-RELIABILITY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="NV-BLOCK-NEEDS-RELIABILITY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ERROR-CORRECTION">
            <xsd:annotation>
               <xsd:documentation>Errors shall be corrected</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeedsReliabilityEnum.errorCorrection"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ERROR-DETECTION">
            <xsd:annotation>
               <xsd:documentation>Errors shall be detected</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeedsReliabilityEnum.errorDetection"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-PROTECTION">
            <xsd:annotation>
               <xsd:documentation>Data need not to be handled with protection</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeedsReliabilityEnum.noProtection"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="NV-BLOCK-NEEDS-WRITING-PRIORITY-ENUM">
      <xsd:annotation>
         <xsd:documentation>Specifies the priority of writing this block in case of concurrent requests to write other blocks.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeedsWritingPriorityEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:NV-BLOCK-NEEDS-WRITING-PRIORITY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="NV-BLOCK-NEEDS-WRITING-PRIORITY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HIGH">
            <xsd:annotation>
               <xsd:documentation>Writing priority is high.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeedsWritingPriorityEnum.high"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="LOW">
            <xsd:annotation>
               <xsd:documentation>Writing priority is low.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeedsWritingPriorityEnum.low"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MEDIUM">
            <xsd:annotation>
               <xsd:documentation>Writing priority is medium.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeedsWritingPriorityEnum.medium"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="OBD-RATIO-CONNECTION-KIND-ENUM">
      <xsd:annotation>
         <xsd:documentation>Defines the way how the IUMPR service connection between the DEM and the client component or module is handled (for details see the DEM Specification).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioConnectionKindEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:OBD-RATIO-CONNECTION-KIND-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="OBD-RATIO-CONNECTION-KIND-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="API-USE">
            <xsd:annotation>
               <xsd:documentation>The IUMPR service (of the DEM) uses an explicit API to connect to the component or module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioConnectionKindEnum.apiUse"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OBSERVER">
            <xsd:annotation>
               <xsd:documentation>The IUMPR service (of the DEM) uses no API but "observes"  the associated diagnostic event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioConnectionKindEnum.observer"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="ORIENT-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies how the table shall be oriented.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OrientEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:ORIENT-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="ORIENT-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LAND">
            <xsd:annotation>
               <xsd:documentation>This indicates that the table is rendered in landscape which results in turning the table 90 degree clockwise.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OrientEnum.land"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PORT">
            <xsd:annotation>
               <xsd:documentation>This indicates that the table is rendered in portrait, which is the regular text flow.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OrientEnum.port"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="PGWIDE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies, if the table shall be rendered across the entire page, even if it is placed in side-head layouts.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PgwideEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:PGWIDE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="PGWIDE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-PGWIDE">
            <xsd:annotation>
               <xsd:documentation>This indicates that the table shall be fit in the current text flow.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PgwideEnum.noPgwide"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PGWIDE">
            <xsd:annotation>
               <xsd:documentation>This indicates that the table may use the entire page width. This is in particular important in case of so called "side-head layouts" but also if the table is in a list or in a note.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PgwideEnum.pgwide"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="PNC-GATEWAY-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>Defines the PncGateway roles.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PncGatewayTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:PNC-GATEWAY-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="PNC-GATEWAY-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ACTIVE">
            <xsd:annotation>
               <xsd:documentation>The active PncGateway functionality shall be performed</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncGatewayTypeEnum.active"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NONE">
            <xsd:annotation>
               <xsd:documentation>No PncGateway functionality shall be performed</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncGatewayTypeEnum.none"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PASSIVE">
            <xsd:annotation>
               <xsd:documentation>The passive PncGateway functionality shall be performed</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncGatewayTypeEnum.passive"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="POSITIVE-INTEGER">
      <xsd:annotation>
         <xsd:documentation>This is a positive integer which can be denoted in Decimal, octal and hexadecimal.
      the value is between 0 and 4294967295.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PositiveInteger";xml.xsd.customType="POSITIVE-INTEGER";xml.xsd.pattern="[1-9][0-9]*|0x[0-9a-f]*|0[0-7]*|0b[0-1]*";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:POSITIVE-INTEGER--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="POSITIVE-INTEGER--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[1-9][0-9]*|0x[0-9a-f]*|0[0-7]*|0b[0-1]*"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="PROCESSING-KIND-ENUM">
      <xsd:annotation>
         <xsd:documentation>Kind of processing which has been applied to a data element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingKindEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:PROCESSING-KIND-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="PROCESSING-KIND-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FILTERED">
            <xsd:annotation>
               <xsd:documentation>Indicates that a raw signal has been manipulated by some application software components by using filters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingKindEnum.filtered"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NONE">
            <xsd:annotation>
               <xsd:documentation>Indicates that none of the other option apply.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingKindEnum.none"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RAW">
            <xsd:annotation>
               <xsd:documentation>Specifies that a signal is taken directly from the basic software modules, i.e. from the ECU abstraction layer. It indicates to a developer that the control algorithm in the software has to provide filters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingKindEnum.raw"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="PROGRAMMINGLANGUAGE-ENUM">
      <xsd:annotation>
         <xsd:documentation>Programming language the implementation was created in.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProgramminglanguageEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:PROGRAMMINGLANGUAGE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="PROGRAMMINGLANGUAGE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="C">
            <xsd:annotation>
               <xsd:documentation>C language</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProgramminglanguageEnum.c"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CPP">
            <xsd:annotation>
               <xsd:documentation>C++ language</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProgramminglanguageEnum.cpp"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="JAVA">
            <xsd:annotation>
               <xsd:documentation>Java language</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProgramminglanguageEnum.java"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="PULSE-TEST-ENUM">
      <xsd:annotation>
         <xsd:documentation>This element indicates to the connected Actuator Software component whether the data-element can be used to generate pulse test sequences using the IoHwAbstraction layer</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PulseTestEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:PULSE-TEST-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="PULSE-TEST-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DISABLE">
            <xsd:annotation>
               <xsd:documentation>Disables the pulse test</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PulseTestEnum.disable"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ENABLE">
            <xsd:annotation>
               <xsd:documentation>Enables the pulse test</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PulseTestEnum.enable"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="RECORD-LAYOUT-ITERATOR-POINT">
      <xsd:annotation>
         <xsd:documentation>This primitive denotes a start / endpoint for the iteration of a recordLayoutGroup. It can be an integer or one of the keywords MAX-TEXT-SIZE|ARRAY-SIZE. Note that negative numbers are counted backwards. Therefore e.g. -1 refers to the last value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordLayoutIteratorPoint";xml.xsd.customType="RECORD-LAYOUT-ITERATOR-POINT";xml.xsd.pattern="-?([0-9]+|MAX-TEXT-SIZE|ARRAY-SIZE)";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:RECORD-LAYOUT-ITERATOR-POINT--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="RECORD-LAYOUT-ITERATOR-POINT--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="-?([0-9]+|MAX-TEXT-SIZE|ARRAY-SIZE)"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="REGULAR-EXPRESSION">
      <xsd:annotation>
         <xsd:documentation>This is a regular expression as defined in 

      http://www.w3.org/TR/xmlschema-2

      As of now it is still produced as a string in XSD.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RegularExpression";xml.xsd.customType="REGULAR-EXPRESSION";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:REGULAR-EXPRESSION--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="REGULAR-EXPRESSION--SIMPLE">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>
   <xsd:complexType name="RESUME-POSITION">
      <xsd:annotation>
         <xsd:documentation>Defines, where a schedule table shall be proceeded in case if it has been interrupted by a run-once table or MRF/SRF.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ResumePosition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:RESUME-POSITION--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="RESUME-POSITION--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONTINUE-AT-IT-POSITION">
            <xsd:annotation>
               <xsd:documentation>Continue at IT Point.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ResumePosition.continueAtItPosition"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="START-FROM-BEGINNING">
            <xsd:annotation>
               <xsd:documentation>Start from the beginning</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ResumePosition.startFromBeginning"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="REVISION-LABEL-STRING">
      <xsd:annotation>
         <xsd:documentation>This primitive represents a revision label which identifies an engineering object. It represents a pattern which 

      * requires three integers representing from left to right MajorVersion, MinorVersion, PatchVersion.

      * may add an application specific suffix separated by one of ".", "_", ";".

      Legal patterns are for example:

      4.0.0
      4.0.0.1234565
      4.0.0_vendor specific;13
      4.0.0;12</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RevisionLabelString";xml.xsd.customType="REVISION-LABEL-STRING";xml.xsd.pattern="[0-9]+\.[0-9]+\.[0-9]+([\._;].*)?";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:REVISION-LABEL-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="REVISION-LABEL-STRING--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[0-9]+\.[0-9]+\.[0-9]+([\._;].*)?"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="RUN-MODE">
      <xsd:annotation>
         <xsd:documentation>The schedule table can be executed in two different modes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RunMode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:RUN-MODE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="RUN-MODE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="RUN-CONTINUOUS">
            <xsd:annotation>
               <xsd:documentation>RUN_CONTINUOUS run mode</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunMode.RunContinuous"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RUN-ONCE">
            <xsd:annotation>
               <xsd:documentation>RUN_ONCE run mode</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunMode.runOnce"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SCALE-CONSTR-VALIDITY-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the possible values of a scale.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrValidityEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SCALE-CONSTR-VALIDITY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SCALE-CONSTR-VALIDITY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NOT-AVAILABLE">
            <xsd:annotation>
               <xsd:documentation>Currently invalid area
         The value usually is presented by the ECU but can currently not be performed
         due to e.g. initialization or temporary problems. Please note, that this behavior
         appears during runtime and cannot be handled while data is edited.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrValidityEnum.notAvailable"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NOT-DEFINED">
            <xsd:annotation>
               <xsd:documentation>Indicates an area which is marked in a specification (e.g. as reserved)
         Shall usually not be set by the ECU but is used by a tester to verify correct ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrValidityEnum.notDefined"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NOT-VALID">
            <xsd:annotation>
               <xsd:documentation>The ECU cannot process the requested data.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrValidityEnum.notValid"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VALID">
            <xsd:annotation>
               <xsd:documentation>Current value is within a valid range and can be presented to user as is.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrValidityEnum.valid"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SECTION-INITIALIZATION-POLICY-TYPE">
      <xsd:annotation>
         <xsd:documentation>SectionInitializationPolicyType describes the intended initialization of MemorySections. 
      The following values are standardized in AUTOSAR Methodology:

      * '''NO-INIT''': No initialization and no clearing is performed. Such data elements must not be read before one has written a value into it.
      * '''INIT''': To be used for data that are initialized by every reset to the specified value (initValue). 
      * '''POWER-ON-INIT''': To be used for data that are initialized by "Power On" to the specified value (initValue). Note: there might be several resets between power on resets. 
      * '''CLEARED''': To be used for data that are initialized by every reset to zero. 
      * '''POWER-ON-CLEARED''': To be used for data that are initialized by "Power On" to zero. Note: there might be several resets between power on resets.

      Please note that the values are defined similar to the representation of enumeration types in the XML schema to ensure backward compatibility.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SectionInitializationPolicyType";xml.xsd.customType="SECTION-INITIALIZATION-POLICY-TYPE";xml.xsd.type="NMTOKEN"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SECTION-INITIALIZATION-POLICY-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SECTION-INITIALIZATION-POLICY-TYPE--SIMPLE">
      <xsd:restriction base="xsd:NMTOKEN"/>
   </xsd:simpleType>
   <xsd:complexType name="SERVER-ARGUMENT-IMPL-POLICY-ENUM">
      <xsd:annotation>
         <xsd:documentation>This defines how the argument type of the servers RunnableEntity is implemented.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerArgumentImplPolicyEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SERVER-ARGUMENT-IMPL-POLICY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SERVER-ARGUMENT-IMPL-POLICY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="USE-ARGUMENT-TYPE">
            <xsd:annotation>
               <xsd:documentation>The argument type of the RunnableEntity is derived from the AutosarDataType of the ArgumentPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerArgumentImplPolicyEnum.useArgumentType"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="USE-ARRAY-BASE-TYPE">
            <xsd:annotation>
               <xsd:documentation>The argument type of the RunnableEntity is derived from the AutosarDataType of the elements of the array that corresponds to the ArgumentPrototype. This represents the base type of the array in C.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerArgumentImplPolicyEnum.useArrayBaseType"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="USE-VOID">
            <xsd:annotation>
               <xsd:documentation>The argument type of the RunnableEntity is void.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerArgumentImplPolicyEnum.useVoid"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SERVICE-PROVIDER-ENUM">
      <xsd:annotation>
         <xsd:documentation>This represents a list of possible service providers</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SERVICE-PROVIDER-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SERVICE-PROVIDER-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ANY-STANDARDIZED">
            <xsd:annotation>
               <xsd:documentation>This value means that the specific nature is either unknown or it is not important for the given purpose. This is also the default value for any attribute of type ServiceProviderEnum</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.anyStandardized"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BASIC-SOFTWARE-MODE-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Basic Software Mode Manager (BswM)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.basicSoftwareModeManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="COM-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the COM Manager (ComM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.comManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="CRYPTO-SERVICE-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Crypto Service Manager (CsM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.cryptoServiceManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DEVELOPMENT-ERROR-TRACER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Development Error Tracer (DET).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.developmentErrorTracer"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DIAGNOSTIC-COMMUNICATION-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Diagnostic Communication Manager (DCM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.diagnosticCommunicationManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DIAGNOSTIC-EVENT-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Diagnostic Event Manager (DEM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.diagnosticEventManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="DIAGNOSTIC-LOG-AND-TRACE">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Diagnostic Log and Trace (DLT).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.diagnosticLogAndTrace"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="ECU-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the ECU Manager (EcuM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.ecuManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FUNCTION-INHIBITION-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Function Inhibition Manager (FIM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.functionInhibitionManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NON-VOLATILE-RAM-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Non-Volatile RAM Manager (NvM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.nonVolatileRamManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OPERATING-SYSTEM">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Operating System (OS).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.operatingSystem"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SYNC-BASE-TIME-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Sync Time Base Manager (StbM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.syncBaseTimeManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VENDOR-SPECIFIC">
            <xsd:annotation>
               <xsd:documentation>This value denotes a vendor-specific service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.vendorSpecific"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="WATCH-DOG-MANAGER">
            <xsd:annotation>
               <xsd:documentation>The service relates to the Watchdog Manager (WdgM).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceProviderEnum.watchDogManager"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-CONTENT-ENUM">
      <xsd:annotation>
         <xsd:documentation>This specifies if the content of the xref element shall be rendered.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowContentEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-CONTENT-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-CONTENT-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-CONTENT">
            <xsd:annotation>
               <xsd:documentation>The content of the Xref.label is '''not''' rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowContentEnum.noShowContent"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-CONTENT">
            <xsd:annotation>
               <xsd:documentation>The content of the element is rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowContentEnum.showContent"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-RESOURCE-ALIAS-NAME-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies if the alias names of the reference target shall be rendered with the xref.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceAliasNameEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-RESOURCE-ALIAS-NAME-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-RESOURCE-ALIAS-NAME-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-ALIAS-NAME">
            <xsd:annotation>
               <xsd:documentation>This indicates that alias names of the referenced object shall '''not''' be rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceAliasNameEnum.noShowAliasName"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-ALIAS-NAME">
            <xsd:annotation>
               <xsd:documentation>This indicates that the alias names of the referenced object shall be rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceAliasNameEnum.showAliasName"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-RESOURCE-CATEGORY-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies if the category of the reference target shall be rendered with the xref.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceCategoryEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-RESOURCE-CATEGORY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-RESOURCE-CATEGORY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-CATEGORY">
            <xsd:annotation>
               <xsd:documentation>The category of the target is '''not''' rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceCategoryEnum.noShowCategory"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-CATEGORY">
            <xsd:annotation>
               <xsd:documentation>The category of the target is  rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceCategoryEnum.showCategory"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-RESOURCE-LONG-NAME-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies if the long name of the reference target shall be rendered with the xref.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceLongNameEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-RESOURCE-LONG-NAME-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-RESOURCE-LONG-NAME-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>The long name of the target is '''not''' rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceLongNameEnum.noShowLongName"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-LONG-NAME">
            <xsd:annotation>
               <xsd:documentation>The long name of the target is rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceLongNameEnum.showLongName"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-RESOURCE-NUMBER-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies if the number (e.g. chapter number) of the reference target shall be rendered with the xref.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceNumberEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-RESOURCE-NUMBER-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-RESOURCE-NUMBER-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-NUMBER">
            <xsd:annotation>
               <xsd:documentation>The number of the target is '''not''' rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceNumberEnum.noShowNumber"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-NUMBER">
            <xsd:annotation>
               <xsd:documentation>The number of the target is rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceNumberEnum.showNumber"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-RESOURCE-PAGE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies if the page numer of the reference target shall be rendered with the xref.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourcePageEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-RESOURCE-PAGE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-RESOURCE-PAGE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-PAGE">
            <xsd:annotation>
               <xsd:documentation>The page number  of the target is '''not''' rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourcePageEnum.noShowPage"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-PAGE">
            <xsd:annotation>
               <xsd:documentation>The page number  of the target is rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourcePageEnum.showPage"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-RESOURCE-SHORT-NAME-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies if the short name of the reference target shall be rendered with the xref.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceShortNameEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-RESOURCE-SHORT-NAME-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-RESOURCE-SHORT-NAME-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-SHORT-NAME">
            <xsd:annotation>
               <xsd:documentation>The short name of the target is '''not''' rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceShortNameEnum.noShowShortName"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-SHORT-NAME">
            <xsd:annotation>
               <xsd:documentation>The short name of the target is rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceShortNameEnum.showShortName"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-RESOURCE-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies if the type (e.g. derived from the class) of the reference target shall be rendered with the xref.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-RESOURCE-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-RESOURCE-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-TYPE">
            <xsd:annotation>
               <xsd:documentation>The type of the target is '''not''' rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceTypeEnum.noShowType"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-TYPE">
            <xsd:annotation>
               <xsd:documentation>The type of the target is rendered at the place of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowResourceTypeEnum.showType"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SHOW-SEE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies if the word "see" shall be rendered before the xref.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ShowSeeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SHOW-SEE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SHOW-SEE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-SEE">
            <xsd:annotation>
               <xsd:documentation>The word "see" is '''not''' rendered before  the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowSeeEnum.noShowSee"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SHOW-SEE">
            <xsd:annotation>
               <xsd:documentation>The word "see"is rendered before the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ShowSeeEnum.showSee"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SIGNAL-FAN-ENUM">
      <xsd:annotation>
         <xsd:documentation>Signal Fan inside the Composition Component Type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalFanEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SIGNAL-FAN-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SIGNAL-FAN-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NFOLD">
            <xsd:annotation>
               <xsd:documentation>The connections internally in the CompositionSwComponentType via DelegationSwConnectors and AssemblySwConnectors are defined in a way that at least one data element present in the S/R interface or one ClientServerOperation in the C/S interface of the outer PortPrototype is involved in a 1:n or n:1 communication pattern.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalFanEnum.nfold"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SINGLE">
            <xsd:annotation>
               <xsd:documentation>The connections internally in the CompositionSwComponentType via DelegationSwConnectors and AssemblySwConnectors are defined in a way that each VariableDataPrototype  present in the S/R interface or ClientServerOperation in the C/S interface of the outer PortPrototype is involved in a 1:1 communication pattern only.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalFanEnum.single"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SO-AD-CONNECTOR-TYPE">
      <xsd:annotation>
         <xsd:documentation>Availability of protocol plug-ins. Entries in the Socket and PDU Routing Tables.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoAdConnectorType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SO-AD-CONNECTOR-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SO-AD-CONNECTOR-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DO-IP">
            <xsd:annotation>
               <xsd:documentation>Diagnosis over IP</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoAdConnectorType.DoIp"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="PDU-R">
            <xsd:annotation>
               <xsd:documentation>Pdu Router</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoAdConnectorType.PduR"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="UDP-NM">
            <xsd:annotation>
               <xsd:documentation>Udp Nm</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoAdConnectorType.UdpNm"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="XCP">
            <xsd:annotation>
               <xsd:documentation>Universal Measurement and Calibration Protocol</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoAdConnectorType.Xcp"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SO-AD-PROTOCOL-TYPE">
      <xsd:annotation>
         <xsd:documentation>Transport Protocols above IP.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoAdProtocolType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SO-AD-PROTOCOL-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SO-AD-PROTOCOL-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="TCP">
            <xsd:annotation>
               <xsd:documentation>Transmission Control Protocol (TCP) enables two hosts to establish a connection and exchange streams of data.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoAdProtocolType.tcp"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="UDP">
            <xsd:annotation>
               <xsd:documentation>User Datagram Protocol (UDP) offers a connectionless way to send and receive datagrams over an IP network. It's used primarily for broadcasting messages over a network.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoAdProtocolType.udp"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="STRING">
      <xsd:annotation>
         <xsd:documentation>This represents a String in which white-space must be normalized before processing. For example: in order to compare two Strings:

      * leading and trailing white-space needs to be removed
      * consecutive white-space (blank, cr, lf, tab) needs to be replaced by one blank.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="String";xml.xsd.customType="STRING";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="STRING--SIMPLE">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>
   <xsd:complexType name="SUPSCRIPT">
      <xsd:annotation>
         <xsd:documentation>This is text which is rendered superscript or subscript depending on the role.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Superscript";xml.xsd.customType="SUPSCRIPT";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SUPSCRIPT--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SUPSCRIPT--SIMPLE">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>
   <xsd:complexType name="SW-CALIBRATION-ACCESS-ENUM">
      <xsd:annotation>
         <xsd:documentation>Determines the access rights to a data object w.r.t. measurement and calibration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalibrationAccessEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SW-CALIBRATION-ACCESS-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SW-CALIBRATION-ACCESS-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NOT-ACCESSIBLE">
            <xsd:annotation>
               <xsd:documentation>The element will not be accessible via MCD tools, i.e. will not appear in the ASAP file.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalibrationAccessEnum.notAccessible"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="READ-ONLY">
            <xsd:annotation>
               <xsd:documentation>The element will only appear as read-only in an ASAP file.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalibrationAccessEnum.readOnly"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="READ-WRITE">
            <xsd:annotation>
               <xsd:documentation>The element will appear in the ASAP file with both read and write access.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalibrationAccessEnum.readWrite"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SW-IMPL-POLICY-ENUM">
      <xsd:annotation>
         <xsd:documentation>Specifies the implementation strategy with respect to consistency mechanisms of variables.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwImplPolicyEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SW-IMPL-POLICY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SW-IMPL-POLICY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONST">
            <xsd:annotation>
               <xsd:documentation>forced implementation such that the  running software within the ECU  must not modify it. For example implemented with the "const" modifier in C.  This can be applied for parameters (not for those in NvRam) as well as argument  data prototypes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwImplPolicyEnum.const"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FIXED">
            <xsd:annotation>
               <xsd:documentation>This data element is fixed. In particular this indicates, that it  might also be implemented  e.g. as in place data, (#DEFINE).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwImplPolicyEnum.fixed"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MEASUREMENT-POINT">
            <xsd:annotation>
               <xsd:documentation>The data element is created for measurement purposes only.  The data element is never read directly within the ECU software. In contrast to  a "standard" data element in an unconnected provide port is, this unconnection  is guaranteed for  measurementPoint data elements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwImplPolicyEnum.measurementPoint"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="QUEUED">
            <xsd:annotation>
               <xsd:documentation>The content of the data element is queued and the data element has 'event' semantics, i.e. data elements are stored in a queue and all data  elements are processed in 'first in first out' order. 
         The queuing is intended to be implemented by RTE Generator.
         This value is not applicable for parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwImplPolicyEnum.queued"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STANDARD">
            <xsd:annotation>
               <xsd:documentation>This is applicable for all kinds of data elements. For variable  data prototypes the 'last is best' semantics applies. For parameter there is no  specific implementation directive.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwImplPolicyEnum.standard"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SW-SERVICE-IMPL-POLICY-ENUM">
      <xsd:annotation>
         <xsd:documentation>This specifies the legal values for the implementation policies for services (in AUTOSAR: BswModuleEntry-s).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceImplPolicyEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SW-SERVICE-IMPL-POLICY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SW-SERVICE-IMPL-POLICY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INLINE">
            <xsd:annotation>
               <xsd:documentation>inline service definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceImplPolicyEnum.inline"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INLINE-CONDITIONAL">
            <xsd:annotation>
               <xsd:documentation>The service (in AUTOSAR: BswModuleEntry) is implemented in a way that it either resolves to an inline function or to a standard function depending on conditions set at a later point in time.

         This could be handled by using the AUTOSAR compiler abstraction macros (INLINE, LOCAL_INLINE) and/or by further compiler switches depending on ECU configuration values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceImplPolicyEnum.inlineConditional"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MACRO">
            <xsd:annotation>
               <xsd:documentation>macro service definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceImplPolicyEnum.macro"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STANDARD">
            <xsd:annotation>
               <xsd:documentation>Standard service and default value, if nothing is defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceImplPolicyEnum.standard"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SW-SERVICE-REENTRANCE-ENUM">
      <xsd:annotation>
         <xsd:documentation>Specifies the legal values for reentrancy of services.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceReentranceEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SW-SERVICE-REENTRANCE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SW-SERVICE-REENTRANCE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="REENTRANCE">
            <xsd:annotation>
               <xsd:documentation>If this element is not defined the service cannot be invoked when it is executing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceReentranceEnum.reentrance"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SW-VARIABLE-ACCESS-IMPL-POLICY-ENUM">
      <xsd:annotation>
         <xsd:documentation>Detailed access policy for variables, for which data consistency is implemented via messages.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableAccessImplPolicyEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SW-VARIABLE-ACCESS-IMPL-POLICY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SW-VARIABLE-ACCESS-IMPL-POLICY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DIRECT">
            <xsd:annotation>
               <xsd:documentation>Messages with DIRECT access are read but ignored by data consistency tool. Data consistency
         is not guaranteed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableAccessImplPolicyEnum.direct"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OPTIMIZED">
            <xsd:annotation>
               <xsd:documentation>A Tool handles data consistency. 

         In SwService, where a message is referenced, only OPTIMIZED access (also default
         value inside SwServcie) is possible.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableAccessImplPolicyEnum.optimized"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="SELECTABLE">
            <xsd:annotation>
               <xsd:documentation>The user can decide inside each single service, where these message is referenced, if
         access to that shall be OPTIMIZED or DIRECT.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableAccessImplPolicyEnum.selectable"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SWC-TO-ECU-MAPPING-CONSTRAINT-TYPE">
      <xsd:annotation>
         <xsd:documentation>There are two different SwcToEcuMapping constraints: dedicated mapping and exclusive mapping.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraintType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SWC-TO-ECU-MAPPING-CONSTRAINT-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SWC-TO-ECU-MAPPING-CONSTRAINT-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEDICATED">
            <xsd:annotation>
               <xsd:documentation>Dedicated mapping means that the SW-C can only be mapped to the ECUs it is dedicated to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraintType.dedicated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="EXCLUSIVE">
            <xsd:annotation>
               <xsd:documentation>Exclusive mapping means that the SW-C cannot be mapped to the ECUs it is excluded from.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraintType.exclusive"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SWC-TO-SWC-OPERATION-ARGUMENTS-DIRECTION-ENUM">
      <xsd:annotation>
         <xsd:documentation>Direction addressed by this  element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArgumentsDirectionEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SWC-TO-SWC-OPERATION-ARGUMENTS-DIRECTION-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SWC-TO-SWC-OPERATION-ARGUMENTS-DIRECTION-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="IN">
            <xsd:annotation>
               <xsd:documentation>IN (all IN and INOUT arguments)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArgumentsDirectionEnum.in"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OUT">
            <xsd:annotation>
               <xsd:documentation>OUT (all OUT and INOUT arguments) .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArgumentsDirectionEnum.out"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="SYNCHRONIZATION-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the type of the synchronization timing constraint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SynchronizationTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:SYNCHRONIZATION-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="SYNCHRONIZATION-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="RESPONSE-SYNCHRONIZATION">
            <xsd:annotation>
               <xsd:documentation>The responses of the associated event chains must occur synchronously with respect to the specified tolerance.

         All associated event chains must have the same stimulus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SynchronizationTypeEnum.responseSynchronization"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STIMULUS-SYNCHRONIZATION">
            <xsd:annotation>
               <xsd:documentation>The stimuli of the associated event chains must occur synchronously with respect to the specified tolerance.

         All associated event chains must have the same response.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SynchronizationTypeEnum.stimulusSynchronization"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-BSW-INTERNAL-BEHAVIOR-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventBswInternalBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswInternalBehaviorTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-BSW-INTERNAL-BEHAVIOR-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-BSW-INTERNAL-BEHAVIOR-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-MODULE-ENTITY-ACTIVATED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the associated BswModuleEntity has been activated, which means that it has entered the state "to be started".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswInternalBehaviorTypeEnum.bswModuleEntityActivated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BSW-MODULE-ENTITY-STARTED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the associated BswModuleEntity has entered the state "started" after its activation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswInternalBehaviorTypeEnum.bswModuleEntityStarted"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BSW-MODULE-ENTITY-TERMINATED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the associated BswModuleEntity has terminated and entered the state "suspended"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswInternalBehaviorTypeEnum.bswModuleEntityTerminated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-BSW-MODE-DECLARATION-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventBswModeDeclaration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclarationTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-BSW-MODE-DECLARATION-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-BSW-MODE-DECLARATION-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-DECLARATION-REQUESTED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the associated ModeDeclarationGroupPrototype has been requested.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclarationTypeEnum.modeDeclarationRequested"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MODE-DECLARATION-SWITCH-COMPLETED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the switch to the associated ModeDeclarationGroupPrototype has been completed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclarationTypeEnum.modeDeclarationSwitchCompleted"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MODE-DECLARATION-SWITCH-INITIATED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the switch to the associated ModeDeclarationGroupPrototype has been initiated by the BswM.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModeDeclarationTypeEnum.modeDeclarationSwitchInitiated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-BSW-MODULE-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventBswModule.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModuleTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-BSW-MODULE-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-BSW-MODULE-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-M-ENTRY-CALL-RETURNED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the call of the associated BswModuleEntry has returned.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModuleTypeEnum.bswMEntryCallReturned"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="BSW-M-ENTRY-CALLED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the associated BswModuleEntry has been called.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventBswModuleTypeEnum.bswMEntryCalled"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-FRAME-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventFrame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrameTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-FRAME-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-FRAME-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FRAME-QUEUED-FOR-TRANSMISSION">
            <xsd:annotation>
               <xsd:documentation>A point in time where the frame containing the named signal / I-PDU is queued for transmission within the related Communication Driver.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrameTypeEnum.frameQueuedForTransmission"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FRAME-RECEIVED-BY-IF">
            <xsd:annotation>
               <xsd:documentation>A point in time where the frame is pushed from the subscriber's communication controller to the corresponding (FlexRay / CAN / LIN) Interface BSW module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrameTypeEnum.frameReceivedByIf"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="FRAME-TRANSMITTED-ON-BUS">
            <xsd:annotation>
               <xsd:documentation>A point in time where the transmission of the frame completes successfully, and the subscriber's communication controller receives the frame from the bus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventFrameTypeEnum.frameTransmittedOnBus"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-I-PDU-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventIPdu.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventIPduTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-I-PDU-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-I-PDU-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-PDU-RECEIVED-BY-COM">
            <xsd:annotation>
               <xsd:documentation>A point in time where the received frame is processed by the corresponding (FlexRay / CAN / LIN) Interface BSW module, routed through the PDUR and the contained PDUs are pushed to the COM module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventIPduTypeEnum.iPduReceivedByCOM"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="I-PDU-SENT-TO-IF">
            <xsd:annotation>
               <xsd:documentation>A point in time where the carrier COM I-PDU is routed through the PDUR and is pushed to the bus specific (FlexRay / CAN / LIN) Interface BSW module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventIPduTypeEnum.iPduSentToIf"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-I-SIGNAL-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventISignal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventISignalTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-I-SIGNAL-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-I-SIGNAL-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-AVAILABLE-FOR-RTE">
            <xsd:annotation>
               <xsd:documentation>A point in time, where the COM module makes the contained signal / signal group available for the RTE and the corresponding Rx Indication callout is generated (if configured).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventISignalTypeEnum.iSignalAvailableForRTE"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="I-SIGNAL-SENT-TO-COM">
            <xsd:annotation>
               <xsd:documentation>A point in time, where a transmission request call is issued by the RTE on a named COM signal / signal group and the new value is stored to the carrier COM I-PDU buffer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventISignalTypeEnum.iSignalSentToCOM"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-MODE-DECLARATION-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventModeDeclaration</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclarationTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-MODE-DECLARATION-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-MODE-DECLARATION-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-DECLARATION-SWITCH-COMPLETED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the switch to the associated ModeDeclarationGroupPrototype has been completed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclarationTypeEnum.modeDeclarationSwitchCompleted"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MODE-DECLARATION-SWITCH-INITIATED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the switch to the associated ModeDeclarationGroupPrototype has been initiated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventModeDeclarationTypeEnum.modeDeclarationSwitchInitiated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-OPERATION-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventOperation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperationTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-OPERATION-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-OPERATION-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="OPERATION-CALL-RECEIVED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the call of the referenced operation is received by the server SWC.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperationTypeEnum.operationCallReceived"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OPERATION-CALL-RESPONSE-RECEIVED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the client SWC has received the response of the referenced operation call.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperationTypeEnum.operationCallResponseReceived"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OPERATION-CALL-RESPONSE-SENT">
            <xsd:annotation>
               <xsd:documentation>A point in time where the server SWC has terminated with the execution of the referenced operation, and has sent out a response.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperationTypeEnum.operationCallResponseSent"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="OPERATION-CALLED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the referenced operation is called by the client SWC.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventOperationTypeEnum.operationCalled"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-SWC-INTERNAL-BEHAVIOR-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventSwcInternalBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehaviorTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-SWC-INTERNAL-BEHAVIOR-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-SWC-INTERNAL-BEHAVIOR-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="RUNNABLE-ENTITY-ACTIVATED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the associated RunnableEntity has been activated, which means that it has entered the state "to be started".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehaviorTypeEnum.runnableEntityActivated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RUNNABLE-ENTITY-STARTED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the associated RunnableEntity has entered the state "started" after its activation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehaviorTypeEnum.runnableEntityStarted"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="RUNNABLE-ENTITY-TERMINATED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the associated RunnableEntity has terminated and entered the state "suspended".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventSwcInternalBehaviorTypeEnum.runnableEntityTerminated"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TD-EVENT-VARIABLE-DATA-PROTOTYPE-TYPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This is used to describe the specific event type of a TDEventVariableDataPrototype</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVariableDataPrototypeTypeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TD-EVENT-VARIABLE-DATA-PROTOTYPE-TYPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TD-EVENT-VARIABLE-DATA-PROTOTYPE-TYPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE-RECEIVED">
            <xsd:annotation>
               <xsd:documentation>A point in time where the referenced variable data prototype has been successfully transmitted and is available in the related communication buffer (of the RTE) for the receiving SWC.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVariableDataPrototypeTypeEnum.variableDataPrototypeReceived"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="VARIABLE-DATA-PROTOTYPE-SENT">
            <xsd:annotation>
               <xsd:documentation>A point in time where the referenced variable data prototype has been successfully sent out by the sending SWC, so that it is available in the related communication buffer (of the RTE) for transmission.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TDEventVariableDataPrototypeTypeEnum.variableDataPrototypeSent"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TABLE-SEPARATOR-STRING">
      <xsd:annotation>
         <xsd:documentation>This represents the ability to denote a separator string within an OASIS exchange table.

      * '''0''': no line is displayed

      * '''1''': line is displayed</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TableSeparatorString";xml.xsd.customType="TABLE-SEPARATOR-STRING";xml.xsd.pattern="[0-1]";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TABLE-SEPARATOR-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TABLE-SEPARATOR-STRING--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[0-1]"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TIME-VALUE">
      <xsd:annotation>
         <xsd:documentation>This primitive type is taken for expressing time values. The numerical value is supposed to be interpreted in the physical unit second.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimeValue";xml.xsd.customType="TIME-VALUE";xml.xsd.type="double"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TIME-VALUE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TIME-VALUE--SIMPLE">
      <xsd:restriction base="xsd:double"/>
   </xsd:simpleType>
   <xsd:complexType name="TP-ACK-TYPE">
      <xsd:annotation>
         <xsd:documentation>Type of Acknowledgement.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TpAckType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TP-ACK-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TP-ACK-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ACK-WITH-RT">
            <xsd:annotation>
               <xsd:documentation>Acknowledgement with retry.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TpAckType.ackWithRt"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NO-ACK">
            <xsd:annotation>
               <xsd:documentation>No acknowledgement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TpAckType.noAck"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TRANSFER-PROPERTY-ENUM">
      <xsd:annotation>
         <xsd:documentation>Transfer Properties of a Signal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransferPropertyEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TRANSFER-PROPERTY-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TRANSFER-PROPERTY-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PENDING">
            <xsd:annotation>
               <xsd:documentation>If the signal has the TransferProperty pending, then the function Com_SendSignal shall not perform a transmission of the IPdu associated with the signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransferPropertyEnum.pending"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TRIGGERED">
            <xsd:annotation>
               <xsd:documentation>The signal in the assigned IPdu is updated and a request for the IPdu's transmission is made.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransferPropertyEnum.triggered"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TRIGGERED-ON-CHANGE">
            <xsd:annotation>
               <xsd:documentation>The signal in the assigned IPdu is updated and a request for the IPdus transmission is made only if the signal value is different from the already stored signal value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransferPropertyEnum.triggeredOnChange"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TRIGGERED-ON-CHANGE-WITHOUT-REPETITION">
            <xsd:annotation>
               <xsd:documentation>The signal in the assigned IPdu is updated and a request for the IPdus transmission is made only if the signal value is different from the already stored signal value.  In the DIRECT/N-TIMES or MIXED transmission mode (EventControlledTiming) the IPdu will be transmitted just once without a repetition, independent of the defined NumberOfRepeats.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransferPropertyEnum.triggeredOnChangeWithoutRepetition"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TRIGGERED-WITHOUT-REPETITION">
            <xsd:annotation>
               <xsd:documentation>The signal in the assigned IPdu is updated and a request for the IPdu's transmission is made. In the DIRECT/N-TIMES or MIXED transmission mode (EventControlledTiming) the IPdu will be transmitted just once without a repetition, independent of the defined NumberOfRepeats.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransferPropertyEnum.triggeredWithoutRepetition"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TRIGGER-MODE">
      <xsd:annotation>
         <xsd:documentation>IPduM can be configured to send a transmission request for the new multiplexed I-PDU to the PDU-Router because of conditions/ modes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TRIGGER-MODE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TRIGGER-MODE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DYNAMIC-PART-TRIGGER">
            <xsd:annotation>
               <xsd:documentation>IPduM sends a transmission request to the PduR if a dynamic part is received.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMode.dynamicPartTrigger"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="NONE">
            <xsd:annotation>
               <xsd:documentation>IPduM does not trigger transmission because of receiving anything of this IPdu in case of TriggerTransmit.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMode.none"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STATIC-OR-DYNAMIC-PART-TRIGGER">
            <xsd:annotation>
               <xsd:documentation>IPduM sends a transmission request to the PduR if a static or dynamic part is received.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMode.staticOrDynamicPartTrigger"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="STATIC-PART-TRIGGER">
            <xsd:annotation>
               <xsd:documentation>IPduM sends a transmission request to the PduR if a static part is received.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TriggerMode.staticPartTrigger"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="TTCAN-TRIGGER-TYPE">
      <xsd:annotation>
         <xsd:documentation>This type lists all trigger types for a time window.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TtcanTriggerType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:TTCAN-TRIGGER-TYPE--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="TTCAN-TRIGGER-TYPE--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="RX-TRIGGER">
            <xsd:annotation>
               <xsd:documentation>Check for message reception</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanTriggerType.rxTrigger"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TX-REF-TRIGGER">
            <xsd:annotation>
               <xsd:documentation>Send reference message in periodic case</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanTriggerType.txRefTrigger"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TX-REF-TRIGGER-GAP">
            <xsd:annotation>
               <xsd:documentation>Send reference message in event-synchronised case</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanTriggerType.txRefTriggerGap"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TX-TRIGGER-MERGED">
            <xsd:annotation>
               <xsd:documentation>Send message in a merged arbitration window</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanTriggerType.txTriggerMerged"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TX-TRIGGER-SINGLE">
            <xsd:annotation>
               <xsd:documentation>Send message in an exclusive time window</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanTriggerType.txTriggerSingle"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="WATCH-TRIGGER">
            <xsd:annotation>
               <xsd:documentation>Check for missing reference message in periodic case</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanTriggerType.watchTrigger"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="WATCH-TRIGGER-GAP">
            <xsd:annotation>
               <xsd:documentation>Check for missing reference message in event-synchronised case</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TtcanTriggerType.watchTriggerGap"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="UNLIMITED-INTEGER">
      <xsd:annotation>
         <xsd:documentation>An instance of UnlimitedInteger is an element in the set of integer numbers ( ..., -2, -1, 0, 1, 2, ...). 

      The range is limited by constraint 2534.

      The value can be expressed in decimal, octal, hexadecimal and binary representation. Negative numbers can only be expressed in decimal notation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnlimitedInteger";xml.xsd.customType="UNLIMITED-INTEGER";xml.xsd.pattern="[+\-]?[1-9][0-9]*|0x[0-9a-f]*|0[0-7]*|0b[0-1]*";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:UNLIMITED-INTEGER--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="UNLIMITED-INTEGER--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[+\-]?[1-9][0-9]*|0x[0-9a-f]*|0[0-7]*|0b[0-1]*"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="URI-STRING">
      <xsd:annotation>
         <xsd:documentation>A Uniform Resource Identifier (URI), is a compact string of characters used to identify or name a resource.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UriString";xml.xsd.customType="URI-STRING";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:URI-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="URI-STRING--SIMPLE">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>
   <xsd:complexType name="VALIGN-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies vertical alignment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ValignEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:VALIGN-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="VALIGN-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BOTTOM">
            <xsd:annotation>
               <xsd:documentation>The contents of the table cell is bottom aligned.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ValignEnum.bottom"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="MIDDLE">
            <xsd:annotation>
               <xsd:documentation>The contents of the table is vertically centered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ValignEnum.middle"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="TOP">
            <xsd:annotation>
               <xsd:documentation>The contents of the table cell is top aligned.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ValignEnum.top"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="VARIABLE-ACCESS-SCOPE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumeration defines scopes for communication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VariableAccessScopeEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:VARIABLE-ACCESS-SCOPE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="VARIABLE-ACCESS-SCOPE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COMMUNICATION-INTER-ECU">
            <xsd:annotation>
               <xsd:documentation>This case is foreseen to express that the corresponding communication shall be considered inter-ECU, i.e. it will cross the ECU boundary. This is considered the default case.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableAccessScopeEnum.communicationInterEcu"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="COMMUNICATION-INTRA-PARTITION">
            <xsd:annotation>
               <xsd:documentation>This case is foreseen to express that the corresponding communication shall '''not''' cross the boundary of a partition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableAccessScopeEnum.communicationIntraPartition"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="INTER-PARTITION-INTRA-ECU">
            <xsd:annotation>
               <xsd:documentation>In this case the communication shall cross the boundaries of partitions within one ECU but it shall not cross the boundaries of the ECU itself.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="VariableAccessScopeEnum.interPartitionIntraEcu"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="VERBATIM-STRING">
      <xsd:annotation>
         <xsd:documentation>This primitive represents a string in which white-space needs to be preserved.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="VerbatimString";xml.xsd.customType="VERBATIM-STRING";xml.xsd.type="string";xml.xsd.whiteSpace="preserve"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:VERBATIM-STRING--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="VERBATIM-STRING--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:whiteSpace value="preserve"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="VIEW-TOKENS">
      <xsd:annotation>
         <xsd:documentation>This primitive specifies the tokens to specify a documentation view.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ViewTokens";xml.xsd.customType="VIEW-TOKENS";xml.xsd.pattern="(-?[a-zA-Z_]+)(( )+-?[a-zA-Z_]+)*";xml.xsd.type="string"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">primitive</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:VIEW-TOKENS--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="VIEW-TOKENS--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="(-?[a-zA-Z_]+)(( )+-?[a-zA-Z_]+)*"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="XML-SPACE-ENUM">
      <xsd:annotation>
         <xsd:documentation>This enumerator specifies the fact that white-space shall be preserved.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="XmlSpaceEnum"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">enumeration</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:XML-SPACE-ENUM--SIMPLE">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:simpleType name="XML-SPACE-ENUM--SIMPLE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="default">
            <xsd:annotation>
               <xsd:documentation>The value "default" signals that applications' default white-space processing modes are acceptable for this element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="XmlSpaceEnum.default";xml.name="default"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
         <xsd:enumeration value="preserve">
            <xsd:annotation>
               <xsd:documentation>the value "preserve" indicates the intent that applications preserve all the white space.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="XmlSpaceEnum.preserve";xml.name="preserve"</xsd:appinfo>
            </xsd:annotation>
         </xsd:enumeration>
      </xsd:restriction>
   </xsd:simpleType>
</xsd:schema>
