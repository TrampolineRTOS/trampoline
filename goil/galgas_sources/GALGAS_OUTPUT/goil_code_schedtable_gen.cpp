//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'goil_code_schedtable_gen.cpp'                     *
//                        Generated by version 1.9.5                         *
//                     november 23th, 2009, at 12h7'23"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != 614
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_code_schedtable_gen.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_code_schedtable_gen.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "generate_schedule_tables"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_generate_schedule_tables (C_Compiler & inLexique,
                                GGS_scheduletable_map   var_cas_sts,
                                GGS_string_map   var_cas_app_for_obj,
                                GGS_string & /* var_cas_header */,
                                GGS_string & var_cas_obj_header,
                                GGS_string & var_cas_implementation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_generate_schedule_tables at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_h_result = GGS_string ("") ;
  GGS_string var_cas_i_result = GGS_string ("") ;
  GGS_string var_cas_st_table = GGS_string ("CONSTP2VAR(tpl_schedule_table, AUTOMATIC, OS_APPL_DATA)\n") ;
  var_cas_st_table.appendCString ("  tpl_schedtable_table[SCHEDTABLE_COUNT] = {\n") ;
  {
    GGS_scheduletable_map::cEnumerator enumerator_839 (var_cas_sts, true) ;
    const GGS_scheduletable_map::cElement * operand_839 = enumerator_839.nextObject () ;
    if ((operand_839 != NULL)) {
      GGS_uint var_cas_i (true, 0) ;
      bool _foreach_loop_839 ;
      do{
        macroValidPointer (operand_839) ;
        GGS_string var_cas_app_name = GGS_string ("") ;
        const GGS_bool cond_1010 = (var_cas_app_for_obj.reader_count ()).operator_strictSup (GGS_uint (0U)) ;
        if (cond_1010.isBuiltAndTrue ()) {
          const GGS_string_map  temp_981 = var_cas_app_for_obj ;
          if (temp_981.isBuilt ()) {
            temp_981 (HERE)->method_get (inLexique, operand_839->mKey, var_cas_app_name COMMA_SOURCE_FILE_AT_LINE (24)) ;
          }
        }
        const GGS_scheduletable_obj  temp_1034 = operand_839->mInfo.st ;
        if (temp_1034.isBuilt ()) {
          temp_1034 (HERE)->method_generate (inLexique, operand_839->mKey, var_cas_app_name, var_cas_i_result COMMA_SOURCE_FILE_AT_LINE (26)) ;
        }
        var_cas_h_result.appendCString ("#define ") ;
        var_cas_h_result.dotAssign_operation (operand_839->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (27))) ;
        var_cas_h_result.appendCString ("_id ") ;
        var_cas_h_result.dotAssign_operation (var_cas_i.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (27))) ;
        var_cas_h_result.appendCString ("\n") ;
        var_cas_h_result.appendCString ("CONST(ScheduleTableType, AUTOMATIC) ") ;
        var_cas_h_result.dotAssign_operation (operand_839->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (28))) ;
        var_cas_h_result.appendCString (" = ") ;
        var_cas_h_result.dotAssign_operation (operand_839->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (28))) ;
        var_cas_h_result.appendCString ("_id;\n") ;
        var_cas_st_table.appendCString ("    &") ;
        var_cas_st_table.dotAssign_operation (operand_839->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (29))) ;
        var_cas_st_table.appendCString ("_sched_table") ;
        var_cas_i.mValue ++ ;
        operand_839 = enumerator_839.nextObject () ;
        _foreach_loop_839 = ((operand_839 != NULL)) ;
        if (_foreach_loop_839) {
          var_cas_st_table.appendCString (",\n") ;
        }
      }while (_foreach_loop_839) ;
    }
  }
  var_cas_st_table.appendCString ("\n"
    "};\n") ;
  const GGS_bool cond_1443 = (var_cas_sts.reader_count ()).operator_isNotEqual (GGS_uint (0U)) ;
  if (cond_1443.isBuiltAndTrue ()) {
    var_cas_i_result.dotAssign_operation (var_cas_st_table) ;
  }
  ::routine_doReplace (inLexique,  var_cas_obj_header,  GGS_string ("$SCHEDTABLE_COUNT$"),  var_cas_sts.reader_count ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (39)) COMMA_SOURCE_FILE_AT_LINE (39)) ;
  ::routine_doReplace (inLexique,  var_cas_implementation,  GGS_string ("$SCHEDTABLEIDS$"),  var_cas_h_result COMMA_SOURCE_FILE_AT_LINE (40)) ;
  ::routine_doReplace (inLexique,  var_cas_implementation,  GGS_string ("$SCHEDULETABLES$"),  var_cas_i_result COMMA_SOURCE_FILE_AT_LINE (41)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_generate_schedule_tables\n") ;
  #endif
}

//---------------------------------------------------------------------------*

