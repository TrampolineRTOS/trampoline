//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'goil_types_os.cpp'                          *
//                       Generated by version 1.9.12                         *
//                       may 17th, 2010, at 15h23'54"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != 742
  #error "This file has been compiled with a version of GALGAS that uses libpm version 742, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_types_os.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_types_os.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_trace_method'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_method::
cPtr_trace_method (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_method * GGS_trace_method::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trace_method) ;
    return (cPtr_trace_method *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_trace_method::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trace_method:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_method::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_method::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_method (& typeid (cPtr_trace_method), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trace_method::galgasRTTI (void) const {
  return & gClassInfoFor__trace_method ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_trace_method'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trace_method ("trace_method", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_trace_method::
GGS_trace_method (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_method::
GGS_trace_method (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_method GGS_trace_method::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_method result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_method *> (inPointer) != NULL)
      : (typeid (cPtr_trace_method) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_method (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_method),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_trace_method::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_method *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_method *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_method::actualTypeName (void) const {
  return "trace_method" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_trace_method::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__trace_method ("trace_method", & kTypeDescriptor_GGS_trace_method) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trace_method::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trace_method * p = NULL ;
    macroMyNew (p, GGS_trace_method (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_method GGS_trace_method::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trace_method result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trace_method * p = dynamic_cast <const GGS_trace_method *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trace_method, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trace_method::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trace_method ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_trace_void'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_void::
cPtr_trace_void (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_trace_method (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_void * GGS_trace_void::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trace_void) ;
    return (cPtr_trace_void *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_void::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_void * ptr = dynamic_cast <const cPtr_trace_void *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_void::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trace_void:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_void::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_void::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_void (& typeid (cPtr_trace_void), & typeid (cPtr_trace_method), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trace_void::galgasRTTI (void) const {
  return & gClassInfoFor__trace_void ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace_void::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace_void (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_trace_void'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trace_void ("trace_void", true, & kTypeDescriptor_GGS_trace_method) ;

//---------------------------------------------------------------------------*

GGS_trace_void::
GGS_trace_void (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_void::
GGS_trace_void (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_void GGS_trace_void::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_void result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_void *> (inPointer) != NULL)
      : (typeid (cPtr_trace_void) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_void (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_void),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_void GGS_trace_void::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace_void result ;
  macroMyNew (result.mPointer, cPtr_trace_void (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_void::actualTypeName (void) const {
  return "trace_void" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trace_void ("trace_void", gClassInfoFor__trace_method, & kTypeDescriptor_GGS_trace_void) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trace_void::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trace_void * p = NULL ;
    macroMyNew (p, GGS_trace_void (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_void GGS_trace_void::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trace_void result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trace_void * p = dynamic_cast <const GGS_trace_void *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trace_void, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trace_void::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trace_void ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_trace_file'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_file::
cPtr_trace_file (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_trace_method (argument_0 COMMA_THERE),
name (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_file * GGS_trace_file::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trace_file) ;
    return (cPtr_trace_file *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_file::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_file * ptr = dynamic_cast <const cPtr_trace_file *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && name.operator_isEqual (ptr->name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_file::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trace_file:"
           << loc.reader_description (inIndentation + 1)
           << name.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_file::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_file::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_file (& typeid (cPtr_trace_file), & typeid (cPtr_trace_method), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trace_file::galgasRTTI (void) const {
  return & gClassInfoFor__trace_file ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace_file::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace_file (loc, name COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_trace_file'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trace_file ("trace_file", true, & kTypeDescriptor_GGS_trace_method) ;

//---------------------------------------------------------------------------*

GGS_trace_file::
GGS_trace_file (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_file::
GGS_trace_file (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_file GGS_trace_file::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_file result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_file *> (inPointer) != NULL)
      : (typeid (cPtr_trace_file) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_file (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_file),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_file GGS_trace_file::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_trace_file result ;
  macroMyNew (result.mPointer, cPtr_trace_file (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_trace_file::
reader_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_file *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_file *) mPointer)->name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_file::actualTypeName (void) const {
  return "trace_file" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trace_file ("trace_file", gClassInfoFor__trace_method, & kTypeDescriptor_GGS_trace_file) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trace_file::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trace_file * p = NULL ;
    macroMyNew (p, GGS_trace_file (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_file GGS_trace_file::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trace_file result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trace_file * p = dynamic_cast <const GGS_trace_file *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trace_file, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trace_file::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trace_file ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'cPtr_trace'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace::
cPtr_trace (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace * GGS_trace::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trace) ;
    return (cPtr_trace *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace * ptr = dynamic_cast <const cPtr_trace *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trace:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace (& typeid (cPtr_trace), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trace::galgasRTTI (void) const {
  return & gClassInfoFor__trace ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         GALGAS class 'GGS_trace'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trace ("trace", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_trace::
GGS_trace (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace::
GGS_trace (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace GGS_trace::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace *> (inPointer) != NULL)
      : (typeid (cPtr_trace) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace GGS_trace::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace result ;
  macroMyNew (result.mPointer, cPtr_trace (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_trace::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace::actualTypeName (void) const {
  return "trace" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_trace::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__trace ("trace", & kTypeDescriptor_GGS_trace) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trace::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trace * p = NULL ;
    macroMyNew (p, GGS_trace (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace GGS_trace::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trace result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trace * p = dynamic_cast <const GGS_trace *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trace, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trace::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trace ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_trace_off'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_off::
cPtr_trace_off (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_trace (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_off * GGS_trace_off::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trace_off) ;
    return (cPtr_trace_off *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_off::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_off * ptr = dynamic_cast <const cPtr_trace_off *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_off::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trace_off:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_off::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_off::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_off (& typeid (cPtr_trace_off), & typeid (cPtr_trace), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trace_off::galgasRTTI (void) const {
  return & gClassInfoFor__trace_off ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace_off::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace_off (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_trace_off'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trace_off ("trace_off", true, & kTypeDescriptor_GGS_trace) ;

//---------------------------------------------------------------------------*

GGS_trace_off::
GGS_trace_off (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_off::
GGS_trace_off (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_off GGS_trace_off::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_off result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_off *> (inPointer) != NULL)
      : (typeid (cPtr_trace_off) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_off (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_off),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_off GGS_trace_off::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trace_off result ;
  macroMyNew (result.mPointer, cPtr_trace_off (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_off::actualTypeName (void) const {
  return "trace_off" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trace_off ("trace_off", gClassInfoFor__trace, & kTypeDescriptor_GGS_trace_off) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trace_off::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trace_off * p = NULL ;
    macroMyNew (p, GGS_trace_off (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_off GGS_trace_off::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trace_off result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trace_off * p = dynamic_cast <const GGS_trace_off *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trace_off, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trace_off::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trace_off ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_trace_on'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trace_on::
cPtr_trace_on (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_trace_method & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_basic_type & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_basic_type & argument_7,
                                const GGS_basic_type & argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_trace (argument_0 COMMA_THERE),
form (argument_1),
meth (argument_2),
trace_task (argument_3),
trace_isr (argument_4),
trace_resource (argument_5),
trace_alarm (argument_6),
trace_user_event (argument_7),
desc (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trace_on * GGS_trace_on::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trace_on) ;
    return (cPtr_trace_on *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trace_on::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trace_on * ptr = dynamic_cast <const cPtr_trace_on *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && form.operator_isEqual (ptr->form).boolValue ()
         && meth.operator_isEqual (ptr->meth).boolValue ()
         && trace_task.operator_isEqual (ptr->trace_task).boolValue ()
         && trace_isr.operator_isEqual (ptr->trace_isr).boolValue ()
         && trace_resource.operator_isEqual (ptr->trace_resource).boolValue ()
         && trace_alarm.operator_isEqual (ptr->trace_alarm).boolValue ()
         && trace_user_event.operator_isEqual (ptr->trace_user_event).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trace_on::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trace_on:"
           << loc.reader_description (inIndentation + 1)
           << form.reader_description (inIndentation + 1)
           << meth.reader_description (inIndentation + 1)
           << trace_task.reader_description (inIndentation + 1)
           << trace_isr.reader_description (inIndentation + 1)
           << trace_resource.reader_description (inIndentation + 1)
           << trace_alarm.reader_description (inIndentation + 1)
           << trace_user_event.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trace_on::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trace_on::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trace_on (& typeid (cPtr_trace_on), & typeid (cPtr_trace), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trace_on::galgasRTTI (void) const {
  return & gClassInfoFor__trace_on ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trace_on::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trace_on (loc, form, meth, trace_task, trace_isr, trace_resource, trace_alarm, trace_user_event, desc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_trace_on'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trace_on ("trace_on", true, & kTypeDescriptor_GGS_trace) ;

//---------------------------------------------------------------------------*

GGS_trace_on::
GGS_trace_on (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trace_on::
GGS_trace_on (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trace_on GGS_trace_on::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trace_on result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trace_on *> (inPointer) != NULL)
      : (typeid (cPtr_trace_on) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trace_on (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trace_on),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_on GGS_trace_on::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_trace_method & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_basic_type & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_basic_type & argument_7,
                 const GGS_basic_type & argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_trace_on result ;
  macroMyNew (result.mPointer, cPtr_trace_on (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_trace_on::
reader_form (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->form ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_method  GGS_trace_on::
reader_meth (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_trace_method   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->meth ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_task (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_task ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_isr (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_isr ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_resource (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_resource ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_alarm (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_alarm ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_trace_user_event (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->trace_user_event ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_trace_on::
reader_desc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trace_on *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trace_on *) mPointer)->desc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trace_on::actualTypeName (void) const {
  return "trace_on" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trace_on ("trace_on", gClassInfoFor__trace, & kTypeDescriptor_GGS_trace_on) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trace_on::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trace_on * p = NULL ;
    macroMyNew (p, GGS_trace_on (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace_on GGS_trace_on::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trace_on result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trace_on * p = dynamic_cast <const GGS_trace_on *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trace_on, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trace_on::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trace_on ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_method"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_method (C_Compiler & inLexique,
                                GGS_trace_method  & var_cas_t,
                                GGS_trace_method   var_cas_s,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_method at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_trace_method _var_2944 = var_cas_t ; // CAST instruction
    if (_var_2944.getPtr () != NULL) {
      macroValidPointer (_var_2944.getPtr ()) ;
      if (typeid (cPtr_trace_void) == typeid (* (_var_2944.getPtr ()))) {
        var_cas_t = var_cas_s ;
      }else{
        var_cas_s.reader_loc (inLexique COMMA_SOURCE_FILE_AT_LINE (112)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (113)) ;
        var_cas_t.reader_loc (inLexique COMMA_SOURCE_FILE_AT_LINE (113)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (114)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_method\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_no_linker'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_no_linker::
cPtr_no_linker (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_no_linker * GGS_no_linker::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_no_linker) ;
    return (cPtr_no_linker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_no_linker::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_no_linker * ptr = dynamic_cast <const cPtr_no_linker *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_no_linker::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@no_linker:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_no_linker::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_no_linker::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_no_linker (& typeid (cPtr_no_linker), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_no_linker::galgasRTTI (void) const {
  return & gClassInfoFor__no_linker ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_no_linker::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_no_linker (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_no_linker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_no_linker ("no_linker", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_no_linker::
GGS_no_linker (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_no_linker::
GGS_no_linker (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_no_linker GGS_no_linker::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_no_linker result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_no_linker *> (inPointer) != NULL)
      : (typeid (cPtr_no_linker) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_no_linker (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_no_linker),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_no_linker GGS_no_linker::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_no_linker result ;
  macroMyNew (result.mPointer, cPtr_no_linker (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_no_linker::actualTypeName (void) const {
  return "no_linker" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__no_linker ("no_linker", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_no_linker) ;

//---------------------------------------------------------------------------*

GGS_object GGS_no_linker::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_no_linker * p = NULL ;
    macroMyNew (p, GGS_no_linker (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_no_linker GGS_no_linker::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_no_linker result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_no_linker * p = dynamic_cast <const GGS_no_linker *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_no_linker, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_no_linker::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_no_linker ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_yes_linker'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_yes_linker::
cPtr_yes_linker (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
linker (argument_1),
script (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_yes_linker * GGS_yes_linker::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_yes_linker) ;
    return (cPtr_yes_linker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_yes_linker::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_yes_linker * ptr = dynamic_cast <const cPtr_yes_linker *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && linker.operator_isEqual (ptr->linker).boolValue ()
         && script.operator_isEqual (ptr->script).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_yes_linker::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@yes_linker:"
           << location.reader_description (inIndentation + 1)
           << linker.reader_description (inIndentation + 1)
           << script.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_yes_linker::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_yes_linker::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_yes_linker (& typeid (cPtr_yes_linker), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_yes_linker::galgasRTTI (void) const {
  return & gClassInfoFor__yes_linker ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_yes_linker::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_yes_linker (location, linker, script COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_yes_linker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_yes_linker ("yes_linker", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_yes_linker::
GGS_yes_linker (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_yes_linker::
GGS_yes_linker (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_yes_linker GGS_yes_linker::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_yes_linker result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_yes_linker *> (inPointer) != NULL)
      : (typeid (cPtr_yes_linker) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_yes_linker (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_yes_linker),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_yes_linker GGS_yes_linker::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_yes_linker result ;
  macroMyNew (result.mPointer, cPtr_yes_linker (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_yes_linker::
reader_linker (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_yes_linker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_yes_linker *) mPointer)->linker ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_yes_linker::
reader_script (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_yes_linker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_yes_linker *) mPointer)->script ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_yes_linker::actualTypeName (void) const {
  return "yes_linker" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__yes_linker ("yes_linker", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_yes_linker) ;

//---------------------------------------------------------------------------*

GGS_object GGS_yes_linker::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_yes_linker * p = NULL ;
    macroMyNew (p, GGS_yes_linker (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_yes_linker GGS_yes_linker::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_yes_linker result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_yes_linker * p = dynamic_cast <const GGS_yes_linker *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_yes_linker, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_yes_linker::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_yes_linker ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_linker"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_linker (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_l,
                                GGS_basic_type   var_cas_nl,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_linker at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_3324 = var_cas_l ; // CAST instruction
    if (_var_3324.getPtr () != NULL) {
      macroValidPointer (_var_3324.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_3324.getPtr ()))) {
        var_cas_l = var_cas_nl ;
      }else{
        var_cas_nl.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (133)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (134)) ;
        var_cas_l.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (134)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (135)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_linker\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_memmap_false'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_memmap_false::
cPtr_memmap_false (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_memmap_false * GGS_memmap_false::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_memmap_false) ;
    return (cPtr_memmap_false *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_memmap_false::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_memmap_false * ptr = dynamic_cast <const cPtr_memmap_false *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_memmap_false::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@memmap_false:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_memmap_false::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_memmap_false::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_memmap_false (& typeid (cPtr_memmap_false), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_memmap_false::galgasRTTI (void) const {
  return & gClassInfoFor__memmap_false ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_memmap_false::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_memmap_false (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_memmap_false'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_memmap_false ("memmap_false", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_memmap_false::
GGS_memmap_false (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_memmap_false::
GGS_memmap_false (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_memmap_false GGS_memmap_false::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_memmap_false result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_memmap_false *> (inPointer) != NULL)
      : (typeid (cPtr_memmap_false) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_memmap_false (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_memmap_false),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_memmap_false GGS_memmap_false::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_memmap_false result ;
  macroMyNew (result.mPointer, cPtr_memmap_false (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_memmap_false::actualTypeName (void) const {
  return "memmap_false" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__memmap_false ("memmap_false", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_memmap_false) ;

//---------------------------------------------------------------------------*

GGS_object GGS_memmap_false::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_memmap_false * p = NULL ;
    macroMyNew (p, GGS_memmap_false (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_memmap_false GGS_memmap_false::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_memmap_false result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_memmap_false * p = dynamic_cast <const GGS_memmap_false *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_memmap_false, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_memmap_false::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_memmap_false ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_memmap_true'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_memmap_true::
cPtr_memmap_true (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_basic_type & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
compiler (argument_1),
assembler (argument_2),
linker (argument_3),
memory_prot (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_memmap_true * GGS_memmap_true::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_memmap_true) ;
    return (cPtr_memmap_true *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_memmap_true::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_memmap_true * ptr = dynamic_cast <const cPtr_memmap_true *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && compiler.operator_isEqual (ptr->compiler).boolValue ()
         && assembler.operator_isEqual (ptr->assembler).boolValue ()
         && linker.operator_isEqual (ptr->linker).boolValue ()
         && memory_prot.operator_isEqual (ptr->memory_prot).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_memmap_true::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@memmap_true:"
           << location.reader_description (inIndentation + 1)
           << compiler.reader_description (inIndentation + 1)
           << assembler.reader_description (inIndentation + 1)
           << linker.reader_description (inIndentation + 1)
           << memory_prot.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_memmap_true::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_memmap_true::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_memmap_true (& typeid (cPtr_memmap_true), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_memmap_true::galgasRTTI (void) const {
  return & gClassInfoFor__memmap_true ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_memmap_true::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_memmap_true (location, compiler, assembler, linker, memory_prot COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_memmap_true'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_memmap_true ("memmap_true", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_memmap_true::
GGS_memmap_true (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_memmap_true::
GGS_memmap_true (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_memmap_true GGS_memmap_true::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_memmap_true result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_memmap_true *> (inPointer) != NULL)
      : (typeid (cPtr_memmap_true) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_memmap_true (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_memmap_true),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_memmap_true GGS_memmap_true::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_basic_type & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_memmap_true result ;
  macroMyNew (result.mPointer, cPtr_memmap_true (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_memmap_true::
reader_compiler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_memmap_true *) mPointer)->compiler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_memmap_true::
reader_assembler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_memmap_true *) mPointer)->assembler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_memmap_true::
reader_linker (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_memmap_true *) mPointer)->linker ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_memmap_true::
reader_memory_prot (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_memmap_true *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_memmap_true *) mPointer)->memory_prot ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_memmap_true::actualTypeName (void) const {
  return "memmap_true" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__memmap_true ("memmap_true", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_memmap_true) ;

//---------------------------------------------------------------------------*

GGS_object GGS_memmap_true::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_memmap_true * p = NULL ;
    macroMyNew (p, GGS_memmap_true (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_memmap_true GGS_memmap_true::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_memmap_true result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_memmap_true * p = dynamic_cast <const GGS_memmap_true *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_memmap_true, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_memmap_true::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_memmap_true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "link_script_name"                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_link_script_name (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_mm COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_link_script_name at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_name ;
  { const GGS_basic_type _var_3834 = var_cas_mm ; // CAST instruction
    if (_var_3834.getPtr () != NULL) {
      macroValidPointer (_var_3834.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_3834.getPtr ()))) {
        const GGS_memmap_true var_cas_m (_var_3834.getPtr ()) ;
        { const GGS_basic_type _var_3759 = var_cas_m.reader_linker (inLexique COMMA_SOURCE_FILE_AT_LINE (153)) ; // CAST instruction
          if (_var_3759.getPtr () != NULL) {
            macroValidPointer (_var_3759.getPtr ()) ;
            if (typeid (cPtr_yes_linker) == typeid (* (_var_3759.getPtr ()))) {
              const GGS_yes_linker var_cas_l (_var_3759.getPtr ()) ;
              var_cas_name = var_cas_l.reader_script (inLexique COMMA_SOURCE_FILE_AT_LINE (155)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (155)) ;
            }else{
              var_cas_name = GGS_string ("") ;
            }
          }
        }
      }else{
        var_cas_name = GGS_string ("") ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_link_script_name\n") ;
  #endif
  return var_cas_name ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_link_script_name (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_basic_type  arg_0 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_link_script_name (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_link_script_name [1] = {& kTypeDescriptor_GGS_basic_type } ;

const C_galgas_function_descriptorEX
kFunction_descriptor_link_script_name ("link_script_name",
                              functionForGenericCall_link_script_name,
                              & kTypeDescriptor_GGS_string,
                              1,
                              kArgumentTypeList_link_script_name) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_memmap"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_memmap (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_m,
                                GGS_basic_type   var_cas_nm,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_memmap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_4089 = var_cas_m ; // CAST instruction
    if (_var_4089.getPtr () != NULL) {
      macroValidPointer (_var_4089.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_4089.getPtr ()))) {
        var_cas_m = var_cas_nm ;
      }else{
        var_cas_nm.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (174)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (175)) ;
        var_cas_m.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (175)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (176)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_memmap\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_os_obj'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_os_obj::
cPtr_os_obj (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_basic_type & argument_2,
                                const GGS_basic_type & argument_3,
                                const GGS_basic_type & argument_4,
                                const GGS_basic_type & argument_5,
                                const GGS_basic_type & argument_6,
                                const GGS_basic_type & argument_7,
                                const GGS_lstring & argument_8,
                                const GGS_basic_type & argument_9,
                                const GGS_basic_type & argument_10,
                                const GGS_basic_type & argument_11,
                                const GGS_basic_type & argument_12,
                                const GGS_basic_type & argument_13,
                                const GGS_basic_type & argument_14,
                                const GGS_basic_type & argument_15,
                                const GGS_lstringlist & argument_16,
                                const GGS_lstring & argument_17,
                                const GGS_lstring & argument_18,
                                const GGS_lstring & argument_19,
                                const GGS_lstringlist & argument_20,
                                const GGS_lstringlist & argument_21,
                                const GGS_lstringlist & argument_22,
                                const GGS_lstring & argument_23,
                                const GGS_lstring & argument_24,
                                const GGS_trace & argument_25,
                                const GGS_ident_map & argument_26
                                COMMA_LOCATION_ARGS)
:cPtr_oil_obj (argument_0 COMMA_THERE),
status (argument_1),
startuphook (argument_2),
shutdownhook (argument_3),
errorhook (argument_4),
pretaskhook (argument_5),
posttaskhook (argument_6),
protectionhook (argument_7),
scalabilityclass (argument_8),
stackmonitoring (argument_9),
usegetserviceid (argument_10),
useparameteraccess (argument_11),
useresscheduler (argument_12),
systemcall (argument_13),
debug (argument_14),
memmap (argument_15),
app_src (argument_16),
compiler (argument_17),
assembler (argument_18),
linker (argument_19),
cflags (argument_20),
asflags (argument_21),
ldflags (argument_22),
app_name (argument_23),
tpl_base_path (argument_24),
trace (argument_25),
others (argument_26) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_os_obj * GGS_os_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_os_obj) ;
    return (cPtr_os_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_os_obj::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_os_obj * ptr = dynamic_cast <const cPtr_os_obj *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = desc.operator_isEqual (ptr->desc).boolValue ()
         && status.operator_isEqual (ptr->status).boolValue ()
         && startuphook.operator_isEqual (ptr->startuphook).boolValue ()
         && shutdownhook.operator_isEqual (ptr->shutdownhook).boolValue ()
         && errorhook.operator_isEqual (ptr->errorhook).boolValue ()
         && pretaskhook.operator_isEqual (ptr->pretaskhook).boolValue ()
         && posttaskhook.operator_isEqual (ptr->posttaskhook).boolValue ()
         && protectionhook.operator_isEqual (ptr->protectionhook).boolValue ()
         && scalabilityclass.operator_isEqual (ptr->scalabilityclass).boolValue ()
         && stackmonitoring.operator_isEqual (ptr->stackmonitoring).boolValue ()
         && usegetserviceid.operator_isEqual (ptr->usegetserviceid).boolValue ()
         && useparameteraccess.operator_isEqual (ptr->useparameteraccess).boolValue ()
         && useresscheduler.operator_isEqual (ptr->useresscheduler).boolValue ()
         && systemcall.operator_isEqual (ptr->systemcall).boolValue ()
         && debug.operator_isEqual (ptr->debug).boolValue ()
         && memmap.operator_isEqual (ptr->memmap).boolValue ()
         && app_src.operator_isEqual (ptr->app_src).boolValue ()
         && compiler.operator_isEqual (ptr->compiler).boolValue ()
         && assembler.operator_isEqual (ptr->assembler).boolValue ()
         && linker.operator_isEqual (ptr->linker).boolValue ()
         && cflags.operator_isEqual (ptr->cflags).boolValue ()
         && asflags.operator_isEqual (ptr->asflags).boolValue ()
         && ldflags.operator_isEqual (ptr->ldflags).boolValue ()
         && app_name.operator_isEqual (ptr->app_name).boolValue ()
         && tpl_base_path.operator_isEqual (ptr->tpl_base_path).boolValue ()
         && trace.operator_isEqual (ptr->trace).boolValue ()
         && others.operator_isEqual (ptr->others).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_os_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@os_obj:"
           << desc.reader_description (inIndentation + 1)
           << status.reader_description (inIndentation + 1)
           << startuphook.reader_description (inIndentation + 1)
           << shutdownhook.reader_description (inIndentation + 1)
           << errorhook.reader_description (inIndentation + 1)
           << pretaskhook.reader_description (inIndentation + 1)
           << posttaskhook.reader_description (inIndentation + 1)
           << protectionhook.reader_description (inIndentation + 1)
           << scalabilityclass.reader_description (inIndentation + 1)
           << stackmonitoring.reader_description (inIndentation + 1)
           << usegetserviceid.reader_description (inIndentation + 1)
           << useparameteraccess.reader_description (inIndentation + 1)
           << useresscheduler.reader_description (inIndentation + 1)
           << systemcall.reader_description (inIndentation + 1)
           << debug.reader_description (inIndentation + 1)
           << memmap.reader_description (inIndentation + 1)
           << app_src.reader_description (inIndentation + 1)
           << compiler.reader_description (inIndentation + 1)
           << assembler.reader_description (inIndentation + 1)
           << linker.reader_description (inIndentation + 1)
           << cflags.reader_description (inIndentation + 1)
           << asflags.reader_description (inIndentation + 1)
           << ldflags.reader_description (inIndentation + 1)
           << app_name.reader_description (inIndentation + 1)
           << tpl_base_path.reader_description (inIndentation + 1)
           << trace.reader_description (inIndentation + 1)
           << others.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_os_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_os_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_os_obj (& typeid (cPtr_os_obj), & typeid (cPtr_oil_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_os_obj::galgasRTTI (void) const {
  return & gClassInfoFor__os_obj ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_os_obj::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_os_obj (desc, status, startuphook, shutdownhook, errorhook, pretaskhook, posttaskhook, protectionhook, scalabilityclass, stackmonitoring, usegetserviceid, useparameteraccess, useresscheduler, systemcall, debug, memmap, app_src, compiler, assembler, linker, cflags, asflags, ldflags, app_name, tpl_base_path, trace, others COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_os_obj'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_os_obj ("os_obj", true, & kTypeDescriptor_GGS_oil_obj) ;

//---------------------------------------------------------------------------*

GGS_os_obj::
GGS_os_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_os_obj::
GGS_os_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_os_obj GGS_os_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_os_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_os_obj *> (inPointer) != NULL)
      : (typeid (cPtr_os_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_os_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_os_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_obj GGS_os_obj::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_basic_type & argument_2,
                 const GGS_basic_type & argument_3,
                 const GGS_basic_type & argument_4,
                 const GGS_basic_type & argument_5,
                 const GGS_basic_type & argument_6,
                 const GGS_basic_type & argument_7,
                 const GGS_lstring & argument_8,
                 const GGS_basic_type & argument_9,
                 const GGS_basic_type & argument_10,
                 const GGS_basic_type & argument_11,
                 const GGS_basic_type & argument_12,
                 const GGS_basic_type & argument_13,
                 const GGS_basic_type & argument_14,
                 const GGS_basic_type & argument_15,
                 const GGS_lstringlist & argument_16,
                 const GGS_lstring & argument_17,
                 const GGS_lstring & argument_18,
                 const GGS_lstring & argument_19,
                 const GGS_lstringlist & argument_20,
                 const GGS_lstringlist & argument_21,
                 const GGS_lstringlist & argument_22,
                 const GGS_lstring & argument_23,
                 const GGS_lstring & argument_24,
                 const GGS_trace & argument_25,
                 const GGS_ident_map & argument_26
                                COMMA_LOCATION_ARGS) {
  GGS_os_obj result ;
  macroMyNew (result.mPointer, cPtr_os_obj (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11,
                                argument_12,
                                argument_13,
                                argument_14,
                                argument_15,
                                argument_16,
                                argument_17,
                                argument_18,
                                argument_19,
                                argument_20,
                                argument_21,
                                argument_22,
                                argument_23,
                                argument_24,
                                argument_25,
                                argument_26 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_status (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->status ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_startuphook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->startuphook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_shutdownhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->shutdownhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_errorhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->errorhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_pretaskhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->pretaskhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_posttaskhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->posttaskhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_protectionhook (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->protectionhook ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_scalabilityclass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->scalabilityclass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_stackmonitoring (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->stackmonitoring ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_usegetserviceid (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->usegetserviceid ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_useparameteraccess (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->useparameteraccess ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_useresscheduler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->useresscheduler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_systemcall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->systemcall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_debug (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->debug ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type  GGS_os_obj::
reader_memmap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_basic_type   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->memmap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_app_src (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->app_src ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_compiler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->compiler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_assembler (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->assembler ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_linker (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->linker ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_cflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->cflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_asflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->asflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_os_obj::
reader_ldflags (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->ldflags ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_app_name (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->app_name ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_os_obj::
reader_tpl_base_path (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->tpl_base_path ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trace  GGS_os_obj::
reader_trace (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_trace   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->trace ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map  GGS_os_obj::
reader_others (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_os_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_os_obj *) mPointer)->others ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setStatus (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->status = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setStartuphook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->startuphook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setShutdownhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->shutdownhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setErrorhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->errorhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setPretaskhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->pretaskhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setPosttaskhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->posttaskhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setProtectionhook (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->protectionhook = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setScalabilityclass (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->scalabilityclass = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setStackmonitoring (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->stackmonitoring = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setUsegetserviceid (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->usegetserviceid = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setUseparameteraccess (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->useparameteraccess = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setUseresscheduler (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->useresscheduler = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setSystemcall (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->systemcall = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setDebug (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->debug = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setMemmap (C_Compiler & /* inLexique */, const GGS_basic_type & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->memmap = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setApp_src (C_Compiler & /* inLexique */, const GGS_lstringlist & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->app_src = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setCompiler (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->compiler = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setAssembler (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->assembler = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setLinker (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->linker = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setCflags (C_Compiler & /* inLexique */, const GGS_lstringlist & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->cflags = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setAsflags (C_Compiler & /* inLexique */, const GGS_lstringlist & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->asflags = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setLdflags (C_Compiler & /* inLexique */, const GGS_lstringlist & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->ldflags = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setApp_name (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->app_name = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setTpl_base_path (C_Compiler & /* inLexique */, const GGS_lstring & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->tpl_base_path = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setTrace (C_Compiler & /* inLexique */, const GGS_trace & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->trace = inValue ;
  }
}

//---------------------------------------------------------------------------*

void GGS_os_obj::
modifier_setOthers (C_Compiler & /* inLexique */, const GGS_ident_map & inValue COMMA_UNUSED_LOCATION_ARGS) {
  if ((mPointer != NULL) && inValue.isBuilt ()) {
    macroValidPointer (mPointer) ;
    if (mPointer->retainCount () > 1) {
      cPtr_os_obj * clone = dynamic_cast <cPtr_os_obj *> (mPointer->makeClone ()) ;
      macroValidPointer (clone) ;
      macroAssignObject (mPointer, clone) ;
    }
    ((cPtr_os_obj *) mPointer)->others = inValue ;
  }
}

//---------------------------------------------------------------------------*

const char * GGS_os_obj::actualTypeName (void) const {
  return "os_obj" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__os_obj ("os_obj", gClassInfoFor__oil_obj, & kTypeDescriptor_GGS_os_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_os_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_os_obj * p = NULL ;
    macroMyNew (p, GGS_os_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_os_obj GGS_os_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_os_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_os_obj * p = dynamic_cast <const GGS_os_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_os_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_os_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_os_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of function "applicationName"                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lstring  function_applicationName (C_Compiler & inLexique,
                                const GGS_os_obj   var_cas_os COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_applicationName at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_lstring  var_cas_name ;
  var_cas_name = var_cas_os.reader_app_name (inLexique COMMA_SOURCE_FILE_AT_LINE (209)) ;
  const GGS_bool cond_5632 = (var_cas_name.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (210))).operator_isEqual (GGS_string ("")) ;
  if (cond_5632.isBuiltAndTrue ()) {
    var_cas_name = function_lstringWith (inLexique, GGS_string ("trampoline") COMMA_SOURCE_FILE_AT_LINE (211)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_applicationName\n") ;
  #endif
  return var_cas_name ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_applicationName (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_os_obj  arg_0 = GGS_os_obj ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_lstring  result = function_applicationName (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_applicationName [1] = {& kTypeDescriptor_GGS_os_obj } ;

const C_galgas_function_descriptorEX
kFunction_descriptor_applicationName ("applicationName",
                              functionForGenericCall_applicationName,
                              & kTypeDescriptor_GGS_lstring ,
                              1,
                              kArgumentTypeList_applicationName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "memory_protection"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_basic_type  function_memory_protection (C_Compiler & inLexique,
                                GGS_os_obj   var_cas_os COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_memory_protection at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_basic_type  var_cas_mp ;
  { const GGS_basic_type _var_5850 = var_cas_os.reader_memmap (inLexique COMMA_SOURCE_FILE_AT_LINE (219)) ; // CAST instruction
    if (_var_5850.getPtr () != NULL) {
      macroValidPointer (_var_5850.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_5850.getPtr ()))) {
        const GGS_memmap_true var_cas_mm (_var_5850.getPtr ()) ;
        var_cas_mp = var_cas_mm.reader_memory_prot (inLexique COMMA_SOURCE_FILE_AT_LINE (221)) ;
      }else{
        var_cas_mp = GGS_bool_class ::constructor_new (inLexique, GGS_location (inLexique), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (223)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_memory_protection\n") ;
  #endif
  return var_cas_mp ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_memory_protection (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_os_obj  arg_0 = GGS_os_obj ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_basic_type  result = function_memory_protection (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_memory_protection [1] = {& kTypeDescriptor_GGS_os_obj } ;

const C_galgas_function_descriptorEX
kFunction_descriptor_memory_protection ("memory_protection",
                              functionForGenericCall_memory_protection,
                              & kTypeDescriptor_GGS_basic_type ,
                              1,
                              kArgumentTypeList_memory_protection) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of function "memory_protection_on"              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool function_memory_protection_on (C_Compiler & inLexique,
                                GGS_os_obj   var_cas_os COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_memory_protection_on at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_mp ;
  { const GGS_basic_type _var_6132 = var_cas_os.reader_memmap (inLexique COMMA_SOURCE_FILE_AT_LINE (231)) ; // CAST instruction
    if (_var_6132.getPtr () != NULL) {
      macroValidPointer (_var_6132.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_6132.getPtr ()))) {
        const GGS_memmap_true var_cas_mm (_var_6132.getPtr ()) ;
        { const GGS_basic_type _var_6096 = var_cas_mm.reader_memory_prot (inLexique COMMA_SOURCE_FILE_AT_LINE (233)) ; // CAST instruction
          if (_var_6096.getPtr () != NULL) {
            macroValidPointer (_var_6096.getPtr ()) ;
            if (typeid (cPtr_bool_class) == typeid (* (_var_6096.getPtr ()))) {
              const GGS_bool_class var_cas_b (_var_6096.getPtr ()) ;
              var_cas_mp = var_cas_b.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (235)) ;
            }else{
              var_cas_mp = GGS_bool (false) ;
            }
          }
        }
      }else{
        var_cas_mp = GGS_bool (false) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_memory_protection_on\n") ;
  #endif
  return var_cas_mp ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_memory_protection_on (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_os_obj  arg_0 = GGS_os_obj ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool result = function_memory_protection_on (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_memory_protection_on [1] = {& kTypeDescriptor_GGS_os_obj } ;

const C_galgas_function_descriptorEX
kFunction_descriptor_memory_protection_on ("memory_protection_on",
                              functionForGenericCall_memory_protection_on,
                              & kTypeDescriptor_GGS_bool,
                              1,
                              kArgumentTypeList_memory_protection_on) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of function "memory_mapping"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool function_memory_mapping (C_Compiler & inLexique,
                                GGS_os_obj   var_cas_os COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_memory_mapping at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_mm ;
  { const GGS_basic_type _var_6299 = var_cas_os.reader_memmap (inLexique COMMA_SOURCE_FILE_AT_LINE (248)) ; // CAST instruction
    if (_var_6299.getPtr () != NULL) {
      macroValidPointer (_var_6299.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_6299.getPtr ()))) {
        var_cas_mm = GGS_bool (true) ;
      }else{
        var_cas_mm = GGS_bool (false) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_memory_mapping\n") ;
  #endif
  return var_cas_mm ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_memory_mapping (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_os_obj  arg_0 = GGS_os_obj ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool result = function_memory_mapping (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_memory_mapping [1] = {& kTypeDescriptor_GGS_os_obj } ;

const C_galgas_function_descriptorEX
kFunction_descriptor_memory_mapping ("memory_mapping",
                              functionForGenericCall_memory_mapping,
                              & kTypeDescriptor_GGS_bool,
                              1,
                              kArgumentTypeList_memory_mapping) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of function "compiler"                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_compiler (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_os_memmap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_compiler at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_cc ;
  { const GGS_basic_type _var_6879 = var_cas_os_memmap ; // CAST instruction
    if (_var_6879.getPtr () != NULL) {
      macroValidPointer (_var_6879.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_6879.getPtr ()))) {
        const GGS_memmap_true var_cas_s (_var_6879.getPtr ()) ;
        var_cas_cc = var_cas_s.reader_compiler (inLexique COMMA_SOURCE_FILE_AT_LINE (266)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (266)) ;
        var_cas_cc = (GGS_string ("compiler/")).operator_concat (var_cas_cc) ;
        GGS_string var_cas_rtd = function_rootTemplatesDirectory (inLexique COMMA_SOURCE_FILE_AT_LINE (268)) ;
        const GGS_bool cond_6828 = (var_cas_rtd).operator_isNotEqual (GGS_string ("")) ;
        if (cond_6828.isBuiltAndTrue ()) {
          GGS_string var_cas_path = ((var_cas_rtd).operator_concat (GGS_string ("/"))).operator_concat (var_cas_cc) ;
          const GGS_bool cond_6815 = (var_cas_path.reader_directoryExists ()).operator_not () ;
          if (cond_6815.isBuiltAndTrue ()) {
            GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, (GGS_string ("no compiler found at path: ")).operator_concat (var_cas_path) COMMA_SOURCE_FILE_AT_LINE (272)) ;
            var_cas_cc = GGS_string ("") ;
          }
        }else if (cond_6828.isBuiltAndFalse ()) {
          var_cas_cc = GGS_string ("") ;
        }
      }else{
        var_cas_cc = GGS_string ("") ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_compiler\n") ;
  #endif
  return var_cas_cc ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_compiler (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_basic_type  arg_0 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_compiler (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_compiler [1] = {& kTypeDescriptor_GGS_basic_type } ;

const C_galgas_function_descriptorEX
kFunction_descriptor_compiler ("compiler",
                              functionForGenericCall_compiler,
                              & kTypeDescriptor_GGS_string,
                              1,
                              kArgumentTypeList_compiler) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Implementation of function "linker"                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_linker (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_os_memmap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_linker at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_lk ;
  { const GGS_basic_type _var_7279 = var_cas_os_memmap ; // CAST instruction
    if (_var_7279.getPtr () != NULL) {
      macroValidPointer (_var_7279.getPtr ()) ;
      if (typeid (cPtr_memmap_true) == typeid (* (_var_7279.getPtr ()))) {
        const GGS_memmap_true var_cas_s (_var_7279.getPtr ()) ;
        { const GGS_basic_type _var_7250 = var_cas_s.reader_linker (inLexique COMMA_SOURCE_FILE_AT_LINE (292)) ; // CAST instruction
          if (_var_7250.getPtr () != NULL) {
            macroValidPointer (_var_7250.getPtr ()) ;
            if (typeid (cPtr_no_linker) == typeid (* (_var_7250.getPtr ()))) {
              var_cas_lk = GGS_string ("") ;
            }else if (typeid (cPtr_yes_linker) == typeid (* (_var_7250.getPtr ()))) {
              const GGS_yes_linker var_cas_l (_var_7250.getPtr ()) ;
              var_cas_lk = var_cas_l.reader_linker (inLexique COMMA_SOURCE_FILE_AT_LINE (294)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (294)) ;
            }else{
              var_cas_lk = GGS_string ("") ;
            }
          }
        }
      }else{
        var_cas_lk = GGS_string ("") ;
      }
    }
  }
  const GGS_bool cond_7545 = (var_cas_lk).operator_isNotEqual (GGS_string ("")) ;
  if (cond_7545.isBuiltAndTrue ()) {
    var_cas_lk = (GGS_string ("linker/")).operator_concat (var_cas_lk) ;
    GGS_string var_cas_rtd = function_rootTemplatesDirectory (inLexique COMMA_SOURCE_FILE_AT_LINE (302)) ;
    const GGS_bool cond_7511 = (var_cas_rtd).operator_isNotEqual (GGS_string ("")) ;
    if (cond_7511.isBuiltAndTrue ()) {
      GGS_string var_cas_path = ((var_cas_rtd).operator_concat (GGS_string ("/"))).operator_concat (var_cas_lk) ;
      const GGS_bool cond_7498 = (var_cas_path.reader_directoryExists ()).operator_not () ;
      if (cond_7498.isBuiltAndTrue ()) {
        var_cas_lk = GGS_string ("") ;
      }
    }else if (cond_7511.isBuiltAndFalse ()) {
      var_cas_lk = GGS_string ("") ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_linker\n") ;
  #endif
  return var_cas_lk ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_linker (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_basic_type  arg_0 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_linker (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_linker [1] = {& kTypeDescriptor_GGS_basic_type } ;

const C_galgas_function_descriptorEX
kFunction_descriptor_linker ("linker",
                              functionForGenericCall_linker,
                              & kTypeDescriptor_GGS_string,
                              1,
                              kArgumentTypeList_linker) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of function "void_os_obj"                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_os_obj  function_void_os_obj (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_void_os_obj at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_os_obj  var_cas_os ;
  GGS_void  var_cas_void_obj = GGS_void ::constructor_new (inLexique, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (317)) ;
  GGS_lstring  var_cas_emptyString = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (318)) ;
  var_cas_os = GGS_os_obj ::constructor_new (inLexique, var_cas_emptyString, var_cas_emptyString, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_emptyString, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, var_cas_void_obj, GGS_lstringlist ::constructor_emptyList (), var_cas_emptyString, var_cas_emptyString, var_cas_emptyString, GGS_lstringlist ::constructor_emptyList (), GGS_lstringlist ::constructor_emptyList (), GGS_lstringlist ::constructor_emptyList (), var_cas_emptyString, var_cas_emptyString, GGS_trace ::constructor_new (inLexique, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (345)), GGS_ident_map ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (346)) COMMA_SOURCE_FILE_AT_LINE (319)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_void_os_obj\n") ;
  #endif
  return var_cas_os ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_void_os_obj (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_os_obj  result = function_void_os_obj (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_void_os_obj ("void_os_obj",
                              functionForGenericCall_void_os_obj,
                              & kTypeDescriptor_GGS_os_obj ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*

