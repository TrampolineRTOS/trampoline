#---------------------------------------------------------------------------*
#
#  @file template_expression_parser.galgas
#
#  @section desc File description
#
#  Expressions parser for GTL.
#
#  @section copyright Copyright
#
#  Goil OIL compiler, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#---------------------------------------------------------------------------*

syntax template_expression_parser (template_scanner){

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <relation_term>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <relation_factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <simple_expression>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <term>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType

rule <variable>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@TvarPath path

#------------------------------------------------------------------------------*
#                                                                              *
#   E X P R E S S I O N                                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <relation_term>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  repeat
  while
    $|$
    @Tvalue leftOperand = outValue
    @Tvalue rightOperand
    @Ttype firstOperandType = outResultType
    @Ttype secondOperandType
    <relation_term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    outValue.mInt64Value = [leftOperand mInt64Value] | [rightOperand mInt64Value]
    matchOrOperatorForTemplate (
      !firstOperandType
      !secondOperandType
      ?outResultType
    )
  while
    $^$
    @Tvalue leftOperand = outValue
    @Tvalue rightOperand
    @Ttype firstOperandType = outResultType
    @Ttype secondOperandType
    <relation_term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    outValue.mInt64Value = [leftOperand mInt64Value] ^ [rightOperand mInt64Value]
    matchXorOperatorForTemplate (
      !firstOperandType
      !secondOperandType
      ?outResultType
    )
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    T E R M                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_term>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <relation_factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  repeat
  while
    $&$
    @Tvalue leftOperand = outValue
    @Tvalue rightOperand
    @Ttype firstOperandType = outResultType
    @Ttype secondOperandType
    <relation_factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
    outValue.mInt64Value = [leftOperand mInt64Value] & [rightOperand mInt64Value]
    matchAndOperatorForTemplate (
      !firstOperandType
      !secondOperandType
      ?outResultType
   )
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    F A C T O R                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <simple_expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  select
  or
    $==$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mInt64Value] == [rightExpression mInt64Value]
    case intType :
      result = [leftExpression mInt64Value] == [rightExpression mInt64Value]
    case floatType :
      result = [leftExpression mFloatValue] == [rightExpression mFloatValue]
    case stringType :
      result = [leftExpression mStringValue] == [rightExpression mStringValue]
    case enumType :
      result = [leftExpression mStringValue] == [rightExpression mStringValue]
    case listType, structType, mapType:
      error @location.here: "lists, structs and maps may not be compared" : result
    case unconstructedType, functionType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue. mInt64Value = if result then 1LS else 0LS end
  or
    $!=$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mInt64Value] != [rightExpression mInt64Value]
    case intType :
      result = [leftExpression mInt64Value] != [rightExpression mInt64Value]
    case floatType :
      result = [leftExpression mFloatValue] != [rightExpression mFloatValue]
    case stringType :
      result = [leftExpression mStringValue] != [rightExpression mStringValue]
    case enumType :
      result = [leftExpression mStringValue] != [rightExpression mStringValue]
    case listType, structType, mapType:
      error @location.here: "lists, structs and maps may not be compared": result
    case unconstructedType, functionType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue. mInt64Value = if result then 1LS else 0LS end
  or
    $<=$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    magnitude_comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mInt64Value] <= [rightExpression mInt64Value]
    case intType :
      result = [leftExpression mInt64Value] <= [rightExpression mInt64Value]
    case floatType :
      result = [leftExpression mFloatValue] <= [rightExpression mFloatValue]
    case stringType, enumType, listType, structType, mapType :
      result = false
    case unconstructedType, functionType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue. mInt64Value = if result then 1LS else 0LS end
  or
    $>=$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    magnitude_comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mInt64Value] >= [rightExpression mInt64Value]
    case intType :
      result = [leftExpression mInt64Value] >= [rightExpression mInt64Value]
    case floatType :
      result = [leftExpression mFloatValue] >= [rightExpression mFloatValue]
    case stringType, enumType, listType, structType, mapType :
      result = false
    case unconstructedType, functionType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue. mInt64Value = if result then 1LS else 0LS end
  or
    $>$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    magnitude_comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mInt64Value] > [rightExpression mInt64Value]
    case intType :
      result = [leftExpression mInt64Value] > [rightExpression mInt64Value]
    case floatType :
      result = [leftExpression mFloatValue] > [rightExpression mFloatValue]
    case stringType, enumType, listType, structType, mapType :
      result = false
    case unconstructedType, functionType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue. mInt64Value = if result then 1LS else 0LS end
  or
    $<$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    magnitude_comparison_types_checkForTemplate ( !leftType !rightType)
    @bool result
    switch leftType
    case boolType :
      result = [leftExpression mInt64Value] < [rightExpression mInt64Value]
    case intType :
      result = [leftExpression mInt64Value] < [rightExpression mInt64Value]
    case floatType :
      result = [leftExpression mFloatValue] < [rightExpression mFloatValue]
    case stringType, enumType, listType, structType, mapType :
      result = false
    case unconstructedType, functionType:
      error @location.here: "internal error, unconstructed type found" : result
    end
    outResultType = @Ttype. boolType
    outValue. mInt64Value = if result then 1LS else 0LS end
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   S I M P L E    E X P R E S S I O N                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <simple_expression>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <term>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  repeat
  while 
    $<<$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    left_shift_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue. mInt64Value = [leftExpression mInt64Value] << [[rightExpression mInt64Value] uint]
  while 
    $>>$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    right_shift_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue. mInt64Value = [leftExpression mInt64Value] >> [[rightExpression mInt64Value] uint]
  while 
    $+$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    addition_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue. mInt64Value = [leftExpression mInt64Value] + [rightExpression mInt64Value]
  while 
    $.$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    concatenation_types_checkForTemplate ( !leftType !rightType ?outResultType)
    if outResultType == @Ttype. stringType then
      outValue.mStringValue = [leftExpression mStringValue] + [rightExpression mStringValue]
    elsif outResultType == @Ttype. listType then
      outValue.mMapListValue = [leftExpression mMapListValue] + [rightExpression mMapListValue]
    end
  while 
    $-$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    addition_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue. mInt64Value = [leftExpression mInt64Value] - [rightExpression mInt64Value]
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   T E R M                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <term>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  repeat
  while 
    $*$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    multiply_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue. mInt64Value = [leftExpression mInt64Value] * [rightExpression mInt64Value]
  while 
    $/$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    divide_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue. mInt64Value = [leftExpression mInt64Value] / [rightExpression mInt64Value]
  while 
    $mod$
    @Tvalue leftExpression = outValue
    @Ttype leftType = outResultType
    @Tvalue rightExpression
    @Ttype rightType
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    modulo_types_checkForTemplate ( !leftType !rightType ?outResultType)
    outValue. mInt64Value = [leftExpression mInt64Value] mod [rightExpression mInt64Value]
#    log leftExpression;
#    log rightExpression;
#    log outValue;
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ( EXPRESSION )                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $($
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
  $)$
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    not FACTOR                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $not$
  @Tvalue expression
  @Ttype operandType
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?expression
    ?operandType
  outValue = valueWithUnsigned(!1L - [expression mInt64Value] !emptyLString())
  checkNotOperatorForTemplate ( !operandType ?outResultType)
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ~ FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $~$
  @Tvalue value
  @Ttype operandType
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?value
    ?operandType
  outValue = valueWithSigned(!~ [value mInt64Value] !emptyLString())
  checkBitComplementOperatorForTemplate ( !operandType ?outResultType)
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    - FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $-$
  @Tvalue value
  @Ttype operandType
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?value
    ?operandType
  outValue = valueWithSigned(!- [value mInt64Value] !emptyLString())
  checkBitComplementOperatorForTemplate ( !operandType ?outResultType)
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    + FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $+$
  @Tvalue value
  @Ttype operandType
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?value
    ?operandType
  outValue = valueWithSigned(![value mInt64Value] !emptyLString())
  checkBitComplementOperatorForTemplate ( !operandType ?outResultType)
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    true                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $yes$
  outValue = valueWithUnsigned(!1L !emptyLString())
  outResultType = @Ttype. boolType
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    false                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $no$
  outValue = valueWithUnsigned(!0L !emptyLString())
  outResultType = @Ttype. boolType
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  @lsint64 literalInt
  $signed_literal_integer64$ ?literalInt
  outValue = valueWithSigned(![literalInt sint64] !emptyLString())
  outResultType = @Ttype. intType
}

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a literal string value                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $string$ ?var @lstring literalString
  outValue = valueWithString(![literalString string] !emptyLString())
  outResultType = @Ttype. stringType
}

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   template method call :   [expression method !... ]                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $[$

  @Tvalue expressionValue
  @Ttype expressionType
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?expressionValue
    ?expressionType

  $identifier$ ?var  @lstring templateMethodName

  var expressionList =@TexpressionList.emptyList{}
  select
  or
    $:$
    repeat
      @Tvalue expression
      @Ttype resultType
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !inVariableMap
        ?expression
        ?resultType
      expressionList += !expression !resultType
    while
      $,$
    end
  end

  $]$

  templateMethodInvocation (
    !expressionType
    !expressionValue
    !templateMethodName
    !expressionList
    ?outResultType
    ?outValue
 )
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  @TvarPath path
  <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path
  select
    searchField ( !path !inVariableMap ?outResultType ?outValue ?*)
  or
    @lstring functionOrVariableName
    [path first ?functionOrVariableName ?* ?*]
#    message "FUNCTION ".[functionOrVariableName string]." ";
  #--- Parse actual arguments
    var actualArgumentList =@TexpressionList.emptyList{}
    $($
    repeat
      @Tvalue expression
      @Ttype resultType
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !inVariableMap
        ?expression
        ?resultType
      actualArgumentList += !expression !resultType
    while
      $,$
    end
    $)$
  #--- Search for function name
  #--- function can be a built in function or a defined function
    if not @function. isFunctionDefined { ![functionOrVariableName string]} then
      #--- the function is not built in, search the function
#      message "NOT BUILT IN\n";
      @Tvalue fct
      @Ttype type
      [inVariableMap searchKey !functionOrVariableName ?type ?fct]
      if [actualArgumentList length] != [[[fct mFunctionValue] args] length] then
        error @location.here : "incorrect number of arguments" : outValue, outResultType
      else
        # set up a variable map for local variables of the function
        var locals =@TfieldMap.emptyMap{}
        # search arguments values and add them to the locals
        for () actual_ in  actualArgumentList , () expected_ in  [[fct mFunctionValue] args] do
          [!?locals insertKey !expected_mValue !actual_mType !actual_mValue]
        end
        @string result = ""
#        message "calling ".[[fct mFunctionValue] name]."\n";
        grammar template_grammar on ([[fct mFunctionValue] content],"") !inPrefix !inPath !inTemplateDirectory !locals !?result !false ?outValue ?outResultType
      end
#      error functionOrVariableName : "there is no '" . functionOrVariableName . "' function defined in GOIL template language" : f;
    else
#      message "BUILT IN\n";
      @function f
      f = @function. functionWithName { ![functionOrVariableName string]}
      #--- Check arguments
      var actualArgumentObjectList =@objectlist.emptyList{}
      let @typelist formalParameterList = [f formalParameterTypeList]
      if [formalParameterList length] != [actualArgumentList length] then
        error functionOrVariableName: "this function is invoked with "
        + [[actualArgumentList length] string]
        + " parameter" + if [actualArgumentList length] > 1 then "s" else "" end
        + ", but requires " 
        + [[formalParameterList length] string]
        + " parameter" + if [formalParameterList length] > 1 then "s" else "" end
        : outValue, outResultType
      else
        @uint idx = 1
        for () formal_ in  formalParameterList, () actual_ in  actualArgumentList do
          switch actual_mType
          case boolType :
            if formal_mValue != `@bool then
              typeError ( !functionOrVariableName !formal_mValue !"boolean" !idx)
            end
            actualArgumentObjectList += ![if [actual_mValue mInt64Value] == 0LS then false else true end object]
          case intType :
            if formal_mValue != `@sint64 then
              typeError ( !functionOrVariableName !formal_mValue !"unsigned" !idx)
            end
            actualArgumentObjectList += ![[actual_mValue mInt64Value] object]
          case floatType :
            if formal_mValue != `@double then
              typeError ( !functionOrVariableName !formal_mValue !"float" !idx)
            end
            actualArgumentObjectList += ![[actual_mValue mFloatValue] object]
          case stringType :
            if formal_mValue != `@string then
              typeError ( !functionOrVariableName !formal_mValue !"string" !idx)
            end
          case enumType :
            if formal_mValue != `@string then
              typeError ( !functionOrVariableName !formal_mValue !"enum" !idx)
            end
            actualArgumentObjectList += ![[actual_mValue mStringValue] object]
          case listType, structType, mapType :
            typeError ( !functionOrVariableName !formal_mValue !"string" !idx)
          case unconstructedType, functionType:
            error @location.here: "internal error, unconstructed type found"
          end
          idx ++     
        end
        outResultType = @Ttype. intType
        outValue = valueWithSigned(!0LS !emptyLString())
        if @uint. errorCount == 0 then
          let @object result = [f invoke !actualArgumentObjectList ![functionOrVariableName location]]
          if [result objectDynamicType] == `@sint64 then
            outResultType = @Ttype. intType
            outValue.mInt64Value = ( result as @sint64)
            # else error functionOrVariableName);
          elsif [result objectDynamicType] == `@bool then
            outResultType = @Ttype. boolType
            outValue.mInt64Value = [( result as @bool) sint64]
            # else error functionOrVariableName) sint64];
          elsif [result objectDynamicType] == `@string then
            outResultType = @Ttype. stringType
            outValue.mStringValue = ( result as @string)
            # else error functionOrVariableName);
          else
            error functionOrVariableName : "this function does not return an unsigned, boolean or string value"
          end
        end
      end
    end
#    message "END OF FUNCTION\n";
  end
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  @TvarPath path
  $exists$ <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path

  @Ttype variableType
  @Tvalue variableValue
  @bool varExists

  searchFieldIfExists ( !path !inVariableMap ?variableType ?variableValue ?varExists)

  select
    $default$
    @Tvalue expression
    @Ttype resultType
    $($
    <expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?expression
      ?resultType
    $)$
    if varExists then
      outResultType = variableType
      outValue = variableValue
    else
      outResultType = resultType
      outValue = expression
    end
  or
    outResultType = @Ttype. boolType
    if varExists then
      outValue = valueWithUnsigned(!1L !emptyLString())
    else
      outValue = valueWithUnsigned(!0L !emptyLString())
    end
  end
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string  inPath
  ?let @string  inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  @TvarPath variableName
  $typeof$ <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?variableName
  @Ttype variableType
  @Tvalue variableValue
  searchField ( !variableName !inVariableMap ?variableType ?variableValue ?*)
  outResultType = @Ttype. enumType
  outValue = valueWithString(![variableType messageGoilTemplateType] !emptyLString())
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  select
    $true$
    outValue = valueWithUnsigned(!1L !emptyLString())
  or
    $false$
    outValue = valueWithUnsigned(!0L !emptyLString())
  end
  outResultType = @Ttype. boolType
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $@$ $identifier$ ?var @lstring enumValue
  outValue = valueWithString(![enumValue string] !emptyLString())
  outResultType = @Ttype. enumType
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $emptylist$
  outValue = @Tvalue. new { !0LS !0.0 !"" !@TfieldMapList. emptyList !@TfieldMap. emptyMap !dummyFunction() !emptyLString()}
  outResultType = @Ttype. listType
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string unused inPrefix
  ?let @string unused inPath
  ?let @string unused inTemplateDirectory
  ?let @TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $emptymap$
  outValue = @Tvalue. new { !0LS !0.0 !"" !@TfieldMapList. emptyList !@TfieldMap. emptyMap !dummyFunction() !emptyLString()}
  outResultType = @Ttype. mapType
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $mapof$
  @Tvalue expValue
  @Ttype expType
  <expression> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?expValue ?expType
  @location where = @location.here
  
  select
    $by$
    $identifier$ ?var @lstring key
    if expType != @Ttype. listType then
      error where: "list expected": outValue, outResultType
    else
      # get the elements of the list to build a map, each key being
      # one of the field of the elements of the list
      var resultMap =@TfieldMap.emptyMap{}
      for () in  [expValue mMapListValue] do
        if [mMap hasKey ![key string]] then
          # the specified key is found, get it and check it is a string
          @Ttype keyType
          @Tvalue keyValue
          [mMap searchKey !key ?keyType ?keyValue]
          if keyType == @Ttype. stringType then
            @lstring keyVal = @lstring. new { ![keyValue mStringValue] ![mMap locationForKey ![key string]]}
            [!?resultMap insertKey !keyVal !@Ttype. structType !valueWithMap(!mMap !emptyLString())]
          else
            error [mMap locationForKey ![key string]]: "the list element specified key is not a string"
          end
        else
          error @location.here: "the list element has not the specified key"
        end
      end
      outResultType = @Ttype. mapType
      outValue = valueWithMap(!resultMap !emptyLString())
    end
  or 
    $end$
    if expType != @Ttype.structType then
      error where: "struct expected": outValue, outResultType
    else
      outResultType = @Ttype. mapType
      outValue = expValue
#      outValue = valueWithMap(![expValue mStructValue] ![expValue mDescription])
    end
  end
}

#------------------------------------------------------------------------------*

rule <factor>
  ?let @string inPrefix
  ?let @string inPath
  ?let @string inTemplateDirectory
  ?let @TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType {
  $listof$
  @TvarPath path
  <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path
#  $by$;
#  $identifier$ ?@lstring key;
  
  @Ttype variableType
  @Tvalue variableValue
  @location where
  searchField ( !path !inVariableMap ?variableType ?variableValue ?where)
  if variableType != @Ttype. mapType then
    error where: "map expected": outValue, outResultType
  else
    var resultList =@TfieldMapList.emptyList{}
    for () in  [variableValue mStructValue] do
      
      resultList += ![mValue mStructValue]
    end
    outResultType = @Ttype. listType
    outValue = valueWithList(!resultList !emptyLString())
  end
}

##------------------------------------------------------------------------------*
#
#rule <factor>
#  ??@string inPrefix
#  ??@string inPath
#  ??@string inTemplateDirectory
#  ??@TfieldMap inVariableMap
#  !@Tvalue outValue
#  !@Ttype outResultType
#:
#  @string resultString := "";
#  $templateresult$;
#  select
#    $if$; $exists$;
#    @bool found;
#    $identifier$ ? @lstring templateName;
#    goilTemplateInvocation
#      !templateName
#      !inPrefix
#      !inPath
#      !inTemplateDirectory
#      !false
#      !inVariableMap
#      !?resultString
#      ?*
#    ;
#  or
#    $identifier$ ? @lstring templateName;
#    goilTemplateInvocation
#      !templateName
#      !inPrefix
#      !inPath
#      !inTemplateDirectory
#      !true
#      !inVariableMap
#      !?resultString
#      ?*
#    ;
#  end select;
#  outValue := [@Tvalue new !0L !resultString ![@TfieldMapList emptyList]];
#  outResultType := [@Ttype stringType];
#end rule;

}

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    &    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

proc matchAndOperatorForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case boolType , boolType :
    outResultType = inLeftExpressionType
  case intType , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "operand type error : (" + [inLeftExpressionType messageGoilTemplateType] +
           " & " + [inRightExpressionType messageGoilTemplateType] + ") is not valid" 
           : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    |    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

proc matchOrOperatorForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case boolType , boolType :
    outResultType = inLeftExpressionType
  case intType , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "operand type error : (" + [inLeftExpressionType messageGoilTemplateType] +
           " | " + [inRightExpressionType messageGoilTemplateType] + ") is not valid" 
           : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    ^    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

proc matchXorOperatorForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case boolType , boolType :
    outResultType = inLeftExpressionType
  case intType , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "operand type error : (" + [inLeftExpressionType messageGoilTemplateType] +
           " | " + [inRightExpressionType messageGoilTemplateType] + ") is not valid" 
           : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    N O T    O P E R A T O R                                   *
#                                                                           *
#---------------------------------------------------------------------------*

proc checkNotOperatorForTemplate
  ?let @Ttype inOperandType
  !@Ttype outResultType {
  if inOperandType != @Ttype. boolType then
    error @location.here : "the 'not' operator is not defined for an "
    + [inOperandType messageGoilTemplateType] + " type"
  end
  outResultType = inOperandType
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ~    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

proc checkBitComplementOperatorForTemplate
  ?let @Ttype inOperandType
  !@Ttype outResultType {
  outResultType = inOperandType
  if inOperandType != @Ttype. intType then
    error @location.here : "the ~ operator is not defined for an "
    + [inOperandType messageGoilTemplateType] + " type"
  end
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    C O M P A R I S O N S                          *
#                                                                           *
#---------------------------------------------------------------------------*

proc comparison_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType {
  match inLeftExpressionType , inRightExpressionType
  case boolType     , boolType :
  case intType      , intType :
  case stringType   , stringType :
  case enumType     , enumType :
  else
    error @location.here : "comparison between " + [inLeftExpressionType messageGoilTemplateType] +
           " and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    <    <=    >    >=   C O M P A R I S O N S     *
#                                                                           *
#---------------------------------------------------------------------------*

proc magnitude_comparison_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType {
  match inLeftExpressionType , inRightExpressionType
  case boolType      , boolType :
  case intType       , intType :
  case stringType    , stringType :
  else
    error @location.here : "comparison between " + [inLeftExpressionType messageGoilTemplateType] +
           " and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S H I F T    O P E R A T O R                               *
#                                                                           *
#---------------------------------------------------------------------------*

proc left_shift_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case intType    , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "shift between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*

proc right_shift_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case intType    , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "shift between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    A D D I T I O N    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

proc addition_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case intType      , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "addition between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    C O N C A T E N A T I O N    O P E R A T O R               *
#                                                                           *
#---------------------------------------------------------------------------*

proc concatenation_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case stringType        , stringType :
    outResultType = inLeftExpressionType
  case listType , listType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "addition between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S U B S T R A C T I O N    O P E R A T O R                 *
#                                                                           *
#---------------------------------------------------------------------------*

proc substraction_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case intType      , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "substraction between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M U L T I P L Y    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

proc multiply_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case intType      , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "multiplication between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    D I V I D E    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

proc divide_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case intType      , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "division between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M O D U L O    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

proc modulo_types_checkForTemplate
  ?let @Ttype inLeftExpressionType
  ?let @Ttype inRightExpressionType
  !@Ttype outResultType {
  match inLeftExpressionType , inRightExpressionType
  case intType      , intType :
    outResultType = inLeftExpressionType
  else
    error @location.here : "modulo between " + [inLeftExpressionType messageGoilTemplateType]
      +" and " + [inRightExpressionType messageGoilTemplateType] + " is not valid"
      : outResultType
  end%match
}

#------------------------------------------------------------------------------*
#                                                                              *
#  A R G U M E N T    L I S T    S I G N A T U R E                             *
#                                                                              *
#------------------------------------------------------------------------------*

func argumentListSignature
  ?let @TexpressionList inParameterTypeList
  -> @string outResult {
  outResult = " this method call has "
  outResult += [[inParameterTypeList length] string] + " argument"
  outResult += if [inParameterTypeList length] > 0 then "s" else "" end
  for () in  inParameterTypeList
  before outResult += ": "
  do outResult += [mType messageGoilTemplateType]
  between outResult += ", "
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#  C H E C K    I N V O C A T I O N    H A S   N O    A R G U M E N T          *
#                                                                              *
#------------------------------------------------------------------------------*

proc checkInvocationHasNoArgument
  ?let @Ttype inType
  ?let @lstring inMethodName
  ?let @TexpressionList inParameterTypeList {
  if [inParameterTypeList length] > 0 then
    error inMethodName:"calling '" + inMethodName + "' on a "
    + [inType messageGoilTemplateType] + " type requires no argument; "
    + argumentListSignature (!inParameterTypeList)
  end
}

proc checkInvocationHasArguments
  ?let @Ttype inType
  ?let @lstring inMethodName
  ?let @TexpressionList inParameterTypeList
  ?let @Ttype inExpectedType
  ?let @uint argsNumber {
  @Ttype parameterType
  [inParameterTypeList first ?* ?parameterType]
  if [inParameterTypeList length] != argsNumber | parameterType != inExpectedType then
    error inMethodName:"calling '" + inMethodName + "' on a "
    + [inType messageGoilTemplateType] + " type requires "+argsNumber+" unsigned argument(s); "
    + argumentListSignature (!inParameterTypeList)
  end  
}

#------------------------------------------------------------------------------*
#                                                                              *
#  M E T H O D    I N V O C A T I O N                                          *
#                                                                              *
#------------------------------------------------------------------------------*

proc templateMethodInvocation
  ?let @Ttype inType
  ?let @Tvalue inValue
  ?let @lstring inMethodName
  ?@TexpressionList inParameterTypeList
  !@Ttype outResultType
  !@Tvalue outResultValue {
  if [inMethodName string] == "description" then
    checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
    outResultType = @Ttype. stringType
    outResultValue = valueWithString(![[inValue mDescription] string] !emptyLString())
  else
    switch inType
    case boolType :
      if [inMethodName string] == "trueOrFalse" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (
          ! if [inValue mInt64Value] > 0LS then "true" else "false" end
          !emptyLString()
        )
      elsif [inMethodName string] == "yesOrNo" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (
          ! if [inValue mInt64Value] > 0LS then "yes" else "no" end
          !emptyLString()
        )
      elsif [inMethodName string] == "unsigned" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. intType
        outResultValue = inValue
      else
        error inMethodName: "the "+inMethodName+" template method is not defined" : outResultValue, outResultType
      end
    case intType :
      if [inMethodName string] == "string" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mInt64Value] string] !emptyLString())
      elsif [inMethodName string] == "hexString" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[[inValue mInt64Value] uint64] hexString] !emptyLString())
      elsif [inMethodName string] == "numberOfBytes" | [inMethodName string] == "signedNumberOfBytes" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. intType
        @sint64 value = [inValue mInt64Value]
        # compute the number of bytes needed
        @uint numberOfBytes = 1
        if [inMethodName string] == "signedNumberOfBytes" then
          value = value * 2
        end
        @uint count = 0
        loop( 4)
        while count < 4 do
          @sint64 maxValue = (1LS << (numberOfBytes * 8)) - 1LS
          if maxValue < value then
            numberOfBytes = numberOfBytes * 2
          end
          count++
        end
        outResultValue = valueWithUnsigned (![numberOfBytes uint64] !emptyLString())
      elsif [inMethodName string] == "numberOfBits" | [inMethodName string] == "signedNumberOfBits" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. intType
        @sint64 value = [inValue mInt64Value]
        if [inMethodName string] == "signedNumberOfBits" then
          value = value * 2
        end
        # compute the number of bits needed
        @sint64 numberOfBits = 0LS
        loop( 64)
        while value != 0LS do
          numberOfBits++
          value = value >> 1
        end
        outResultValue = valueWithSigned(!numberOfBits !emptyLString())
      else
        error inMethodName: "the "+inMethodName+" template method is not defined for "+[inType messageGoilTemplateType] : outResultValue, outResultType
      end
    case stringType :
      if [inMethodName string] == "HTMLRepresentation" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] HTMLRepresentation] !emptyLString())
      elsif [inMethodName string] == "identifierRepresentation" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] identifierRepresentation] !emptyLString())
      elsif [inMethodName string] == "fileExists" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. boolType
        outResultValue = valueWithBool (![[inValue mStringValue] fileExists] !emptyLString())
      elsif [inMethodName string] == "lowercaseString" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] lowercaseString] !emptyLString())
      elsif [inMethodName string] == "length" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. intType
        outResultValue = valueWithUnsigned (![[[inValue mStringValue] length] uint64] !emptyLString())
      elsif [inMethodName string] == "stringByCapitalizingFirstCharacter" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] stringByCapitalizingFirstCharacter] !emptyLString())
      elsif [inMethodName string] == "uppercaseString" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] uppercaseString] !emptyLString())
      elsif [inMethodName string] == "unsigned" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. intType
        outResultValue = valueWithUnsigned (![[[inValue mStringValue] decimalUnsignedNumber] uint64] !emptyLString())
      elsif [inMethodName string] == "leftSubString" then
        checkInvocationHasArguments ( !inType !inMethodName !inParameterTypeList !@Ttype. intType !1)
        @Tvalue parameter
        [inParameterTypeList first ?parameter ?*]
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] leftSubString ![[parameter mInt64Value] uint]] !emptyLString())
      elsif [inMethodName string] == "rightSubString" then
        checkInvocationHasArguments ( !inType !inMethodName !inParameterTypeList !@Ttype. intType !1)
        @Tvalue parameter
        [inParameterTypeList first ?parameter ?*]
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] rightSubString ![[parameter mInt64Value] uint]] !emptyLString())
      elsif [inMethodName string] == "subString" then
        checkInvocationHasArguments ( !inType !inMethodName !inParameterTypeList !@Ttype. intType !2)
        @Tvalue start = [inParameterTypeList mValueAtIndex !0]
        @Tvalue length = [inParameterTypeList mValueAtIndex !1]
  #      log start;
  #      log length;
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] subString ![[start mInt64Value] uint] ![[length mInt64Value] uint]] !emptyLString())
      elsif [inMethodName string] == "reversedString" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] reversedString] !emptyLString())
      elsif [inMethodName string] == "componentsSeparatedByString" then
        checkInvocationHasArguments ( !inType !inMethodName !inParameterTypeList !@Ttype. stringType !1)
        @Tvalue separator
        [inParameterTypeList first ?separator ?*]
        @stringlist stringlist = [[inValue mStringValue] componentsSeparatedByString ![separator mStringValue]]
        var result =@TfieldMapList.emptyList{}
        for () in  stringlist do
          var item =@TfieldMap.emptyMap{}
          addStringValue ( !?item !lstringWith(!"VALUE") !mValue !emptyLString())
          result += !item
        end
        outResultType = @Ttype. listType
        outResultValue = valueWithList(!result !emptyLString())
      elsif [inMethodName string] == "interpretEscape" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![[inValue mStringValue] stringByReplacingStringByString !"\\n" !"\n"] !emptyLString())
      elsif [inMethodName string] == "columnPrefixedBy" then
        checkInvocationHasArguments ( !inType !inMethodName !inParameterTypeList !@Ttype. stringType !1)
        @Tvalue separator
        [inParameterTypeList first ?separator ?*]
        outResultType = @Ttype. stringType
        outResultValue = valueWithString (![separator mStringValue]+[[inValue mStringValue] stringByReplacingStringByString !"\n" !"\n"+[separator mStringValue]] !emptyLString())
      elsif [inMethodName string] == "wrap" then
        checkInvocationHasArguments ( !inType !inMethodName !inParameterTypeList !@Ttype. intType !2)
#        checkInvocationHasArguments !inType !inMethodName !inParameterTypeList ![@Ttype stringType] !2;
        @Tvalue width
        [!?inParameterTypeList popFirst ?width ?*]
        @Tvalue shift
        [!?inParameterTypeList popFirst ?shift ?*]
        @string stringshift = @string. stringWithSequenceOfCharacters { !' ' ![[shift mInt64Value] uint]}
        @string result = [inValue mStringValue]
#        @string result := [[inValue mStringValue] stringByReplacingStringByString !"\n" !" "];
#        message result;
#        @string previous := "";
#        loop [result length]:
#          previous := result;
#          result := [result stringByReplacingStringByString !"  " !" "];
#        while result != previous do
#        end loop;
        @stringlist paragraph = [result componentsSeparatedByString !"\n"]
        var resultParagraph =@stringlist.emptyList{}
        for () para_ in  paragraph do
          @stringlist parts = [para_mValue componentsSeparatedByString !" "]
          @sint64 linewidth = 0LS
          @bool newline = true
          result = ""
          for () word_ in  parts do
            if linewidth + [word_mValue length] > [width mInt64Value] then
              result += "\n" + stringshift
              linewidth = [shift mInt64Value]
              newline = true
            end
            if newline == false then
              linewidth = linewidth + 1LS
              result += " "
            end
            linewidth = linewidth + [word_mValue length]
            result += word_mValue
            newline = false
          end
          resultParagraph += !result
        end
        outResultType = @Ttype. stringType
        outResultValue = valueWithString(!@string. componentsJoinedByString { !resultParagraph !"\n"} !emptyLString())
      elsif [inMethodName string] == "substringExists" then
        checkInvocationHasArguments ( !inType !inMethodName !inParameterTypeList !@Ttype. stringType !1)
        [!?inParameterTypeList popFirst ?var @Tvalue subString ?*]
        @uint start = 0
        @uint stop = [[inValue mStringValue] length] - [[subString mStringValue] length]
        @bool exists = false 
        loop( [[inValue mStringValue] length])
        while start <= stop do
          if [[inValue mStringValue] subString !start ![[subString mStringValue] length]] == [subString mStringValue] then
            exists = true
          end
          start++
        end        
        outResultType = @Ttype. boolType
        outResultValue = valueWithBool(!exists !emptyLString())
      else
        error inMethodName: "the "+inMethodName+" template method is not defined for "+[inType messageGoilTemplateType] : outResultValue, outResultType
      end
    case floatType:
        error inMethodName: "the "+inMethodName+" template method is not defined for "+[inType messageGoilTemplateType] : outResultValue, outResultType
    case listType :
      if [inMethodName string] == "length" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. intType
        outResultValue = valueWithUnsigned (![[[inValue mMapListValue] length] uint64] !emptyLString())
      elsif [inMethodName string] == "first" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. structType
        @TfieldMap firstElement
        [[inValue mMapListValue] first ?firstElement]
        outResultValue = valueWithStruct (!firstElement !emptyLString())
      elsif [inMethodName string] == "last" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. structType
        @TfieldMap lastElement
        [[inValue mMapListValue] last ?lastElement]
        outResultValue = valueWithStruct (!lastElement !emptyLString())
      else
        error inMethodName: "the "+inMethodName+" template method is not defined for "+[inType messageGoilTemplateType] : outResultValue, outResultType
      end
    case mapType :
      if [inMethodName string] == "length" then
        checkInvocationHasNoArgument ( !inType !inMethodName !inParameterTypeList)
        outResultType = @Ttype. intType
        outResultValue = valueWithUnsigned (![[[inValue mStructValue] count] uint64] !emptyLString())
      else
        error inMethodName: "the "+inMethodName+" template method is not defined for "+[inType messageGoilTemplateType] : outResultValue, outResultType
      end
    case enumType, structType:
        error inMethodName: "the "+inMethodName+" template method is not defined for "+[inType messageGoilTemplateType] : outResultValue, outResultType
    case unconstructedType, functionType:
      error @location.here: "internal error, unconstructed type found": outResultValue, outResultType
    end
  end
}

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   function call        :   function_name (..., ...)                          *
#   variable             :   variable_name                                     *
#                                                                              *
#------------------------------------------------------------------------------*

proc typeError
  ?let @lstring inFunctionName
  ?let @type inActualType
  ?let @string inExpectedTypeName
  ?let @uint inParameterIndex {
  @string m = "the function requires the parameter " + [inParameterIndex string]
  + " to be " + inExpectedTypeName + "; its type is "
  if inActualType == `@bool then
    m += "boolean"
  elsif inActualType == `@uint64 then
    m += "unsigned"
  elsif inActualType == `@string then
    m += "string"
  else
    m += "a not allowed type"
  end
  error inFunctionName : m
}