#-----------------------------------------------------------------------------*
#
#  @file gtl_data_types.galgas
#
#  @section desc File description
#
#  datatypes of gtl GTL.
#
#  @section copyright Copyright
#
#  Goil OIL compiler, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#-----------------------------------------------------------------------------*

getter @type typeName
  ->@string typeName
{
  if    self == `@gtlInt           then typeName = "int"
  elsif self == `@gtlChar          then typeName = "char"
  elsif self == `@gtlFloat         then typeName = "float"
  elsif self == `@gtlString        then typeName = "string"
  elsif self == `@gtlBool          then typeName = "bool"
  elsif self == `@gtlStruct        then typeName = "struct"
  elsif self == `@gtlList          then typeName = "list"
  elsif self == `@gtlMap           then typeName = "map"
  elsif self == `@gtlType          then typeName = "type"
  elsif self == `@gtlEnum          then typeName = "enum"
  elsif self == `@gtlSet           then typeName = "set"
  elsif self == `@gtlUnconstructed then typeName = "unconstructed"
  else typeName = "-unknown-" end
}

getter @string gtlType
  ?let @location location
  ->@type type
{
  if    self == "int"           then type = `@gtlInt
  elsif self == "char"          then type = `@gtlChar
  elsif self == "float"         then type = `@gtlFloat
  elsif self == "string"        then type = `@gtlString
  elsif self == "bool"          then type = `@gtlBool
  elsif self == "struct"        then type = `@gtlStruct
  elsif self == "list"          then type = `@gtlList
  elsif self == "map"           then type = `@gtlMap
  elsif self == "type"          then type = `@gtlType
  elsif self == "enum"          then type = `@gtlEnum
  elsif self == "set"           then type = `@gtlSet
  elsif self == "unconstructed" then type = `@gtlUnconstructed
  else error location : "unknown type" : type end
}

getter @lstring gtlType
  ->@type type
{
  let @string typeName = [self string]
  if    typeName == "int"           then type = `@gtlInt
  elsif typeName == "char"          then type = `@gtlChar
  elsif typeName == "float"         then type = `@gtlFloat
  elsif typeName == "string"        then type = `@gtlString
  elsif typeName == "bool"          then type = `@gtlBool
  elsif typeName == "struct"        then type = `@gtlStruct
  elsif typeName == "list"          then type = `@gtlList
  elsif typeName == "map"           then type = `@gtlMap
  elsif typeName == "type"          then type = `@gtlType
  elsif typeName == "enum"          then type = `@gtlEnum
  elsif typeName == "set"           then type = `@gtlSet
  elsif typeName == "unconstructed" then type = `@gtlUnconstructed
  else error location : "unknown type" : type end
}

private func %once noArgument -> @gtlTypedArgumentList result
{
  result = .emptyList
}

private func %once intArgument -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlInt }
}

private func %once charArgument -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlChar }
}

private func %once charCharArguments -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlChar }
  result += !`@gtlChar
}

private func %once charIntArguments -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlChar }
  result += !`@gtlInt
}

private func %once floatArgument -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlFloat }
}

private func %once stringArgument -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlString }
}

private func %once stringStringArgument -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlString }
  result += !`@gtlString
}

private func %once boolIntArguments -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlBool }
  result += !`@gtlInt
}

private func %once intIntArguments -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlInt }
  result += !`@gtlInt
}

private func %once intAnyArguments -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlInt }
  result += !`@gtlData
}

private func %once anyArgument     -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlData }
}

private func %once structArgument  -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlStruct }
} 

private func %once expressionArgument  -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlExpr }
} 

private func %once setArgument  -> @gtlTypedArgumentList result
{
  result = .listWithValue { !`@gtlSet }
} 

private proc argumentsCheck
  ?let @lstring methodName
  ?@gtlTypedArgumentList abstractArgumentList
  ?@gtlDataList         concreteArgumentList
{
  let @uint concreteLength = [concreteArgumentList length]
  let @uint abstractLength = [abstractArgumentList length]
  if [abstractArgumentList length] != [concreteArgumentList length] then
    error methodName : [methodName string] + " expects " + abstractLength +
                       " arguments. " + concreteLength + " arguments provided."
  else
    for () in concreteArgumentList, () in abstractArgumentList do (index)
      if [data dynamicType] != type & type != `@gtlData then
        error [data location] : [type typeName] +
                                " expected for argument " +
                                (index + 1)
      end
    end
  end 
}

func %once emptylstring ->@lstring result
{
  result = .new { !"" !.nowhere }
}

func lstring ?@string string ->@lstring result
{
  result = .new { !string !.nowhere }
}

abstract class @gtlData {
  @location where 
  @lstring  meta  
}

getter @gtlData location -> @location result {
  result = where
}

abstract getter @gtlData desc ?let @uint tab -> @string
abstract getter @gtlData string  -> @string
abstract getter @gtlData lstring -> @lstring
abstract getter @gtlData bool    -> @bool
abstract getter @gtlData int     -> @bigint
abstract getter @gtlData float   -> @double
abstract getter @gtlData plusOp  -> @gtlData
abstract getter @gtlData minusOp -> @gtlData
abstract getter @gtlData notOp   -> @gtlData
abstract getter @gtlData addOp ?let @gtlData right -> @gtlData
abstract getter @gtlData subOp ?let @gtlData right -> @gtlData
abstract getter @gtlData mulOp ?let @gtlData right -> @gtlData
abstract getter @gtlData divOp ?let @gtlData right -> @gtlData
abstract getter @gtlData modOp ?let @gtlData right -> @gtlData
abstract getter @gtlData andOp ?let @gtlData right -> @gtlData
abstract getter @gtlData orOp  ?let @gtlData right -> @gtlData
abstract getter @gtlData xorOp ?let @gtlData right -> @gtlData
abstract getter @gtlData slOp  ?let @gtlData right -> @gtlData
abstract getter @gtlData srOp  ?let @gtlData right -> @gtlData
abstract getter @gtlData neqOp ?let @gtlData right -> @gtlData
abstract getter @gtlData eqOp  ?let @gtlData right -> @gtlData
abstract getter @gtlData ltOp  ?let @gtlData right -> @gtlData
abstract getter @gtlData leOp  ?let @gtlData right -> @gtlData
abstract getter @gtlData gtOp  ?let @gtlData right -> @gtlData
abstract getter @gtlData geOp  ?let @gtlData right -> @gtlData

abstract getter @gtlData embeddedType -> @type

abstract method @gtlData addMyValue ?!@objectlist objectList

list @gtlTypedArgumentList {
  @type type
}

abstract getter @gtlData performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData       

abstract setter @gtlData performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib

method @gtlData structField
  ?let @lstring name
  !@gtlData     result
  !@bool        found
{
  error name : "a " + [[self dynamicType] typeName] + " is not a struct" : result, found
}

getter @gtlData resultField
  ?let @lstring name
  ->@gtlData     result
{
  error name : "a " + [[self dynamicType] typeName] + " is not a struct" : result
}

setter @gtlData setStructField
  ?let @lstring name
  ?let @gtlData unused data
{
  
  error name : "a " + [[self dynamicType] typeName] + " is not a struct"
}

setter @gtlData setStructFieldAtLevel
  ?let @lstring name
  ?let @gtlData unused data
  ?let @uint    unused level
{
  
  error name : "a " + [[self dynamicType] typeName] + " is not a struct"
}

setter @gtlData deleteStructField
  ?let @lstring name
{
  error name : "a " + [[self dynamicType] typeName] + " is not a struct"
}

getter @gtlData hasStructField
  ?let @lstring unused name
  ->@bool result
{
  result = false
}

getter @gtlData overrideMap
  -> @gtlStruct mapOverriden
{
  error self : "INTERNAL ERROR : a variable map should be a @gtlStruct" : mapOverriden
}

getter @gtlData overriddenMap
  -> @gtlStruct overriddenMap
{
  error self : "INTERNAL ERROR : a variable map should be a @gtlStruct" : overriddenMap
}

method @gtlData mapItem
  ?let @lstring name
  !@gtlData     result
{
  error name : "a " + [[self dynamicType] typeName] + " is not a map" : result
}

getter @gtlData hasMapItem
  ?let @lstring unused name
  ->@bool result
{
  result = false
}

setter @gtlData setMapItem
  ?let @lstring name
  ?let @gtlData unused data
{
  error name : "a " + [[self dynamicType] typeName] + " is not a map"
}

setter @gtlData deleteMapItem
  ?let @lstring name
{
  error name : "a " + [[self dynamicType] typeName] + " is not a map"
}

method @gtlData itemAtIndex
  !@gtlData     result
  ?let @gtlInt  index
{
  error index : "a " + [[self dynamicType] typeName] + " is not a list" : result
}

getter @gtlData hasItemAtIndex
  ?let @gtlInt unused index
  ->@bool result
{
  result = false
}

setter @gtlData setItemAtIndex
  ?let @gtlData unused data
  ?let @gtlInt  index
{
  error index : "a " + [[self dynamicType] typeName] + " is not a list"
}

setter @gtlData deleteItemAtIndex
  ?let @gtlInt  index
{
  error index : "a " + [[self dynamicType] typeName] + " is not a list"
}

setter @gtlData appendItem
  ?let @gtlData item
{
  error item : "a " + [[self dynamicType] typeName] + " is not a list"
}

#-----------------------------------------------------------------------------*
# unconstructed type and operations on unconstructed
#-----------------------------------------------------------------------------*
class @gtlUnconstructed : @gtlData {}

override getter @gtlUnconstructed desc
  ?let @uint tab
  -> @string result
{
  result = @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "unconstructed\n"
}

override getter @gtlUnconstructed string  -> @string result {
  error where : "cannot cast an unconstructed to a string" : result
}

override getter @gtlUnconstructed lstring -> @lstring result {
  error where : "cannot cast an unconstructed to a lstring" : result
}

override getter @gtlUnconstructed bool    -> @bool result {
  error where : "cannot cast an unconstructed to a bool" : result
}

override getter @gtlUnconstructed int     -> @bigint result {
  error where : "cannot cast an unconstructed to an int" : result
}

override getter @gtlUnconstructed float   -> @double result {
  error where : "cannot cast an unconstructed to a float" : result
}

override getter @gtlUnconstructed plusOp  -> @gtlData result {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed minusOp -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed notOp   -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed addOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed subOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed mulOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed divOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed modOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed andOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed orOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed xorOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed slOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed srOp ?let @gtlData unused right -> @gtlData result  {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed neqOp ?let @gtlData unused right -> @gtlData result {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed eqOp ?let @gtlData unused right -> @gtlData result {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed geOp ?let @gtlData unused right -> @gtlData result {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "unconstructed forbidden" : result
}
override getter @gtlUnconstructed leOp ?let @gtlData unused right -> @gtlData result {
  error where : "unconstructed forbidden" : result
}

override getter @gtlUnconstructed embeddedType -> @type result
{
  error where : "unconstructed data provided as argument" : result
}

override method @gtlUnconstructed addMyValue ?!@objectlist unused objectList
{
  error where : "Attempting to pass an unconstructed data to a function"
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlUnconstructed
#-----------------------------------------------------------------------------*
override getter @gtlUnconstructed performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if "type"      == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  elsif [lib getterExists !"unconstructed" !methodName] then
    result = [[lib getGetter !"unconstructed" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  else
    error methodName : "unknown getter '" + methodName +"' for unconstructed target" : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlUnconstructed
#-----------------------------------------------------------------------------*
override setter @gtlUnconstructed performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"unconstructed" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"unconstructed" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for unconstructed target"
  end
}


#-----------------------------------------------------------------------------*
# type type and operations on type
#-----------------------------------------------------------------------------*
class @gtlType   : @gtlData { @type type }

override getter @gtlType desc
  ?let @uint tab
  -> @string result
{
  result = @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "type: " + [type typeName] + "\n"
}

override getter @gtlType string  -> @string result { result = [type typeName] }

override getter @gtlType lstring -> @lstring result {
  result = .new { ![type typeName] !where }
}

override getter @gtlType bool    -> @bool result {
  error where : "cannot cast a type to a bool" : result
}

override getter @gtlType int     -> @bigint result {
  error where : "cannot cast a type to an int" : result
}

override getter @gtlType float   -> @double result {
  error where : "cannot cast a type to a float" : result
}

override getter @gtlType plusOp  -> @gtlData result {
  error where : "type forbidden" : result
}
override getter @gtlType minusOp -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType notOp   -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType addOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType subOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType mulOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType divOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType modOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType andOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType orOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType xorOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType slOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType srOp ?let @gtlData unused right -> @gtlData result  {
  error where : "type forbidden" : result
}
override getter @gtlType neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlType then
    result = @gtlBool.new { !where !emptylstring() !type != [right as @gtlType type] }
  else
    error [right where] : "type expected" : result
  end
}
override getter @gtlType eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlType then
    result = @gtlBool.new { !where !emptylstring() !type == [right as @gtlType type] }
  else
    error [right where] : "type expected" : result
  end
}
override getter @gtlType gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "type forbidden" : result
}
override getter @gtlType geOp ?let @gtlData unused right -> @gtlData result {
  error where : "type forbidden" : result
}
override getter @gtlType ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "type forbidden" : result
}
override getter @gtlType leOp ?let @gtlData unused right -> @gtlData result {
  error where : "type forbidden" : result
}

override getter @gtlType embeddedType -> @type result
{
  result = `@type
}

override method @gtlType addMyValue ?!@objectlist objectList
{
  objectList += ![type object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlType
#-----------------------------------------------------------------------------*
override getter @gtlType performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "string"    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![self string]
    }
  elsif "type"      == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  elsif [lib getterExists !"type" !methodName] then
    result = [[lib getGetter !"type" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  else
    error methodName : "unknown getter '" + methodName +"' for type target" : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlType
#-----------------------------------------------------------------------------*
override setter @gtlType performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"type" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"type" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    type = [copy as @gtlType type]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for type target"
  end
}

#-----------------------------------------------------------------------------*
# type enum and operations on enum
#-----------------------------------------------------------------------------*
class @gtlEnum   : @gtlData { @string value }

override getter @gtlEnum desc
  ?let @uint tab
  -> @string result
{
  result = @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "enum: " + value + "\n"
}

override getter @gtlEnum string  -> @string result { result = value }

override getter @gtlEnum lstring -> @lstring result {
  result = .new { !value !where }
}

override getter @gtlEnum bool    -> @bool result {
  error where : "cannot cast an enum to a bool" : result
}

override getter @gtlEnum int     -> @bigint result {
  error where : "cannot cast an enum to an int" : result
}

override getter @gtlEnum float   -> @double result {
  error where : "cannot cast an enum to a float" : result
}

override getter @gtlEnum plusOp  -> @gtlData result {
  error where : "enum forbidden" : result
}
override getter @gtlEnum minusOp -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum notOp   -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum addOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum subOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum mulOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum divOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum modOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum andOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum orOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum xorOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum slOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum srOp ?let @gtlData unused right -> @gtlData result  {
  error where : "enum forbidden" : result
}
override getter @gtlEnum neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlEnum then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value != [right as @gtlEnum value] 
    }
  else
    error [right where] : "enum expected" : result
  end
}
override getter @gtlEnum eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlEnum then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value == [right as @gtlEnum value] 
    }
  else
    error [right where] : "enum expected" : result
  end
}
override getter @gtlEnum gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "enum forbidden" : result
}
override getter @gtlEnum geOp ?let @gtlData unused right -> @gtlData result {
  error where : "enum forbidden" : result
}
override getter @gtlEnum ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "enum forbidden" : result
}
override getter @gtlEnum leOp ?let @gtlData unused right -> @gtlData result {
  error where : "enum forbidden" : result
}

override getter @gtlEnum embeddedType -> @type result
{
  error where : "enum forbidden as built in function argument" : result
}

override method @gtlEnum addMyValue ?!@objectlist unused objectList
{
  error where : "enum forbidden as built in function argument"
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlEnum
#-----------------------------------------------------------------------------*
override getter @gtlEnum performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "string"    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![self string]
    }
  elsif "type"      == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"enum" !methodName] then
    result = [[lib getGetter !"enum" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for enum target" : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlEnum
#-----------------------------------------------------------------------------*
override setter @gtlEnum performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"enum" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"enum" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlEnum value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for enum target"
  end
}

#-----------------------------------------------------------------------------*
# Int type and operations on int
#-----------------------------------------------------------------------------*
class @gtlChar : @gtlData { @char value }

override getter @gtlChar desc
  ?let @uint tab
  -> @string result
{
  result = @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "char: " + [value string] + "\n"
}

override getter @gtlChar string  -> @string result { result = [value string] }

override getter @gtlChar lstring -> @lstring result {
  result = .new { ![value string] !where }
}

override getter @gtlChar bool    -> @bool result {
  error where : "cannot cast a char to a bool" : result
}

override getter @gtlChar int     -> @bigint result {
  result = [[value uint] bigint]
}

override getter @gtlChar float   -> @double result {
  error where : "cannot cast a char to a float" : result
}

override getter @gtlChar plusOp  -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar minusOp -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar notOp   -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar addOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar subOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar divOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar modOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar andOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar orOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar slOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar srOp ?let @gtlData unused right -> @gtlData result {
  error where : "char forbidden" : result
}

override getter @gtlChar neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlChar then
    result = @gtlBool.new {
      !where
      !emptylstring()
      !value != [right as @gtlChar value]
    }
  else
    error right : "char expected" : result
  end
}

override getter @gtlChar eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlChar then
    result = @gtlBool.new {
      !where
      !emptylstring()
      !value == [right as @gtlChar value]
    }
  else
    error right : "char expected" : result
  end
}

override getter @gtlChar gtOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlChar then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value > [right as @gtlChar value] 
    }
  else
    error right : "char expected" : result
  end
}

override getter @gtlChar geOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlChar then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value >= [right as @gtlChar value]
    }
  else
    error [right where] : "char expected" : result
  end
}

override getter @gtlChar ltOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlChar then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value < [right as @gtlChar value]
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlChar leOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlChar then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value <= [right as @gtlChar value]
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlChar embeddedType -> @type result
{
  result = `@char
}

override method @gtlChar addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlChar
#-----------------------------------------------------------------------------*
override getter @gtlChar performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "string"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![self string]
    }
  elsif "isAlnum"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value isalnum]
    }
  elsif "isCntrl"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value iscntrl]
    }
  elsif "isDigit"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value isdigit]
    }
  elsif "isAlpha"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value isalpha]
    }
  elsif "isLower"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value islower]
    }
  elsif "isUpper"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value isupper]
    }
  elsif "isXDigit"                == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value isxdigit]
    }
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"char" !methodName] then
    result = [[lib getGetter !"char" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for char target" : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlChar
#-----------------------------------------------------------------------------*
override setter @gtlChar performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"char" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"char" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlChar value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for char target"
  end
}

#-----------------------------------------------------------------------------*
# Int type and operations on int
#-----------------------------------------------------------------------------*
class @gtlInt    : @gtlData { @bigint  value }

override getter @gtlInt desc
  ?let @uint tab
  -> @string result
{
  result = @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "integer: " + [value string] + "\n"
}

override getter @gtlInt string  -> @string result { result = [value string] }

override getter @gtlInt lstring -> @lstring result {
  result = .new { ![value string] !where }
}

override getter @gtlInt bool    -> @bool result {
  error where : "cannot cast an int to a bool" : result
}

override getter @gtlInt int     -> @bigint result {
  result = value
}

override getter @gtlInt float   -> @double result {
  result = [[value sint64] double]
}

override getter @gtlInt plusOp  -> @gtlData result { result = self }

override getter @gtlInt minusOp -> @gtlData result { 
  result = @gtlInt.new { !where !emptylstring() !-value }
}

override getter @gtlInt notOp   -> @gtlData result { 
  result = @gtlInt.new { !where !emptylstring() !~value }
}

override getter @gtlInt addOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlInt.new {
      !where 
      !emptylstring() 
      !value + [right as @gtlInt value] 
    }
  else
    error [right where] : "*int expected" : result
  end
}

override getter @gtlInt subOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlInt.new { 
      !where 
      !emptylstring() 
      !value - [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt mulOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlInt.new { 
      !where 
      !emptylstring() 
      !value * [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt divOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlInt.new {
      !where 
      !emptylstring() 
      !value / [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end  
}

override getter @gtlInt modOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlInt.new { 
      !where 
      !emptylstring() 
      !value mod [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt andOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlInt.new { 
      !where 
      !emptylstring() 
      !value & [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt orOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlInt.new {
      !where
      !emptylstring()
      !value | [right as @gtlInt value]
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt xorOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlInt.new {
      !where
      !emptylstring()
      !value ^ [right as @gtlInt value]
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt slOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    let @bigint r = [right as @gtlInt value];
    if r >= 0 then 
      result = @gtlInt.new {
        !where
        !emptylstring()
        !value << [[right as @gtlInt value] uint]
      }
    else
      error [right where] : "positive int expected" : result
    end
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt srOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    let @bigint r = [right as @gtlInt value];
    if r >= 0 then 
      result = @gtlInt.new { !where !emptylstring() !value >> [r uint] }
    else
      error [right where] : "positive int expected" : result
    end
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value != [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlBool.new {
      !where
      !emptylstring()
      !value == [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt gtOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value > [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt geOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value >= [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt ltOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value < [right as @gtlInt value]
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt leOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value <= [right as @gtlInt value] 
    }
  else
    error [right where] : "int expected" : result
  end
}

override getter @gtlInt embeddedType -> @type result
{
  result = `@bigint
}

override method @gtlInt addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlInt
#-----------------------------------------------------------------------------*
override getter @gtlInt performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "string"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![self string]
    }
  elsif "padded"                 == methodName then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint fieldSize = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    result = @gtlString.new {
      ![methodName location]
      !emptylstring()
      ![[self string] stringByLeftAndRightPadding !fieldSize !' ']
    }
  elsif "leftPadded"             == methodName then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint fieldSize = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    result = @gtlString.new {
      ![methodName location] 
      !emptylstring() 
      ![[self string] stringByLeftPadding !fieldSize !' ']
    }
  elsif "rightPadded"            == methodName then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint fieldSize = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    result = @gtlString.new {
      ![methodName location] 
      !emptylstring() 
      ![[self string] stringByRightPadding !fieldSize !' ']
    }
  elsif "hexString"              == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value hexString]
    }
  elsif "xString"                == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value xString]
    }
  elsif "numberOfBytes"          == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring() 
      !([[value bitCountForUnsignedRepresentation] bigint] - 1) / 8 + 1
    }
  elsif "signedNumberOfBytes"    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring() 
      !([[value bitCountForSignedRepresentation] bigint] - 1) / 8 + 1
    }
  elsif "numberOfBits"           == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring() 
      ![[value bitCountForUnsignedRepresentation] bigint]
    }
  elsif "signedNumberOfBits"     == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring() 
      ![[value bitCountForSignedRepresentation] bigint]
    }
  elsif "sign"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring() 
      ![[value sign] bigint]
    }
  elsif "fitsUnsignedInByte"     == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring() 
      ![value bitCountForUnsignedRepresentation] <= 8
    }
  elsif "fitsSignedInByte"       == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value bitCountForSignedRepresentation] <= 8
    }
  elsif "fitsUnsignedInShort"    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value bitCountForUnsignedRepresentation] <= 16
    }
  elsif "fitsSignedInShort"      == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value bitCountForSignedRepresentation] <= 16
    }
  elsif "fitsUnsignedInLong"     == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value bitCountForUnsignedRepresentation] <= 32
    }
  elsif "fitsSignedInLong"       == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value bitCountForSignedRepresentation] <= 32
    }
  elsif "fitsUnsignedInLongLong" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value bitCountForUnsignedRepresentation] <= 64
    }
  elsif "fitsSignedInLongLong"   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value bitCountForSignedRepresentation] <= 64
    }
  elsif "abs"                    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring()
      ![value abs]
    }
  elsif "bitAtIndex"             == methodName then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value bitAtIndex !index]
    }
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !true
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"int" !methodName] then
    result = [[lib getGetter !"int" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for int target" : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlInt
#-----------------------------------------------------------------------------*
override setter @gtlInt performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if    [methodName string] == "setBitAtIndex" then
    argumentsCheck(!methodName !boolIntArguments() !arguments)
    let @bool bit = [[arguments dataAtIndex !0] as @gtlBool value]
    let @uint index = [[[arguments dataAtIndex !1] as @gtlInt value] uint]
    [!?value setBitAtIndex !bit !index]
    where = methodName
  elsif [methodName string] == "complementBitAtIndex" then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    [!?value complementBitAtIndex !index]
    where = methodName
  elsif "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"int" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"int" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlInt value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for int target"
  end
}

#-----------------------------------------------------------------------------*
# Float type and operations on float
#-----------------------------------------------------------------------------*
class @gtlFloat  : @gtlData { @double value }

override getter @gtlFloat desc
  ?let @uint tab
  -> @string result
{
  result = @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "float: " + [value string] + "\n"
}

override getter @gtlFloat string -> @string result { result = [value string] }

override getter @gtlFloat lstring -> @lstring result {
  result = .new { ![value string] !where }
}

override getter @gtlFloat bool    -> @bool result {
  error where : "cannot cast a float to a bool" : result
}

override getter @gtlFloat int     -> @bigint result {
  result = [[value sint64] bigint]
}

override getter @gtlFloat float   -> @double result {
  result = value
}

override getter @gtlFloat plusOp  -> @gtlData result { result = self }

override getter @gtlFloat minusOp -> @gtlData result {
  result = @gtlFloat.new { !where !emptylstring() !-value }
}

override getter @gtlFloat notOp   -> @gtlData result {
  error where : "float forbidden" : result
}

override getter @gtlFloat addOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlFloat.new {
      !where
      !emptylstring()
      !value + [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat subOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlFloat.new {
      !where
      !emptylstring()
      !value - [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat mulOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlFloat.new {
      !where
      !emptylstring() 
      !value * [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat divOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlFloat.new {
      !where
      !emptylstring() 
      !value / [right as @gtlFloat value]
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat modOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}

override getter @gtlFloat andOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}

override getter @gtlFloat orOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}

override getter @gtlFloat xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}

override getter @gtlFloat slOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}

override getter @gtlFloat srOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}

override getter @gtlFloat neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value != [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlBool.new {
      !where 
      !emptylstring()
      !value == [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat gtOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value > [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat geOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlBool.new {
      !where 
      !emptylstring()
      !value >= [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat ltOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value < [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat leOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlFloat then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value <= [right as @gtlFloat value] 
    }
  else
    error [right where] : "float expected" : result
  end
}

override getter @gtlFloat embeddedType -> @type result
{
  result = `@double
}

override method @gtlFloat addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlFloat
#-----------------------------------------------------------------------------*
override getter @gtlFloat performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "string"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![self string]
    }
  elsif "cos"                    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value cos]
    }
  elsif "sin"                    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value sin]
    }
  elsif "tan"                    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value tan]
    }
  elsif "cosDegree"              == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value cosDegree]
    }
  elsif "sinDegree"              == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value sinDegree]
    }
  elsif "tanDegree"              == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value tanDegree]
    }
  elsif "exp"                    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value exp]
    }
  elsif "logn"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value logn]
    }
  elsif "log2"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value log2]
    }
  elsif "log10"                  == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value log10]
    }
  elsif "sqrt"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value sqrt]
    }
  elsif "power"                  == methodName then
    argumentsCheck(!methodName !floatArgument() !arguments)
    let @double power = [[arguments dataAtIndex !0] as @gtlFloat value]
    result = @gtlFloat.new {
      ![methodName location] !emptylstring() ![value power !power]
    }
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !true
    }
  elsif "int" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location] !emptylstring() ![[value sint64] bigint]
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"float" !methodName] then
    result = [[lib getGetter !"float" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for float target" : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlFloat
#-----------------------------------------------------------------------------*
override setter @gtlFloat performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"float" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"float" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlFloat value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for float target"
  end
}

#-----------------------------------------------------------------------------*
# String type and operations on string
#-----------------------------------------------------------------------------*
class @gtlString : @gtlData { @string  value }

override getter @gtlString desc
  ?let @uint tab
  -> @string result
{
  result = @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "string: \"" + value + "\"\n"
}

override getter @gtlString string -> @string result { result = value }

override getter @gtlString lstring -> @lstring result { result = .new{!value !where} }

override getter @gtlString bool   -> @bool result {
  error where : "cannot cast a string to a bool" : result
}

override getter @gtlString int    -> @bigint result {
  result = [[value decimalUnsignedNumber] bigint]
}

override getter @gtlString float  -> @double result {
  result = [[value decimalUnsignedNumber] double]
}

override getter @gtlString plusOp  -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString minusOp -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString notOp   -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString addOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlString then
    result = @gtlString.new {
      !where 
      !emptylstring() 
      !value + [right as @gtlString value] 
    }
  else
    error [right where] : "string expected" : result
  end
}

override getter @gtlString subOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString divOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString modOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString andOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString orOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString slOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString srOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}

override getter @gtlString neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlString then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value != [right as @gtlString value] 
    }
  else
    error [right where] : "string expected" : result
  end
}

override getter @gtlString eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlString then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value == [right as @gtlString value] 
    }
  else
    error [right where] : "string expected" : result
  end
}

override getter @gtlString gtOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlString then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value > [right as @gtlString value] 
    }
  else
    error [right where] : "string expected" : result
  end
}

override getter @gtlString geOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlString then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value >= [right as @gtlString value] 
    }
  else
    error [right where] : "string expected" : result
  end
}

override getter @gtlString ltOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlString then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value < [right as @gtlString value] 
    }
  else
    error [right where] : "string expected" : result
  end
}

override getter @gtlString leOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlString then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value <= [right as @gtlString value] 
    }
  else
    error [right where] : "string expected" : result
  end
}

override getter @gtlString embeddedType -> @type result
{
  result = `@string
}

override method @gtlString addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlString
#-----------------------------------------------------------------------------*
override getter @gtlString performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    [methodName string] == "string" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() !value
    }
  elsif [methodName string] == "charAtIndex" then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    result = @gtlChar.new {
      ![methodName location] !emptylstring() ![value characterAtIndex !index]
    }
  elsif [methodName string] == "indexOfChar" then
    argumentsCheck(!methodName !charArgument() !arguments)
    let @char lookedUpChar = [[arguments dataAtIndex !0] as @gtlChar value]
    @uint index = 0
    let @uint length = [value length]
    @bool found = false
    loop (length)
    while not found && index < length do
      if [value characterAtIndex !index] == lookedUpChar then
        found = true
      else
        index++
      end
    end
    result = @gtlInt.new {
      ![methodName location] 
      !emptylstring() 
      !if found then [index bigint] else -1 end
    }
  elsif [methodName string] == "indexOfCharInRange" then
    argumentsCheck(!methodName !charCharArguments() !arguments)
    let @char minChar = [[arguments dataAtIndex !0] as @gtlChar value]
    let @char maxChar = [[arguments dataAtIndex !1] as @gtlChar value]
    @uint index = 0
    let @uint length = [value length]
    @bool found = false
    loop (length)
    while not found && index < length do
      let @char currentChar = [value characterAtIndex !index]
      if currentChar >= minChar && currentChar <= maxChar then
        found = true
      else
        index++
      end
    end
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring()
      !if found then [index bigint] else -1 end
    }
  elsif [methodName string] == "containsChar" then
    argumentsCheck(!methodName !charArgument() !arguments)
    let @char lookedUpChar = [[arguments dataAtIndex !0] as @gtlChar value]
    result = @gtlBool.new {
      ![methodName location] 
      !emptylstring() 
      ![value containsCharacter !lookedUpChar]
    }
  elsif [methodName string] == "containsCharInRange" then
    argumentsCheck(!methodName !charCharArguments() !arguments)
    let @char minChar = [[arguments dataAtIndex !0] as @gtlChar value]
    let @char maxChar = [[arguments dataAtIndex !1] as @gtlChar value]
    result = @gtlBool.new {
      ![methodName location] 
      !emptylstring() 
      ![value containsCharacterInRange !minChar !maxChar]
    }
  elsif [methodName string] == "HTMLRepresentation" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value HTMLRepresentation]
    }
  elsif [methodName string] == "identifierRepresentation" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value identifierRepresentation]
    }
  elsif [methodName string] == "fileExists" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value fileExists]
    }
  elsif [methodName string] == "lowercaseString" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value lowercaseString]
    }
  elsif [methodName string] == "length" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location] !emptylstring() ![[value length] bigint]
    }
  elsif [methodName string] == "capitalized"
        || "stringByCapitalizingFirstCharacter" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value stringByCapitalizingFirstCharacter]
    }
  elsif [methodName string] == "uppercaseString" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value uppercaseString]
    }
  elsif [methodName string] == "unsigned" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location] !emptylstring() ![[value decimalUnsignedNumber] bigint]
    }
  elsif [methodName string] == "subStringExists" then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @string subString = [[arguments dataAtIndex !0] as @gtlString value]
    let @uint subStringLength = [subString length]
    @uint start = 0
    let @uint stop = [value length] - subStringLength
    @bool exists = false 
    loop ( [value length] )
    while (not exists) && (start <= stop) do
      if [value subString !start !subStringLength] == subString then
        exists = true
      end
      start++
    end        
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !exists
    }
  elsif [methodName string] == "leftSubString" then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value leftSubString !index]
    }
  elsif [methodName string] == "rightSubString" then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value rightSubString !index]
    }
  elsif [methodName string] == "subString" then
    argumentsCheck(!methodName !intIntArguments() !arguments)
    let @uint start = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    let @uint length = [[[arguments dataAtIndex !1] as @gtlInt value] uint]
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value subString !start !length]
    }
  elsif [methodName string] == "reversedString" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![value reversedString]
    }
  elsif [methodName string] == "componentsSeparatedByString" then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @string separator = [[arguments dataAtIndex !0] as @gtlString value]
    let @stringlist stringlist = [value componentsSeparatedByString !separator]
    @list components = .emptyList
    for (str) in stringlist do
      components += !@gtlString.new {
        ![methodName location] !emptylstring() !str
      }
    end
    result = @gtlList.new {
      ![methodName location] !emptylstring() !components
    }
  elsif [methodName string] == "interpretEscape" then
    warning methodName : "deprecated method"
    result = self
  elsif [methodName string] == "columnPrefixedBy" then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @string prefix = [[arguments dataAtIndex !0] as @gtlString value]
    result = @gtlString.new {
      ![methodName location]
      !emptylstring() 
      ![prefix + value stringByReplacingStringByString !"\n" !"\n" + prefix]
    }
  elsif [methodName string] == "wrap" then
    argumentsCheck(!methodName !intIntArguments() !arguments)
    let @uint width = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    let @uint shift = [[[arguments dataAtIndex !1] as @gtlInt value] uint]
    let @string stringShift = .stringWithSequenceOfCharacters { !' ' !shift }
    let @stringlist paragraphs = [value componentsSeparatedByString !"\n"]
    var @stringlist resultParagraphs = .emptyList{}
    for (paragraph) in paragraphs do
      let @stringlist words = [paragraph componentsSeparatedByString !" "]
      @uint lineWidth = 0
      @string line = ""
      for (word) in words do
        if word != "" then
          if lineWidth + [word length] > width then
            line += "\n" + stringShift
            lineWidth = shift
          end
          lineWidth += [word length] + 1
          line += word + " "
        end        
      end
      resultParagraphs += !line
    end
    result = @gtlString.new {
      ![methodName location]
      !emptylstring() 
      !@string.componentsJoinedByString { !resultParagraphs !"\n" }
    }
  elsif [methodName string] == "replaceString" then
    argumentsCheck(!methodName !stringStringArgument() !arguments)
    let @string find = [[arguments dataAtIndex !0] as @gtlString value]
    let @string rep  = [[arguments dataAtIndex !1] as @gtlString value]
    result = @gtlString.new {
      ![methodName location]
      !emptylstring() 
      ![value stringByReplacingStringByString !find !rep]
    }
  elsif [methodName string] == "subStringExists" then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @string subString = [[arguments dataAtIndex !0] as @gtlString string]
    let @uint subLength = [subString length]
    @uint start = 0
    let @uint stop = [value length] - subLength
    @bool exists = false
    loop ([value length])
    while start <= stop & not exists do
      if [value subString !start !subLength] == subString then
        exists = true
      end
      start++
    end
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring() 
      !exists
    }
  elsif [methodName string] == "envVarExists" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location]
      !emptylstring()
      ![value doesEnvironmentVariableExist]
    }
  elsif [methodName string] == "envVar" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location]
      !emptylstring()
      !@string.stringWithEnvironmentVariableOrEmpty { ! value }
    }
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"string" !methodName] then
    result = [[lib getGetter !"string" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  elsif "files" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    let @stringlist  fileList = [value regularFiles !false]
    @lstringset files = .emptyMap
    for (file) in fileList do
      [!?files put !@lstring.new { !file ![methodName location] } ]
    end
    result = @gtlSet.new {
      ![methodName location] !emptylstring() !files
    }
  elsif "filesWithExtensions" == methodName then
    argumentsCheck(!methodName !setArgument() !arguments)
    @stringlist extensions = .emptyList
    for (ext) in [[arguments dataAtIndex !0] as @gtlSet value] do
      extensions += ![ext string]
    end
    let @stringlist  fileList = [value regularFilesWithExtensions !false !extensions]
    @lstringset files = .emptyMap
    for (file) in fileList do
      [!?files put !@lstring.new { !file ![methodName location] } ]
    end
    result = @gtlSet.new {
      ![methodName location] !emptylstring() !files
    }
  else
    error methodName : "unknown getter '" + methodName +"' for string target"
      : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlFloat
#-----------------------------------------------------------------------------*
override setter @gtlString performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if    "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif          "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif "setCharAtIndex" == methodName then
    argumentsCheck(!methodName !charIntArguments() !arguments)
    let @char charToSet = [[arguments dataAtIndex !0] as @gtlChar value]
    let @uint index = [[[arguments dataAtIndex !1] as @gtlInt value] uint]
    [!?value setCharacterAtIndex !charToSet !index]
    where = methodName
  elsif "insertCharAtIndex" == methodName then
    argumentsCheck(!methodName !charIntArguments() !arguments)
    let @char charToInsert = [[arguments dataAtIndex !0] as @gtlChar value]
    let @uint index = [[[arguments dataAtIndex !1] as @gtlInt value] uint]
    [!?value insertCharacterAtIndex !charToInsert !index]
    where = methodName
  elsif "removeCharAtIndex" == methodName then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[[arguments dataAtIndex !0] as @gtlInt value] uint]
    [!?value removeCharacterAtIndex ?* !index]
    where = methodName
  elsif [lib setterExists !"string" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"string" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlString value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for string target"
  end
}

#-----------------------------------------------------------------------------*
# Bool type and operations on bool
#-----------------------------------------------------------------------------*
class @gtlBool : @gtlData { @bool value }

override getter @gtlBool desc
  ?let @uint tab
  -> @string result
{
  result = @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "boolean: " + [value cString] + "\n"
}

override getter @gtlBool string -> @string result { result = [value cString] }

override getter @gtlBool lstring -> @lstring result {
  result = .new { ![value cString] !where }
}

override getter @gtlBool bool   -> @bool result {
  result = value
}

override getter @gtlBool int    -> @bigint result {
  result = if value then 1 else 0 end
}

override getter @gtlBool float  -> @double result {
  result = if value then 1.0 else 0.0 end
}

override getter @gtlBool plusOp  -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool minusOp -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool notOp   -> @gtlData result {
  result = @gtlBool.new { !where !emptylstring() !not value }
}

override getter @gtlBool addOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool subOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool divOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool modOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool andOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new { 
      !where 
      !emptylstring() 
      !value & [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool orOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value | [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool xorOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value ^ [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool slOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool srOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}

override getter @gtlBool neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new { 
      !where 
      !emptylstring() 
      !value != [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value == [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool gtOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value > [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool geOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value >= [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool ltOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value < [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool leOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlBool then
    result = @gtlBool.new {
      !where 
      !emptylstring() 
      !value <= [right as @gtlBool value] 
    }
  else
    error [right where] : "bool expected" : result
  end
}

override getter @gtlBool embeddedType -> @type result
{
  result = `@bool
}

override method @gtlBool addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlBool
#-----------------------------------------------------------------------------*
override getter @gtlBool performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if     [methodName string] == "trueOrFalse" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location]
      !emptylstring()
      !if value then "true" else "false" end
    }
  elsif  [methodName string] == "string" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location]
      !emptylstring()
      ![self string]
    }
  elsif [methodName string] == "yesOrNo" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location]
      !emptylstring()
      !if value then "yes" else "no" end
    }
  elsif [methodName string] == "TRUEOrFALSE" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location]
      !emptylstring()
      !if value then "TRUE" else "FALSE" end
    }
  elsif [methodName string] == "YESOrNO" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location]
      !emptylstring()
      !if value then "YES" else "NO" end
    }
  elsif [methodName string] == "int" || [methodName string] == "unsigned" then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring()
      !if value then 1 else 0 end
    }
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"bool" !methodName] then
    result = [[lib getGetter !"bool" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for boolean target"
      : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @@gtlBool
#-----------------------------------------------------------------------------*
override setter @gtlBool performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"bool" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"bool" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlBool value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for boolean target"
  end
}

#-----------------------------------------------------------------------------*
# foundation types for collections
#-----------------------------------------------------------------------------*
list @list { @gtlData value }

#-----------------------------------------------------------------------------*
# Set type and operations on set
#-----------------------------------------------------------------------------*
map @lstringset {
  insert put error message "set element named '%K' is already declared in %L"
  search get error message "there is no set element named '%K' to get"
  remove del error message "there is no set element named '%K' to delete"
}

class @gtlSet : @gtlData { @lstringset value }

override getter @gtlSet desc
  ?let @uint tab
  -> @string result
{
  result =  @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "set: @!\n" 
  for () in value
  before
    result += @string.stringWithSequenceOfCharacters{!' ' !tab+4}
  do
    result += lkey
  between
    result += ", "
  after
    result += "\n"
  end
  result += @string.stringWithSequenceOfCharacters{!' ' !tab} + "!\n"
}

override getter @gtlSet string -> @string result {
  error where : "cannot cast a set to a string" : result
}

override getter @gtlSet lstring -> @lstring result {
  error where : "cannot cast a set to a lstring" : result
}

override getter @gtlSet bool   -> @bool result {
  error where : "cannot cast a set to a bool" : result
}

override getter @gtlSet int    -> @bigint result {
  error where : "cannot cast a set to an int" : result
}

override getter @gtlSet float  -> @double result {
  error where : "cannot cast a set to a float" : result
}

override getter @gtlSet plusOp  -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet minusOp -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet notOp   -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet addOp ?let @gtlData right -> @gtlData result {
  @lstringset set = value
  let @lstring element = [right lstring]
  if [set hasKey !element] then
    [!?set del !element]
  end
  [!?set put ![right lstring]]
  result = @gtlSet.new { !where !emptylstring() !set }
}

override getter @gtlSet subOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    @lstringset resultSet = value
    for (lkey) in [right as @gtlSet value] do
      if [resultSet hasKey !lkey] then
        [!?resultSet del !lkey]
      end
    end
    result = @gtlSet.new {
      !where !emptylstring() !resultSet
    }
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet divOp ?let @gtlData unused right -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet modOp ?let @gtlData unused right -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet andOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    @lstringset resultSet = .emptyMap
    for (rightKey) in [right as @gtlSet value] do
      if [value hasKey !rightKey] then
        [!?resultSet put !rightKey]
      end
    end
    result = @gtlSet.new {
      !where !emptylstring() !resultSet
    }
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet orOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    @lstringset resultSet = [right as @gtlSet value]
    for (leftKey) in value do
      if not [resultSet hasKey !leftKey] then
        [!?resultSet put !leftKey]
      end
    end
    result = @gtlSet.new {
      !where !emptylstring() !resultSet
    }
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet slOp ?let @gtlData unused right -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet srOp ?let @gtlData unused right -> @gtlData result {
  error where : "set forbidden" : result
}

override getter @gtlSet neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    result = @gtlBool.new {
      !where !emptylstring() !value != [right as @gtlSet value]
    }
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    result = @gtlBool.new {
      !where !emptylstring() !value == [right as @gtlSet value]
    }
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet gtOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    if [right as @gtlSet value] == value then
      result = @gtlBool.new { !where !emptylstring() !false }
    else
      @bool included = true
      for (val) in [right as @gtlSet value] while included do
        if not [value hasKey !val] then included = false end
      end
      result = @gtlBool.new { !where !emptylstring() !included }
    end
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet geOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    @bool included = true
    for (val) in [right as @gtlSet value] while included do
      if not [value hasKey !val] then included = false end
    end
    result = @gtlBool.new { !where !emptylstring() !included }
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet ltOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    if [right as @gtlSet value] == value then
      result = @gtlBool.new { !where !emptylstring() !false }
    else
      @bool included = true
      for (val) in value while included do
        if not [[right as @gtlSet value] hasKey !val] then included = false end
      end
      result = @gtlBool.new { !where !emptylstring() !included }
    end
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet leOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlSet then
    @bool included = true
    for (val) in value while included do
      if not [[right as @gtlSet value] hasKey !val] then included = false end
    end
    result = @gtlBool.new { !where !emptylstring() !included }
  else
    error right : "set expected" : result
  end
}

override getter @gtlSet embeddedType -> @type result
{
  error where : "struct forbidden as built in function argument" : result
}

override method @gtlSet addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlSet
#-----------------------------------------------------------------------------*
override getter @gtlSet performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "length"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring()
      ![[value count] bigint]
    }
  elsif "list"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlList.new {
      ![methodName location] !emptylstring() !.emptyList
    }
    for () in value do
      [!?result appendItem !@gtlString.new { !lkey !emptylstring() !lkey }]
    end
  elsif "contains"               == methodName then
    argumentsCheck(!methodName !anyArgument() !arguments)
    let @string key = [[arguments dataAtIndex !0] string]
    result = @gtlBool.new {
      ![methodName location] !emptylstring() ![value hasKey !key]
    }
  elsif "elementNamed"           == methodName then
    argumentsCheck(!methodName !anyArgument() !arguments)
    let @string key = [[arguments dataAtIndex !0] string]
    let @location loc = [value locationForKey !key]
    result = @gtlString.new {
      !loc !emptylstring() !key
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"set" !methodName] then
    result = [[lib getGetter !"set" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for set target"
      : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlStruct
#-----------------------------------------------------------------------------*
override setter @gtlSet performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif       "add"   == methodName then
    argumentsCheck(!methodName !anyArgument() !arguments)
    let @lstring key = [[arguments dataAtIndex !0] lstring]
    if [value hasKey !key] then
      [!?value del !key]
    end
    [!?value put !key]
    where = methodName
  elsif      "remove" == methodName then
    argumentsCheck(!methodName !anyArgument() !arguments)
    let @lstring key = [[arguments dataAtIndex !0] lstring]
    if [value hasKey !key] then
      [!?value del !key]
    end
    where = methodName
  elsif [lib setterExists !"set" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"set" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlSet value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for set target"
  end
}

#-----------------------------------------------------------------------------*
# Struct type and operations on struct
#-----------------------------------------------------------------------------*
class @gtlStruct : @gtlData { @gtlVarMap  value }

override getter @gtlStruct desc
  ?let @uint tab
  -> @string result
{
  result =  @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "struct: @{\n"
  for () in value do
    result += @string.stringWithSequenceOfCharacters{!' ' !tab+4} +
      [lkey string] + " :>\n" + 
      [value desc !tab+8]
  end
  result += @string.stringWithSequenceOfCharacters{!' ' !tab} + "}\n"
}

override getter @gtlStruct string -> @string result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct lstring -> @lstring result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct bool   -> @bool result {
  error where : "cannot cast a struct to a bool" : result
}

override getter @gtlStruct int    -> @bigint result {
  error where : "cannot cast a struct to an int" : result
}

override getter @gtlStruct float  -> @double result {
  error where : "cannot cast a struct to a float" : result
}

override getter @gtlStruct plusOp  -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct minusOp -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct notOp   -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct addOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct subOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct divOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct modOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct andOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct orOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct slOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct srOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlStruct then
    let @gtlVarMap rValue = [right as @gtlStruct value]
    @bool equal
    if [value count] != [rValue count] then
      equal = false
    else
      equal = true
      for (lkey lValue) in value do
        if [rValue hasKey !lkey] then
          [rValue get !lkey ?let @gtlData rData]
          equal = equal & [lValue eqOp !rData]
        else
          equal = false
        end
      end
    end
    result = @gtlBool.new { !where !emptylstring() !not equal }
  else
    error [right where] : "struct expected" : result
  end
}

override getter @gtlStruct eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlStruct then
    let @gtlVarMap rValue = [right as @gtlStruct value]
    @bool equal
    if [value count] != [rValue count] then
      equal = false
    else
      equal = true
      for (lkey lValue) in value do
        if [rValue hasKey !lkey] then
          [rValue get !lkey ?let @gtlData rData]
          equal = equal & [lValue eqOp !rData]
        else
          equal = false
        end
      end
    end
    result = @gtlBool.new { !where !emptylstring() !equal }
  else
    error [right where] : "struct expected" : result
  end
}

override getter @gtlStruct gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct geOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct leOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

override getter @gtlStruct embeddedType -> @type result
{
  error where : "struct forbidden as built in function argument" : result
}

override method @gtlStruct addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlStruct
#-----------------------------------------------------------------------------*
override getter @gtlStruct performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "map"                    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlMap.new {
      ![methodName location]
      !emptylstring()
      !value
    }
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"struct" !methodName] then
    result = [[lib getGetter !"struct" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for struct target"
      : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlStruct
#-----------------------------------------------------------------------------*
override setter @gtlStruct performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"struct" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"struct" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlStruct value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for struct target"
  end
}

#-----------------------------------------------------------------------------*
# get a data from a @gtlStruct
#-----------------------------------------------------------------------------*
override method @gtlStruct structField
  ?let @lstring name
  !@gtlData     result
  !@bool        found
{
  if [value hasKey !name] then
    [value get !name ?result]
    found = true
  else
    result = @gtlUnconstructed.new { !name !emptylstring() }
    found = false
  end
}

override getter @gtlStruct resultField
  ?let @lstring name
  ->@gtlData    result
{
  if [value hasKey !name] then
    [value get !name ?result]
  else
    result = @gtlUnconstructed.new { !name !emptylstring() }
  end
}

#-----------------------------------------------------------------------------*
# check if a field exists in a @gtlStruct
#-----------------------------------------------------------------------------*
override getter @gtlStruct hasStructField
  ?let @lstring name
  ->@bool result
{
  result = [value hasKey !name]
}

#-----------------------------------------------------------------------------*
# Set a data in a @gtlStruct
#-----------------------------------------------------------------------------*
override setter @gtlStruct setStructField
  ?let @lstring name
  ?let @gtlData data
{
  [!?value replaceOrCreate !name !data]
}

#-----------------------------------------------------------------------------*
# Set a data in a @gtlStruct
#-----------------------------------------------------------------------------*
override setter @gtlStruct setStructFieldAtLevel
  ?let @lstring name
  ?let @gtlData data
  ?let @uint    level
{
  [!?value replaceOrCreateAtLevel !name !data !level]
}

#-----------------------------------------------------------------------------*
# delete a data in a @gtlStruct
#-----------------------------------------------------------------------------*
override setter @gtlStruct deleteStructField
  ?let @lstring name
{
  [!?value del !name ?*]
}

#-----------------------------------------------------------------------------*
# List type and operations on lists
#-----------------------------------------------------------------------------*
class @gtlList   : @gtlData { @list value }

override getter @gtlList desc
  ?let @uint tab
  -> @string result
{
  result =  @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "list: @(\n"
  for () in value do (i)
    result += @string.stringWithSequenceOfCharacters{!' ' !tab+4} +
      [i string] + " :>\n" + 
      [value desc !tab+8]
  end
  result += @string.stringWithSequenceOfCharacters{!' ' !tab} + ")\n"
}

override getter @gtlList string -> @string result {
  error where : "list forbidden" : result
}

override getter @gtlList lstring -> @lstring result {
  error where : "list forbidden" : result
}

override getter @gtlList bool   -> @bool result {
  error where : "cannot cast a list to a bool" : result
}

override getter @gtlList int    -> @bigint result {
  error where : "cannot cast a list to an int" : result
}

override getter @gtlList float  -> @double result {
  error where : "cannot cast a list to a float" : result
}

override getter @gtlList plusOp  -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList minusOp -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList notOp   -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList addOp ?let @gtlData right -> @gtlData result {
  @list res = value;
  res += !right
  result = @gtlList.new { !where !emptylstring() !res  }
}

override getter @gtlList subOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList divOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList modOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList andOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList orOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlList then
    result = @gtlList.new { 
      !where 
      !emptylstring() 
      !value + [right as @gtlList value] 
    }
  else
    error [right where] : "list expected" : result
  end
}

override getter @gtlList xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList slOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList srOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}

override getter @gtlList neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlList then
    let @list rValue = [right as @gtlList value]
    @bool equal
    if [value length] != [rValue length] then
      equal = false
    else
      equal = true
      for (left) in value, (right) in rValue do
        equal = equal & [left eqOp !right]
      end
    end
    result = @gtlBool.new { !where !emptylstring() !not equal }
  else
    error [right where] : "list expected" : result
  end
}

override getter @gtlList eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlList then
    let @list rValue = [right as @gtlList value]
    @bool equal
    if [value length] != [rValue length] then
      equal = false
    else
      equal = true
      for (left) in value, (right) in rValue do
        equal = equal & [left eqOp !right]
      end
    end
    result = @gtlBool.new { !where !emptylstring() !equal }
  else
    error [right where] : "list expected" : result
  end
}

override getter @gtlList gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the > operator" : result
}

override getter @gtlList geOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the >= operator" : result
}

override getter @gtlList ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the < operator" : result
}

override getter @gtlList leOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the <= operator" : result
}

override getter @gtlList embeddedType -> @type result
{
  error where : "list forbidden as built in function argument" : result
}

override method @gtlList addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlList
#-----------------------------------------------------------------------------*
override getter @gtlList performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "length"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring()
      ![[value length] bigint]
    }
  elsif "first"                  == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    [value first ?result]     
  elsif "last"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    [value last ?result]
  elsif "elementAtIndex"         == methodName then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[arguments dataAtIndex !0] int]
    if index < [value length] then
      result = [value valueAtIndex !index]
    else
      error methodName : "index out of bounds" : result
    end
  elsif "subListTo"              == methodName then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[arguments dataAtIndex !0] int]
    if index < [value length] then
      result = @gtlList.new {
        !methodName
        !emptylstring()
        ![value subListToIndex !index]
      }
    else
      result = self
    end
  elsif "subListFrom"            == methodName then
    argumentsCheck(!methodName !intArgument() !arguments)
    let @uint index = [[arguments dataAtIndex !0] int]
    if index < [value length] then
      result = @gtlList.new {
        !methodName
        !emptylstring()
        ![value subListFromIndex !index]
      }
    else
      result = @gtlList.new {
        !methodName
        !emptylstring()
        !.emptyList
      }
    end
  elsif "subList"                == methodName then
    argumentsCheck(!methodName !intIntArguments() !arguments)
    let @uint start  = [[arguments dataAtIndex !0] int]
    @uint length = [[arguments dataAtIndex !1] int]
    if start < [value length] then
      if start + length > [value length] then
        length = [value length] - start
      end
      result = @gtlList.new {
        !methodName
        !emptylstring()
        ![value subListWithRange !@range.new { !start !length }]
      }
    else
      result = @gtlList.new {
        !methodName
        !emptylstring()
        !.emptyList
      }
    end
  elsif "mapBy"                  == methodName then
    argumentsCheck(!methodName !anyArgument() !arguments)
    let @lstring key = [[arguments dataAtIndex !0] lstring]
    @gtlVarMap resultMap = .emptyMap
    for (item) in [self value] do (index)
      cast item
      case == @gtlStruct itemStruct:
        if [[itemStruct value] hasKey ![key string]] then
          [[itemStruct value] get !key ?let @gtlData keyValue]
          [!?resultMap put
            ![keyValue lstring]
            !item
          ]
        else
          error methodName : "item at index " + index
            + " does not have field named " + key
        end
      case == @gtlMap itemMap:
        if [[itemMap value] hasKey ![key string]] then
          [[itemMap value] get !key ?let @gtlData keyValue]
          [!?resultMap put
            ![keyValue lstring]
            !item
          ]
        else
          error methodName : "item at index " + index
            + " does not have field named " + key
        end
      else
        error methodName : "list of struct expected"
      end
    end
    result = @gtlMap.new { !where !emptylstring() !resultMap }
  elsif "set"                    == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    @lstringset resultSet = .emptyMap
    for (item) in value do
      let @lstring itemKey = [item lstring]
      if [resultSet hasKey !itemKey] then
        [!?resultSet del !itemKey]
      end
      [!?resultSet put !itemKey]
    end
    result = @gtlSet.new {
      !methodName !emptylstring() !resultSet
    }
  elsif "setBy"                    == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @lstring key = [[arguments dataAtIndex !0] lstring]
    @lstringset resultSet = .emptyMap
    for (item) in value do
      [item structField !key ?let @gtlData field ?*]
      let @lstring resKey = [field lstring]
      if [resultSet hasKey !resKey] then
        [!?resultSet del !resKey]
      end
      [!?resultSet put !resKey]
    end
    result = @gtlSet.new {
      !methodName !emptylstring() !resultSet
    }
  elsif "componentsJoinedByString" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @string joiner = [[arguments dataAtIndex !0] string]
    @string stringResult = ""
    for (item) in value
    do
      stringResult = stringResult + [item string]
    between
      stringResult = stringResult + joiner
    end
    result = @gtlString.new {
      ![methodName location] !emptylstring() !stringResult
    }
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif "where" == methodName then
    if [arguments length] < 1 | [arguments length] > 2 then
      error methodName : "where expects 1 ou 2 arguments. " +
                         [arguments length] + " arguments provided." : result
    else
      if [[arguments dataAtIndex !0] dynamicType] != `@gtlExpr then
        error methodName : "expression expected for argument 1" : result
      else
        @gtlStruct vars
        if [arguments length] == 2 then
          if [[arguments dataAtIndex !1] dynamicType] != `@gtlStruct then
            error methodName : "struct expected for argument 1" : vars
          else
            vars = [arguments dataAtIndex !1] as @gtlStruct
          end
        else
          vars = .new { !where !emptylstring() !.emptyMap }
        end
        let @gtlExpression expr = [[arguments dataAtIndex !0] as @gtlExpr value]
        @list resultList = .emptyList
        for (item) in value
        do
          [!?vars setStructField !@lstring.new {!"__item__" ![item where]} !item]
          let @gtlData evalResult = [expr eval !context !vars !lib]
          if [evalResult bool] then
            resultList += !item
          end
        end
        result = @gtlList.new {
          !methodName
          !emptylstring()
          !resultList
        }
      end
    end
  elsif [lib getterExists !"list" !methodName] then
    result = [[lib getGetter !"list" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for list target"
      : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlList
#-----------------------------------------------------------------------------*
override setter @gtlList performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif      "insert" == methodName then
    argumentsCheck(!methodName !intAnyArguments() !arguments)
    let @uint insertIndex = [[arguments dataAtIndex !0] int]
    let @gtlData node = [arguments dataAtIndex !1]
    if insertIndex < [value length] then
      [!?value insertAtIndex !node !insertIndex]
    else
      value += !node
    end
    where = methodName
  elsif [lib setterExists !"list" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"list" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlList value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for list target"
  end
}

override setter @gtlList setItemAtIndex
  ?let @gtlData data
  ?let @gtlInt  index
{
  [!?value setValueAtIndex !data ![[index value] uint]]
}

override setter @gtlList deleteItemAtIndex
  ?let @gtlInt  index
{
  let @uint indexUint = [[index value] uint]
  if indexUint < [value length] then
    if indexUint == 0 then
      value = [value subListFromIndex !1]
    elsif indexUint == [value length] - 1 then
      value = [value subListToIndex !indexUint - 1]
    else
      value = [value subListToIndex !indexUint - 1]
            + [value subListFromIndex !indexUint + 1]
    end
  end
}

override method @gtlList itemAtIndex
  !@gtlData     data
  ?let @gtlInt  index
{
  data = [value valueAtIndex ![[index value] uint]]
}

override getter @gtlList hasItemAtIndex
  ?let @gtlInt index
  ->@bool result
{
  result = [value length] > [[index value] uint]
}

override setter @gtlList appendItem
  ?let @gtlData item
{
  value += !item
}

#-----------------------------------------------------------------------------*
# Map type and operations on maps
#-----------------------------------------------------------------------------*
class @gtlMap    : @gtlData { @gtlVarMap  value }

override getter @gtlMap desc
  ?let @uint tab
  -> @string result
{
  result =  @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "map: @[\n"
  for () in value do
    result += @string.stringWithSequenceOfCharacters{!' ' !tab+4} +
      "\""+ [lkey string] + "\" :>\n" + 
      [value desc !tab+8]
  end
  result += @string.stringWithSequenceOfCharacters{!' ' !tab} + "]\n"
}

override getter @gtlMap string -> @string result {
  error where : "map forbidden" : result
}

override getter @gtlMap lstring -> @lstring result {
  error where : "map forbidden" : result
}

override getter @gtlMap bool    -> @bool result {
  error where : "cannot cast a map to a bool" : result
}

override getter @gtlMap int     -> @bigint result {
  error where : "cannot cast a map to an int" : result
}

override getter @gtlMap float   -> @double result {
  error where : "cannot cast a map to a float" : result
}

override getter @gtlMap plusOp  -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap minusOp -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap notOp   -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap addOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap subOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap divOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap modOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap andOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap orOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap slOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap srOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}

override getter @gtlMap neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlMap then
    let @gtlVarMap rValue = [right as @gtlMap value]
    @bool equal
    if [value count] != [rValue count] then
      equal = false
    else
      equal = true
      for (lkey lValue) in value do
        if [rValue hasKey !lkey] then
          [rValue get !lkey ?let @gtlData rData]
          equal = equal & [lValue eqOp !rData]
        else
          equal = false
        end
      end
    end
    result = @gtlBool.new { !where !emptylstring() !not equal }
  else
    error [right where] : "struct expected" : result
  end
}

override getter @gtlMap eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlMap then
    let @gtlVarMap rValue = [right as @gtlMap value]
    @bool equal
    if [value count] != [rValue count] then
      equal = false
    else
      equal = true
      for (lkey lValue) in value do
        if [rValue hasKey !lkey] then
          [rValue get !lkey ?let @gtlData rData]
          equal = equal & [lValue eqOp !rData]
        else
          equal = false
        end
      end
    end
    result = @gtlBool.new { !where !emptylstring() !equal }
  else
    error [right where] : "struct expected" : result
  end
}

override getter @gtlMap gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the > operator" : result
}

override getter @gtlMap geOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the >= operator" : result
}

override getter @gtlMap ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the < operator" : result
}

override getter @gtlMap leOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the <= operator" : result
}

override getter @gtlMap embeddedType -> @type result
{
  error where : "map forbidden as built in function argument" : result
}

override method @gtlMap addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlMap
#-----------------------------------------------------------------------------*
override getter @gtlMap performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if    "length"                 == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlInt.new {
      ![methodName location]
      !emptylstring() 
      ![[value count] bigint]
    }
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "list"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    @list resultList = .emptyList
    for (unused key item) in [self value] do
      resultList += !item
    end
    result = @gtlList.new { !where !emptylstring() !resultList }
  elsif "where" == methodName then
    if [arguments length] < 1 | [arguments length] > 2 then
      error methodName : "where expects 1 ou 2 arguments. " +
                         [arguments length] + " arguments provided." : result
    else
      if [[arguments dataAtIndex !0] dynamicType] != `@gtlExpr then
        error methodName : "expression expected for argument 1" : result
      else
        @gtlStruct vars
        if [arguments length] == 2 then
          if [[arguments dataAtIndex !1] dynamicType] != `@gtlStruct then
            error methodName : "struct expected for argument 1" : vars
          else
            vars = [arguments dataAtIndex !1] as @gtlStruct
          end
        else
          vars = .new { !where !emptylstring() !.emptyMap }
        end
        let @gtlExpression expr = [[arguments dataAtIndex !0] as @gtlExpr value]
        @gtlVarMap resultMap = .emptyMap
        for (key item) in value
        do
          [!?vars setStructField !@lstring.new {!"__item__" ![item where]} !item]
          let @gtlData evalResult = [expr eval !context !vars !lib]
          if [evalResult bool] then
            [!?resultMap put !key !item]
          end
        end
        result = @gtlMap.new {
          !methodName
          !emptylstring()
          !resultMap
        }
      end
    end
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif [lib getterExists !"map" !methodName] then
    result = [[lib getGetter !"map" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  else
    error methodName : "unknown getter '" + methodName +"' for map target"
      : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @gtlMap
#-----------------------------------------------------------------------------*
override setter @gtlMap performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"map" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"map" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlMap value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for map target"
  end
}

#-----------------------------------------------------------------------------*
# Set a data in a @gtlMap
#-----------------------------------------------------------------------------*
override setter @gtlMap setMapItem
  ?let @lstring name
  ?let @gtlData data
{
  [!?value replaceOrCreate !name !data]
}

override setter @gtlMap deleteMapItem
  ?let @lstring name
{
  [!?value del !name ?*]
}

override method @gtlMap mapItem
  ?let @lstring name
  !@gtlData     result
{
  if [value hasKey !name] then
    [value get !name ?result]
  else
    result = @gtlUnconstructed.new { !name !emptylstring() }
  end
}

override getter @gtlMap hasMapItem
  ?let @lstring name
  ->@bool result
{
  result = [value hasKey !name]
}

#-----------------------------------------------------------------------------*
# Expression type and operations on maps
#-----------------------------------------------------------------------------*
class @gtlExpr : @gtlData { @gtlExpression value }

override getter @gtlExpr desc
  ?let @uint tab
  -> @string result
{
  result =  @string.stringWithSequenceOfCharacters{!' ' !tab} +
    "expression: @? " + [value stringRepresentation] + " ?\n"
}

override getter @gtlExpr string -> @string result {
  error where : "expression forbidden" : result
}

override getter @gtlExpr lstring -> @lstring result {
  error where : "expression forbidden" : result
}

override getter @gtlExpr bool    -> @bool result {
  error where : "cannot cast an expression to a bool" : result
}

override getter @gtlExpr int     -> @bigint result {
  error where : "cannot cast an expression to an int" : result
}

override getter @gtlExpr float   -> @double result {
  error where : "cannot cast an expression to a float" : result
}

override getter @gtlExpr plusOp  -> @gtlData result {
  result = self
}

override getter @gtlExpr minusOp -> @gtlData result {
  result = @gtlExpr.new {
    !where
    !emptylstring()
    !@gtlMinusExpression.new { !where !value }
  }
}

override getter @gtlExpr notOp   -> @gtlData result {
  result = @gtlExpr.new {
    !where
    !emptylstring()
    !@gtlNotExpression.new { !where !value }
  }
}

override getter @gtlExpr addOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlAddExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr subOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlSubstractExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr mulOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlMultiplyExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr divOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlDivideExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr modOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlModulusExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr andOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlAndExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr orOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlOrExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr xorOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlXorExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr slOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlShiftLeftExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr srOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlShiftRightExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr neqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlNotEqualExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr eqOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlEqualExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr gtOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlGreaterThanExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr geOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlGreaterOrEqualExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr ltOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlLowerThanExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr leOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlExpr then
    result = @gtlExpr.new {
      !where
      !emptylstring()
      !@gtlLowerOrEqualExpression.new { !where !value ![right as @gtlExpr value] }
    }
  else
    error [right where] : "Expression expected" : result
  end
}

override getter @gtlExpr embeddedType -> @type result
{
  error where : "expression forbidden as built in function argument" : result
}

override method @gtlExpr addMyValue ?!@objectlist objectList
{
  objectList += ![value object]
}

#-----------------------------------------------------------------------------*
# Performs a getter on a @gtlBool
#-----------------------------------------------------------------------------*
override getter @gtlExpr performGetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
  ->@gtlData        result
{
  if     [methodName string] == "eval" then
    argumentsCheck(!methodName !structArgument() !arguments)
    let @gtlData vars = [arguments dataAtIndex !0]
    result = [value eval !context !vars !lib]
  elsif "type"                   == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlType.new {
      ![methodName location] !emptylstring() ![self dynamicType]
    }
  elsif "isANumber" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlBool.new {
      ![methodName location] !emptylstring() !false
    }
  elsif "description" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      !meta !emptylstring() !meta
    }
  elsif "location" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    result = @gtlString.new {
      ![methodName location] !emptylstring() ![where locationString]
    }
  elsif [lib getterExists !"expression" !methodName] then
    result = [[lib getGetter !"expression" !methodName] callGetter
      ![methodName location]
      !context
      !lib
      !self
      !arguments
    ]
  else
    error methodName : "unknown getter '" + methodName +"' for expression target"
      : result
  end
}

#-----------------------------------------------------------------------------*
# Performs a setter on a @@gtlBool
#-----------------------------------------------------------------------------*
override setter @gtlExpr performSetter
  ?let @lstring     methodName
  ?let @gtlDataList arguments
  ?let @gtlContext  context
  ?let @library     lib
{
  if "setDescription" == methodName then
    argumentsCheck(!methodName !stringArgument() !arguments)
    let @gtlString descriptionToSet = [arguments dataAtIndex !0] as @gtlString
    [!?self setMeta !descriptionToSet]
    where = methodName
  elsif       "touch" == methodName then
    argumentsCheck(!methodName !noArgument() !arguments)
    where = methodName
  elsif [lib setterExists !"expression" !methodName] then
    @gtlData copy = self
    [[lib getSetter !"expression" !methodName] callSetter
      ![methodName location]
      !context
      !lib
      !?copy
      !arguments
    ]
    value = [copy as @gtlExpr value]
    where = [copy where]
    meta  = [copy meta]
  else
    error methodName : "unknown setter '" + methodName +"' for expression target"
  end
}


